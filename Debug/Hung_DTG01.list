
Hung_DTG01.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0001d1d4  080000c0  080000c0  000100c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00004f2c  0801d294  0801d294  0002d294  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080221c0  080221c0  00040290  2**0
                  CONTENTS
  4 .ARM          00000008  080221c0  080221c0  000321c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  080221c8  080221c8  00040290  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  080221c8  080221c8  000321c8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  080221cc  080221cc  000321cc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000290  20000000  080221d0  00040000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00003b80  20000290  08022460  00040290  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20003e10  08022460  00043e10  2**0
                  ALLOC
 11 .ARM.attributes 00000028  00000000  00000000  00040290  2**0
                  CONTENTS, READONLY
 12 .debug_info   00053d3d  00000000  00000000  000402b8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00008cd1  00000000  00000000  00093ff5  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00001b60  00000000  00000000  0009ccc8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00001b58  00000000  00000000  0009e828  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  0002270d  00000000  00000000  000a0380  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   00032904  00000000  00000000  000c2a8d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    00089a32  00000000  00000000  000f5391  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000053  00000000  00000000  0017edc3  2**0
                  CONTENTS, READONLY
 20 .debug_frame  0000648c  00000000  00000000  0017ee18  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	20000290 	.word	0x20000290
 80000e0:	00000000 	.word	0x00000000
 80000e4:	0801d27c 	.word	0x0801d27c

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	20000294 	.word	0x20000294
 8000104:	0801d27c 	.word	0x0801d27c

08000108 <strlen>:
 8000108:	2300      	movs	r3, #0
 800010a:	5cc2      	ldrb	r2, [r0, r3]
 800010c:	3301      	adds	r3, #1
 800010e:	2a00      	cmp	r2, #0
 8000110:	d1fb      	bne.n	800010a <strlen+0x2>
 8000112:	1e58      	subs	r0, r3, #1
 8000114:	4770      	bx	lr
	...

08000118 <__gnu_thumb1_case_shi>:
 8000118:	b403      	push	{r0, r1}
 800011a:	4671      	mov	r1, lr
 800011c:	0849      	lsrs	r1, r1, #1
 800011e:	0040      	lsls	r0, r0, #1
 8000120:	0049      	lsls	r1, r1, #1
 8000122:	5e09      	ldrsh	r1, [r1, r0]
 8000124:	0049      	lsls	r1, r1, #1
 8000126:	448e      	add	lr, r1
 8000128:	bc03      	pop	{r0, r1}
 800012a:	4770      	bx	lr

0800012c <__udivsi3>:
 800012c:	2200      	movs	r2, #0
 800012e:	0843      	lsrs	r3, r0, #1
 8000130:	428b      	cmp	r3, r1
 8000132:	d374      	bcc.n	800021e <__udivsi3+0xf2>
 8000134:	0903      	lsrs	r3, r0, #4
 8000136:	428b      	cmp	r3, r1
 8000138:	d35f      	bcc.n	80001fa <__udivsi3+0xce>
 800013a:	0a03      	lsrs	r3, r0, #8
 800013c:	428b      	cmp	r3, r1
 800013e:	d344      	bcc.n	80001ca <__udivsi3+0x9e>
 8000140:	0b03      	lsrs	r3, r0, #12
 8000142:	428b      	cmp	r3, r1
 8000144:	d328      	bcc.n	8000198 <__udivsi3+0x6c>
 8000146:	0c03      	lsrs	r3, r0, #16
 8000148:	428b      	cmp	r3, r1
 800014a:	d30d      	bcc.n	8000168 <__udivsi3+0x3c>
 800014c:	22ff      	movs	r2, #255	; 0xff
 800014e:	0209      	lsls	r1, r1, #8
 8000150:	ba12      	rev	r2, r2
 8000152:	0c03      	lsrs	r3, r0, #16
 8000154:	428b      	cmp	r3, r1
 8000156:	d302      	bcc.n	800015e <__udivsi3+0x32>
 8000158:	1212      	asrs	r2, r2, #8
 800015a:	0209      	lsls	r1, r1, #8
 800015c:	d065      	beq.n	800022a <__udivsi3+0xfe>
 800015e:	0b03      	lsrs	r3, r0, #12
 8000160:	428b      	cmp	r3, r1
 8000162:	d319      	bcc.n	8000198 <__udivsi3+0x6c>
 8000164:	e000      	b.n	8000168 <__udivsi3+0x3c>
 8000166:	0a09      	lsrs	r1, r1, #8
 8000168:	0bc3      	lsrs	r3, r0, #15
 800016a:	428b      	cmp	r3, r1
 800016c:	d301      	bcc.n	8000172 <__udivsi3+0x46>
 800016e:	03cb      	lsls	r3, r1, #15
 8000170:	1ac0      	subs	r0, r0, r3
 8000172:	4152      	adcs	r2, r2
 8000174:	0b83      	lsrs	r3, r0, #14
 8000176:	428b      	cmp	r3, r1
 8000178:	d301      	bcc.n	800017e <__udivsi3+0x52>
 800017a:	038b      	lsls	r3, r1, #14
 800017c:	1ac0      	subs	r0, r0, r3
 800017e:	4152      	adcs	r2, r2
 8000180:	0b43      	lsrs	r3, r0, #13
 8000182:	428b      	cmp	r3, r1
 8000184:	d301      	bcc.n	800018a <__udivsi3+0x5e>
 8000186:	034b      	lsls	r3, r1, #13
 8000188:	1ac0      	subs	r0, r0, r3
 800018a:	4152      	adcs	r2, r2
 800018c:	0b03      	lsrs	r3, r0, #12
 800018e:	428b      	cmp	r3, r1
 8000190:	d301      	bcc.n	8000196 <__udivsi3+0x6a>
 8000192:	030b      	lsls	r3, r1, #12
 8000194:	1ac0      	subs	r0, r0, r3
 8000196:	4152      	adcs	r2, r2
 8000198:	0ac3      	lsrs	r3, r0, #11
 800019a:	428b      	cmp	r3, r1
 800019c:	d301      	bcc.n	80001a2 <__udivsi3+0x76>
 800019e:	02cb      	lsls	r3, r1, #11
 80001a0:	1ac0      	subs	r0, r0, r3
 80001a2:	4152      	adcs	r2, r2
 80001a4:	0a83      	lsrs	r3, r0, #10
 80001a6:	428b      	cmp	r3, r1
 80001a8:	d301      	bcc.n	80001ae <__udivsi3+0x82>
 80001aa:	028b      	lsls	r3, r1, #10
 80001ac:	1ac0      	subs	r0, r0, r3
 80001ae:	4152      	adcs	r2, r2
 80001b0:	0a43      	lsrs	r3, r0, #9
 80001b2:	428b      	cmp	r3, r1
 80001b4:	d301      	bcc.n	80001ba <__udivsi3+0x8e>
 80001b6:	024b      	lsls	r3, r1, #9
 80001b8:	1ac0      	subs	r0, r0, r3
 80001ba:	4152      	adcs	r2, r2
 80001bc:	0a03      	lsrs	r3, r0, #8
 80001be:	428b      	cmp	r3, r1
 80001c0:	d301      	bcc.n	80001c6 <__udivsi3+0x9a>
 80001c2:	020b      	lsls	r3, r1, #8
 80001c4:	1ac0      	subs	r0, r0, r3
 80001c6:	4152      	adcs	r2, r2
 80001c8:	d2cd      	bcs.n	8000166 <__udivsi3+0x3a>
 80001ca:	09c3      	lsrs	r3, r0, #7
 80001cc:	428b      	cmp	r3, r1
 80001ce:	d301      	bcc.n	80001d4 <__udivsi3+0xa8>
 80001d0:	01cb      	lsls	r3, r1, #7
 80001d2:	1ac0      	subs	r0, r0, r3
 80001d4:	4152      	adcs	r2, r2
 80001d6:	0983      	lsrs	r3, r0, #6
 80001d8:	428b      	cmp	r3, r1
 80001da:	d301      	bcc.n	80001e0 <__udivsi3+0xb4>
 80001dc:	018b      	lsls	r3, r1, #6
 80001de:	1ac0      	subs	r0, r0, r3
 80001e0:	4152      	adcs	r2, r2
 80001e2:	0943      	lsrs	r3, r0, #5
 80001e4:	428b      	cmp	r3, r1
 80001e6:	d301      	bcc.n	80001ec <__udivsi3+0xc0>
 80001e8:	014b      	lsls	r3, r1, #5
 80001ea:	1ac0      	subs	r0, r0, r3
 80001ec:	4152      	adcs	r2, r2
 80001ee:	0903      	lsrs	r3, r0, #4
 80001f0:	428b      	cmp	r3, r1
 80001f2:	d301      	bcc.n	80001f8 <__udivsi3+0xcc>
 80001f4:	010b      	lsls	r3, r1, #4
 80001f6:	1ac0      	subs	r0, r0, r3
 80001f8:	4152      	adcs	r2, r2
 80001fa:	08c3      	lsrs	r3, r0, #3
 80001fc:	428b      	cmp	r3, r1
 80001fe:	d301      	bcc.n	8000204 <__udivsi3+0xd8>
 8000200:	00cb      	lsls	r3, r1, #3
 8000202:	1ac0      	subs	r0, r0, r3
 8000204:	4152      	adcs	r2, r2
 8000206:	0883      	lsrs	r3, r0, #2
 8000208:	428b      	cmp	r3, r1
 800020a:	d301      	bcc.n	8000210 <__udivsi3+0xe4>
 800020c:	008b      	lsls	r3, r1, #2
 800020e:	1ac0      	subs	r0, r0, r3
 8000210:	4152      	adcs	r2, r2
 8000212:	0843      	lsrs	r3, r0, #1
 8000214:	428b      	cmp	r3, r1
 8000216:	d301      	bcc.n	800021c <__udivsi3+0xf0>
 8000218:	004b      	lsls	r3, r1, #1
 800021a:	1ac0      	subs	r0, r0, r3
 800021c:	4152      	adcs	r2, r2
 800021e:	1a41      	subs	r1, r0, r1
 8000220:	d200      	bcs.n	8000224 <__udivsi3+0xf8>
 8000222:	4601      	mov	r1, r0
 8000224:	4152      	adcs	r2, r2
 8000226:	4610      	mov	r0, r2
 8000228:	4770      	bx	lr
 800022a:	e7ff      	b.n	800022c <__udivsi3+0x100>
 800022c:	b501      	push	{r0, lr}
 800022e:	2000      	movs	r0, #0
 8000230:	f000 f806 	bl	8000240 <__aeabi_idiv0>
 8000234:	bd02      	pop	{r1, pc}
 8000236:	46c0      	nop			; (mov r8, r8)

08000238 <__aeabi_uidivmod>:
 8000238:	2900      	cmp	r1, #0
 800023a:	d0f7      	beq.n	800022c <__udivsi3+0x100>
 800023c:	e776      	b.n	800012c <__udivsi3>
 800023e:	4770      	bx	lr

08000240 <__aeabi_idiv0>:
 8000240:	4770      	bx	lr
 8000242:	46c0      	nop			; (mov r8, r8)

08000244 <__aeabi_uldivmod>:
 8000244:	2b00      	cmp	r3, #0
 8000246:	d111      	bne.n	800026c <__aeabi_uldivmod+0x28>
 8000248:	2a00      	cmp	r2, #0
 800024a:	d10f      	bne.n	800026c <__aeabi_uldivmod+0x28>
 800024c:	2900      	cmp	r1, #0
 800024e:	d100      	bne.n	8000252 <__aeabi_uldivmod+0xe>
 8000250:	2800      	cmp	r0, #0
 8000252:	d002      	beq.n	800025a <__aeabi_uldivmod+0x16>
 8000254:	2100      	movs	r1, #0
 8000256:	43c9      	mvns	r1, r1
 8000258:	1c08      	adds	r0, r1, #0
 800025a:	b407      	push	{r0, r1, r2}
 800025c:	4802      	ldr	r0, [pc, #8]	; (8000268 <__aeabi_uldivmod+0x24>)
 800025e:	a102      	add	r1, pc, #8	; (adr r1, 8000268 <__aeabi_uldivmod+0x24>)
 8000260:	1840      	adds	r0, r0, r1
 8000262:	9002      	str	r0, [sp, #8]
 8000264:	bd03      	pop	{r0, r1, pc}
 8000266:	46c0      	nop			; (mov r8, r8)
 8000268:	ffffffd9 	.word	0xffffffd9
 800026c:	b403      	push	{r0, r1}
 800026e:	4668      	mov	r0, sp
 8000270:	b501      	push	{r0, lr}
 8000272:	9802      	ldr	r0, [sp, #8]
 8000274:	f000 f82e 	bl	80002d4 <__udivmoddi4>
 8000278:	9b01      	ldr	r3, [sp, #4]
 800027a:	469e      	mov	lr, r3
 800027c:	b002      	add	sp, #8
 800027e:	bc0c      	pop	{r2, r3}
 8000280:	4770      	bx	lr
 8000282:	46c0      	nop			; (mov r8, r8)

08000284 <__aeabi_lmul>:
 8000284:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000286:	0415      	lsls	r5, r2, #16
 8000288:	0c2d      	lsrs	r5, r5, #16
 800028a:	000f      	movs	r7, r1
 800028c:	0001      	movs	r1, r0
 800028e:	002e      	movs	r6, r5
 8000290:	46c6      	mov	lr, r8
 8000292:	4684      	mov	ip, r0
 8000294:	0400      	lsls	r0, r0, #16
 8000296:	0c14      	lsrs	r4, r2, #16
 8000298:	0c00      	lsrs	r0, r0, #16
 800029a:	0c09      	lsrs	r1, r1, #16
 800029c:	4346      	muls	r6, r0
 800029e:	434d      	muls	r5, r1
 80002a0:	4360      	muls	r0, r4
 80002a2:	4361      	muls	r1, r4
 80002a4:	1940      	adds	r0, r0, r5
 80002a6:	0c34      	lsrs	r4, r6, #16
 80002a8:	1824      	adds	r4, r4, r0
 80002aa:	b500      	push	{lr}
 80002ac:	42a5      	cmp	r5, r4
 80002ae:	d903      	bls.n	80002b8 <__aeabi_lmul+0x34>
 80002b0:	2080      	movs	r0, #128	; 0x80
 80002b2:	0240      	lsls	r0, r0, #9
 80002b4:	4680      	mov	r8, r0
 80002b6:	4441      	add	r1, r8
 80002b8:	0c25      	lsrs	r5, r4, #16
 80002ba:	186d      	adds	r5, r5, r1
 80002bc:	4661      	mov	r1, ip
 80002be:	4359      	muls	r1, r3
 80002c0:	437a      	muls	r2, r7
 80002c2:	0430      	lsls	r0, r6, #16
 80002c4:	1949      	adds	r1, r1, r5
 80002c6:	0424      	lsls	r4, r4, #16
 80002c8:	0c00      	lsrs	r0, r0, #16
 80002ca:	1820      	adds	r0, r4, r0
 80002cc:	1889      	adds	r1, r1, r2
 80002ce:	bc80      	pop	{r7}
 80002d0:	46b8      	mov	r8, r7
 80002d2:	bdf0      	pop	{r4, r5, r6, r7, pc}

080002d4 <__udivmoddi4>:
 80002d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80002d6:	4657      	mov	r7, sl
 80002d8:	464e      	mov	r6, r9
 80002da:	4645      	mov	r5, r8
 80002dc:	46de      	mov	lr, fp
 80002de:	b5e0      	push	{r5, r6, r7, lr}
 80002e0:	0004      	movs	r4, r0
 80002e2:	000d      	movs	r5, r1
 80002e4:	4692      	mov	sl, r2
 80002e6:	4699      	mov	r9, r3
 80002e8:	b083      	sub	sp, #12
 80002ea:	428b      	cmp	r3, r1
 80002ec:	d830      	bhi.n	8000350 <__udivmoddi4+0x7c>
 80002ee:	d02d      	beq.n	800034c <__udivmoddi4+0x78>
 80002f0:	4649      	mov	r1, r9
 80002f2:	4650      	mov	r0, sl
 80002f4:	f000 f8ba 	bl	800046c <__clzdi2>
 80002f8:	0029      	movs	r1, r5
 80002fa:	0006      	movs	r6, r0
 80002fc:	0020      	movs	r0, r4
 80002fe:	f000 f8b5 	bl	800046c <__clzdi2>
 8000302:	1a33      	subs	r3, r6, r0
 8000304:	4698      	mov	r8, r3
 8000306:	3b20      	subs	r3, #32
 8000308:	469b      	mov	fp, r3
 800030a:	d433      	bmi.n	8000374 <__udivmoddi4+0xa0>
 800030c:	465a      	mov	r2, fp
 800030e:	4653      	mov	r3, sl
 8000310:	4093      	lsls	r3, r2
 8000312:	4642      	mov	r2, r8
 8000314:	001f      	movs	r7, r3
 8000316:	4653      	mov	r3, sl
 8000318:	4093      	lsls	r3, r2
 800031a:	001e      	movs	r6, r3
 800031c:	42af      	cmp	r7, r5
 800031e:	d83a      	bhi.n	8000396 <__udivmoddi4+0xc2>
 8000320:	42af      	cmp	r7, r5
 8000322:	d100      	bne.n	8000326 <__udivmoddi4+0x52>
 8000324:	e078      	b.n	8000418 <__udivmoddi4+0x144>
 8000326:	465b      	mov	r3, fp
 8000328:	1ba4      	subs	r4, r4, r6
 800032a:	41bd      	sbcs	r5, r7
 800032c:	2b00      	cmp	r3, #0
 800032e:	da00      	bge.n	8000332 <__udivmoddi4+0x5e>
 8000330:	e075      	b.n	800041e <__udivmoddi4+0x14a>
 8000332:	2200      	movs	r2, #0
 8000334:	2300      	movs	r3, #0
 8000336:	9200      	str	r2, [sp, #0]
 8000338:	9301      	str	r3, [sp, #4]
 800033a:	2301      	movs	r3, #1
 800033c:	465a      	mov	r2, fp
 800033e:	4093      	lsls	r3, r2
 8000340:	9301      	str	r3, [sp, #4]
 8000342:	2301      	movs	r3, #1
 8000344:	4642      	mov	r2, r8
 8000346:	4093      	lsls	r3, r2
 8000348:	9300      	str	r3, [sp, #0]
 800034a:	e028      	b.n	800039e <__udivmoddi4+0xca>
 800034c:	4282      	cmp	r2, r0
 800034e:	d9cf      	bls.n	80002f0 <__udivmoddi4+0x1c>
 8000350:	2200      	movs	r2, #0
 8000352:	2300      	movs	r3, #0
 8000354:	9200      	str	r2, [sp, #0]
 8000356:	9301      	str	r3, [sp, #4]
 8000358:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800035a:	2b00      	cmp	r3, #0
 800035c:	d001      	beq.n	8000362 <__udivmoddi4+0x8e>
 800035e:	601c      	str	r4, [r3, #0]
 8000360:	605d      	str	r5, [r3, #4]
 8000362:	9800      	ldr	r0, [sp, #0]
 8000364:	9901      	ldr	r1, [sp, #4]
 8000366:	b003      	add	sp, #12
 8000368:	bcf0      	pop	{r4, r5, r6, r7}
 800036a:	46bb      	mov	fp, r7
 800036c:	46b2      	mov	sl, r6
 800036e:	46a9      	mov	r9, r5
 8000370:	46a0      	mov	r8, r4
 8000372:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000374:	4642      	mov	r2, r8
 8000376:	2320      	movs	r3, #32
 8000378:	1a9b      	subs	r3, r3, r2
 800037a:	4652      	mov	r2, sl
 800037c:	40da      	lsrs	r2, r3
 800037e:	4641      	mov	r1, r8
 8000380:	0013      	movs	r3, r2
 8000382:	464a      	mov	r2, r9
 8000384:	408a      	lsls	r2, r1
 8000386:	0017      	movs	r7, r2
 8000388:	4642      	mov	r2, r8
 800038a:	431f      	orrs	r7, r3
 800038c:	4653      	mov	r3, sl
 800038e:	4093      	lsls	r3, r2
 8000390:	001e      	movs	r6, r3
 8000392:	42af      	cmp	r7, r5
 8000394:	d9c4      	bls.n	8000320 <__udivmoddi4+0x4c>
 8000396:	2200      	movs	r2, #0
 8000398:	2300      	movs	r3, #0
 800039a:	9200      	str	r2, [sp, #0]
 800039c:	9301      	str	r3, [sp, #4]
 800039e:	4643      	mov	r3, r8
 80003a0:	2b00      	cmp	r3, #0
 80003a2:	d0d9      	beq.n	8000358 <__udivmoddi4+0x84>
 80003a4:	07fb      	lsls	r3, r7, #31
 80003a6:	0872      	lsrs	r2, r6, #1
 80003a8:	431a      	orrs	r2, r3
 80003aa:	4646      	mov	r6, r8
 80003ac:	087b      	lsrs	r3, r7, #1
 80003ae:	e00e      	b.n	80003ce <__udivmoddi4+0xfa>
 80003b0:	42ab      	cmp	r3, r5
 80003b2:	d101      	bne.n	80003b8 <__udivmoddi4+0xe4>
 80003b4:	42a2      	cmp	r2, r4
 80003b6:	d80c      	bhi.n	80003d2 <__udivmoddi4+0xfe>
 80003b8:	1aa4      	subs	r4, r4, r2
 80003ba:	419d      	sbcs	r5, r3
 80003bc:	2001      	movs	r0, #1
 80003be:	1924      	adds	r4, r4, r4
 80003c0:	416d      	adcs	r5, r5
 80003c2:	2100      	movs	r1, #0
 80003c4:	3e01      	subs	r6, #1
 80003c6:	1824      	adds	r4, r4, r0
 80003c8:	414d      	adcs	r5, r1
 80003ca:	2e00      	cmp	r6, #0
 80003cc:	d006      	beq.n	80003dc <__udivmoddi4+0x108>
 80003ce:	42ab      	cmp	r3, r5
 80003d0:	d9ee      	bls.n	80003b0 <__udivmoddi4+0xdc>
 80003d2:	3e01      	subs	r6, #1
 80003d4:	1924      	adds	r4, r4, r4
 80003d6:	416d      	adcs	r5, r5
 80003d8:	2e00      	cmp	r6, #0
 80003da:	d1f8      	bne.n	80003ce <__udivmoddi4+0xfa>
 80003dc:	9800      	ldr	r0, [sp, #0]
 80003de:	9901      	ldr	r1, [sp, #4]
 80003e0:	465b      	mov	r3, fp
 80003e2:	1900      	adds	r0, r0, r4
 80003e4:	4169      	adcs	r1, r5
 80003e6:	2b00      	cmp	r3, #0
 80003e8:	db24      	blt.n	8000434 <__udivmoddi4+0x160>
 80003ea:	002b      	movs	r3, r5
 80003ec:	465a      	mov	r2, fp
 80003ee:	4644      	mov	r4, r8
 80003f0:	40d3      	lsrs	r3, r2
 80003f2:	002a      	movs	r2, r5
 80003f4:	40e2      	lsrs	r2, r4
 80003f6:	001c      	movs	r4, r3
 80003f8:	465b      	mov	r3, fp
 80003fa:	0015      	movs	r5, r2
 80003fc:	2b00      	cmp	r3, #0
 80003fe:	db2a      	blt.n	8000456 <__udivmoddi4+0x182>
 8000400:	0026      	movs	r6, r4
 8000402:	409e      	lsls	r6, r3
 8000404:	0033      	movs	r3, r6
 8000406:	0026      	movs	r6, r4
 8000408:	4647      	mov	r7, r8
 800040a:	40be      	lsls	r6, r7
 800040c:	0032      	movs	r2, r6
 800040e:	1a80      	subs	r0, r0, r2
 8000410:	4199      	sbcs	r1, r3
 8000412:	9000      	str	r0, [sp, #0]
 8000414:	9101      	str	r1, [sp, #4]
 8000416:	e79f      	b.n	8000358 <__udivmoddi4+0x84>
 8000418:	42a3      	cmp	r3, r4
 800041a:	d8bc      	bhi.n	8000396 <__udivmoddi4+0xc2>
 800041c:	e783      	b.n	8000326 <__udivmoddi4+0x52>
 800041e:	4642      	mov	r2, r8
 8000420:	2320      	movs	r3, #32
 8000422:	2100      	movs	r1, #0
 8000424:	1a9b      	subs	r3, r3, r2
 8000426:	2200      	movs	r2, #0
 8000428:	9100      	str	r1, [sp, #0]
 800042a:	9201      	str	r2, [sp, #4]
 800042c:	2201      	movs	r2, #1
 800042e:	40da      	lsrs	r2, r3
 8000430:	9201      	str	r2, [sp, #4]
 8000432:	e786      	b.n	8000342 <__udivmoddi4+0x6e>
 8000434:	4642      	mov	r2, r8
 8000436:	2320      	movs	r3, #32
 8000438:	1a9b      	subs	r3, r3, r2
 800043a:	002a      	movs	r2, r5
 800043c:	4646      	mov	r6, r8
 800043e:	409a      	lsls	r2, r3
 8000440:	0023      	movs	r3, r4
 8000442:	40f3      	lsrs	r3, r6
 8000444:	4644      	mov	r4, r8
 8000446:	4313      	orrs	r3, r2
 8000448:	002a      	movs	r2, r5
 800044a:	40e2      	lsrs	r2, r4
 800044c:	001c      	movs	r4, r3
 800044e:	465b      	mov	r3, fp
 8000450:	0015      	movs	r5, r2
 8000452:	2b00      	cmp	r3, #0
 8000454:	dad4      	bge.n	8000400 <__udivmoddi4+0x12c>
 8000456:	4642      	mov	r2, r8
 8000458:	002f      	movs	r7, r5
 800045a:	2320      	movs	r3, #32
 800045c:	0026      	movs	r6, r4
 800045e:	4097      	lsls	r7, r2
 8000460:	1a9b      	subs	r3, r3, r2
 8000462:	40de      	lsrs	r6, r3
 8000464:	003b      	movs	r3, r7
 8000466:	4333      	orrs	r3, r6
 8000468:	e7cd      	b.n	8000406 <__udivmoddi4+0x132>
 800046a:	46c0      	nop			; (mov r8, r8)

0800046c <__clzdi2>:
 800046c:	b510      	push	{r4, lr}
 800046e:	2900      	cmp	r1, #0
 8000470:	d103      	bne.n	800047a <__clzdi2+0xe>
 8000472:	f000 f807 	bl	8000484 <__clzsi2>
 8000476:	3020      	adds	r0, #32
 8000478:	e002      	b.n	8000480 <__clzdi2+0x14>
 800047a:	1c08      	adds	r0, r1, #0
 800047c:	f000 f802 	bl	8000484 <__clzsi2>
 8000480:	bd10      	pop	{r4, pc}
 8000482:	46c0      	nop			; (mov r8, r8)

08000484 <__clzsi2>:
 8000484:	211c      	movs	r1, #28
 8000486:	2301      	movs	r3, #1
 8000488:	041b      	lsls	r3, r3, #16
 800048a:	4298      	cmp	r0, r3
 800048c:	d301      	bcc.n	8000492 <__clzsi2+0xe>
 800048e:	0c00      	lsrs	r0, r0, #16
 8000490:	3910      	subs	r1, #16
 8000492:	0a1b      	lsrs	r3, r3, #8
 8000494:	4298      	cmp	r0, r3
 8000496:	d301      	bcc.n	800049c <__clzsi2+0x18>
 8000498:	0a00      	lsrs	r0, r0, #8
 800049a:	3908      	subs	r1, #8
 800049c:	091b      	lsrs	r3, r3, #4
 800049e:	4298      	cmp	r0, r3
 80004a0:	d301      	bcc.n	80004a6 <__clzsi2+0x22>
 80004a2:	0900      	lsrs	r0, r0, #4
 80004a4:	3904      	subs	r1, #4
 80004a6:	a202      	add	r2, pc, #8	; (adr r2, 80004b0 <__clzsi2+0x2c>)
 80004a8:	5c10      	ldrb	r0, [r2, r0]
 80004aa:	1840      	adds	r0, r0, r1
 80004ac:	4770      	bx	lr
 80004ae:	46c0      	nop			; (mov r8, r8)
 80004b0:	02020304 	.word	0x02020304
 80004b4:	01010101 	.word	0x01010101
	...

080004c0 <HAL_UART_RxCpltCallback>:
	80,
	"/get",
};

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
 80004c0:	b580      	push	{r7, lr}
 80004c2:	b082      	sub	sp, #8
 80004c4:	af00      	add	r7, sp, #0
 80004c6:	6078      	str	r0, [r7, #4]
//	m_rx_buff.data[m_rx_buff.index] = data ;
//	m_rx_buff.index++;

	RingBuffer_Push(&Rx_Buffer, data);
 80004c8:	4b08      	ldr	r3, [pc, #32]	; (80004ec <HAL_UART_RxCpltCallback+0x2c>)
 80004ca:	781a      	ldrb	r2, [r3, #0]
 80004cc:	4b08      	ldr	r3, [pc, #32]	; (80004f0 <HAL_UART_RxCpltCallback+0x30>)
 80004ce:	0011      	movs	r1, r2
 80004d0:	0018      	movs	r0, r3
 80004d2:	f001 fec7 	bl	8002264 <RingBuffer_Push>
	HAL_UART_Receive_IT(&huart1, &data, 1);
 80004d6:	4905      	ldr	r1, [pc, #20]	; (80004ec <HAL_UART_RxCpltCallback+0x2c>)
 80004d8:	4b06      	ldr	r3, [pc, #24]	; (80004f4 <HAL_UART_RxCpltCallback+0x34>)
 80004da:	2201      	movs	r2, #1
 80004dc:	0018      	movs	r0, r3
 80004de:	f003 faf1 	bl	8003ac4 <HAL_UART_Receive_IT>
}
 80004e2:	46c0      	nop			; (mov r8, r8)
 80004e4:	46bd      	mov	sp, r7
 80004e6:	b002      	add	sp, #8
 80004e8:	bd80      	pop	{r7, pc}
 80004ea:	46c0      	nop			; (mov r8, r8)
 80004ec:	200002ac 	.word	0x200002ac
 80004f0:	20001460 	.word	0x20001460
 80004f4:	200013c8 	.word	0x200013c8

080004f8 <App_Main>:
static void dns_initialize(void);

void App_Main ()
{
 80004f8:	b580      	push	{r7, lr}
 80004fa:	af00      	add	r7, sp, #0
	// Note: Sửa NOPULL -> PULLUP:  GPIO_InitStruct.Pull = GPIO_PULLUP; de tranh loi nhan NULL truoc khi Power on EC200
	HAL_UART_Receive_IT(&huart1, &data, 1);
 80004fc:	490e      	ldr	r1, [pc, #56]	; (8000538 <App_Main+0x40>)
 80004fe:	4b0f      	ldr	r3, [pc, #60]	; (800053c <App_Main+0x44>)
 8000500:	2201      	movs	r2, #1
 8000502:	0018      	movs	r0, r3
 8000504:	f003 fade 	bl	8003ac4 <HAL_UART_Receive_IT>

 	dns_initialize();
 8000508:	f000 f820 	bl	800054c <dns_initialize>
	lwip_init();
 800050c:	f007 fc79 	bl	8007e02 <lwip_init>
	//MQTT_Client_Init(&MQTT_Cfg);
	HTTP_Client_Init(&HTTP_Cfg);
 8000510:	4b0b      	ldr	r3, [pc, #44]	; (8000540 <App_Main+0x48>)
 8000512:	0018      	movs	r0, r3
 8000514:	f004 fd76 	bl	8005004 <HTTP_Client_Init>
	DEBUG_INFO("Application started\r\n");
 8000518:	f01c f912 	bl	801c740 <sys_get_tick_ms>
 800051c:	0001      	movs	r1, r0
 800051e:	4a09      	ldr	r2, [pc, #36]	; (8000544 <App_Main+0x4c>)
 8000520:	4b09      	ldr	r3, [pc, #36]	; (8000548 <App_Main+0x50>)
 8000522:	0018      	movs	r0, r3
 8000524:	f001 fe52 	bl	80021cc <app_debug_rtt_raw>
	GMS_Hardware_Init();
 8000528:	f000 ff74 	bl	8001414 <GMS_Hardware_Init>
	//UART_SendData(USART1, bf_send, sizeof(bf_send));
	while(1)
	{
		GSM_mnr_task();
 800052c:	f000 ff66 	bl	80013fc <GSM_mnr_task>
		//MQTT_Client_Polling_Task(NULL);
		HTTP_Client_Polling_Task(NULL);
 8000530:	2000      	movs	r0, #0
 8000532:	f004 feef 	bl	8005314 <HTTP_Client_Polling_Task>
		GSM_mnr_task();
 8000536:	e7f9      	b.n	800052c <App_Main+0x34>
 8000538:	200002ac 	.word	0x200002ac
 800053c:	200013c8 	.word	0x200013c8
 8000540:	20000000 	.word	0x20000000
 8000544:	0801d2f4 	.word	0x0801d2f4
 8000548:	0801d2f8 	.word	0x0801d2f8

0800054c <dns_initialize>:
	}
}

static void dns_initialize(void)
{
 800054c:	b580      	push	{r7, lr}
 800054e:	b082      	sub	sp, #8
 8000550:	af00      	add	r7, sp, #0
    ip_addr_t dns_server_0 = IPADDR4_INIT_BYTES(8, 8, 8, 8);
 8000552:	4b0a      	ldr	r3, [pc, #40]	; (800057c <dns_initialize+0x30>)
 8000554:	607b      	str	r3, [r7, #4]
    ip_addr_t dns_server_1 = IPADDR4_INIT_BYTES(1, 1, 1, 1);
 8000556:	4b0a      	ldr	r3, [pc, #40]	; (8000580 <dns_initialize+0x34>)
 8000558:	603b      	str	r3, [r7, #0]
    dns_setserver(0, &dns_server_0);
 800055a:	1d3b      	adds	r3, r7, #4
 800055c:	0019      	movs	r1, r3
 800055e:	2000      	movs	r0, #0
 8000560:	f006 f868 	bl	8006634 <dns_setserver>
    dns_setserver(1, &dns_server_1);
 8000564:	003b      	movs	r3, r7
 8000566:	0019      	movs	r1, r3
 8000568:	2001      	movs	r0, #1
 800056a:	f006 f863 	bl	8006634 <dns_setserver>
    dns_init();
 800056e:	f006 f85b 	bl	8006628 <dns_init>
}
 8000572:	46c0      	nop			; (mov r8, r8)
 8000574:	46bd      	mov	sp, r7
 8000576:	b002      	add	sp, #8
 8000578:	bd80      	pop	{r7, pc}
 800057a:	46c0      	nop			; (mov r8, r8)
 800057c:	08080808 	.word	0x08080808
 8000580:	01010101 	.word	0x01010101

08000584 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 8000584:	b590      	push	{r4, r7, lr}
 8000586:	b08b      	sub	sp, #44	; 0x2c
 8000588:	af00      	add	r7, sp, #0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800058a:	2414      	movs	r4, #20
 800058c:	193b      	adds	r3, r7, r4
 800058e:	0018      	movs	r0, r3
 8000590:	2314      	movs	r3, #20
 8000592:	001a      	movs	r2, r3
 8000594:	2100      	movs	r1, #0
 8000596:	f01c f949 	bl	801c82c <memset>

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
 800059a:	4b42      	ldr	r3, [pc, #264]	; (80006a4 <MX_GPIO_Init+0x120>)
 800059c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800059e:	4b41      	ldr	r3, [pc, #260]	; (80006a4 <MX_GPIO_Init+0x120>)
 80005a0:	2180      	movs	r1, #128	; 0x80
 80005a2:	430a      	orrs	r2, r1
 80005a4:	62da      	str	r2, [r3, #44]	; 0x2c
 80005a6:	4b3f      	ldr	r3, [pc, #252]	; (80006a4 <MX_GPIO_Init+0x120>)
 80005a8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80005aa:	2280      	movs	r2, #128	; 0x80
 80005ac:	4013      	ands	r3, r2
 80005ae:	613b      	str	r3, [r7, #16]
 80005b0:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80005b2:	4b3c      	ldr	r3, [pc, #240]	; (80006a4 <MX_GPIO_Init+0x120>)
 80005b4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80005b6:	4b3b      	ldr	r3, [pc, #236]	; (80006a4 <MX_GPIO_Init+0x120>)
 80005b8:	2104      	movs	r1, #4
 80005ba:	430a      	orrs	r2, r1
 80005bc:	62da      	str	r2, [r3, #44]	; 0x2c
 80005be:	4b39      	ldr	r3, [pc, #228]	; (80006a4 <MX_GPIO_Init+0x120>)
 80005c0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80005c2:	2204      	movs	r2, #4
 80005c4:	4013      	ands	r3, r2
 80005c6:	60fb      	str	r3, [r7, #12]
 80005c8:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80005ca:	4b36      	ldr	r3, [pc, #216]	; (80006a4 <MX_GPIO_Init+0x120>)
 80005cc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80005ce:	4b35      	ldr	r3, [pc, #212]	; (80006a4 <MX_GPIO_Init+0x120>)
 80005d0:	2101      	movs	r1, #1
 80005d2:	430a      	orrs	r2, r1
 80005d4:	62da      	str	r2, [r3, #44]	; 0x2c
 80005d6:	4b33      	ldr	r3, [pc, #204]	; (80006a4 <MX_GPIO_Init+0x120>)
 80005d8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80005da:	2201      	movs	r2, #1
 80005dc:	4013      	ands	r3, r2
 80005de:	60bb      	str	r3, [r7, #8]
 80005e0:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80005e2:	4b30      	ldr	r3, [pc, #192]	; (80006a4 <MX_GPIO_Init+0x120>)
 80005e4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80005e6:	4b2f      	ldr	r3, [pc, #188]	; (80006a4 <MX_GPIO_Init+0x120>)
 80005e8:	2102      	movs	r1, #2
 80005ea:	430a      	orrs	r2, r1
 80005ec:	62da      	str	r2, [r3, #44]	; 0x2c
 80005ee:	4b2d      	ldr	r3, [pc, #180]	; (80006a4 <MX_GPIO_Init+0x120>)
 80005f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80005f2:	2202      	movs	r2, #2
 80005f4:	4013      	ands	r3, r2
 80005f6:	607b      	str	r3, [r7, #4]
 80005f8:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, CHARGE_EN_Pin|EN_GSM_Pin, GPIO_PIN_RESET);
 80005fa:	4b2b      	ldr	r3, [pc, #172]	; (80006a8 <MX_GPIO_Init+0x124>)
 80005fc:	2200      	movs	r2, #0
 80005fe:	2150      	movs	r1, #80	; 0x50
 8000600:	0018      	movs	r0, r3
 8000602:	f002 fa5f 	bl	8002ac4 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GSM_PWKEY_Pin|GSM_EN_Pin, GPIO_PIN_RESET);
 8000606:	2381      	movs	r3, #129	; 0x81
 8000608:	0219      	lsls	r1, r3, #8
 800060a:	23a0      	movs	r3, #160	; 0xa0
 800060c:	05db      	lsls	r3, r3, #23
 800060e:	2200      	movs	r2, #0
 8000610:	0018      	movs	r0, r3
 8000612:	f002 fa57 	bl	8002ac4 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GSM_RESET_GPIO_Port, GSM_RESET_Pin, GPIO_PIN_RESET);
 8000616:	2380      	movs	r3, #128	; 0x80
 8000618:	009b      	lsls	r3, r3, #2
 800061a:	4824      	ldr	r0, [pc, #144]	; (80006ac <MX_GPIO_Init+0x128>)
 800061c:	2200      	movs	r2, #0
 800061e:	0019      	movs	r1, r3
 8000620:	f002 fa50 	bl	8002ac4 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : PCPin PCPin */
  GPIO_InitStruct.Pin = CHARGE_EN_Pin|EN_GSM_Pin;
 8000624:	193b      	adds	r3, r7, r4
 8000626:	2250      	movs	r2, #80	; 0x50
 8000628:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800062a:	193b      	adds	r3, r7, r4
 800062c:	2201      	movs	r2, #1
 800062e:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000630:	193b      	adds	r3, r7, r4
 8000632:	2200      	movs	r2, #0
 8000634:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000636:	193b      	adds	r3, r7, r4
 8000638:	2200      	movs	r2, #0
 800063a:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800063c:	193b      	adds	r3, r7, r4
 800063e:	4a1a      	ldr	r2, [pc, #104]	; (80006a8 <MX_GPIO_Init+0x124>)
 8000640:	0019      	movs	r1, r3
 8000642:	0010      	movs	r0, r2
 8000644:	f002 f8c0 	bl	80027c8 <HAL_GPIO_Init>

  /*Configure GPIO pins : PAPin PAPin */
  GPIO_InitStruct.Pin = GSM_PWKEY_Pin|GSM_EN_Pin;
 8000648:	0021      	movs	r1, r4
 800064a:	187b      	adds	r3, r7, r1
 800064c:	2281      	movs	r2, #129	; 0x81
 800064e:	0212      	lsls	r2, r2, #8
 8000650:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000652:	000c      	movs	r4, r1
 8000654:	193b      	adds	r3, r7, r4
 8000656:	2201      	movs	r2, #1
 8000658:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800065a:	193b      	adds	r3, r7, r4
 800065c:	2200      	movs	r2, #0
 800065e:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000660:	193b      	adds	r3, r7, r4
 8000662:	2200      	movs	r2, #0
 8000664:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000666:	193a      	adds	r2, r7, r4
 8000668:	23a0      	movs	r3, #160	; 0xa0
 800066a:	05db      	lsls	r3, r3, #23
 800066c:	0011      	movs	r1, r2
 800066e:	0018      	movs	r0, r3
 8000670:	f002 f8aa 	bl	80027c8 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = GSM_RESET_Pin;
 8000674:	0021      	movs	r1, r4
 8000676:	187b      	adds	r3, r7, r1
 8000678:	2280      	movs	r2, #128	; 0x80
 800067a:	0092      	lsls	r2, r2, #2
 800067c:	601a      	str	r2, [r3, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800067e:	187b      	adds	r3, r7, r1
 8000680:	2201      	movs	r2, #1
 8000682:	605a      	str	r2, [r3, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000684:	187b      	adds	r3, r7, r1
 8000686:	2200      	movs	r2, #0
 8000688:	609a      	str	r2, [r3, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800068a:	187b      	adds	r3, r7, r1
 800068c:	2200      	movs	r2, #0
 800068e:	60da      	str	r2, [r3, #12]
  HAL_GPIO_Init(GSM_RESET_GPIO_Port, &GPIO_InitStruct);
 8000690:	187b      	adds	r3, r7, r1
 8000692:	4a06      	ldr	r2, [pc, #24]	; (80006ac <MX_GPIO_Init+0x128>)
 8000694:	0019      	movs	r1, r3
 8000696:	0010      	movs	r0, r2
 8000698:	f002 f896 	bl	80027c8 <HAL_GPIO_Init>

}
 800069c:	46c0      	nop			; (mov r8, r8)
 800069e:	46bd      	mov	sp, r7
 80006a0:	b00b      	add	sp, #44	; 0x2c
 80006a2:	bd90      	pop	{r4, r7, pc}
 80006a4:	40021000 	.word	0x40021000
 80006a8:	50000800 	.word	0x50000800
 80006ac:	50000400 	.word	0x50000400

080006b0 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 80006b0:	b580      	push	{r7, lr}
 80006b2:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 80006b4:	f001 fe8e 	bl	80023d4 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 80006b8:	f000 f808 	bl	80006cc <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 80006bc:	f7ff ff62 	bl	8000584 <MX_GPIO_Init>
  MX_USART1_UART_Init();
 80006c0:	f000 f8f0 	bl	80008a4 <MX_USART1_UART_Init>
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	  App_Main();
 80006c4:	f7ff ff18 	bl	80004f8 <App_Main>
 80006c8:	e7fc      	b.n	80006c4 <main+0x14>
	...

080006cc <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80006cc:	b590      	push	{r4, r7, lr}
 80006ce:	b09b      	sub	sp, #108	; 0x6c
 80006d0:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80006d2:	2434      	movs	r4, #52	; 0x34
 80006d4:	193b      	adds	r3, r7, r4
 80006d6:	0018      	movs	r0, r3
 80006d8:	2334      	movs	r3, #52	; 0x34
 80006da:	001a      	movs	r2, r3
 80006dc:	2100      	movs	r1, #0
 80006de:	f01c f8a5 	bl	801c82c <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80006e2:	2320      	movs	r3, #32
 80006e4:	18fb      	adds	r3, r7, r3
 80006e6:	0018      	movs	r0, r3
 80006e8:	2314      	movs	r3, #20
 80006ea:	001a      	movs	r2, r3
 80006ec:	2100      	movs	r1, #0
 80006ee:	f01c f89d 	bl	801c82c <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 80006f2:	003b      	movs	r3, r7
 80006f4:	0018      	movs	r0, r3
 80006f6:	2320      	movs	r3, #32
 80006f8:	001a      	movs	r2, r3
 80006fa:	2100      	movs	r1, #0
 80006fc:	f01c f896 	bl	801c82c <memset>

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8000700:	4b29      	ldr	r3, [pc, #164]	; (80007a8 <SystemClock_Config+0xdc>)
 8000702:	681b      	ldr	r3, [r3, #0]
 8000704:	4a29      	ldr	r2, [pc, #164]	; (80007ac <SystemClock_Config+0xe0>)
 8000706:	401a      	ands	r2, r3
 8000708:	4b27      	ldr	r3, [pc, #156]	; (80007a8 <SystemClock_Config+0xdc>)
 800070a:	2180      	movs	r1, #128	; 0x80
 800070c:	0109      	lsls	r1, r1, #4
 800070e:	430a      	orrs	r2, r1
 8000710:	601a      	str	r2, [r3, #0]
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8000712:	0021      	movs	r1, r4
 8000714:	187b      	adds	r3, r7, r1
 8000716:	2202      	movs	r2, #2
 8000718:	601a      	str	r2, [r3, #0]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 800071a:	187b      	adds	r3, r7, r1
 800071c:	2201      	movs	r2, #1
 800071e:	60da      	str	r2, [r3, #12]
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 8000720:	187b      	adds	r3, r7, r1
 8000722:	2210      	movs	r2, #16
 8000724:	611a      	str	r2, [r3, #16]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000726:	187b      	adds	r3, r7, r1
 8000728:	2202      	movs	r2, #2
 800072a:	625a      	str	r2, [r3, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 800072c:	187b      	adds	r3, r7, r1
 800072e:	2200      	movs	r2, #0
 8000730:	629a      	str	r2, [r3, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLLMUL_4;
 8000732:	187b      	adds	r3, r7, r1
 8000734:	2280      	movs	r2, #128	; 0x80
 8000736:	02d2      	lsls	r2, r2, #11
 8000738:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLDIV = RCC_PLLDIV_2;
 800073a:	187b      	adds	r3, r7, r1
 800073c:	2280      	movs	r2, #128	; 0x80
 800073e:	03d2      	lsls	r2, r2, #15
 8000740:	631a      	str	r2, [r3, #48]	; 0x30
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000742:	187b      	adds	r3, r7, r1
 8000744:	0018      	movs	r0, r3
 8000746:	f002 f9db 	bl	8002b00 <HAL_RCC_OscConfig>
 800074a:	1e03      	subs	r3, r0, #0
 800074c:	d001      	beq.n	8000752 <SystemClock_Config+0x86>
  {
    Error_Handler();
 800074e:	f000 f82f 	bl	80007b0 <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000752:	2120      	movs	r1, #32
 8000754:	187b      	adds	r3, r7, r1
 8000756:	220f      	movs	r2, #15
 8000758:	601a      	str	r2, [r3, #0]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800075a:	187b      	adds	r3, r7, r1
 800075c:	2203      	movs	r2, #3
 800075e:	605a      	str	r2, [r3, #4]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000760:	187b      	adds	r3, r7, r1
 8000762:	2200      	movs	r2, #0
 8000764:	609a      	str	r2, [r3, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8000766:	187b      	adds	r3, r7, r1
 8000768:	2200      	movs	r2, #0
 800076a:	60da      	str	r2, [r3, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 800076c:	187b      	adds	r3, r7, r1
 800076e:	2200      	movs	r2, #0
 8000770:	611a      	str	r2, [r3, #16]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8000772:	187b      	adds	r3, r7, r1
 8000774:	2101      	movs	r1, #1
 8000776:	0018      	movs	r0, r3
 8000778:	f002 fd3e 	bl	80031f8 <HAL_RCC_ClockConfig>
 800077c:	1e03      	subs	r3, r0, #0
 800077e:	d001      	beq.n	8000784 <SystemClock_Config+0xb8>
  {
    Error_Handler();
 8000780:	f000 f816 	bl	80007b0 <Error_Handler>
  }
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1;
 8000784:	003b      	movs	r3, r7
 8000786:	2201      	movs	r2, #1
 8000788:	601a      	str	r2, [r3, #0]
  PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
 800078a:	003b      	movs	r3, r7
 800078c:	2200      	movs	r2, #0
 800078e:	609a      	str	r2, [r3, #8]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8000790:	003b      	movs	r3, r7
 8000792:	0018      	movs	r0, r3
 8000794:	f002 ff54 	bl	8003640 <HAL_RCCEx_PeriphCLKConfig>
 8000798:	1e03      	subs	r3, r0, #0
 800079a:	d001      	beq.n	80007a0 <SystemClock_Config+0xd4>
  {
    Error_Handler();
 800079c:	f000 f808 	bl	80007b0 <Error_Handler>
  }
}
 80007a0:	46c0      	nop			; (mov r8, r8)
 80007a2:	46bd      	mov	sp, r7
 80007a4:	b01b      	add	sp, #108	; 0x6c
 80007a6:	bd90      	pop	{r4, r7, pc}
 80007a8:	40007000 	.word	0x40007000
 80007ac:	ffffe7ff 	.word	0xffffe7ff

080007b0 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 80007b0:	b580      	push	{r7, lr}
 80007b2:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80007b4:	b672      	cpsid	i
}
 80007b6:	46c0      	nop			; (mov r8, r8)
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 80007b8:	e7fe      	b.n	80007b8 <Error_Handler+0x8>
	...

080007bc <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80007bc:	b580      	push	{r7, lr}
 80007be:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80007c0:	4b07      	ldr	r3, [pc, #28]	; (80007e0 <HAL_MspInit+0x24>)
 80007c2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80007c4:	4b06      	ldr	r3, [pc, #24]	; (80007e0 <HAL_MspInit+0x24>)
 80007c6:	2101      	movs	r1, #1
 80007c8:	430a      	orrs	r2, r1
 80007ca:	635a      	str	r2, [r3, #52]	; 0x34
  __HAL_RCC_PWR_CLK_ENABLE();
 80007cc:	4b04      	ldr	r3, [pc, #16]	; (80007e0 <HAL_MspInit+0x24>)
 80007ce:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80007d0:	4b03      	ldr	r3, [pc, #12]	; (80007e0 <HAL_MspInit+0x24>)
 80007d2:	2180      	movs	r1, #128	; 0x80
 80007d4:	0549      	lsls	r1, r1, #21
 80007d6:	430a      	orrs	r2, r1
 80007d8:	639a      	str	r2, [r3, #56]	; 0x38
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80007da:	46c0      	nop			; (mov r8, r8)
 80007dc:	46bd      	mov	sp, r7
 80007de:	bd80      	pop	{r7, pc}
 80007e0:	40021000 	.word	0x40021000

080007e4 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable Interrupt.
  */
void NMI_Handler(void)
{
 80007e4:	b580      	push	{r7, lr}
 80007e6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 80007e8:	e7fe      	b.n	80007e8 <NMI_Handler+0x4>

080007ea <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 80007ea:	b580      	push	{r7, lr}
 80007ec:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 80007ee:	e7fe      	b.n	80007ee <HardFault_Handler+0x4>

080007f0 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 80007f0:	b580      	push	{r7, lr}
 80007f2:	af00      	add	r7, sp, #0

  /* USER CODE END SVC_IRQn 0 */
  /* USER CODE BEGIN SVC_IRQn 1 */

  /* USER CODE END SVC_IRQn 1 */
}
 80007f4:	46c0      	nop			; (mov r8, r8)
 80007f6:	46bd      	mov	sp, r7
 80007f8:	bd80      	pop	{r7, pc}

080007fa <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 80007fa:	b580      	push	{r7, lr}
 80007fc:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 80007fe:	46c0      	nop			; (mov r8, r8)
 8000800:	46bd      	mov	sp, r7
 8000802:	bd80      	pop	{r7, pc}

08000804 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8000804:	b580      	push	{r7, lr}
 8000806:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8000808:	f001 fe38 	bl	800247c <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 800080c:	46c0      	nop			; (mov r8, r8)
 800080e:	46bd      	mov	sp, r7
 8000810:	bd80      	pop	{r7, pc}
	...

08000814 <USART1_IRQHandler>:

/**
  * @brief This function handles USART1 global interrupt / USART1 wake-up interrupt through EXTI line 25.
  */
void USART1_IRQHandler(void)
{
 8000814:	b580      	push	{r7, lr}
 8000816:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USART1_IRQn 0 */
	/* Check RXNE flag value in ISR register */

  /* USER CODE END USART1_IRQn 0 */
  HAL_UART_IRQHandler(&huart1);
 8000818:	4b03      	ldr	r3, [pc, #12]	; (8000828 <USART1_IRQHandler+0x14>)
 800081a:	0018      	movs	r0, r3
 800081c:	f003 f9ba 	bl	8003b94 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN USART1_IRQn 1 */

  /* USER CODE END USART1_IRQn 1 */
}
 8000820:	46c0      	nop			; (mov r8, r8)
 8000822:	46bd      	mov	sp, r7
 8000824:	bd80      	pop	{r7, pc}
 8000826:	46c0      	nop			; (mov r8, r8)
 8000828:	200013c8 	.word	0x200013c8

0800082c <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 800082c:	b580      	push	{r7, lr}
 800082e:	b086      	sub	sp, #24
 8000830:	af00      	add	r7, sp, #0
 8000832:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8000834:	4a13      	ldr	r2, [pc, #76]	; (8000884 <_sbrk+0x58>)
 8000836:	4b14      	ldr	r3, [pc, #80]	; (8000888 <_sbrk+0x5c>)
 8000838:	1ad3      	subs	r3, r2, r3
 800083a:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 800083c:	697b      	ldr	r3, [r7, #20]
 800083e:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8000840:	4b12      	ldr	r3, [pc, #72]	; (800088c <_sbrk+0x60>)
 8000842:	681b      	ldr	r3, [r3, #0]
 8000844:	2b00      	cmp	r3, #0
 8000846:	d102      	bne.n	800084e <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 8000848:	4b10      	ldr	r3, [pc, #64]	; (800088c <_sbrk+0x60>)
 800084a:	4a11      	ldr	r2, [pc, #68]	; (8000890 <_sbrk+0x64>)
 800084c:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 800084e:	4b0f      	ldr	r3, [pc, #60]	; (800088c <_sbrk+0x60>)
 8000850:	681a      	ldr	r2, [r3, #0]
 8000852:	687b      	ldr	r3, [r7, #4]
 8000854:	18d3      	adds	r3, r2, r3
 8000856:	693a      	ldr	r2, [r7, #16]
 8000858:	429a      	cmp	r2, r3
 800085a:	d205      	bcs.n	8000868 <_sbrk+0x3c>
  {
    errno = ENOMEM;
 800085c:	4b0d      	ldr	r3, [pc, #52]	; (8000894 <_sbrk+0x68>)
 800085e:	220c      	movs	r2, #12
 8000860:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 8000862:	2301      	movs	r3, #1
 8000864:	425b      	negs	r3, r3
 8000866:	e009      	b.n	800087c <_sbrk+0x50>
  }

  prev_heap_end = __sbrk_heap_end;
 8000868:	4b08      	ldr	r3, [pc, #32]	; (800088c <_sbrk+0x60>)
 800086a:	681b      	ldr	r3, [r3, #0]
 800086c:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 800086e:	4b07      	ldr	r3, [pc, #28]	; (800088c <_sbrk+0x60>)
 8000870:	681a      	ldr	r2, [r3, #0]
 8000872:	687b      	ldr	r3, [r7, #4]
 8000874:	18d2      	adds	r2, r2, r3
 8000876:	4b05      	ldr	r3, [pc, #20]	; (800088c <_sbrk+0x60>)
 8000878:	601a      	str	r2, [r3, #0]

  return (void *)prev_heap_end;
 800087a:	68fb      	ldr	r3, [r7, #12]
}
 800087c:	0018      	movs	r0, r3
 800087e:	46bd      	mov	sp, r7
 8000880:	b006      	add	sp, #24
 8000882:	bd80      	pop	{r7, pc}
 8000884:	20005000 	.word	0x20005000
 8000888:	00000400 	.word	0x00000400
 800088c:	200002b0 	.word	0x200002b0
 8000890:	20003e10 	.word	0x20003e10
 8000894:	20003e00 	.word	0x20003e00

08000898 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 8000898:	b580      	push	{r7, lr}
 800089a:	af00      	add	r7, sp, #0
  /* Configure the Vector Table location add offset address ------------------*/
#if defined (USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 800089c:	46c0      	nop			; (mov r8, r8)
 800089e:	46bd      	mov	sp, r7
 80008a0:	bd80      	pop	{r7, pc}
	...

080008a4 <MX_USART1_UART_Init>:
UART_HandleTypeDef huart1;

/* USART1 init function */

void MX_USART1_UART_Init(void)
{
 80008a4:	b580      	push	{r7, lr}
 80008a6:	af00      	add	r7, sp, #0
  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
 80008a8:	4b14      	ldr	r3, [pc, #80]	; (80008fc <MX_USART1_UART_Init+0x58>)
 80008aa:	4a15      	ldr	r2, [pc, #84]	; (8000900 <MX_USART1_UART_Init+0x5c>)
 80008ac:	601a      	str	r2, [r3, #0]
  huart1.Init.BaudRate = 115200;
 80008ae:	4b13      	ldr	r3, [pc, #76]	; (80008fc <MX_USART1_UART_Init+0x58>)
 80008b0:	22e1      	movs	r2, #225	; 0xe1
 80008b2:	0252      	lsls	r2, r2, #9
 80008b4:	605a      	str	r2, [r3, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 80008b6:	4b11      	ldr	r3, [pc, #68]	; (80008fc <MX_USART1_UART_Init+0x58>)
 80008b8:	2200      	movs	r2, #0
 80008ba:	609a      	str	r2, [r3, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 80008bc:	4b0f      	ldr	r3, [pc, #60]	; (80008fc <MX_USART1_UART_Init+0x58>)
 80008be:	2200      	movs	r2, #0
 80008c0:	60da      	str	r2, [r3, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 80008c2:	4b0e      	ldr	r3, [pc, #56]	; (80008fc <MX_USART1_UART_Init+0x58>)
 80008c4:	2200      	movs	r2, #0
 80008c6:	611a      	str	r2, [r3, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 80008c8:	4b0c      	ldr	r3, [pc, #48]	; (80008fc <MX_USART1_UART_Init+0x58>)
 80008ca:	220c      	movs	r2, #12
 80008cc:	615a      	str	r2, [r3, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 80008ce:	4b0b      	ldr	r3, [pc, #44]	; (80008fc <MX_USART1_UART_Init+0x58>)
 80008d0:	2200      	movs	r2, #0
 80008d2:	619a      	str	r2, [r3, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 80008d4:	4b09      	ldr	r3, [pc, #36]	; (80008fc <MX_USART1_UART_Init+0x58>)
 80008d6:	2200      	movs	r2, #0
 80008d8:	61da      	str	r2, [r3, #28]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 80008da:	4b08      	ldr	r3, [pc, #32]	; (80008fc <MX_USART1_UART_Init+0x58>)
 80008dc:	2200      	movs	r2, #0
 80008de:	621a      	str	r2, [r3, #32]
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 80008e0:	4b06      	ldr	r3, [pc, #24]	; (80008fc <MX_USART1_UART_Init+0x58>)
 80008e2:	2200      	movs	r2, #0
 80008e4:	625a      	str	r2, [r3, #36]	; 0x24
  if (HAL_UART_Init(&huart1) != HAL_OK)
 80008e6:	4b05      	ldr	r3, [pc, #20]	; (80008fc <MX_USART1_UART_Init+0x58>)
 80008e8:	0018      	movs	r0, r3
 80008ea:	f002 ffef 	bl	80038cc <HAL_UART_Init>
 80008ee:	1e03      	subs	r3, r0, #0
 80008f0:	d001      	beq.n	80008f6 <MX_USART1_UART_Init+0x52>
  {
    Error_Handler();
 80008f2:	f7ff ff5d 	bl	80007b0 <Error_Handler>
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}
 80008f6:	46c0      	nop			; (mov r8, r8)
 80008f8:	46bd      	mov	sp, r7
 80008fa:	bd80      	pop	{r7, pc}
 80008fc:	200013c8 	.word	0x200013c8
 8000900:	40013800 	.word	0x40013800

08000904 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 8000904:	b590      	push	{r4, r7, lr}
 8000906:	b089      	sub	sp, #36	; 0x24
 8000908:	af00      	add	r7, sp, #0
 800090a:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800090c:	240c      	movs	r4, #12
 800090e:	193b      	adds	r3, r7, r4
 8000910:	0018      	movs	r0, r3
 8000912:	2314      	movs	r3, #20
 8000914:	001a      	movs	r2, r3
 8000916:	2100      	movs	r1, #0
 8000918:	f01b ff88 	bl	801c82c <memset>
  if(uartHandle->Instance==USART1)
 800091c:	687b      	ldr	r3, [r7, #4]
 800091e:	681b      	ldr	r3, [r3, #0]
 8000920:	4a1c      	ldr	r2, [pc, #112]	; (8000994 <HAL_UART_MspInit+0x90>)
 8000922:	4293      	cmp	r3, r2
 8000924:	d132      	bne.n	800098c <HAL_UART_MspInit+0x88>
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* USART1 clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 8000926:	4b1c      	ldr	r3, [pc, #112]	; (8000998 <HAL_UART_MspInit+0x94>)
 8000928:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800092a:	4b1b      	ldr	r3, [pc, #108]	; (8000998 <HAL_UART_MspInit+0x94>)
 800092c:	2180      	movs	r1, #128	; 0x80
 800092e:	01c9      	lsls	r1, r1, #7
 8000930:	430a      	orrs	r2, r1
 8000932:	635a      	str	r2, [r3, #52]	; 0x34

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8000934:	4b18      	ldr	r3, [pc, #96]	; (8000998 <HAL_UART_MspInit+0x94>)
 8000936:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000938:	4b17      	ldr	r3, [pc, #92]	; (8000998 <HAL_UART_MspInit+0x94>)
 800093a:	2101      	movs	r1, #1
 800093c:	430a      	orrs	r2, r1
 800093e:	62da      	str	r2, [r3, #44]	; 0x2c
 8000940:	4b15      	ldr	r3, [pc, #84]	; (8000998 <HAL_UART_MspInit+0x94>)
 8000942:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000944:	2201      	movs	r2, #1
 8000946:	4013      	ands	r3, r2
 8000948:	60bb      	str	r3, [r7, #8]
 800094a:	68bb      	ldr	r3, [r7, #8]
    /**USART1 GPIO Configuration
    PA9     ------> USART1_TX
    PA10     ------> USART1_RX
    */
    GPIO_InitStruct.Pin = MCU_TX0_Pin|MCU_RX0_Pin;
 800094c:	193b      	adds	r3, r7, r4
 800094e:	22c0      	movs	r2, #192	; 0xc0
 8000950:	00d2      	lsls	r2, r2, #3
 8000952:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000954:	0021      	movs	r1, r4
 8000956:	187b      	adds	r3, r7, r1
 8000958:	2202      	movs	r2, #2
 800095a:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800095c:	187b      	adds	r3, r7, r1
 800095e:	2200      	movs	r2, #0
 8000960:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000962:	187b      	adds	r3, r7, r1
 8000964:	2203      	movs	r2, #3
 8000966:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF4_USART1;
 8000968:	187b      	adds	r3, r7, r1
 800096a:	2204      	movs	r2, #4
 800096c:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800096e:	187a      	adds	r2, r7, r1
 8000970:	23a0      	movs	r3, #160	; 0xa0
 8000972:	05db      	lsls	r3, r3, #23
 8000974:	0011      	movs	r1, r2
 8000976:	0018      	movs	r0, r3
 8000978:	f001 ff26 	bl	80027c8 <HAL_GPIO_Init>

    /* USART1 interrupt Init */
    HAL_NVIC_SetPriority(USART1_IRQn, 1, 0);
 800097c:	2200      	movs	r2, #0
 800097e:	2101      	movs	r1, #1
 8000980:	201b      	movs	r0, #27
 8000982:	f001 fe67 	bl	8002654 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 8000986:	201b      	movs	r0, #27
 8000988:	f001 fe79 	bl	800267e <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USART1_MspInit 1 */

  /* USER CODE END USART1_MspInit 1 */
  }
}
 800098c:	46c0      	nop			; (mov r8, r8)
 800098e:	46bd      	mov	sp, r7
 8000990:	b009      	add	sp, #36	; 0x24
 8000992:	bd90      	pop	{r4, r7, pc}
 8000994:	40013800 	.word	0x40013800
 8000998:	40021000 	.word	0x40021000

0800099c <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
   ldr   r0, =_estack
 800099c:	480d      	ldr	r0, [pc, #52]	; (80009d4 <LoopForever+0x2>)
   mov   sp, r0          /* set stack pointer */
 800099e:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 80009a0:	480d      	ldr	r0, [pc, #52]	; (80009d8 <LoopForever+0x6>)
  ldr r1, =_edata
 80009a2:	490e      	ldr	r1, [pc, #56]	; (80009dc <LoopForever+0xa>)
  ldr r2, =_sidata
 80009a4:	4a0e      	ldr	r2, [pc, #56]	; (80009e0 <LoopForever+0xe>)
  movs r3, #0
 80009a6:	2300      	movs	r3, #0
  b LoopCopyDataInit
 80009a8:	e002      	b.n	80009b0 <LoopCopyDataInit>

080009aa <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 80009aa:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 80009ac:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 80009ae:	3304      	adds	r3, #4

080009b0 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 80009b0:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 80009b2:	428c      	cmp	r4, r1
  bcc CopyDataInit
 80009b4:	d3f9      	bcc.n	80009aa <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 80009b6:	4a0b      	ldr	r2, [pc, #44]	; (80009e4 <LoopForever+0x12>)
  ldr r4, =_ebss
 80009b8:	4c0b      	ldr	r4, [pc, #44]	; (80009e8 <LoopForever+0x16>)
  movs r3, #0
 80009ba:	2300      	movs	r3, #0
  b LoopFillZerobss
 80009bc:	e001      	b.n	80009c2 <LoopFillZerobss>

080009be <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 80009be:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 80009c0:	3204      	adds	r2, #4

080009c2 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 80009c2:	42a2      	cmp	r2, r4
  bcc FillZerobss
 80009c4:	d3fb      	bcc.n	80009be <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 80009c6:	f7ff ff67 	bl	8000898 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80009ca:	f01b fed7 	bl	801c77c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 80009ce:	f7ff fe6f 	bl	80006b0 <main>

080009d2 <LoopForever>:

LoopForever:
    b LoopForever
 80009d2:	e7fe      	b.n	80009d2 <LoopForever>
   ldr   r0, =_estack
 80009d4:	20005000 	.word	0x20005000
  ldr r0, =_sdata
 80009d8:	20000000 	.word	0x20000000
  ldr r1, =_edata
 80009dc:	20000290 	.word	0x20000290
  ldr r2, =_sidata
 80009e0:	080221d0 	.word	0x080221d0
  ldr r2, =_sbss
 80009e4:	20000290 	.word	0x20000290
  ldr r4, =_ebss
 80009e8:	20003e10 	.word	0x20003e10

080009ec <ADC1_COMP_IRQHandler>:
 * @retval : None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 80009ec:	e7fe      	b.n	80009ec <ADC1_COMP_IRQHandler>
	...

080009f0 <__NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
 80009f0:	b580      	push	{r7, lr}
 80009f2:	af00      	add	r7, sp, #0
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80009f4:	f3bf 8f4f 	dsb	sy
}
 80009f8:	46c0      	nop			; (mov r8, r8)
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80009fa:	4b04      	ldr	r3, [pc, #16]	; (8000a0c <__NVIC_SystemReset+0x1c>)
 80009fc:	4a04      	ldr	r2, [pc, #16]	; (8000a10 <__NVIC_SystemReset+0x20>)
 80009fe:	60da      	str	r2, [r3, #12]
  __ASM volatile ("dsb 0xF":::"memory");
 8000a00:	f3bf 8f4f 	dsb	sy
}
 8000a04:	46c0      	nop			; (mov r8, r8)
                 SCB_AIRCR_SYSRESETREQ_Msk);
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 8000a06:	46c0      	nop			; (mov r8, r8)
 8000a08:	e7fd      	b.n	8000a06 <__NVIC_SystemReset+0x16>
 8000a0a:	46c0      	nop			; (mov r8, r8)
 8000a0c:	e000ed00 	.word	0xe000ed00
 8000a10:	05fa0004 	.word	0x05fa0004

08000a14 <GSM_Config_Module>:
    {"ATD*99***1#\r\n", "CONNECT", "", "", "", 1000, 10, open_ppp_stack}, // Open ppp stack
    
};

void GSM_Config_Module (GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 8000a14:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000a16:	b089      	sub	sp, #36	; 0x24
 8000a18:	af04      	add	r7, sp, #16
 8000a1a:	0002      	movs	r2, r0
 8000a1c:	6039      	str	r1, [r7, #0]
 8000a1e:	1dfb      	adds	r3, r7, #7
 8000a20:	701a      	strb	r2, [r3, #0]
    uint8_t TableIndex = GSM_Manager.step;
 8000a22:	210f      	movs	r1, #15
 8000a24:	187b      	adds	r3, r7, r1
 8000a26:	4a34      	ldr	r2, [pc, #208]	; (8000af8 <GSM_Config_Module+0xe4>)
 8000a28:	7852      	ldrb	r2, [r2, #1]
 8000a2a:	701a      	strb	r2, [r3, #0]
    uint8_t TableSize = sizeof(atc_table_config_module)/sizeof(atc_table_config_module[0]);
 8000a2c:	200e      	movs	r0, #14
 8000a2e:	183b      	adds	r3, r7, r0
 8000a30:	2218      	movs	r2, #24
 8000a32:	701a      	strb	r2, [r3, #0]
    if(TableIndex > TableSize)
 8000a34:	187a      	adds	r2, r7, r1
 8000a36:	183b      	adds	r3, r7, r0
 8000a38:	7812      	ldrb	r2, [r2, #0]
 8000a3a:	781b      	ldrb	r3, [r3, #0]
 8000a3c:	429a      	cmp	r2, r3
 8000a3e:	d857      	bhi.n	8000af0 <GSM_Config_Module+0xdc>
    {
        return;
    }
    DEBUG_PrintResult_ATC(atc_table_config_module[TableIndex-1].cmd, (event == GSM_EVENT_OK)?"[OK]":"[FAIL]");
 8000a40:	187b      	adds	r3, r7, r1
 8000a42:	781b      	ldrb	r3, [r3, #0]
 8000a44:	1e5a      	subs	r2, r3, #1
 8000a46:	4b2d      	ldr	r3, [pc, #180]	; (8000afc <GSM_Config_Module+0xe8>)
 8000a48:	0152      	lsls	r2, r2, #5
 8000a4a:	58d2      	ldr	r2, [r2, r3]
 8000a4c:	1dfb      	adds	r3, r7, #7
 8000a4e:	781b      	ldrb	r3, [r3, #0]
 8000a50:	2b00      	cmp	r3, #0
 8000a52:	d101      	bne.n	8000a58 <GSM_Config_Module+0x44>
 8000a54:	4b2a      	ldr	r3, [pc, #168]	; (8000b00 <GSM_Config_Module+0xec>)
 8000a56:	e000      	b.n	8000a5a <GSM_Config_Module+0x46>
 8000a58:	4b2a      	ldr	r3, [pc, #168]	; (8000b04 <GSM_Config_Module+0xf0>)
 8000a5a:	0019      	movs	r1, r3
 8000a5c:	0010      	movs	r0, r2
 8000a5e:	f001 f9e5 	bl	8001e2c <DEBUG_PrintResult_ATC>
    if(event == GSM_EVENT_OK)
 8000a62:	1dfb      	adds	r3, r7, #7
 8000a64:	781b      	ldrb	r3, [r3, #0]
 8000a66:	2b00      	cmp	r3, #0
 8000a68:	d13e      	bne.n	8000ae8 <GSM_Config_Module+0xd4>
    {
        if(TableIndex < TableSize)
 8000a6a:	210f      	movs	r1, #15
 8000a6c:	187a      	adds	r2, r7, r1
 8000a6e:	230e      	movs	r3, #14
 8000a70:	18fb      	adds	r3, r7, r3
 8000a72:	7812      	ldrb	r2, [r2, #0]
 8000a74:	781b      	ldrb	r3, [r3, #0]
 8000a76:	429a      	cmp	r2, r3
 8000a78:	d215      	bcs.n	8000aa6 <GSM_Config_Module+0x92>
        {
        	//HAL_Delay(2000);
            GSM_SendCommand_AT(atc_table_config_module[TableIndex]);
 8000a7a:	187b      	adds	r3, r7, r1
 8000a7c:	781b      	ldrb	r3, [r3, #0]
 8000a7e:	4c1f      	ldr	r4, [pc, #124]	; (8000afc <GSM_Config_Module+0xe8>)
 8000a80:	015b      	lsls	r3, r3, #5
 8000a82:	2110      	movs	r1, #16
 8000a84:	18e2      	adds	r2, r4, r3
 8000a86:	1851      	adds	r1, r2, r1
 8000a88:	466a      	mov	r2, sp
 8000a8a:	c961      	ldmia	r1!, {r0, r5, r6}
 8000a8c:	c261      	stmia	r2!, {r0, r5, r6}
 8000a8e:	6809      	ldr	r1, [r1, #0]
 8000a90:	6011      	str	r1, [r2, #0]
 8000a92:	5918      	ldr	r0, [r3, r4]
 8000a94:	18e2      	adds	r2, r4, r3
 8000a96:	6851      	ldr	r1, [r2, #4]
 8000a98:	18e2      	adds	r2, r4, r3
 8000a9a:	6892      	ldr	r2, [r2, #8]
 8000a9c:	18e3      	adds	r3, r4, r3
 8000a9e:	68db      	ldr	r3, [r3, #12]
 8000aa0:	f000 ff48 	bl	8001934 <GSM_SendCommand_AT>
 8000aa4:	e019      	b.n	8000ada <GSM_Config_Module+0xc6>
        }
        else
        {
            // Da Config Module xong
            GSM_Manager.step = 0;
 8000aa6:	4b14      	ldr	r3, [pc, #80]	; (8000af8 <GSM_Config_Module+0xe4>)
 8000aa8:	2200      	movs	r2, #0
 8000aaa:	705a      	strb	r2, [r3, #1]
            DEBUG_INFO("Config module DONE.\r\n");
 8000aac:	f01b fe48 	bl	801c740 <sys_get_tick_ms>
 8000ab0:	0001      	movs	r1, r0
 8000ab2:	4a15      	ldr	r2, [pc, #84]	; (8000b08 <GSM_Config_Module+0xf4>)
 8000ab4:	4b15      	ldr	r3, [pc, #84]	; (8000b0c <GSM_Config_Module+0xf8>)
 8000ab6:	0018      	movs	r0, r3
 8000ab8:	f001 fb88 	bl	80021cc <app_debug_rtt_raw>
            GSM_SendCommand_AT(atc_table_open_ppp_stack[0]);
 8000abc:	4b14      	ldr	r3, [pc, #80]	; (8000b10 <GSM_Config_Module+0xfc>)
 8000abe:	466a      	mov	r2, sp
 8000ac0:	0011      	movs	r1, r2
 8000ac2:	001a      	movs	r2, r3
 8000ac4:	3210      	adds	r2, #16
 8000ac6:	ca31      	ldmia	r2!, {r0, r4, r5}
 8000ac8:	c131      	stmia	r1!, {r0, r4, r5}
 8000aca:	6812      	ldr	r2, [r2, #0]
 8000acc:	600a      	str	r2, [r1, #0]
 8000ace:	6818      	ldr	r0, [r3, #0]
 8000ad0:	6859      	ldr	r1, [r3, #4]
 8000ad2:	689a      	ldr	r2, [r3, #8]
 8000ad4:	68db      	ldr	r3, [r3, #12]
 8000ad6:	f000 ff2d 	bl	8001934 <GSM_SendCommand_AT>
        }
        GSM_Manager.step++;
 8000ada:	4b07      	ldr	r3, [pc, #28]	; (8000af8 <GSM_Config_Module+0xe4>)
 8000adc:	785b      	ldrb	r3, [r3, #1]
 8000ade:	3301      	adds	r3, #1
 8000ae0:	b2da      	uxtb	r2, r3
 8000ae2:	4b05      	ldr	r3, [pc, #20]	; (8000af8 <GSM_Config_Module+0xe4>)
 8000ae4:	705a      	strb	r2, [r3, #1]
 8000ae6:	e004      	b.n	8000af2 <GSM_Config_Module+0xde>
    }
    else //if(event == GSM_EVENT_TIMEOUT)
    {
        GSM_Manager_ChangeState(GSM_STATE_RESET);
 8000ae8:	2001      	movs	r0, #1
 8000aea:	f000 fbe9 	bl	80012c0 <GSM_Manager_ChangeState>
 8000aee:	e000      	b.n	8000af2 <GSM_Config_Module+0xde>
        return;
 8000af0:	46c0      	nop			; (mov r8, r8)
    }
}
 8000af2:	46bd      	mov	sp, r7
 8000af4:	b005      	add	sp, #20
 8000af6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000af8:	2000144c 	.word	0x2000144c
 8000afc:	08021514 	.word	0x08021514
 8000b00:	0801d4ac 	.word	0x0801d4ac
 8000b04:	0801d4b4 	.word	0x0801d4b4
 8000b08:	0801d35c 	.word	0x0801d35c
 8000b0c:	0801d4bc 	.word	0x0801d4bc
 8000b10:	08021814 	.word	0x08021814

08000b14 <open_ppp_stack>:
void open_ppp_stack(GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 8000b14:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000b16:	b089      	sub	sp, #36	; 0x24
 8000b18:	af04      	add	r7, sp, #16
 8000b1a:	0002      	movs	r2, r0
 8000b1c:	6039      	str	r1, [r7, #0]
 8000b1e:	1dfb      	adds	r3, r7, #7
 8000b20:	701a      	strb	r2, [r3, #0]
    DEBUG_INFO("Open PPP stack step %d\r\n", GSM_Manager.step);
 8000b22:	f01b fe0d 	bl	801c740 <sys_get_tick_ms>
 8000b26:	0001      	movs	r1, r0
 8000b28:	4b43      	ldr	r3, [pc, #268]	; (8000c38 <open_ppp_stack+0x124>)
 8000b2a:	785b      	ldrb	r3, [r3, #1]
 8000b2c:	4a43      	ldr	r2, [pc, #268]	; (8000c3c <open_ppp_stack+0x128>)
 8000b2e:	4844      	ldr	r0, [pc, #272]	; (8000c40 <open_ppp_stack+0x12c>)
 8000b30:	f001 fb4c 	bl	80021cc <app_debug_rtt_raw>
    uint8_t TableIndex = GSM_Manager.step;
 8000b34:	210f      	movs	r1, #15
 8000b36:	187b      	adds	r3, r7, r1
 8000b38:	4a3f      	ldr	r2, [pc, #252]	; (8000c38 <open_ppp_stack+0x124>)
 8000b3a:	7852      	ldrb	r2, [r2, #1]
 8000b3c:	701a      	strb	r2, [r3, #0]
    uint8_t TableSize = sizeof(atc_table_open_ppp_stack)/sizeof(atc_table_open_ppp_stack[0]);
 8000b3e:	200e      	movs	r0, #14
 8000b40:	183b      	adds	r3, r7, r0
 8000b42:	2204      	movs	r2, #4
 8000b44:	701a      	strb	r2, [r3, #0]
    if(TableIndex > TableSize)
 8000b46:	187a      	adds	r2, r7, r1
 8000b48:	183b      	adds	r3, r7, r0
 8000b4a:	7812      	ldrb	r2, [r2, #0]
 8000b4c:	781b      	ldrb	r3, [r3, #0]
 8000b4e:	429a      	cmp	r2, r3
 8000b50:	d86d      	bhi.n	8000c2e <open_ppp_stack+0x11a>
    {
        return;
    }
    DEBUG_PrintResult_ATC(atc_table_open_ppp_stack[TableIndex-1].cmd, (event == GSM_EVENT_OK)?"[OK]":"[FAIL]");
 8000b52:	187b      	adds	r3, r7, r1
 8000b54:	781b      	ldrb	r3, [r3, #0]
 8000b56:	1e5a      	subs	r2, r3, #1
 8000b58:	4b3a      	ldr	r3, [pc, #232]	; (8000c44 <open_ppp_stack+0x130>)
 8000b5a:	0152      	lsls	r2, r2, #5
 8000b5c:	58d2      	ldr	r2, [r2, r3]
 8000b5e:	1dfb      	adds	r3, r7, #7
 8000b60:	781b      	ldrb	r3, [r3, #0]
 8000b62:	2b00      	cmp	r3, #0
 8000b64:	d101      	bne.n	8000b6a <open_ppp_stack+0x56>
 8000b66:	4b38      	ldr	r3, [pc, #224]	; (8000c48 <open_ppp_stack+0x134>)
 8000b68:	e000      	b.n	8000b6c <open_ppp_stack+0x58>
 8000b6a:	4b38      	ldr	r3, [pc, #224]	; (8000c4c <open_ppp_stack+0x138>)
 8000b6c:	0019      	movs	r1, r3
 8000b6e:	0010      	movs	r0, r2
 8000b70:	f001 f95c 	bl	8001e2c <DEBUG_PrintResult_ATC>
    if(event == GSM_EVENT_OK)
 8000b74:	1dfb      	adds	r3, r7, #7
 8000b76:	781b      	ldrb	r3, [r3, #0]
 8000b78:	2b00      	cmp	r3, #0
 8000b7a:	d154      	bne.n	8000c26 <open_ppp_stack+0x112>
    {
        if(TableIndex < TableSize)
 8000b7c:	210f      	movs	r1, #15
 8000b7e:	187a      	adds	r2, r7, r1
 8000b80:	230e      	movs	r3, #14
 8000b82:	18fb      	adds	r3, r7, r3
 8000b84:	7812      	ldrb	r2, [r2, #0]
 8000b86:	781b      	ldrb	r3, [r3, #0]
 8000b88:	429a      	cmp	r2, r3
 8000b8a:	d215      	bcs.n	8000bb8 <open_ppp_stack+0xa4>
        {
            GSM_SendCommand_AT(atc_table_open_ppp_stack[TableIndex]);
 8000b8c:	187b      	adds	r3, r7, r1
 8000b8e:	781b      	ldrb	r3, [r3, #0]
 8000b90:	4c2c      	ldr	r4, [pc, #176]	; (8000c44 <open_ppp_stack+0x130>)
 8000b92:	015b      	lsls	r3, r3, #5
 8000b94:	2110      	movs	r1, #16
 8000b96:	18e2      	adds	r2, r4, r3
 8000b98:	1851      	adds	r1, r2, r1
 8000b9a:	466a      	mov	r2, sp
 8000b9c:	c961      	ldmia	r1!, {r0, r5, r6}
 8000b9e:	c261      	stmia	r2!, {r0, r5, r6}
 8000ba0:	6809      	ldr	r1, [r1, #0]
 8000ba2:	6011      	str	r1, [r2, #0]
 8000ba4:	5918      	ldr	r0, [r3, r4]
 8000ba6:	18e2      	adds	r2, r4, r3
 8000ba8:	6851      	ldr	r1, [r2, #4]
 8000baa:	18e2      	adds	r2, r4, r3
 8000bac:	6892      	ldr	r2, [r2, #8]
 8000bae:	18e3      	adds	r3, r4, r3
 8000bb0:	68db      	ldr	r3, [r3, #12]
 8000bb2:	f000 febf 	bl	8001934 <GSM_SendCommand_AT>
 8000bb6:	e02f      	b.n	8000c18 <open_ppp_stack+0x104>
        }
        else
        {
            GSM_Manager.mode = GSM_INTERNET_MODE_PPP_STACK;
 8000bb8:	4b1f      	ldr	r3, [pc, #124]	; (8000c38 <open_ppp_stack+0x124>)
 8000bba:	2201      	movs	r2, #1
 8000bbc:	709a      	strb	r2, [r3, #2]
            // Da CONNECT PPP thanh cong
            GSM_Manager_ChangeState(GSM_STATE_OK);
 8000bbe:	2002      	movs	r0, #2
 8000bc0:	f000 fb7e 	bl	80012c0 <GSM_Manager_ChangeState>

            //Create PPP connection
            m_ppp_control_block = pppos_create(&m_ppp_netif, ppp_output_callback, ppp_link_status_cb, NULL);
 8000bc4:	4a22      	ldr	r2, [pc, #136]	; (8000c50 <open_ppp_stack+0x13c>)
 8000bc6:	4923      	ldr	r1, [pc, #140]	; (8000c54 <open_ppp_stack+0x140>)
 8000bc8:	4823      	ldr	r0, [pc, #140]	; (8000c58 <open_ppp_stack+0x144>)
 8000bca:	2300      	movs	r3, #0
 8000bcc:	f019 f950 	bl	8019e70 <pppos_create>
 8000bd0:	0002      	movs	r2, r0
 8000bd2:	4b22      	ldr	r3, [pc, #136]	; (8000c5c <open_ppp_stack+0x148>)
 8000bd4:	601a      	str	r2, [r3, #0]
            if (m_ppp_control_block == NULL)
 8000bd6:	4b21      	ldr	r3, [pc, #132]	; (8000c5c <open_ppp_stack+0x148>)
 8000bd8:	681b      	ldr	r3, [r3, #0]
 8000bda:	2b00      	cmp	r3, #0
 8000bdc:	d109      	bne.n	8000bf2 <open_ppp_stack+0xde>
            {
                DEBUG_ERROR("Create PPP interface ERR!\r\n");
 8000bde:	f01b fdaf 	bl	801c740 <sys_get_tick_ms>
 8000be2:	0001      	movs	r1, r0
 8000be4:	4a15      	ldr	r2, [pc, #84]	; (8000c3c <open_ppp_stack+0x128>)
 8000be6:	4b1e      	ldr	r3, [pc, #120]	; (8000c60 <open_ppp_stack+0x14c>)
 8000be8:	0018      	movs	r0, r3
 8000bea:	f001 faef 	bl	80021cc <app_debug_rtt_raw>
                //assert(0);
                // TODO handle memory error
                NVIC_SystemReset();
 8000bee:	f7ff feff 	bl	80009f0 <__NVIC_SystemReset>
            }

            /* Set this interface as default route */
            ppp_set_default(m_ppp_control_block);
 8000bf2:	4b1a      	ldr	r3, [pc, #104]	; (8000c5c <open_ppp_stack+0x148>)
 8000bf4:	681b      	ldr	r3, [r3, #0]
 8000bf6:	6a1b      	ldr	r3, [r3, #32]
 8000bf8:	0018      	movs	r0, r3
 8000bfa:	f008 f88d 	bl	8008d18 <netif_set_default>
            //ppp_set_auth(m_ppp_control_block, PPPAUTHTYPE_CHAP, "", "");
            ppp_set_notify_phase_callback(m_ppp_control_block, ppp_notify_phase_cb);
 8000bfe:	4b17      	ldr	r3, [pc, #92]	; (8000c5c <open_ppp_stack+0x148>)
 8000c00:	681b      	ldr	r3, [r3, #0]
 8000c02:	4a18      	ldr	r2, [pc, #96]	; (8000c64 <open_ppp_stack+0x150>)
 8000c04:	0011      	movs	r1, r2
 8000c06:	0018      	movs	r0, r3
 8000c08:	f018 fc7a 	bl	8019500 <ppp_set_notify_phase_callback>
            ppp_connect(m_ppp_control_block, 0);
 8000c0c:	4b13      	ldr	r3, [pc, #76]	; (8000c5c <open_ppp_stack+0x148>)
 8000c0e:	681b      	ldr	r3, [r3, #0]
 8000c10:	2100      	movs	r1, #0
 8000c12:	0018      	movs	r0, r3
 8000c14:	f018 fc88 	bl	8019528 <ppp_connect>
        }
        GSM_Manager.step++;
 8000c18:	4b07      	ldr	r3, [pc, #28]	; (8000c38 <open_ppp_stack+0x124>)
 8000c1a:	785b      	ldrb	r3, [r3, #1]
 8000c1c:	3301      	adds	r3, #1
 8000c1e:	b2da      	uxtb	r2, r3
 8000c20:	4b05      	ldr	r3, [pc, #20]	; (8000c38 <open_ppp_stack+0x124>)
 8000c22:	705a      	strb	r2, [r3, #1]
 8000c24:	e004      	b.n	8000c30 <open_ppp_stack+0x11c>
    }
    else //if(event == GSM_EVENT_TIMEOUT)
    {
        // Handle ERROR
        GSM_Manager_ChangeState(GSM_STATE_RESET);
 8000c26:	2001      	movs	r0, #1
 8000c28:	f000 fb4a 	bl	80012c0 <GSM_Manager_ChangeState>
 8000c2c:	e000      	b.n	8000c30 <open_ppp_stack+0x11c>
        return;
 8000c2e:	46c0      	nop			; (mov r8, r8)
    }
}
 8000c30:	46bd      	mov	sp, r7
 8000c32:	b005      	add	sp, #20
 8000c34:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000c36:	46c0      	nop			; (mov r8, r8)
 8000c38:	2000144c 	.word	0x2000144c
 8000c3c:	0801d35c 	.word	0x0801d35c
 8000c40:	0801d4ec 	.word	0x0801d4ec
 8000c44:	08021814 	.word	0x08021814
 8000c48:	0801d4ac 	.word	0x0801d4ac
 8000c4c:	0801d4b4 	.word	0x0801d4b4
 8000c50:	08000f71 	.word	0x08000f71
 8000c54:	08000e99 	.word	0x08000e99
 8000c58:	200002cc 	.word	0x200002cc
 8000c5c:	20000308 	.word	0x20000308
 8000c60:	0801d520 	.word	0x0801d520
 8000c64:	08000d75 	.word	0x08000d75

08000c68 <GSM_GET_IMEI_Buffer>:
void GSM_GET_IMEI_Buffer(GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 8000c68:	b580      	push	{r7, lr}
 8000c6a:	b082      	sub	sp, #8
 8000c6c:	af00      	add	r7, sp, #0
 8000c6e:	0002      	movs	r2, r0
 8000c70:	6039      	str	r1, [r7, #0]
 8000c72:	1dfb      	adds	r3, r7, #7
 8000c74:	701a      	strb	r2, [r3, #0]
    if(event != GSM_EVENT_OK)
 8000c76:	1dfb      	adds	r3, r7, #7
 8000c78:	781b      	ldrb	r3, [r3, #0]
 8000c7a:	2b00      	cmp	r3, #0
 8000c7c:	d007      	beq.n	8000c8e <GSM_GET_IMEI_Buffer+0x26>
    {
        GSM_Config_Module(event, &Resp_Buffer);
 8000c7e:	003a      	movs	r2, r7
 8000c80:	1dfb      	adds	r3, r7, #7
 8000c82:	781b      	ldrb	r3, [r3, #0]
 8000c84:	0011      	movs	r1, r2
 8000c86:	0018      	movs	r0, r3
 8000c88:	f7ff fec4 	bl	8000a14 <GSM_Config_Module>
 8000c8c:	e02e      	b.n	8000cec <GSM_GET_IMEI_Buffer+0x84>
    }
    else
    {
        if(strlen((char*)GSM_IMEI_Buffer) < 14)
 8000c8e:	4b19      	ldr	r3, [pc, #100]	; (8000cf4 <GSM_GET_IMEI_Buffer+0x8c>)
 8000c90:	0018      	movs	r0, r3
 8000c92:	f7ff fa39 	bl	8000108 <strlen>
 8000c96:	0003      	movs	r3, r0
 8000c98:	2b0d      	cmp	r3, #13
 8000c9a:	d820      	bhi.n	8000cde <GSM_GET_IMEI_Buffer+0x76>
        {
            GSM_Utilities_Get_IMEI(Resp_Buffer, GSM_IMEI_Buffer, 16);
 8000c9c:	683b      	ldr	r3, [r7, #0]
 8000c9e:	4915      	ldr	r1, [pc, #84]	; (8000cf4 <GSM_GET_IMEI_Buffer+0x8c>)
 8000ca0:	2210      	movs	r2, #16
 8000ca2:	0018      	movs	r0, r3
 8000ca4:	f001 f806 	bl	8001cb4 <GSM_Utilities_Get_IMEI>
            if(strlen((char*)GSM_IMEI_Buffer) < 15)
 8000ca8:	4b12      	ldr	r3, [pc, #72]	; (8000cf4 <GSM_GET_IMEI_Buffer+0x8c>)
 8000caa:	0018      	movs	r0, r3
 8000cac:	f7ff fa2c 	bl	8000108 <strlen>
 8000cb0:	0003      	movs	r3, r0
 8000cb2:	2b0e      	cmp	r3, #14
 8000cb4:	d80b      	bhi.n	8000cce <GSM_GET_IMEI_Buffer+0x66>
            {
                DEBUG_WARN("IMEI's invalid!\r\n");
 8000cb6:	f01b fd43 	bl	801c740 <sys_get_tick_ms>
 8000cba:	0001      	movs	r1, r0
 8000cbc:	4a0e      	ldr	r2, [pc, #56]	; (8000cf8 <GSM_GET_IMEI_Buffer+0x90>)
 8000cbe:	4b0f      	ldr	r3, [pc, #60]	; (8000cfc <GSM_GET_IMEI_Buffer+0x94>)
 8000cc0:	0018      	movs	r0, r3
 8000cc2:	f001 fa83 	bl	80021cc <app_debug_rtt_raw>
                GSM_Manager_ChangeState(GSM_STATE_RESET); // Cant get GSM imei, maybe gsm module error =>> Restart module
 8000cc6:	2001      	movs	r0, #1
 8000cc8:	f000 fafa 	bl	80012c0 <GSM_Manager_ChangeState>
                return;
 8000ccc:	e00e      	b.n	8000cec <GSM_GET_IMEI_Buffer+0x84>
            }
            else
            {
                DEBUG_INFO("GSM IMEI: %s\r\n", GSM_IMEI_Buffer);
 8000cce:	f01b fd37 	bl	801c740 <sys_get_tick_ms>
 8000cd2:	0001      	movs	r1, r0
 8000cd4:	4b07      	ldr	r3, [pc, #28]	; (8000cf4 <GSM_GET_IMEI_Buffer+0x8c>)
 8000cd6:	4a08      	ldr	r2, [pc, #32]	; (8000cf8 <GSM_GET_IMEI_Buffer+0x90>)
 8000cd8:	4809      	ldr	r0, [pc, #36]	; (8000d00 <GSM_GET_IMEI_Buffer+0x98>)
 8000cda:	f001 fa77 	bl	80021cc <app_debug_rtt_raw>
            }
        }
        GSM_Config_Module(event, &Resp_Buffer);
 8000cde:	003a      	movs	r2, r7
 8000ce0:	1dfb      	adds	r3, r7, #7
 8000ce2:	781b      	ldrb	r3, [r3, #0]
 8000ce4:	0011      	movs	r1, r2
 8000ce6:	0018      	movs	r0, r3
 8000ce8:	f7ff fe94 	bl	8000a14 <GSM_Config_Module>
    }
}
 8000cec:	46bd      	mov	sp, r7
 8000cee:	b002      	add	sp, #8
 8000cf0:	bd80      	pop	{r7, pc}
 8000cf2:	46c0      	nop			; (mov r8, r8)
 8000cf4:	200002b4 	.word	0x200002b4
 8000cf8:	0801d35c 	.word	0x0801d35c
 8000cfc:	0801d558 	.word	0x0801d558
 8000d00:	0801d584 	.word	0x0801d584

08000d04 <GSM_GET_Signal_Strength>:
void GSM_GET_Signal_Strength(GSM_Response_Event_TypDef event, void *Resp_Buffer)
{
 8000d04:	b580      	push	{r7, lr}
 8000d06:	b082      	sub	sp, #8
 8000d08:	af00      	add	r7, sp, #0
 8000d0a:	0002      	movs	r2, r0
 8000d0c:	6039      	str	r1, [r7, #0]
 8000d0e:	1dfb      	adds	r3, r7, #7
 8000d10:	701a      	strb	r2, [r3, #0]
    
    if(event != GSM_EVENT_OK)
 8000d12:	1dfb      	adds	r3, r7, #7
 8000d14:	781b      	ldrb	r3, [r3, #0]
 8000d16:	2b00      	cmp	r3, #0
 8000d18:	d007      	beq.n	8000d2a <GSM_GET_Signal_Strength+0x26>
    {
        GSM_Config_Module(event, &Resp_Buffer);
 8000d1a:	003a      	movs	r2, r7
 8000d1c:	1dfb      	adds	r3, r7, #7
 8000d1e:	781b      	ldrb	r3, [r3, #0]
 8000d20:	0011      	movs	r1, r2
 8000d22:	0018      	movs	r0, r3
 8000d24:	f7ff fe76 	bl	8000a14 <GSM_Config_Module>
            gsm_utilities_get_signal_strength_from_buffer(Resp_Buffer, &GSM_Signal_Strength);
            DEBUG_INFO("GSM Signal strength: %d\r\n", GSM_Signal_Strength);
        }
        GSM_Config_Module(event, &Resp_Buffer);
    }
}
 8000d28:	e019      	b.n	8000d5e <GSM_GET_Signal_Strength+0x5a>
        if(GSM_Signal_Strength == 0)
 8000d2a:	4b0f      	ldr	r3, [pc, #60]	; (8000d68 <GSM_GET_Signal_Strength+0x64>)
 8000d2c:	881b      	ldrh	r3, [r3, #0]
 8000d2e:	2b00      	cmp	r3, #0
 8000d30:	d10e      	bne.n	8000d50 <GSM_GET_Signal_Strength+0x4c>
            gsm_utilities_get_signal_strength_from_buffer(Resp_Buffer, &GSM_Signal_Strength);
 8000d32:	683b      	ldr	r3, [r7, #0]
 8000d34:	4a0c      	ldr	r2, [pc, #48]	; (8000d68 <GSM_GET_Signal_Strength+0x64>)
 8000d36:	0011      	movs	r1, r2
 8000d38:	0018      	movs	r0, r3
 8000d3a:	f000 ffff 	bl	8001d3c <gsm_utilities_get_signal_strength_from_buffer>
            DEBUG_INFO("GSM Signal strength: %d\r\n", GSM_Signal_Strength);
 8000d3e:	f01b fcff 	bl	801c740 <sys_get_tick_ms>
 8000d42:	0001      	movs	r1, r0
 8000d44:	4b08      	ldr	r3, [pc, #32]	; (8000d68 <GSM_GET_Signal_Strength+0x64>)
 8000d46:	881b      	ldrh	r3, [r3, #0]
 8000d48:	4a08      	ldr	r2, [pc, #32]	; (8000d6c <GSM_GET_Signal_Strength+0x68>)
 8000d4a:	4809      	ldr	r0, [pc, #36]	; (8000d70 <GSM_GET_Signal_Strength+0x6c>)
 8000d4c:	f001 fa3e 	bl	80021cc <app_debug_rtt_raw>
        GSM_Config_Module(event, &Resp_Buffer);
 8000d50:	003a      	movs	r2, r7
 8000d52:	1dfb      	adds	r3, r7, #7
 8000d54:	781b      	ldrb	r3, [r3, #0]
 8000d56:	0011      	movs	r1, r2
 8000d58:	0018      	movs	r0, r3
 8000d5a:	f7ff fe5b 	bl	8000a14 <GSM_Config_Module>
}
 8000d5e:	46c0      	nop			; (mov r8, r8)
 8000d60:	46bd      	mov	sp, r7
 8000d62:	b002      	add	sp, #8
 8000d64:	bd80      	pop	{r7, pc}
 8000d66:	46c0      	nop			; (mov r8, r8)
 8000d68:	200002c8 	.word	0x200002c8
 8000d6c:	0801d35c 	.word	0x0801d35c
 8000d70:	0801d5ac 	.word	0x0801d5ac

08000d74 <ppp_notify_phase_cb>:
static void ppp_notify_phase_cb(ppp_pcb *pcb, u8_t phase, void *ctx)
{
 8000d74:	b580      	push	{r7, lr}
 8000d76:	b084      	sub	sp, #16
 8000d78:	af00      	add	r7, sp, #0
 8000d7a:	60f8      	str	r0, [r7, #12]
 8000d7c:	607a      	str	r2, [r7, #4]
 8000d7e:	200b      	movs	r0, #11
 8000d80:	183b      	adds	r3, r7, r0
 8000d82:	1c0a      	adds	r2, r1, #0
 8000d84:	701a      	strb	r2, [r3, #0]
    switch (phase)
 8000d86:	183b      	adds	r3, r7, r0
 8000d88:	781b      	ldrb	r3, [r3, #0]
 8000d8a:	2b0c      	cmp	r3, #12
 8000d8c:	d85b      	bhi.n	8000e46 <ppp_notify_phase_cb+0xd2>
 8000d8e:	009a      	lsls	r2, r3, #2
 8000d90:	4b34      	ldr	r3, [pc, #208]	; (8000e64 <ppp_notify_phase_cb+0xf0>)
 8000d92:	18d3      	adds	r3, r2, r3
 8000d94:	681b      	ldr	r3, [r3, #0]
 8000d96:	469f      	mov	pc, r3
    {
    /* Session is down (either permanently or briefly) */
    case PPP_PHASE_DEAD:
        DEBUG_INFO("PPP_PHASE_DEAD\r\n");
 8000d98:	f01b fcd2 	bl	801c740 <sys_get_tick_ms>
 8000d9c:	0001      	movs	r1, r0
 8000d9e:	4a32      	ldr	r2, [pc, #200]	; (8000e68 <ppp_notify_phase_cb+0xf4>)
 8000da0:	4b32      	ldr	r3, [pc, #200]	; (8000e6c <ppp_notify_phase_cb+0xf8>)
 8000da2:	0018      	movs	r0, r3
 8000da4:	f001 fa12 	bl	80021cc <app_debug_rtt_raw>
        GSM_Manager.ppp_phase = PPP_PHASE_DEAD;
 8000da8:	4b31      	ldr	r3, [pc, #196]	; (8000e70 <ppp_notify_phase_cb+0xfc>)
 8000daa:	2200      	movs	r2, #0
 8000dac:	70da      	strb	r2, [r3, #3]
        break;
 8000dae:	e055      	b.n	8000e5c <ppp_notify_phase_cb+0xe8>

    /* We are between two sessions */
    case PPP_PHASE_HOLDOFF:
        DEBUG_INFO("PPP_PHASE_HOLDOFF\r\n");
 8000db0:	f01b fcc6 	bl	801c740 <sys_get_tick_ms>
 8000db4:	0001      	movs	r1, r0
 8000db6:	4a2c      	ldr	r2, [pc, #176]	; (8000e68 <ppp_notify_phase_cb+0xf4>)
 8000db8:	4b2e      	ldr	r3, [pc, #184]	; (8000e74 <ppp_notify_phase_cb+0x100>)
 8000dba:	0018      	movs	r0, r3
 8000dbc:	f001 fa06 	bl	80021cc <app_debug_rtt_raw>
        GSM_Manager.ppp_phase = PPP_PHASE_HOLDOFF;
 8000dc0:	4b2b      	ldr	r3, [pc, #172]	; (8000e70 <ppp_notify_phase_cb+0xfc>)
 8000dc2:	2202      	movs	r2, #2
 8000dc4:	70da      	strb	r2, [r3, #3]
        break;
 8000dc6:	e049      	b.n	8000e5c <ppp_notify_phase_cb+0xe8>

    /* Session just started */
    case PPP_PHASE_INITIALIZE:
        DEBUG_INFO("PPP_PHASE_INITIALIZE\r\n");
 8000dc8:	f01b fcba 	bl	801c740 <sys_get_tick_ms>
 8000dcc:	0001      	movs	r1, r0
 8000dce:	4a26      	ldr	r2, [pc, #152]	; (8000e68 <ppp_notify_phase_cb+0xf4>)
 8000dd0:	4b29      	ldr	r3, [pc, #164]	; (8000e78 <ppp_notify_phase_cb+0x104>)
 8000dd2:	0018      	movs	r0, r3
 8000dd4:	f001 f9fa 	bl	80021cc <app_debug_rtt_raw>
        GSM_Manager.ppp_phase = PPP_PHASE_INITIALIZE;
 8000dd8:	4b25      	ldr	r3, [pc, #148]	; (8000e70 <ppp_notify_phase_cb+0xfc>)
 8000dda:	2203      	movs	r2, #3
 8000ddc:	70da      	strb	r2, [r3, #3]
        break;
 8000dde:	e03d      	b.n	8000e5c <ppp_notify_phase_cb+0xe8>

    case PPP_PHASE_NETWORK:
        DEBUG_INFO("PPP_PHASE_NETWORK\r\n");
 8000de0:	f01b fcae 	bl	801c740 <sys_get_tick_ms>
 8000de4:	0001      	movs	r1, r0
 8000de6:	4a20      	ldr	r2, [pc, #128]	; (8000e68 <ppp_notify_phase_cb+0xf4>)
 8000de8:	4b24      	ldr	r3, [pc, #144]	; (8000e7c <ppp_notify_phase_cb+0x108>)
 8000dea:	0018      	movs	r0, r3
 8000dec:	f001 f9ee 	bl	80021cc <app_debug_rtt_raw>
        break;
 8000df0:	e034      	b.n	8000e5c <ppp_notify_phase_cb+0xe8>

    case PPP_PHASE_ESTABLISH:
        DEBUG_INFO("PPP_PHASE_ESTABLISH\r\n");
 8000df2:	f01b fca5 	bl	801c740 <sys_get_tick_ms>
 8000df6:	0001      	movs	r1, r0
 8000df8:	4a1b      	ldr	r2, [pc, #108]	; (8000e68 <ppp_notify_phase_cb+0xf4>)
 8000dfa:	4b21      	ldr	r3, [pc, #132]	; (8000e80 <ppp_notify_phase_cb+0x10c>)
 8000dfc:	0018      	movs	r0, r3
 8000dfe:	f001 f9e5 	bl	80021cc <app_debug_rtt_raw>
        break;
 8000e02:	e02b      	b.n	8000e5c <ppp_notify_phase_cb+0xe8>

    /* Session is running */
    case PPP_PHASE_RUNNING:
        DEBUG_INFO("PPP_PHASE_RUNNING\r\n");
 8000e04:	f01b fc9c 	bl	801c740 <sys_get_tick_ms>
 8000e08:	0001      	movs	r1, r0
 8000e0a:	4a17      	ldr	r2, [pc, #92]	; (8000e68 <ppp_notify_phase_cb+0xf4>)
 8000e0c:	4b1d      	ldr	r3, [pc, #116]	; (8000e84 <ppp_notify_phase_cb+0x110>)
 8000e0e:	0018      	movs	r0, r3
 8000e10:	f001 f9dc 	bl	80021cc <app_debug_rtt_raw>
        GSM_Manager.ppp_phase = PPP_PHASE_RUNNING;
 8000e14:	4b16      	ldr	r3, [pc, #88]	; (8000e70 <ppp_notify_phase_cb+0xfc>)
 8000e16:	220a      	movs	r2, #10
 8000e18:	70da      	strb	r2, [r3, #3]
        m_ppp_connected = true;
 8000e1a:	4b1b      	ldr	r3, [pc, #108]	; (8000e88 <ppp_notify_phase_cb+0x114>)
 8000e1c:	2201      	movs	r2, #1
 8000e1e:	701a      	strb	r2, [r3, #0]
        break;
 8000e20:	e01c      	b.n	8000e5c <ppp_notify_phase_cb+0xe8>

    case PPP_PHASE_TERMINATE:
        DEBUG_INFO("PPP_PHASE_TERMINATE\r\n");
 8000e22:	f01b fc8d 	bl	801c740 <sys_get_tick_ms>
 8000e26:	0001      	movs	r1, r0
 8000e28:	4a0f      	ldr	r2, [pc, #60]	; (8000e68 <ppp_notify_phase_cb+0xf4>)
 8000e2a:	4b18      	ldr	r3, [pc, #96]	; (8000e8c <ppp_notify_phase_cb+0x118>)
 8000e2c:	0018      	movs	r0, r3
 8000e2e:	f001 f9cd 	bl	80021cc <app_debug_rtt_raw>
        break;
 8000e32:	e013      	b.n	8000e5c <ppp_notify_phase_cb+0xe8>

    case PPP_PHASE_DISCONNECT:
        DEBUG_INFO("PPP_PHASE_DISCONNECT\r\n");
 8000e34:	f01b fc84 	bl	801c740 <sys_get_tick_ms>
 8000e38:	0001      	movs	r1, r0
 8000e3a:	4a0b      	ldr	r2, [pc, #44]	; (8000e68 <ppp_notify_phase_cb+0xf4>)
 8000e3c:	4b14      	ldr	r3, [pc, #80]	; (8000e90 <ppp_notify_phase_cb+0x11c>)
 8000e3e:	0018      	movs	r0, r3
 8000e40:	f001 f9c4 	bl	80021cc <app_debug_rtt_raw>
        break;
 8000e44:	e00a      	b.n	8000e5c <ppp_notify_phase_cb+0xe8>

    default:
        DEBUG_INFO("Unknown PPP phase %d\r\n", phase);
 8000e46:	f01b fc7b 	bl	801c740 <sys_get_tick_ms>
 8000e4a:	0001      	movs	r1, r0
 8000e4c:	230b      	movs	r3, #11
 8000e4e:	18fb      	adds	r3, r7, r3
 8000e50:	781b      	ldrb	r3, [r3, #0]
 8000e52:	4a05      	ldr	r2, [pc, #20]	; (8000e68 <ppp_notify_phase_cb+0xf4>)
 8000e54:	480f      	ldr	r0, [pc, #60]	; (8000e94 <ppp_notify_phase_cb+0x120>)
 8000e56:	f001 f9b9 	bl	80021cc <app_debug_rtt_raw>
        break;
 8000e5a:	46c0      	nop			; (mov r8, r8)
    }
}
 8000e5c:	46c0      	nop			; (mov r8, r8)
 8000e5e:	46bd      	mov	sp, r7
 8000e60:	b004      	add	sp, #16
 8000e62:	bd80      	pop	{r7, pc}
 8000e64:	08021894 	.word	0x08021894
 8000e68:	0801d35c 	.word	0x0801d35c
 8000e6c:	0801d5e0 	.word	0x0801d5e0
 8000e70:	2000144c 	.word	0x2000144c
 8000e74:	0801d60c 	.word	0x0801d60c
 8000e78:	0801d63c 	.word	0x0801d63c
 8000e7c:	0801d66c 	.word	0x0801d66c
 8000e80:	0801d69c 	.word	0x0801d69c
 8000e84:	0801d6cc 	.word	0x0801d6cc
 8000e88:	2000030c 	.word	0x2000030c
 8000e8c:	0801d6fc 	.word	0x0801d6fc
 8000e90:	0801d72c 	.word	0x0801d72c
 8000e94:	0801d75c 	.word	0x0801d75c

08000e98 <ppp_output_callback>:
static uint32_t ppp_output_callback(ppp_pcb *pcb, u8_t *data, u32_t len, void *ctx)
{
 8000e98:	b580      	push	{r7, lr}
 8000e9a:	b084      	sub	sp, #16
 8000e9c:	af00      	add	r7, sp, #0
 8000e9e:	60f8      	str	r0, [r7, #12]
 8000ea0:	60b9      	str	r1, [r7, #8]
 8000ea2:	607a      	str	r2, [r7, #4]
 8000ea4:	603b      	str	r3, [r7, #0]
    GSM_UART_TX( data, len, 1000);
 8000ea6:	687b      	ldr	r3, [r7, #4]
 8000ea8:	b29a      	uxth	r2, r3
 8000eaa:	23fa      	movs	r3, #250	; 0xfa
 8000eac:	009b      	lsls	r3, r3, #2
 8000eae:	68b9      	ldr	r1, [r7, #8]
 8000eb0:	4803      	ldr	r0, [pc, #12]	; (8000ec0 <ppp_output_callback+0x28>)
 8000eb2:	f002 fd5f 	bl	8003974 <HAL_UART_Transmit>
    return len;
 8000eb6:	687b      	ldr	r3, [r7, #4]
}
 8000eb8:	0018      	movs	r0, r3
 8000eba:	46bd      	mov	sp, r7
 8000ebc:	b004      	add	sp, #16
 8000ebe:	bd80      	pop	{r7, pc}
 8000ec0:	200013c8 	.word	0x200013c8

08000ec4 <gsm_data_layer_get_ppp_control_block>:
void *gsm_data_layer_get_ppp_control_block(void)
{
 8000ec4:	b580      	push	{r7, lr}
 8000ec6:	af00      	add	r7, sp, #0
    return m_ppp_control_block;
 8000ec8:	4b02      	ldr	r3, [pc, #8]	; (8000ed4 <gsm_data_layer_get_ppp_control_block+0x10>)
 8000eca:	681b      	ldr	r3, [r3, #0]
}
 8000ecc:	0018      	movs	r0, r3
 8000ece:	46bd      	mov	sp, r7
 8000ed0:	bd80      	pop	{r7, pc}
 8000ed2:	46c0      	nop			; (mov r8, r8)
 8000ed4:	20000308 	.word	0x20000308

08000ed8 <initialize_stnp>:
static void initialize_stnp(void)
{
 8000ed8:	b580      	push	{r7, lr}
 8000eda:	af00      	add	r7, sp, #0
    static bool sntp_start = false;
    if (sntp_start == false)
 8000edc:	4b0f      	ldr	r3, [pc, #60]	; (8000f1c <initialize_stnp+0x44>)
 8000ede:	781b      	ldrb	r3, [r3, #0]
 8000ee0:	2201      	movs	r2, #1
 8000ee2:	4053      	eors	r3, r2
 8000ee4:	b2db      	uxtb	r3, r3
 8000ee6:	2b00      	cmp	r3, #0
 8000ee8:	d014      	beq.n	8000f14 <initialize_stnp+0x3c>
    {
        sntp_start = true;
 8000eea:	4b0c      	ldr	r3, [pc, #48]	; (8000f1c <initialize_stnp+0x44>)
 8000eec:	2201      	movs	r2, #1
 8000eee:	701a      	strb	r2, [r3, #0]
        DEBUG_INFO("Initialize stnp\r\n");
 8000ef0:	f01b fc26 	bl	801c740 <sys_get_tick_ms>
 8000ef4:	0001      	movs	r1, r0
 8000ef6:	4a0a      	ldr	r2, [pc, #40]	; (8000f20 <initialize_stnp+0x48>)
 8000ef8:	4b0a      	ldr	r3, [pc, #40]	; (8000f24 <initialize_stnp+0x4c>)
 8000efa:	0018      	movs	r0, r3
 8000efc:	f001 f966 	bl	80021cc <app_debug_rtt_raw>
        sntp_setoperatingmode(SNTP_OPMODE_POLL);
 8000f00:	2000      	movs	r0, #0
 8000f02:	f005 facb 	bl	800649c <sntp_setoperatingmode>
        sntp_setservername(0, "pool.ntp.org");
 8000f06:	4b08      	ldr	r3, [pc, #32]	; (8000f28 <initialize_stnp+0x50>)
 8000f08:	0019      	movs	r1, r3
 8000f0a:	2000      	movs	r0, #0
 8000f0c:	f005 faf8 	bl	8006500 <sntp_setservername>
        sntp_init();
 8000f10:	f005 fa5e 	bl	80063d0 <sntp_init>
    }
}
 8000f14:	46c0      	nop			; (mov r8, r8)
 8000f16:	46bd      	mov	sp, r7
 8000f18:	bd80      	pop	{r7, pc}
 8000f1a:	46c0      	nop			; (mov r8, r8)
 8000f1c:	2000030d 	.word	0x2000030d
 8000f20:	0801d35c 	.word	0x0801d35c
 8000f24:	0801d78c 	.word	0x0801d78c
 8000f28:	0801d7b8 	.word	0x0801d7b8

08000f2c <lwip_sntp_recv_callback>:

void lwip_sntp_recv_callback(uint32_t time)
{
 8000f2c:	b580      	push	{r7, lr}
 8000f2e:	b082      	sub	sp, #8
 8000f30:	af00      	add	r7, sp, #0
 8000f32:	6078      	str	r0, [r7, #4]
    if (time == 0)
 8000f34:	687b      	ldr	r3, [r7, #4]
 8000f36:	2b00      	cmp	r3, #0
 8000f38:	d108      	bne.n	8000f4c <lwip_sntp_recv_callback+0x20>
    {
        DEBUG_WARN("NTP: Error, server not responding or bad response\r\n");
 8000f3a:	f01b fc01 	bl	801c740 <sys_get_tick_ms>
 8000f3e:	0001      	movs	r1, r0
 8000f40:	4a08      	ldr	r2, [pc, #32]	; (8000f64 <lwip_sntp_recv_callback+0x38>)
 8000f42:	4b09      	ldr	r3, [pc, #36]	; (8000f68 <lwip_sntp_recv_callback+0x3c>)
 8000f44:	0018      	movs	r0, r3
 8000f46:	f001 f941 	bl	80021cc <app_debug_rtt_raw>
    }
    else
    {
        DEBUG_INFO("NTP: %u seconds elapsed since 1.1.1970\r\n", time);
    }
}
 8000f4a:	e007      	b.n	8000f5c <lwip_sntp_recv_callback+0x30>
        DEBUG_INFO("NTP: %u seconds elapsed since 1.1.1970\r\n", time);
 8000f4c:	f01b fbf8 	bl	801c740 <sys_get_tick_ms>
 8000f50:	0001      	movs	r1, r0
 8000f52:	687b      	ldr	r3, [r7, #4]
 8000f54:	4a03      	ldr	r2, [pc, #12]	; (8000f64 <lwip_sntp_recv_callback+0x38>)
 8000f56:	4805      	ldr	r0, [pc, #20]	; (8000f6c <lwip_sntp_recv_callback+0x40>)
 8000f58:	f001 f938 	bl	80021cc <app_debug_rtt_raw>
}
 8000f5c:	46c0      	nop			; (mov r8, r8)
 8000f5e:	46bd      	mov	sp, r7
 8000f60:	b002      	add	sp, #8
 8000f62:	bd80      	pop	{r7, pc}
 8000f64:	0801d35c 	.word	0x0801d35c
 8000f68:	0801d7c8 	.word	0x0801d7c8
 8000f6c:	0801d818 	.word	0x0801d818

08000f70 <ppp_link_status_cb>:
 * ===================
 *
 * PPP status callback is called on PPP status change (up, down, ...) from lwIP core thread
 */
static void ppp_link_status_cb(ppp_pcb *pcb, int err_code, void *ctx)
{
 8000f70:	b590      	push	{r4, r7, lr}
 8000f72:	b087      	sub	sp, #28
 8000f74:	af00      	add	r7, sp, #0
 8000f76:	60f8      	str	r0, [r7, #12]
 8000f78:	60b9      	str	r1, [r7, #8]
 8000f7a:	607a      	str	r2, [r7, #4]
    struct netif *pppif = ppp_netif(pcb);
 8000f7c:	68fb      	ldr	r3, [r7, #12]
 8000f7e:	6a1b      	ldr	r3, [r3, #32]
 8000f80:	617b      	str	r3, [r7, #20]
 8000f82:	68bb      	ldr	r3, [r7, #8]
 8000f84:	2b0c      	cmp	r3, #12
 8000f86:	d900      	bls.n	8000f8a <ppp_link_status_cb+0x1a>
 8000f88:	e0df      	b.n	800114a <ppp_link_status_cb+0x1da>
 8000f8a:	68bb      	ldr	r3, [r7, #8]
 8000f8c:	009a      	lsls	r2, r3, #2
 8000f8e:	4b7c      	ldr	r3, [pc, #496]	; (8001180 <ppp_link_status_cb+0x210>)
 8000f90:	18d3      	adds	r3, r2, r3
 8000f92:	681b      	ldr	r3, [r3, #0]
 8000f94:	469f      	mov	pc, r3
    {
#if LWIP_DNS
        const ip_addr_t *ns;
#endif /* LWIP_DNS */

        DEBUG_INFO("PPP Connected\r\n");
 8000f96:	f01b fbd3 	bl	801c740 <sys_get_tick_ms>
 8000f9a:	0001      	movs	r1, r0
 8000f9c:	4a79      	ldr	r2, [pc, #484]	; (8001184 <ppp_link_status_cb+0x214>)
 8000f9e:	4b7a      	ldr	r3, [pc, #488]	; (8001188 <ppp_link_status_cb+0x218>)
 8000fa0:	0018      	movs	r0, r3
 8000fa2:	f001 f913 	bl	80021cc <app_debug_rtt_raw>

#if PPP_IPV4_SUPPORT

        DEBUG_INFO("\tour_ipaddr    = %s\r\n", ipaddr_ntoa(&pppif->ip_addr));
 8000fa6:	f01b fbcb 	bl	801c740 <sys_get_tick_ms>
 8000faa:	0004      	movs	r4, r0
 8000fac:	697b      	ldr	r3, [r7, #20]
 8000fae:	3304      	adds	r3, #4
 8000fb0:	0018      	movs	r0, r3
 8000fb2:	f012 fd37 	bl	8013a24 <ip4addr_ntoa>
 8000fb6:	0003      	movs	r3, r0
 8000fb8:	4a72      	ldr	r2, [pc, #456]	; (8001184 <ppp_link_status_cb+0x214>)
 8000fba:	4874      	ldr	r0, [pc, #464]	; (800118c <ppp_link_status_cb+0x21c>)
 8000fbc:	0021      	movs	r1, r4
 8000fbe:	f001 f905 	bl	80021cc <app_debug_rtt_raw>
        DEBUG_INFO("\this_ipaddr    = %s\r\n", ipaddr_ntoa(&pppif->gw));
 8000fc2:	f01b fbbd 	bl	801c740 <sys_get_tick_ms>
 8000fc6:	0004      	movs	r4, r0
 8000fc8:	697b      	ldr	r3, [r7, #20]
 8000fca:	330c      	adds	r3, #12
 8000fcc:	0018      	movs	r0, r3
 8000fce:	f012 fd29 	bl	8013a24 <ip4addr_ntoa>
 8000fd2:	0003      	movs	r3, r0
 8000fd4:	4a6b      	ldr	r2, [pc, #428]	; (8001184 <ppp_link_status_cb+0x214>)
 8000fd6:	486e      	ldr	r0, [pc, #440]	; (8001190 <ppp_link_status_cb+0x220>)
 8000fd8:	0021      	movs	r1, r4
 8000fda:	f001 f8f7 	bl	80021cc <app_debug_rtt_raw>
        DEBUG_INFO("\tnetmask       = %s\r\n", ipaddr_ntoa(&pppif->netmask));
 8000fde:	f01b fbaf 	bl	801c740 <sys_get_tick_ms>
 8000fe2:	0004      	movs	r4, r0
 8000fe4:	697b      	ldr	r3, [r7, #20]
 8000fe6:	3308      	adds	r3, #8
 8000fe8:	0018      	movs	r0, r3
 8000fea:	f012 fd1b 	bl	8013a24 <ip4addr_ntoa>
 8000fee:	0003      	movs	r3, r0
 8000ff0:	4a64      	ldr	r2, [pc, #400]	; (8001184 <ppp_link_status_cb+0x214>)
 8000ff2:	4868      	ldr	r0, [pc, #416]	; (8001194 <ppp_link_status_cb+0x224>)
 8000ff4:	0021      	movs	r1, r4
 8000ff6:	f001 f8e9 	bl	80021cc <app_debug_rtt_raw>
        HAL_Delay(1);
 8000ffa:	2001      	movs	r0, #1
 8000ffc:	f001 fa5a 	bl	80024b4 <HAL_Delay>

#if LWIP_DNS
        ns = dns_getserver(0);
 8001000:	2000      	movs	r0, #0
 8001002:	f005 fb3d 	bl	8006680 <dns_getserver>
 8001006:	0003      	movs	r3, r0
 8001008:	613b      	str	r3, [r7, #16]
        DEBUG_INFO("\tdns1          = %s\r\n", ipaddr_ntoa(ns));
 800100a:	f01b fb99 	bl	801c740 <sys_get_tick_ms>
 800100e:	0004      	movs	r4, r0
 8001010:	693b      	ldr	r3, [r7, #16]
 8001012:	0018      	movs	r0, r3
 8001014:	f012 fd06 	bl	8013a24 <ip4addr_ntoa>
 8001018:	0003      	movs	r3, r0
 800101a:	4a5a      	ldr	r2, [pc, #360]	; (8001184 <ppp_link_status_cb+0x214>)
 800101c:	485e      	ldr	r0, [pc, #376]	; (8001198 <ppp_link_status_cb+0x228>)
 800101e:	0021      	movs	r1, r4
 8001020:	f001 f8d4 	bl	80021cc <app_debug_rtt_raw>
        ns = dns_getserver(1);
 8001024:	2001      	movs	r0, #1
 8001026:	f005 fb2b 	bl	8006680 <dns_getserver>
 800102a:	0003      	movs	r3, r0
 800102c:	613b      	str	r3, [r7, #16]
        DEBUG_INFO("\tdns2          = %s\r\n", ipaddr_ntoa(ns));
 800102e:	f01b fb87 	bl	801c740 <sys_get_tick_ms>
 8001032:	0004      	movs	r4, r0
 8001034:	693b      	ldr	r3, [r7, #16]
 8001036:	0018      	movs	r0, r3
 8001038:	f012 fcf4 	bl	8013a24 <ip4addr_ntoa>
 800103c:	0003      	movs	r3, r0
 800103e:	4a51      	ldr	r2, [pc, #324]	; (8001184 <ppp_link_status_cb+0x214>)
 8001040:	4856      	ldr	r0, [pc, #344]	; (800119c <ppp_link_status_cb+0x22c>)
 8001042:	0021      	movs	r1, r4
 8001044:	f001 f8c2 	bl	80021cc <app_debug_rtt_raw>
        HAL_Delay(1);
 8001048:	2001      	movs	r0, #1
 800104a:	f001 fa33 	bl	80024b4 <HAL_Delay>
#endif /* PPP_IPV4_SUPPORT */

#if PPP_IPV6_SUPPORT
        DEBUG_INFO("\r   our6_ipaddr = %s\n", ip6addr_ntoa(netif_ip6_addr(pppif, 0)));
#endif /* PPP_IPV6_SUPPORT */
        break;
 800104e:	e085      	b.n	800115c <ppp_link_status_cb+0x1ec>
    }

    case PPPERR_PARAM:
    {
        DEBUG_INFO("status_cb: Invalid parameter\r\n");
 8001050:	f01b fb76 	bl	801c740 <sys_get_tick_ms>
 8001054:	0001      	movs	r1, r0
 8001056:	4a4b      	ldr	r2, [pc, #300]	; (8001184 <ppp_link_status_cb+0x214>)
 8001058:	4b51      	ldr	r3, [pc, #324]	; (80011a0 <ppp_link_status_cb+0x230>)
 800105a:	0018      	movs	r0, r3
 800105c:	f001 f8b6 	bl	80021cc <app_debug_rtt_raw>
        break;
 8001060:	e07c      	b.n	800115c <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_OPEN:
    {
        DEBUG_INFO("status_cb: Unable to open PPP session\r\n");
 8001062:	f01b fb6d 	bl	801c740 <sys_get_tick_ms>
 8001066:	0001      	movs	r1, r0
 8001068:	4a46      	ldr	r2, [pc, #280]	; (8001184 <ppp_link_status_cb+0x214>)
 800106a:	4b4e      	ldr	r3, [pc, #312]	; (80011a4 <ppp_link_status_cb+0x234>)
 800106c:	0018      	movs	r0, r3
 800106e:	f001 f8ad 	bl	80021cc <app_debug_rtt_raw>
        break;
 8001072:	e073      	b.n	800115c <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_DEVICE:
    {
        DEBUG_INFO("status_cb: Invalid I/O device for PPP\r\n");
 8001074:	f01b fb64 	bl	801c740 <sys_get_tick_ms>
 8001078:	0001      	movs	r1, r0
 800107a:	4a42      	ldr	r2, [pc, #264]	; (8001184 <ppp_link_status_cb+0x214>)
 800107c:	4b4a      	ldr	r3, [pc, #296]	; (80011a8 <ppp_link_status_cb+0x238>)
 800107e:	0018      	movs	r0, r3
 8001080:	f001 f8a4 	bl	80021cc <app_debug_rtt_raw>
        break;
 8001084:	e06a      	b.n	800115c <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_ALLOC:
    {
        DEBUG_INFO("status_cb: Unable to allocate resources\r\n");
 8001086:	f01b fb5b 	bl	801c740 <sys_get_tick_ms>
 800108a:	0001      	movs	r1, r0
 800108c:	4a3d      	ldr	r2, [pc, #244]	; (8001184 <ppp_link_status_cb+0x214>)
 800108e:	4b47      	ldr	r3, [pc, #284]	; (80011ac <ppp_link_status_cb+0x23c>)
 8001090:	0018      	movs	r0, r3
 8001092:	f001 f89b 	bl	80021cc <app_debug_rtt_raw>
        break;
 8001096:	e061      	b.n	800115c <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_USER: /* 5 */
    {
        /* ppp_close() was previously called, reconnect */
        DEBUG_INFO("status_cb: ppp is closed by user OK! Try to re-open...\r\n");
 8001098:	f01b fb52 	bl	801c740 <sys_get_tick_ms>
 800109c:	0001      	movs	r1, r0
 800109e:	4a39      	ldr	r2, [pc, #228]	; (8001184 <ppp_link_status_cb+0x214>)
 80010a0:	4b43      	ldr	r3, [pc, #268]	; (80011b0 <ppp_link_status_cb+0x240>)
 80010a2:	0018      	movs	r0, r3
 80010a4:	f001 f892 	bl	80021cc <app_debug_rtt_raw>
        /* ppp_free(); -- can be called here */
        ppp_free(m_ppp_control_block);
 80010a8:	4b42      	ldr	r3, [pc, #264]	; (80011b4 <ppp_link_status_cb+0x244>)
 80010aa:	681b      	ldr	r3, [r3, #0]
 80010ac:	0018      	movs	r0, r3
 80010ae:	f018 fad9 	bl	8019664 <ppp_free>
        GSM_Manager_ChangeState(GSM_STATE_REOPEN_PPP);
 80010b2:	2003      	movs	r0, #3
 80010b4:	f000 f904 	bl	80012c0 <GSM_Manager_ChangeState>
        break;
 80010b8:	e050      	b.n	800115c <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_CONNECT: /* 6 */
    {
        DEBUG_INFO("status_cb: Connection lost\r\n");
 80010ba:	f01b fb41 	bl	801c740 <sys_get_tick_ms>
 80010be:	0001      	movs	r1, r0
 80010c0:	4a30      	ldr	r2, [pc, #192]	; (8001184 <ppp_link_status_cb+0x214>)
 80010c2:	4b3d      	ldr	r3, [pc, #244]	; (80011b8 <ppp_link_status_cb+0x248>)
 80010c4:	0018      	movs	r0, r3
 80010c6:	f001 f881 	bl	80021cc <app_debug_rtt_raw>
        m_ppp_connected = false;
 80010ca:	4b3c      	ldr	r3, [pc, #240]	; (80011bc <ppp_link_status_cb+0x24c>)
 80010cc:	2200      	movs	r2, #0
 80010ce:	701a      	strb	r2, [r3, #0]
        ppp_close(m_ppp_control_block, 1);
 80010d0:	4b38      	ldr	r3, [pc, #224]	; (80011b4 <ppp_link_status_cb+0x244>)
 80010d2:	681b      	ldr	r3, [r3, #0]
 80010d4:	2101      	movs	r1, #1
 80010d6:	0018      	movs	r0, r3
 80010d8:	f018 fa5c 	bl	8019594 <ppp_close>
        break;
 80010dc:	e03e      	b.n	800115c <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_AUTHFAIL:
    {
        DEBUG_INFO("status_cb: Failed authentication challenge\r\n");
 80010de:	f01b fb2f 	bl	801c740 <sys_get_tick_ms>
 80010e2:	0001      	movs	r1, r0
 80010e4:	4a27      	ldr	r2, [pc, #156]	; (8001184 <ppp_link_status_cb+0x214>)
 80010e6:	4b36      	ldr	r3, [pc, #216]	; (80011c0 <ppp_link_status_cb+0x250>)
 80010e8:	0018      	movs	r0, r3
 80010ea:	f001 f86f 	bl	80021cc <app_debug_rtt_raw>
        break;
 80010ee:	e035      	b.n	800115c <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_PROTOCOL:
    {
        DEBUG_INFO("status_cb: Failed to meet protocol\n");
 80010f0:	f01b fb26 	bl	801c740 <sys_get_tick_ms>
 80010f4:	0001      	movs	r1, r0
 80010f6:	4a23      	ldr	r2, [pc, #140]	; (8001184 <ppp_link_status_cb+0x214>)
 80010f8:	4b32      	ldr	r3, [pc, #200]	; (80011c4 <ppp_link_status_cb+0x254>)
 80010fa:	0018      	movs	r0, r3
 80010fc:	f001 f866 	bl	80021cc <app_debug_rtt_raw>
        break;
 8001100:	e02c      	b.n	800115c <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_PEERDEAD:
    {
        DEBUG_INFO("status_cb: Connection timeout\r\n");
 8001102:	f01b fb1d 	bl	801c740 <sys_get_tick_ms>
 8001106:	0001      	movs	r1, r0
 8001108:	4a1e      	ldr	r2, [pc, #120]	; (8001184 <ppp_link_status_cb+0x214>)
 800110a:	4b2f      	ldr	r3, [pc, #188]	; (80011c8 <ppp_link_status_cb+0x258>)
 800110c:	0018      	movs	r0, r3
 800110e:	f001 f85d 	bl	80021cc <app_debug_rtt_raw>
        break;
 8001112:	e023      	b.n	800115c <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_IDLETIMEOUT:
    {
        DEBUG_INFO("status_cb: Idle Timeout\r\n");
 8001114:	f01b fb14 	bl	801c740 <sys_get_tick_ms>
 8001118:	0001      	movs	r1, r0
 800111a:	4a1a      	ldr	r2, [pc, #104]	; (8001184 <ppp_link_status_cb+0x214>)
 800111c:	4b2b      	ldr	r3, [pc, #172]	; (80011cc <ppp_link_status_cb+0x25c>)
 800111e:	0018      	movs	r0, r3
 8001120:	f001 f854 	bl	80021cc <app_debug_rtt_raw>
        break;
 8001124:	e01a      	b.n	800115c <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_CONNECTTIME:
    {
        DEBUG_INFO("status_cb: Max connect time reached\r\n");
 8001126:	f01b fb0b 	bl	801c740 <sys_get_tick_ms>
 800112a:	0001      	movs	r1, r0
 800112c:	4a15      	ldr	r2, [pc, #84]	; (8001184 <ppp_link_status_cb+0x214>)
 800112e:	4b28      	ldr	r3, [pc, #160]	; (80011d0 <ppp_link_status_cb+0x260>)
 8001130:	0018      	movs	r0, r3
 8001132:	f001 f84b 	bl	80021cc <app_debug_rtt_raw>
        break;
 8001136:	e011      	b.n	800115c <ppp_link_status_cb+0x1ec>
    }
    case PPPERR_LOOPBACK:
    {
        DEBUG_INFO("status_cb: Loopback detected\r\n");
 8001138:	f01b fb02 	bl	801c740 <sys_get_tick_ms>
 800113c:	0001      	movs	r1, r0
 800113e:	4a11      	ldr	r2, [pc, #68]	; (8001184 <ppp_link_status_cb+0x214>)
 8001140:	4b24      	ldr	r3, [pc, #144]	; (80011d4 <ppp_link_status_cb+0x264>)
 8001142:	0018      	movs	r0, r3
 8001144:	f001 f842 	bl	80021cc <app_debug_rtt_raw>
        break;
 8001148:	e008      	b.n	800115c <ppp_link_status_cb+0x1ec>
    }
    default:
    {
        DEBUG_INFO("status_cb: Unknown error code %d\r\n", err_code);
 800114a:	f01b faf9 	bl	801c740 <sys_get_tick_ms>
 800114e:	0001      	movs	r1, r0
 8001150:	68bb      	ldr	r3, [r7, #8]
 8001152:	4a0c      	ldr	r2, [pc, #48]	; (8001184 <ppp_link_status_cb+0x214>)
 8001154:	4820      	ldr	r0, [pc, #128]	; (80011d8 <ppp_link_status_cb+0x268>)
 8001156:	f001 f839 	bl	80021cc <app_debug_rtt_raw>
        break;
 800115a:	46c0      	nop			; (mov r8, r8)
    /*
	* This should be in the switch case, this is put outside of the switch
	* case for example readability.
	*/

    if (err_code == PPPERR_NONE)
 800115c:	68bb      	ldr	r3, [r7, #8]
 800115e:	2b00      	cmp	r3, #0
 8001160:	d10a      	bne.n	8001178 <ppp_link_status_cb+0x208>
    {
        DEBUG_INFO("PPP is opened OK\r\n");
 8001162:	f01b faed 	bl	801c740 <sys_get_tick_ms>
 8001166:	0001      	movs	r1, r0
 8001168:	4a06      	ldr	r2, [pc, #24]	; (8001184 <ppp_link_status_cb+0x214>)
 800116a:	4b1c      	ldr	r3, [pc, #112]	; (80011dc <ppp_link_status_cb+0x26c>)
 800116c:	0018      	movs	r0, r3
 800116e:	f001 f82d 	bl	80021cc <app_debug_rtt_raw>
        initialize_stnp();
 8001172:	f7ff feb1 	bl	8000ed8 <initialize_stnp>
        return;
 8001176:	46c0      	nop			; (mov r8, r8)
   * Try to reconnect in 30 seconds, if you need a modem chatscript you have
   * to do a much better signaling here ;-)
   */
    //  ppp_connect(pcb, 30);
    /* OR ppp_listen(pcb); */
}
 8001178:	46bd      	mov	sp, r7
 800117a:	b007      	add	sp, #28
 800117c:	bd90      	pop	{r4, r7, pc}
 800117e:	46c0      	nop			; (mov r8, r8)
 8001180:	080218c8 	.word	0x080218c8
 8001184:	0801d35c 	.word	0x0801d35c
 8001188:	0801d85c 	.word	0x0801d85c
 800118c:	0801d888 	.word	0x0801d888
 8001190:	0801d8b8 	.word	0x0801d8b8
 8001194:	0801d8e8 	.word	0x0801d8e8
 8001198:	0801d918 	.word	0x0801d918
 800119c:	0801d948 	.word	0x0801d948
 80011a0:	0801d978 	.word	0x0801d978
 80011a4:	0801d9b0 	.word	0x0801d9b0
 80011a8:	0801d9f4 	.word	0x0801d9f4
 80011ac:	0801da38 	.word	0x0801da38
 80011b0:	0801da7c 	.word	0x0801da7c
 80011b4:	20000308 	.word	0x20000308
 80011b8:	0801dad0 	.word	0x0801dad0
 80011bc:	2000030c 	.word	0x2000030c
 80011c0:	0801db08 	.word	0x0801db08
 80011c4:	0801db50 	.word	0x0801db50
 80011c8:	0801db90 	.word	0x0801db90
 80011cc:	0801dbcc 	.word	0x0801dbcc
 80011d0:	0801dc00 	.word	0x0801dc00
 80011d4:	0801dc40 	.word	0x0801dc40
 80011d8:	0801dc78 	.word	0x0801dc78
 80011dc:	0801dcb4 	.word	0x0801dcb4

080011e0 <Polling_GSM_StateMachine>:
void Polling_GSM_StateMachine (void)
{
 80011e0:	b5b0      	push	{r4, r5, r7, lr}
 80011e2:	b086      	sub	sp, #24
 80011e4:	af04      	add	r7, sp, #16
    static uint32_t last_tick = 0;
    uint32_t current_tick = sys_get_tick_ms();
 80011e6:	f01b faab 	bl	801c740 <sys_get_tick_ms>
 80011ea:	0003      	movs	r3, r0
 80011ec:	607b      	str	r3, [r7, #4]
    if(current_tick - last_tick >= (uint32_t)1000)
 80011ee:	4b23      	ldr	r3, [pc, #140]	; (800127c <Polling_GSM_StateMachine+0x9c>)
 80011f0:	681b      	ldr	r3, [r3, #0]
 80011f2:	687a      	ldr	r2, [r7, #4]
 80011f4:	1ad2      	subs	r2, r2, r3
 80011f6:	23fa      	movs	r3, #250	; 0xfa
 80011f8:	009b      	lsls	r3, r3, #2
 80011fa:	429a      	cmp	r2, r3
 80011fc:	d332      	bcc.n	8001264 <Polling_GSM_StateMachine+0x84>
    {
        last_tick = current_tick;
 80011fe:	4b1f      	ldr	r3, [pc, #124]	; (800127c <Polling_GSM_StateMachine+0x9c>)
 8001200:	687a      	ldr	r2, [r7, #4]
 8001202:	601a      	str	r2, [r3, #0]
        switch (GSM_Manager.state)
 8001204:	4b1e      	ldr	r3, [pc, #120]	; (8001280 <Polling_GSM_StateMachine+0xa0>)
 8001206:	781b      	ldrb	r3, [r3, #0]
 8001208:	2b03      	cmp	r3, #3
 800120a:	d02d      	beq.n	8001268 <Polling_GSM_StateMachine+0x88>
 800120c:	dc20      	bgt.n	8001250 <Polling_GSM_StateMachine+0x70>
 800120e:	2b02      	cmp	r3, #2
 8001210:	d02c      	beq.n	800126c <Polling_GSM_StateMachine+0x8c>
 8001212:	dc1d      	bgt.n	8001250 <Polling_GSM_StateMachine+0x70>
 8001214:	2b00      	cmp	r3, #0
 8001216:	d004      	beq.n	8001222 <Polling_GSM_StateMachine+0x42>
 8001218:	2b01      	cmp	r3, #1
 800121a:	d119      	bne.n	8001250 <Polling_GSM_StateMachine+0x70>
        {
            case GSM_STATE_RESET:
                GSM_Turn_on_Power();
 800121c:	f000 face 	bl	80017bc <GSM_Turn_on_Power>
                break;
 8001220:	e027      	b.n	8001272 <Polling_GSM_StateMachine+0x92>
            case GSM_STATE_POWER_ON:
                if(GSM_Manager.step == 0)
 8001222:	4b17      	ldr	r3, [pc, #92]	; (8001280 <Polling_GSM_StateMachine+0xa0>)
 8001224:	785b      	ldrb	r3, [r3, #1]
 8001226:	2b00      	cmp	r3, #0
 8001228:	d122      	bne.n	8001270 <Polling_GSM_StateMachine+0x90>
                {
                    GSM_Manager.step = 1;
 800122a:	4b15      	ldr	r3, [pc, #84]	; (8001280 <Polling_GSM_StateMachine+0xa0>)
 800122c:	2201      	movs	r2, #1
 800122e:	705a      	strb	r2, [r3, #1]
                    GSM_SendCommand_AT(atc_table_config_module[0]);
 8001230:	4b14      	ldr	r3, [pc, #80]	; (8001284 <Polling_GSM_StateMachine+0xa4>)
 8001232:	466a      	mov	r2, sp
 8001234:	0011      	movs	r1, r2
 8001236:	001a      	movs	r2, r3
 8001238:	3210      	adds	r2, #16
 800123a:	ca31      	ldmia	r2!, {r0, r4, r5}
 800123c:	c131      	stmia	r1!, {r0, r4, r5}
 800123e:	6812      	ldr	r2, [r2, #0]
 8001240:	600a      	str	r2, [r1, #0]
 8001242:	6818      	ldr	r0, [r3, #0]
 8001244:	6859      	ldr	r1, [r3, #4]
 8001246:	689a      	ldr	r2, [r3, #8]
 8001248:	68db      	ldr	r3, [r3, #12]
 800124a:	f000 fb73 	bl	8001934 <GSM_SendCommand_AT>
                }
                break;
 800124e:	e00f      	b.n	8001270 <Polling_GSM_StateMachine+0x90>
                break;
            case GSM_STATE_REOPEN_PPP:

            	break;
            default:
                DEBUG_WARN("Unhandled state %d.\r\n", GSM_Manager.state);
 8001250:	f01b fa76 	bl	801c740 <sys_get_tick_ms>
 8001254:	0001      	movs	r1, r0
 8001256:	4b0a      	ldr	r3, [pc, #40]	; (8001280 <Polling_GSM_StateMachine+0xa0>)
 8001258:	781b      	ldrb	r3, [r3, #0]
 800125a:	4a0b      	ldr	r2, [pc, #44]	; (8001288 <Polling_GSM_StateMachine+0xa8>)
 800125c:	480b      	ldr	r0, [pc, #44]	; (800128c <Polling_GSM_StateMachine+0xac>)
 800125e:	f000 ffb5 	bl	80021cc <app_debug_rtt_raw>
                break;
 8001262:	e006      	b.n	8001272 <Polling_GSM_StateMachine+0x92>
        }
    }
 8001264:	46c0      	nop			; (mov r8, r8)
 8001266:	e004      	b.n	8001272 <Polling_GSM_StateMachine+0x92>
            	break;
 8001268:	46c0      	nop			; (mov r8, r8)
 800126a:	e002      	b.n	8001272 <Polling_GSM_StateMachine+0x92>
                break;
 800126c:	46c0      	nop			; (mov r8, r8)
 800126e:	e000      	b.n	8001272 <Polling_GSM_StateMachine+0x92>
                break;
 8001270:	46c0      	nop			; (mov r8, r8)
}
 8001272:	46c0      	nop			; (mov r8, r8)
 8001274:	46bd      	mov	sp, r7
 8001276:	b002      	add	sp, #8
 8001278:	bdb0      	pop	{r4, r5, r7, pc}
 800127a:	46c0      	nop			; (mov r8, r8)
 800127c:	20000310 	.word	0x20000310
 8001280:	2000144c 	.word	0x2000144c
 8001284:	08021514 	.word	0x08021514
 8001288:	0801d35c 	.word	0x0801d35c
 800128c:	0801dce0 	.word	0x0801dce0

08001290 <gsm_is_in_ppp_mode>:
bool gsm_is_in_ppp_mode(void)
{
 8001290:	b580      	push	{r7, lr}
 8001292:	af00      	add	r7, sp, #0
    return GSM_Manager.mode == GSM_INTERNET_MODE_PPP_STACK? true : false;
 8001294:	4b04      	ldr	r3, [pc, #16]	; (80012a8 <gsm_is_in_ppp_mode+0x18>)
 8001296:	789b      	ldrb	r3, [r3, #2]
 8001298:	3b01      	subs	r3, #1
 800129a:	425a      	negs	r2, r3
 800129c:	4153      	adcs	r3, r2
 800129e:	b2db      	uxtb	r3, r3
}
 80012a0:	0018      	movs	r0, r3
 80012a2:	46bd      	mov	sp, r7
 80012a4:	bd80      	pop	{r7, pc}
 80012a6:	46c0      	nop			; (mov r8, r8)
 80012a8:	2000144c 	.word	0x2000144c

080012ac <gsm_data_layer_is_ppp_connected>:
bool gsm_data_layer_is_ppp_connected(void)
{
 80012ac:	b580      	push	{r7, lr}
 80012ae:	af00      	add	r7, sp, #0
    return m_ppp_connected;
 80012b0:	4b02      	ldr	r3, [pc, #8]	; (80012bc <gsm_data_layer_is_ppp_connected+0x10>)
 80012b2:	781b      	ldrb	r3, [r3, #0]
}
 80012b4:	0018      	movs	r0, r3
 80012b6:	46bd      	mov	sp, r7
 80012b8:	bd80      	pop	{r7, pc}
 80012ba:	46c0      	nop			; (mov r8, r8)
 80012bc:	2000030c 	.word	0x2000030c

080012c0 <GSM_Manager_ChangeState>:


void GSM_Manager_ChangeState(Gsm_State_TypDef state)
{
 80012c0:	b5b0      	push	{r4, r5, r7, lr}
 80012c2:	b086      	sub	sp, #24
 80012c4:	af04      	add	r7, sp, #16
 80012c6:	0002      	movs	r2, r0
 80012c8:	1dfb      	adds	r3, r7, #7
 80012ca:	701a      	strb	r2, [r3, #0]
    GSM_Manager.state = state;
 80012cc:	4b38      	ldr	r3, [pc, #224]	; (80013b0 <GSM_Manager_ChangeState+0xf0>)
 80012ce:	1dfa      	adds	r2, r7, #7
 80012d0:	7812      	ldrb	r2, [r2, #0]
 80012d2:	701a      	strb	r2, [r3, #0]
    GSM_Manager.step = 0;
 80012d4:	4b36      	ldr	r3, [pc, #216]	; (80013b0 <GSM_Manager_ChangeState+0xf0>)
 80012d6:	2200      	movs	r2, #0
 80012d8:	705a      	strb	r2, [r3, #1]
    DEBUG_INFO("Change GSM State to: ");
 80012da:	f01b fa31 	bl	801c740 <sys_get_tick_ms>
 80012de:	0001      	movs	r1, r0
 80012e0:	4a34      	ldr	r2, [pc, #208]	; (80013b4 <GSM_Manager_ChangeState+0xf4>)
 80012e2:	4b35      	ldr	r3, [pc, #212]	; (80013b8 <GSM_Manager_ChangeState+0xf8>)
 80012e4:	0018      	movs	r0, r3
 80012e6:	f000 ff71 	bl	80021cc <app_debug_rtt_raw>
    switch (state)
 80012ea:	1dfb      	adds	r3, r7, #7
 80012ec:	781b      	ldrb	r3, [r3, #0]
 80012ee:	2b03      	cmp	r3, #3
 80012f0:	d033      	beq.n	800135a <GSM_Manager_ChangeState+0x9a>
 80012f2:	dc55      	bgt.n	80013a0 <GSM_Manager_ChangeState+0xe0>
 80012f4:	2b02      	cmp	r3, #2
 80012f6:	d005      	beq.n	8001304 <GSM_Manager_ChangeState+0x44>
 80012f8:	dc52      	bgt.n	80013a0 <GSM_Manager_ChangeState+0xe0>
 80012fa:	2b00      	cmp	r3, #0
 80012fc:	d026      	beq.n	800134c <GSM_Manager_ChangeState+0x8c>
 80012fe:	2b01      	cmp	r3, #1
 8001300:	d005      	beq.n	800130e <GSM_Manager_ChangeState+0x4e>
            GSM_HwLayer_Reset_Rx_Buffer(); // Reset USART RX buffer
            GSM_SendCommand_AT(atc_table_open_ppp_stack[0]);
        }
        break;
    default:
        break;
 8001302:	e04d      	b.n	80013a0 <GSM_Manager_ChangeState+0xe0>
        DEBUG_RAW("OK\r\n");
 8001304:	4b2d      	ldr	r3, [pc, #180]	; (80013bc <GSM_Manager_ChangeState+0xfc>)
 8001306:	0018      	movs	r0, r3
 8001308:	f000 ff60 	bl	80021cc <app_debug_rtt_raw>
        break;
 800130c:	e04b      	b.n	80013a6 <GSM_Manager_ChangeState+0xe6>
    	DEBUG_RAW("RESET\r\n");
 800130e:	4b2c      	ldr	r3, [pc, #176]	; (80013c0 <GSM_Manager_ChangeState+0x100>)
 8001310:	0018      	movs	r0, r3
 8001312:	f000 ff5b 	bl	80021cc <app_debug_rtt_raw>
        GSM_HwLayer_Reset_Rx_Buffer(); // Reset USART RX buffer
 8001316:	f000 fbf9 	bl	8001b0c <GSM_HwLayer_Reset_Rx_Buffer>
        GSM_Manager_ChangeInternetMode(GSM_INTERNET_MODE_AT_STACK);
 800131a:	2000      	movs	r0, #0
 800131c:	f000 f85e 	bl	80013dc <GSM_Manager_ChangeInternetMode>
        HAL_GPIO_WritePin(EN_GSM_GPIO_Port,EN_GSM_Pin,0);    // Set GSM power en level to 0 = power off device
 8001320:	4b28      	ldr	r3, [pc, #160]	; (80013c4 <GSM_Manager_ChangeState+0x104>)
 8001322:	2200      	movs	r2, #0
 8001324:	2140      	movs	r1, #64	; 0x40
 8001326:	0018      	movs	r0, r3
 8001328:	f001 fbcc 	bl	8002ac4 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GSM_RESET_GPIO_Port,GSM_RESET_Pin,1);  // Set GSM Reset pin to high
 800132c:	2380      	movs	r3, #128	; 0x80
 800132e:	009b      	lsls	r3, r3, #2
 8001330:	4825      	ldr	r0, [pc, #148]	; (80013c8 <GSM_Manager_ChangeState+0x108>)
 8001332:	2201      	movs	r2, #1
 8001334:	0019      	movs	r1, r3
 8001336:	f001 fbc5 	bl	8002ac4 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GSM_PWKEY_GPIO_Port,GSM_PWKEY_Pin,0);  // Reset GSM power key pin
 800133a:	2380      	movs	r3, #128	; 0x80
 800133c:	0059      	lsls	r1, r3, #1
 800133e:	23a0      	movs	r3, #160	; 0xa0
 8001340:	05db      	lsls	r3, r3, #23
 8001342:	2200      	movs	r2, #0
 8001344:	0018      	movs	r0, r3
 8001346:	f001 fbbd 	bl	8002ac4 <HAL_GPIO_WritePin>
        break;
 800134a:	e02c      	b.n	80013a6 <GSM_Manager_ChangeState+0xe6>
    	DEBUG_RAW("POWER ON\r\n");
 800134c:	4b1f      	ldr	r3, [pc, #124]	; (80013cc <GSM_Manager_ChangeState+0x10c>)
 800134e:	0018      	movs	r0, r3
 8001350:	f000 ff3c 	bl	80021cc <app_debug_rtt_raw>
        GSM_HwLayer_Reset_Rx_Buffer(); // Reset USART RX buffer
 8001354:	f000 fbda 	bl	8001b0c <GSM_HwLayer_Reset_Rx_Buffer>
        break;
 8001358:	e025      	b.n	80013a6 <GSM_Manager_ChangeState+0xe6>
    	DEBUG_RAW("REOPEN PPP\r\n");
 800135a:	4b1d      	ldr	r3, [pc, #116]	; (80013d0 <GSM_Manager_ChangeState+0x110>)
 800135c:	0018      	movs	r0, r3
 800135e:	f000 ff35 	bl	80021cc <app_debug_rtt_raw>
        if (GSM_Manager.step == 0)
 8001362:	4b13      	ldr	r3, [pc, #76]	; (80013b0 <GSM_Manager_ChangeState+0xf0>)
 8001364:	785b      	ldrb	r3, [r3, #1]
 8001366:	2b00      	cmp	r3, #0
 8001368:	d11c      	bne.n	80013a4 <GSM_Manager_ChangeState+0xe4>
            GSM_Manager.step = 1;
 800136a:	4b11      	ldr	r3, [pc, #68]	; (80013b0 <GSM_Manager_ChangeState+0xf0>)
 800136c:	2201      	movs	r2, #1
 800136e:	705a      	strb	r2, [r3, #1]
            m_ppp_connected = false;
 8001370:	4b18      	ldr	r3, [pc, #96]	; (80013d4 <GSM_Manager_ChangeState+0x114>)
 8001372:	2200      	movs	r2, #0
 8001374:	701a      	strb	r2, [r3, #0]
            GSM_Manager_ChangeInternetMode(GSM_INTERNET_MODE_AT_STACK);
 8001376:	2000      	movs	r0, #0
 8001378:	f000 f830 	bl	80013dc <GSM_Manager_ChangeInternetMode>
            GSM_HwLayer_Reset_Rx_Buffer(); // Reset USART RX buffer
 800137c:	f000 fbc6 	bl	8001b0c <GSM_HwLayer_Reset_Rx_Buffer>
            GSM_SendCommand_AT(atc_table_open_ppp_stack[0]);
 8001380:	4b15      	ldr	r3, [pc, #84]	; (80013d8 <GSM_Manager_ChangeState+0x118>)
 8001382:	466a      	mov	r2, sp
 8001384:	0011      	movs	r1, r2
 8001386:	001a      	movs	r2, r3
 8001388:	3210      	adds	r2, #16
 800138a:	ca31      	ldmia	r2!, {r0, r4, r5}
 800138c:	c131      	stmia	r1!, {r0, r4, r5}
 800138e:	6812      	ldr	r2, [r2, #0]
 8001390:	600a      	str	r2, [r1, #0]
 8001392:	6818      	ldr	r0, [r3, #0]
 8001394:	6859      	ldr	r1, [r3, #4]
 8001396:	689a      	ldr	r2, [r3, #8]
 8001398:	68db      	ldr	r3, [r3, #12]
 800139a:	f000 facb 	bl	8001934 <GSM_SendCommand_AT>
        break;
 800139e:	e001      	b.n	80013a4 <GSM_Manager_ChangeState+0xe4>
        break;
 80013a0:	46c0      	nop			; (mov r8, r8)
 80013a2:	e000      	b.n	80013a6 <GSM_Manager_ChangeState+0xe6>
        break;
 80013a4:	46c0      	nop			; (mov r8, r8)
    }
}
 80013a6:	46c0      	nop			; (mov r8, r8)
 80013a8:	46bd      	mov	sp, r7
 80013aa:	b002      	add	sp, #8
 80013ac:	bdb0      	pop	{r4, r5, r7, pc}
 80013ae:	46c0      	nop			; (mov r8, r8)
 80013b0:	2000144c 	.word	0x2000144c
 80013b4:	0801d35c 	.word	0x0801d35c
 80013b8:	0801dd10 	.word	0x0801dd10
 80013bc:	0801d34c 	.word	0x0801d34c
 80013c0:	0801dd40 	.word	0x0801dd40
 80013c4:	50000800 	.word	0x50000800
 80013c8:	50000400 	.word	0x50000400
 80013cc:	0801dd48 	.word	0x0801dd48
 80013d0:	0801dd54 	.word	0x0801dd54
 80013d4:	2000030c 	.word	0x2000030c
 80013d8:	08021814 	.word	0x08021814

080013dc <GSM_Manager_ChangeInternetMode>:
void GSM_Manager_ChangeInternetMode(gsm_internet_mode_t mode)
{
 80013dc:	b580      	push	{r7, lr}
 80013de:	b082      	sub	sp, #8
 80013e0:	af00      	add	r7, sp, #0
 80013e2:	0002      	movs	r2, r0
 80013e4:	1dfb      	adds	r3, r7, #7
 80013e6:	701a      	strb	r2, [r3, #0]
    GSM_Manager.mode = mode;
 80013e8:	4b03      	ldr	r3, [pc, #12]	; (80013f8 <GSM_Manager_ChangeInternetMode+0x1c>)
 80013ea:	1dfa      	adds	r2, r7, #7
 80013ec:	7812      	ldrb	r2, [r2, #0]
 80013ee:	709a      	strb	r2, [r3, #2]
}
 80013f0:	46c0      	nop			; (mov r8, r8)
 80013f2:	46bd      	mov	sp, r7
 80013f4:	b002      	add	sp, #8
 80013f6:	bd80      	pop	{r7, pc}
 80013f8:	2000144c 	.word	0x2000144c

080013fc <GSM_mnr_task>:
void GSM_mnr_task(void)
{
 80013fc:	b580      	push	{r7, lr}
 80013fe:	af00      	add	r7, sp, #0
    GSM_Hardware_Layer_Run();
 8001400:	f000 f832 	bl	8001468 <GSM_Hardware_Layer_Run>
    Polling_GSM_StateMachine();
 8001404:	f7ff feec 	bl	80011e0 <Polling_GSM_StateMachine>
    GSM_Hardware_pppos_Polling();
 8001408:	f000 fb28 	bl	8001a5c <GSM_Hardware_pppos_Polling>
}
 800140c:	46c0      	nop			; (mov r8, r8)
 800140e:	46bd      	mov	sp, r7
 8001410:	bd80      	pop	{r7, pc}
	...

08001414 <GMS_Hardware_Init>:
static GSM_Hardware_atc_TypDef m_gsm_atc;
// Buffer for ppp
static GSM_Modem_Buffer_TypDef m_gsm_modem_buffer;

void GMS_Hardware_Init(void)
{
 8001414:	b580      	push	{r7, lr}
 8001416:	af00      	add	r7, sp, #0
	// Turn off power GSM
	HAL_GPIO_WritePin(EN_GSM_GPIO_Port,EN_GSM_Pin,0);
 8001418:	4b10      	ldr	r3, [pc, #64]	; (800145c <GMS_Hardware_Init+0x48>)
 800141a:	2200      	movs	r2, #0
 800141c:	2140      	movs	r1, #64	; 0x40
 800141e:	0018      	movs	r0, r3
 8001420:	f001 fb50 	bl	8002ac4 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GSM_RESET_GPIO_Port,GSM_RESET_Pin,1);
 8001424:	2380      	movs	r3, #128	; 0x80
 8001426:	009b      	lsls	r3, r3, #2
 8001428:	480d      	ldr	r0, [pc, #52]	; (8001460 <GMS_Hardware_Init+0x4c>)
 800142a:	2201      	movs	r2, #1
 800142c:	0019      	movs	r1, r3
 800142e:	f001 fb49 	bl	8002ac4 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GSM_PWKEY_GPIO_Port,GSM_PWKEY_Pin,0);
 8001432:	2380      	movs	r3, #128	; 0x80
 8001434:	0059      	lsls	r1, r3, #1
 8001436:	23a0      	movs	r3, #160	; 0xa0
 8001438:	05db      	lsls	r3, r3, #23
 800143a:	2200      	movs	r2, #0
 800143c:	0018      	movs	r0, r3
 800143e:	f001 fb41 	bl	8002ac4 <HAL_GPIO_WritePin>
	//Init SEGGER RTT Debug
	SEGGER_RTT_Init();
 8001442:	f000 febb 	bl	80021bc <SEGGER_RTT_Init>
	// Cap phat bo nho cho RxRingBuffer
	RingBuffer_Init(&Rx_Buffer, 100);
 8001446:	4b07      	ldr	r3, [pc, #28]	; (8001464 <GMS_Hardware_Init+0x50>)
 8001448:	2164      	movs	r1, #100	; 0x64
 800144a:	0018      	movs	r0, r3
 800144c:	f000 fef0 	bl	8002230 <RingBuffer_Init>
	// Set default GMS State to GMS_STATE_RESET
	GSM_Manager_ChangeState(GSM_STATE_RESET);
 8001450:	2001      	movs	r0, #1
 8001452:	f7ff ff35 	bl	80012c0 <GSM_Manager_ChangeState>
}
 8001456:	46c0      	nop			; (mov r8, r8)
 8001458:	46bd      	mov	sp, r7
 800145a:	bd80      	pop	{r7, pc}
 800145c:	50000800 	.word	0x50000800
 8001460:	50000400 	.word	0x50000400
 8001464:	20001460 	.word	0x20001460

08001468 <GSM_Hardware_Layer_Run>:
void GSM_Hardware_Layer_Run(void)
{
 8001468:	b590      	push	{r4, r7, lr}
 800146a:	b097      	sub	sp, #92	; 0x5c
 800146c:	af02      	add	r7, sp, #8
	static uint32_t LastTick = 0;
	uint32_t Current_Tick = sys_get_tick_ms();
 800146e:	f01b f967 	bl	801c740 <sys_get_tick_ms>
 8001472:	0003      	movs	r3, r0
 8001474:	64bb      	str	r3, [r7, #72]	; 0x48

	if(Current_Tick - LastTick < (uint32_t)5)
 8001476:	4bc2      	ldr	r3, [pc, #776]	; (8001780 <GSM_Hardware_Layer_Run+0x318>)
 8001478:	681b      	ldr	r3, [r3, #0]
 800147a:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800147c:	1ad3      	subs	r3, r2, r3
 800147e:	2b04      	cmp	r3, #4
 8001480:	d800      	bhi.n	8001484 <GSM_Hardware_Layer_Run+0x1c>
 8001482:	e178      	b.n	8001776 <GSM_Hardware_Layer_Run+0x30e>
	{
		return;
	}
	uint32_t diff = sys_get_tick_ms() - m_gsm_atc.atc.Last_time_send_atc_ms;
 8001484:	f01b f95c 	bl	801c740 <sys_get_tick_ms>
 8001488:	0002      	movs	r2, r0
 800148a:	4bbe      	ldr	r3, [pc, #760]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 800148c:	699b      	ldr	r3, [r3, #24]
 800148e:	1ad3      	subs	r3, r2, r3
 8001490:	647b      	str	r3, [r7, #68]	; 0x44
	if(m_gsm_atc.atc.Timeout_atc_ms && diff >= m_gsm_atc.atc.Timeout_atc_ms)
 8001492:	4bbc      	ldr	r3, [pc, #752]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 8001494:	695b      	ldr	r3, [r3, #20]
 8001496:	2b00      	cmp	r3, #0
 8001498:	d100      	bne.n	800149c <GSM_Hardware_Layer_Run+0x34>
 800149a:	e07a      	b.n	8001592 <GSM_Hardware_Layer_Run+0x12a>
 800149c:	4bb9      	ldr	r3, [pc, #740]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 800149e:	695b      	ldr	r3, [r3, #20]
 80014a0:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80014a2:	429a      	cmp	r2, r3
 80014a4:	d375      	bcc.n	8001592 <GSM_Hardware_Layer_Run+0x12a>
	{
		if(--m_gsm_atc.atc.Retry_Count_atc <= 0)
 80014a6:	4bb7      	ldr	r3, [pc, #732]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 80014a8:	7f1b      	ldrb	r3, [r3, #28]
 80014aa:	3b01      	subs	r3, #1
 80014ac:	b2da      	uxtb	r2, r3
 80014ae:	4bb5      	ldr	r3, [pc, #724]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 80014b0:	771a      	strb	r2, [r3, #28]
 80014b2:	4bb4      	ldr	r3, [pc, #720]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 80014b4:	7f1b      	ldrb	r3, [r3, #28]
 80014b6:	2b00      	cmp	r3, #0
 80014b8:	d11b      	bne.n	80014f2 <GSM_Hardware_Layer_Run+0x8a>
		{
			m_gsm_atc.atc.Timeout_atc_ms = 0;
 80014ba:	4bb2      	ldr	r3, [pc, #712]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 80014bc:	2200      	movs	r2, #0
 80014be:	615a      	str	r2, [r3, #20]
			if(m_gsm_atc.atc.Send_at_Callback != NULL)
 80014c0:	4ab0      	ldr	r2, [pc, #704]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 80014c2:	2384      	movs	r3, #132	; 0x84
 80014c4:	00db      	lsls	r3, r3, #3
 80014c6:	58d3      	ldr	r3, [r2, r3]
 80014c8:	2b00      	cmp	r3, #0
 80014ca:	d006      	beq.n	80014da <GSM_Hardware_Layer_Run+0x72>
			{
				m_gsm_atc.atc.Send_at_Callback(GSM_EVENT_TIMEOUT,NULL);
 80014cc:	4aad      	ldr	r2, [pc, #692]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 80014ce:	2384      	movs	r3, #132	; 0x84
 80014d0:	00db      	lsls	r3, r3, #3
 80014d2:	58d3      	ldr	r3, [r2, r3]
 80014d4:	2100      	movs	r1, #0
 80014d6:	2001      	movs	r0, #1
 80014d8:	4798      	blx	r3
			}
			memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 80014da:	2380      	movs	r3, #128	; 0x80
 80014dc:	00da      	lsls	r2, r3, #3
 80014de:	4baa      	ldr	r3, [pc, #680]	; (8001788 <GSM_Hardware_Layer_Run+0x320>)
 80014e0:	2100      	movs	r1, #0
 80014e2:	0018      	movs	r0, r3
 80014e4:	f01b f9a2 	bl	801c82c <memset>
			m_gsm_atc.atc.Recv_Buffer.index = 0;
 80014e8:	4ba6      	ldr	r3, [pc, #664]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 80014ea:	4aa8      	ldr	r2, [pc, #672]	; (800178c <GSM_Hardware_Layer_Run+0x324>)
 80014ec:	2100      	movs	r1, #0
 80014ee:	5299      	strh	r1, [r3, r2]
 80014f0:	e04f      	b.n	8001592 <GSM_Hardware_Layer_Run+0x12a>
		}
		else
		{
			char sub_cmd[64] = "";
 80014f2:	1d3b      	adds	r3, r7, #4
 80014f4:	2200      	movs	r2, #0
 80014f6:	601a      	str	r2, [r3, #0]
 80014f8:	3304      	adds	r3, #4
 80014fa:	223c      	movs	r2, #60	; 0x3c
 80014fc:	2100      	movs	r1, #0
 80014fe:	0018      	movs	r0, r3
 8001500:	f01b f994 	bl	801c82c <memset>
			strncpy(sub_cmd, m_gsm_atc.atc.cmd + 0, strlen(m_gsm_atc.atc.cmd) - 2);
 8001504:	4b9f      	ldr	r3, [pc, #636]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 8001506:	681c      	ldr	r4, [r3, #0]
 8001508:	4b9e      	ldr	r3, [pc, #632]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 800150a:	681b      	ldr	r3, [r3, #0]
 800150c:	0018      	movs	r0, r3
 800150e:	f7fe fdfb 	bl	8000108 <strlen>
 8001512:	0003      	movs	r3, r0
 8001514:	1e9a      	subs	r2, r3, #2
 8001516:	1d3b      	adds	r3, r7, #4
 8001518:	0021      	movs	r1, r4
 800151a:	0018      	movs	r0, r3
 800151c:	f01b fa7c 	bl	801ca18 <strncpy>
			DEBUG_WARN("Retry send [%s] %d.\r\n", sub_cmd, m_gsm_atc.atc.Retry_Count_atc);
 8001520:	f01b f90e 	bl	801c740 <sys_get_tick_ms>
 8001524:	0001      	movs	r1, r0
 8001526:	4b97      	ldr	r3, [pc, #604]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 8001528:	7f1b      	ldrb	r3, [r3, #28]
 800152a:	001c      	movs	r4, r3
 800152c:	1d3b      	adds	r3, r7, #4
 800152e:	4a98      	ldr	r2, [pc, #608]	; (8001790 <GSM_Hardware_Layer_Run+0x328>)
 8001530:	4898      	ldr	r0, [pc, #608]	; (8001794 <GSM_Hardware_Layer_Run+0x32c>)
 8001532:	9400      	str	r4, [sp, #0]
 8001534:	f000 fe4a 	bl	80021cc <app_debug_rtt_raw>
			DEBUG_RAW("index = %d\r\n",m_gsm_atc.atc.Recv_Buffer.index);
 8001538:	4b92      	ldr	r3, [pc, #584]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 800153a:	4a94      	ldr	r2, [pc, #592]	; (800178c <GSM_Hardware_Layer_Run+0x324>)
 800153c:	5a9b      	ldrh	r3, [r3, r2]
 800153e:	001a      	movs	r2, r3
 8001540:	4b95      	ldr	r3, [pc, #596]	; (8001798 <GSM_Hardware_Layer_Run+0x330>)
 8001542:	0011      	movs	r1, r2
 8001544:	0018      	movs	r0, r3
 8001546:	f000 fe41 	bl	80021cc <app_debug_rtt_raw>
			DEBUG_RAW("%s\r\n", (char*)m_gsm_atc.atc.Recv_Buffer.u8Buffer);
 800154a:	4a8f      	ldr	r2, [pc, #572]	; (8001788 <GSM_Hardware_Layer_Run+0x320>)
 800154c:	4b93      	ldr	r3, [pc, #588]	; (800179c <GSM_Hardware_Layer_Run+0x334>)
 800154e:	0011      	movs	r1, r2
 8001550:	0018      	movs	r0, r3
 8001552:	f000 fe3b 	bl	80021cc <app_debug_rtt_raw>
			m_gsm_atc.atc.Last_time_send_atc_ms = sys_get_tick_ms();
 8001556:	f01b f8f3 	bl	801c740 <sys_get_tick_ms>
 800155a:	0002      	movs	r2, r0
 800155c:	4b89      	ldr	r3, [pc, #548]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 800155e:	619a      	str	r2, [r3, #24]
			memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 8001560:	2380      	movs	r3, #128	; 0x80
 8001562:	00da      	lsls	r2, r3, #3
 8001564:	4b88      	ldr	r3, [pc, #544]	; (8001788 <GSM_Hardware_Layer_Run+0x320>)
 8001566:	2100      	movs	r1, #0
 8001568:	0018      	movs	r0, r3
 800156a:	f01b f95f 	bl	801c82c <memset>
			m_gsm_atc.atc.Recv_Buffer.index = 0;
 800156e:	4b85      	ldr	r3, [pc, #532]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 8001570:	4a86      	ldr	r2, [pc, #536]	; (800178c <GSM_Hardware_Layer_Run+0x324>)
 8001572:	2100      	movs	r1, #0
 8001574:	5299      	strh	r1, [r3, r2]
			GSM_UART_TX((uint8_t*) m_gsm_atc.atc.cmd, strlen(m_gsm_atc.atc.cmd), 200);
 8001576:	4b83      	ldr	r3, [pc, #524]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 8001578:	681c      	ldr	r4, [r3, #0]
 800157a:	4b82      	ldr	r3, [pc, #520]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 800157c:	681b      	ldr	r3, [r3, #0]
 800157e:	0018      	movs	r0, r3
 8001580:	f7fe fdc2 	bl	8000108 <strlen>
 8001584:	0003      	movs	r3, r0
 8001586:	b29a      	uxth	r2, r3
 8001588:	4885      	ldr	r0, [pc, #532]	; (80017a0 <GSM_Hardware_Layer_Run+0x338>)
 800158a:	23c8      	movs	r3, #200	; 0xc8
 800158c:	0021      	movs	r1, r4
 800158e:	f002 f9f1 	bl	8003974 <HAL_UART_Transmit>
		}
	}
	if(strlen(m_gsm_atc.atc.expect_resp) && strstr((char*)m_gsm_atc.atc.Recv_Buffer.u8Buffer, m_gsm_atc.atc.expect_resp))
 8001592:	4b7c      	ldr	r3, [pc, #496]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 8001594:	685b      	ldr	r3, [r3, #4]
 8001596:	781b      	ldrb	r3, [r3, #0]
 8001598:	2b00      	cmp	r3, #0
 800159a:	d06e      	beq.n	800167a <GSM_Hardware_Layer_Run+0x212>
 800159c:	4b79      	ldr	r3, [pc, #484]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 800159e:	685a      	ldr	r2, [r3, #4]
 80015a0:	4b79      	ldr	r3, [pc, #484]	; (8001788 <GSM_Hardware_Layer_Run+0x320>)
 80015a2:	0011      	movs	r1, r2
 80015a4:	0018      	movs	r0, r3
 80015a6:	f01b fa4b 	bl	801ca40 <strstr>
 80015aa:	1e03      	subs	r3, r0, #0
 80015ac:	d065      	beq.n	800167a <GSM_Hardware_Layer_Run+0x212>
	{
		bool do_callback = true;
 80015ae:	244f      	movs	r4, #79	; 0x4f
 80015b0:	193b      	adds	r3, r7, r4
 80015b2:	2201      	movs	r2, #1
 80015b4:	701a      	strb	r2, [r3, #0]
		if(m_gsm_atc.atc.expected_response_at_the_end && strlen(m_gsm_atc.atc.expected_response_at_the_end))
 80015b6:	4b73      	ldr	r3, [pc, #460]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 80015b8:	689b      	ldr	r3, [r3, #8]
 80015ba:	2b00      	cmp	r3, #0
 80015bc:	d03d      	beq.n	800163a <GSM_Hardware_Layer_Run+0x1d2>
 80015be:	4b71      	ldr	r3, [pc, #452]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 80015c0:	689b      	ldr	r3, [r3, #8]
 80015c2:	781b      	ldrb	r3, [r3, #0]
 80015c4:	2b00      	cmp	r3, #0
 80015c6:	d038      	beq.n	800163a <GSM_Hardware_Layer_Run+0x1d2>
		{
			Expect_len_compare = strlen(m_gsm_atc.atc.expected_response_at_the_end);
 80015c8:	4b6e      	ldr	r3, [pc, #440]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 80015ca:	689b      	ldr	r3, [r3, #8]
 80015cc:	0018      	movs	r0, r3
 80015ce:	f7fe fd9b 	bl	8000108 <strlen>
 80015d2:	0002      	movs	r2, r0
 80015d4:	4b73      	ldr	r3, [pc, #460]	; (80017a4 <GSM_Hardware_Layer_Run+0x33c>)
 80015d6:	601a      	str	r2, [r3, #0]
			Current_Response_len = strlen((char*)m_gsm_atc.atc.Recv_Buffer.u8Buffer);
 80015d8:	4b6b      	ldr	r3, [pc, #428]	; (8001788 <GSM_Hardware_Layer_Run+0x320>)
 80015da:	0018      	movs	r0, r3
 80015dc:	f7fe fd94 	bl	8000108 <strlen>
 80015e0:	0002      	movs	r2, r0
 80015e2:	4b71      	ldr	r3, [pc, #452]	; (80017a8 <GSM_Hardware_Layer_Run+0x340>)
 80015e4:	601a      	str	r2, [r3, #0]
			if(Expect_len_compare < Current_Response_len)
 80015e6:	4b6f      	ldr	r3, [pc, #444]	; (80017a4 <GSM_Hardware_Layer_Run+0x33c>)
 80015e8:	681a      	ldr	r2, [r3, #0]
 80015ea:	4b6f      	ldr	r3, [pc, #444]	; (80017a8 <GSM_Hardware_Layer_Run+0x340>)
 80015ec:	681b      	ldr	r3, [r3, #0]
 80015ee:	429a      	cmp	r2, r3
 80015f0:	d21f      	bcs.n	8001632 <GSM_Hardware_Layer_Run+0x1ca>
			{
				p_compare_end_str = &m_gsm_atc.atc.Recv_Buffer.u8Buffer[Current_Response_len - Expect_len_compare];
 80015f2:	4b6d      	ldr	r3, [pc, #436]	; (80017a8 <GSM_Hardware_Layer_Run+0x340>)
 80015f4:	681a      	ldr	r2, [r3, #0]
 80015f6:	4b6b      	ldr	r3, [pc, #428]	; (80017a4 <GSM_Hardware_Layer_Run+0x33c>)
 80015f8:	681b      	ldr	r3, [r3, #0]
 80015fa:	1ad3      	subs	r3, r2, r3
 80015fc:	3318      	adds	r3, #24
 80015fe:	001a      	movs	r2, r3
 8001600:	4b60      	ldr	r3, [pc, #384]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 8001602:	18d3      	adds	r3, r2, r3
 8001604:	1d9a      	adds	r2, r3, #6
 8001606:	4b69      	ldr	r3, [pc, #420]	; (80017ac <GSM_Hardware_Layer_Run+0x344>)
 8001608:	601a      	str	r2, [r3, #0]
				if(memcmp(p_compare_end_str,m_gsm_atc.atc.expected_response_at_the_end,Expect_len_compare) == 0)
 800160a:	4b68      	ldr	r3, [pc, #416]	; (80017ac <GSM_Hardware_Layer_Run+0x344>)
 800160c:	6818      	ldr	r0, [r3, #0]
 800160e:	4b5d      	ldr	r3, [pc, #372]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 8001610:	6899      	ldr	r1, [r3, #8]
 8001612:	4b64      	ldr	r3, [pc, #400]	; (80017a4 <GSM_Hardware_Layer_Run+0x33c>)
 8001614:	681b      	ldr	r3, [r3, #0]
 8001616:	001a      	movs	r2, r3
 8001618:	f01b f8de 	bl	801c7d8 <memcmp>
 800161c:	1e03      	subs	r3, r0, #0
 800161e:	d103      	bne.n	8001628 <GSM_Hardware_Layer_Run+0x1c0>
				{
					// Compare thành công đuôi Response
					do_callback = true;
 8001620:	193b      	adds	r3, r7, r4
 8001622:	2201      	movs	r2, #1
 8001624:	701a      	strb	r2, [r3, #0]
 8001626:	e008      	b.n	800163a <GSM_Hardware_Layer_Run+0x1d2>
				}
				else
				{
					do_callback = false;
 8001628:	234f      	movs	r3, #79	; 0x4f
 800162a:	18fb      	adds	r3, r7, r3
 800162c:	2200      	movs	r2, #0
 800162e:	701a      	strb	r2, [r3, #0]
 8001630:	e003      	b.n	800163a <GSM_Hardware_Layer_Run+0x1d2>
				}
			}
			else
			{
				do_callback = false;
 8001632:	234f      	movs	r3, #79	; 0x4f
 8001634:	18fb      	adds	r3, r7, r3
 8001636:	2200      	movs	r2, #0
 8001638:	701a      	strb	r2, [r3, #0]
			}
		}
		if(do_callback == true)
 800163a:	234f      	movs	r3, #79	; 0x4f
 800163c:	18fb      	adds	r3, r7, r3
 800163e:	781b      	ldrb	r3, [r3, #0]
 8001640:	2b00      	cmp	r3, #0
 8001642:	d100      	bne.n	8001646 <GSM_Hardware_Layer_Run+0x1de>
 8001644:	e090      	b.n	8001768 <GSM_Hardware_Layer_Run+0x300>
		{
			m_gsm_atc.atc.Timeout_atc_ms = 0;
 8001646:	4b4f      	ldr	r3, [pc, #316]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 8001648:	2200      	movs	r2, #0
 800164a:	615a      	str	r2, [r3, #20]
			m_gsm_atc.atc.Retry_Count_atc = 0;
 800164c:	4b4d      	ldr	r3, [pc, #308]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 800164e:	2200      	movs	r2, #0
 8001650:	771a      	strb	r2, [r3, #28]
			m_gsm_atc.atc.Send_at_Callback(GSM_EVENT_OK,m_gsm_atc.atc.Recv_Buffer.u8Buffer);
 8001652:	4a4c      	ldr	r2, [pc, #304]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 8001654:	2384      	movs	r3, #132	; 0x84
 8001656:	00db      	lsls	r3, r3, #3
 8001658:	58d3      	ldr	r3, [r2, r3]
 800165a:	4a4b      	ldr	r2, [pc, #300]	; (8001788 <GSM_Hardware_Layer_Run+0x320>)
 800165c:	0011      	movs	r1, r2
 800165e:	2000      	movs	r0, #0
 8001660:	4798      	blx	r3
			memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 8001662:	2380      	movs	r3, #128	; 0x80
 8001664:	00da      	lsls	r2, r3, #3
 8001666:	4b48      	ldr	r3, [pc, #288]	; (8001788 <GSM_Hardware_Layer_Run+0x320>)
 8001668:	2100      	movs	r1, #0
 800166a:	0018      	movs	r0, r3
 800166c:	f01b f8de 	bl	801c82c <memset>
			m_gsm_atc.atc.Recv_Buffer.index = 0;
 8001670:	4b44      	ldr	r3, [pc, #272]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 8001672:	4a46      	ldr	r2, [pc, #280]	; (800178c <GSM_Hardware_Layer_Run+0x324>)
 8001674:	2100      	movs	r1, #0
 8001676:	5299      	strh	r1, [r3, r2]
	{
 8001678:	e076      	b.n	8001768 <GSM_Hardware_Layer_Run+0x300>
		}

	}
	else if(strlen(m_gsm_atc.atc.expect_error) && strstr((char*)m_gsm_atc.atc.Recv_Buffer.u8Buffer, m_gsm_atc.atc.expect_error))
 800167a:	4b42      	ldr	r3, [pc, #264]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 800167c:	68db      	ldr	r3, [r3, #12]
 800167e:	781b      	ldrb	r3, [r3, #0]
 8001680:	2b00      	cmp	r3, #0
 8001682:	d100      	bne.n	8001686 <GSM_Hardware_Layer_Run+0x21e>
 8001684:	e071      	b.n	800176a <GSM_Hardware_Layer_Run+0x302>
 8001686:	4b3f      	ldr	r3, [pc, #252]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 8001688:	68da      	ldr	r2, [r3, #12]
 800168a:	4b3f      	ldr	r3, [pc, #252]	; (8001788 <GSM_Hardware_Layer_Run+0x320>)
 800168c:	0011      	movs	r1, r2
 800168e:	0018      	movs	r0, r3
 8001690:	f01b f9d6 	bl	801ca40 <strstr>
 8001694:	1e03      	subs	r3, r0, #0
 8001696:	d068      	beq.n	800176a <GSM_Hardware_Layer_Run+0x302>
	{
		bool do_callback = true;
 8001698:	244e      	movs	r4, #78	; 0x4e
 800169a:	193b      	adds	r3, r7, r4
 800169c:	2201      	movs	r2, #1
 800169e:	701a      	strb	r2, [r3, #0]
		if(m_gsm_atc.atc.expect_error_at_the_end && strlen(m_gsm_atc.atc.expect_error_at_the_end))
 80016a0:	4b38      	ldr	r3, [pc, #224]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 80016a2:	691b      	ldr	r3, [r3, #16]
 80016a4:	2b00      	cmp	r3, #0
 80016a6:	d03d      	beq.n	8001724 <GSM_Hardware_Layer_Run+0x2bc>
 80016a8:	4b36      	ldr	r3, [pc, #216]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 80016aa:	691b      	ldr	r3, [r3, #16]
 80016ac:	781b      	ldrb	r3, [r3, #0]
 80016ae:	2b00      	cmp	r3, #0
 80016b0:	d038      	beq.n	8001724 <GSM_Hardware_Layer_Run+0x2bc>
		{
			Expect_len_compare_error_handle = strlen(m_gsm_atc.atc.expect_error_at_the_end);
 80016b2:	4b34      	ldr	r3, [pc, #208]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 80016b4:	691b      	ldr	r3, [r3, #16]
 80016b6:	0018      	movs	r0, r3
 80016b8:	f7fe fd26 	bl	8000108 <strlen>
 80016bc:	0002      	movs	r2, r0
 80016be:	4b3c      	ldr	r3, [pc, #240]	; (80017b0 <GSM_Hardware_Layer_Run+0x348>)
 80016c0:	601a      	str	r2, [r3, #0]
			Current_Response_len_error_handle = strlen((char*)m_gsm_atc.atc.Recv_Buffer.u8Buffer);
 80016c2:	4b31      	ldr	r3, [pc, #196]	; (8001788 <GSM_Hardware_Layer_Run+0x320>)
 80016c4:	0018      	movs	r0, r3
 80016c6:	f7fe fd1f 	bl	8000108 <strlen>
 80016ca:	0002      	movs	r2, r0
 80016cc:	4b39      	ldr	r3, [pc, #228]	; (80017b4 <GSM_Hardware_Layer_Run+0x34c>)
 80016ce:	601a      	str	r2, [r3, #0]
			if(Expect_len_compare_error_handle < Current_Response_len_error_handle)
 80016d0:	4b37      	ldr	r3, [pc, #220]	; (80017b0 <GSM_Hardware_Layer_Run+0x348>)
 80016d2:	681a      	ldr	r2, [r3, #0]
 80016d4:	4b37      	ldr	r3, [pc, #220]	; (80017b4 <GSM_Hardware_Layer_Run+0x34c>)
 80016d6:	681b      	ldr	r3, [r3, #0]
 80016d8:	429a      	cmp	r2, r3
 80016da:	d21f      	bcs.n	800171c <GSM_Hardware_Layer_Run+0x2b4>
			{
				p_compare_end_str_error_handle = &m_gsm_atc.atc.Recv_Buffer.u8Buffer[Current_Response_len_error_handle - Expect_len_compare_error_handle];
 80016dc:	4b35      	ldr	r3, [pc, #212]	; (80017b4 <GSM_Hardware_Layer_Run+0x34c>)
 80016de:	681a      	ldr	r2, [r3, #0]
 80016e0:	4b33      	ldr	r3, [pc, #204]	; (80017b0 <GSM_Hardware_Layer_Run+0x348>)
 80016e2:	681b      	ldr	r3, [r3, #0]
 80016e4:	1ad3      	subs	r3, r2, r3
 80016e6:	3318      	adds	r3, #24
 80016e8:	001a      	movs	r2, r3
 80016ea:	4b26      	ldr	r3, [pc, #152]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 80016ec:	18d3      	adds	r3, r2, r3
 80016ee:	1d9a      	adds	r2, r3, #6
 80016f0:	4b31      	ldr	r3, [pc, #196]	; (80017b8 <GSM_Hardware_Layer_Run+0x350>)
 80016f2:	601a      	str	r2, [r3, #0]
				if(memcmp(p_compare_end_str_error_handle,m_gsm_atc.atc.expect_error_at_the_end,Expect_len_compare_error_handle))
 80016f4:	4b30      	ldr	r3, [pc, #192]	; (80017b8 <GSM_Hardware_Layer_Run+0x350>)
 80016f6:	6818      	ldr	r0, [r3, #0]
 80016f8:	4b22      	ldr	r3, [pc, #136]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 80016fa:	6919      	ldr	r1, [r3, #16]
 80016fc:	4b2c      	ldr	r3, [pc, #176]	; (80017b0 <GSM_Hardware_Layer_Run+0x348>)
 80016fe:	681b      	ldr	r3, [r3, #0]
 8001700:	001a      	movs	r2, r3
 8001702:	f01b f869 	bl	801c7d8 <memcmp>
 8001706:	1e03      	subs	r3, r0, #0
 8001708:	d003      	beq.n	8001712 <GSM_Hardware_Layer_Run+0x2aa>
				{
					// Compare thành công đuôi Response (trường hợp Response Error)
					do_callback = true;
 800170a:	193b      	adds	r3, r7, r4
 800170c:	2201      	movs	r2, #1
 800170e:	701a      	strb	r2, [r3, #0]
 8001710:	e008      	b.n	8001724 <GSM_Hardware_Layer_Run+0x2bc>
				}
				else
				{
					do_callback = false;
 8001712:	234e      	movs	r3, #78	; 0x4e
 8001714:	18fb      	adds	r3, r7, r3
 8001716:	2200      	movs	r2, #0
 8001718:	701a      	strb	r2, [r3, #0]
 800171a:	e003      	b.n	8001724 <GSM_Hardware_Layer_Run+0x2bc>
				}
			}
			else
			{
				do_callback = false;
 800171c:	234e      	movs	r3, #78	; 0x4e
 800171e:	18fb      	adds	r3, r7, r3
 8001720:	2200      	movs	r2, #0
 8001722:	701a      	strb	r2, [r3, #0]
			}
		}
		if(do_callback == true)
 8001724:	234e      	movs	r3, #78	; 0x4e
 8001726:	18fb      	adds	r3, r7, r3
 8001728:	781b      	ldrb	r3, [r3, #0]
 800172a:	2b00      	cmp	r3, #0
 800172c:	d01d      	beq.n	800176a <GSM_Hardware_Layer_Run+0x302>
		{
			m_gsm_atc.atc.Last_time_send_atc_ms = 0;
 800172e:	4b15      	ldr	r3, [pc, #84]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 8001730:	2200      	movs	r2, #0
 8001732:	619a      	str	r2, [r3, #24]
			m_gsm_atc.atc.Timeout_atc_ms = 0;
 8001734:	4b13      	ldr	r3, [pc, #76]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 8001736:	2200      	movs	r2, #0
 8001738:	615a      	str	r2, [r3, #20]
			m_gsm_atc.atc.Retry_Count_atc = 0;
 800173a:	4b12      	ldr	r3, [pc, #72]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 800173c:	2200      	movs	r2, #0
 800173e:	771a      	strb	r2, [r3, #28]
			m_gsm_atc.atc.Send_at_Callback(GSM_EVENT_ERROR,m_gsm_atc.atc.Recv_Buffer.u8Buffer);
 8001740:	4a10      	ldr	r2, [pc, #64]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 8001742:	2384      	movs	r3, #132	; 0x84
 8001744:	00db      	lsls	r3, r3, #3
 8001746:	58d3      	ldr	r3, [r2, r3]
 8001748:	4a0f      	ldr	r2, [pc, #60]	; (8001788 <GSM_Hardware_Layer_Run+0x320>)
 800174a:	0011      	movs	r1, r2
 800174c:	2002      	movs	r0, #2
 800174e:	4798      	blx	r3
			memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 8001750:	2380      	movs	r3, #128	; 0x80
 8001752:	00da      	lsls	r2, r3, #3
 8001754:	4b0c      	ldr	r3, [pc, #48]	; (8001788 <GSM_Hardware_Layer_Run+0x320>)
 8001756:	2100      	movs	r1, #0
 8001758:	0018      	movs	r0, r3
 800175a:	f01b f867 	bl	801c82c <memset>
			m_gsm_atc.atc.Recv_Buffer.index = 0;
 800175e:	4b09      	ldr	r3, [pc, #36]	; (8001784 <GSM_Hardware_Layer_Run+0x31c>)
 8001760:	4a0a      	ldr	r2, [pc, #40]	; (800178c <GSM_Hardware_Layer_Run+0x324>)
 8001762:	2100      	movs	r1, #0
 8001764:	5299      	strh	r1, [r3, r2]
 8001766:	e000      	b.n	800176a <GSM_Hardware_Layer_Run+0x302>
	{
 8001768:	46c0      	nop			; (mov r8, r8)
		}
	}
	LastTick = sys_get_tick_ms();
 800176a:	f01a ffe9 	bl	801c740 <sys_get_tick_ms>
 800176e:	0002      	movs	r2, r0
 8001770:	4b03      	ldr	r3, [pc, #12]	; (8001780 <GSM_Hardware_Layer_Run+0x318>)
 8001772:	601a      	str	r2, [r3, #0]
 8001774:	e000      	b.n	8001778 <GSM_Hardware_Layer_Run+0x310>
		return;
 8001776:	46c0      	nop			; (mov r8, r8)
}
 8001778:	46bd      	mov	sp, r7
 800177a:	b015      	add	sp, #84	; 0x54
 800177c:	bd90      	pop	{r4, r7, pc}
 800177e:	46c0      	nop			; (mov r8, r8)
 8001780:	20000d3c 	.word	0x20000d3c
 8001784:	20000314 	.word	0x20000314
 8001788:	20000332 	.word	0x20000332
 800178c:	0000041e 	.word	0x0000041e
 8001790:	0801dd64 	.word	0x0801dd64
 8001794:	0801dd68 	.word	0x0801dd68
 8001798:	0801dd98 	.word	0x0801dd98
 800179c:	0801dda8 	.word	0x0801dda8
 80017a0:	200013c8 	.word	0x200013c8
 80017a4:	20001454 	.word	0x20001454
 80017a8:	20001458 	.word	0x20001458
 80017ac:	20001474 	.word	0x20001474
 80017b0:	20001450 	.word	0x20001450
 80017b4:	20001470 	.word	0x20001470
 80017b8:	2000145c 	.word	0x2000145c

080017bc <GSM_Turn_on_Power>:
void GSM_Turn_on_Power(void)
{
 80017bc:	b580      	push	{r7, lr}
 80017be:	af00      	add	r7, sp, #0
	static uint8_t step;
	DEBUG_INFO("GSM Hard reset step %d.\r\n", step);
 80017c0:	f01a ffbe 	bl	801c740 <sys_get_tick_ms>
 80017c4:	0001      	movs	r1, r0
 80017c6:	4b52      	ldr	r3, [pc, #328]	; (8001910 <GSM_Turn_on_Power+0x154>)
 80017c8:	781b      	ldrb	r3, [r3, #0]
 80017ca:	4a52      	ldr	r2, [pc, #328]	; (8001914 <GSM_Turn_on_Power+0x158>)
 80017cc:	4852      	ldr	r0, [pc, #328]	; (8001918 <GSM_Turn_on_Power+0x15c>)
 80017ce:	f000 fcfd 	bl	80021cc <app_debug_rtt_raw>
	switch (step)
 80017d2:	4b4f      	ldr	r3, [pc, #316]	; (8001910 <GSM_Turn_on_Power+0x154>)
 80017d4:	781b      	ldrb	r3, [r3, #0]
 80017d6:	2b07      	cmp	r3, #7
 80017d8:	d900      	bls.n	80017dc <GSM_Turn_on_Power+0x20>
 80017da:	e094      	b.n	8001906 <GSM_Turn_on_Power+0x14a>
 80017dc:	009a      	lsls	r2, r3, #2
 80017de:	4b4f      	ldr	r3, [pc, #316]	; (800191c <GSM_Turn_on_Power+0x160>)
 80017e0:	18d3      	adds	r3, r2, r3
 80017e2:	681b      	ldr	r3, [r3, #0]
 80017e4:	469f      	mov	pc, r3
	{
		case 0:
			HAL_GPIO_WritePin(EN_GSM_GPIO_Port,EN_GSM_Pin,0);
 80017e6:	4b4e      	ldr	r3, [pc, #312]	; (8001920 <GSM_Turn_on_Power+0x164>)
 80017e8:	2200      	movs	r2, #0
 80017ea:	2140      	movs	r1, #64	; 0x40
 80017ec:	0018      	movs	r0, r3
 80017ee:	f001 f969 	bl	8002ac4 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(GSM_RESET_GPIO_Port,GSM_RESET_Pin,1);
 80017f2:	2380      	movs	r3, #128	; 0x80
 80017f4:	009b      	lsls	r3, r3, #2
 80017f6:	484b      	ldr	r0, [pc, #300]	; (8001924 <GSM_Turn_on_Power+0x168>)
 80017f8:	2201      	movs	r2, #1
 80017fa:	0019      	movs	r1, r3
 80017fc:	f001 f962 	bl	8002ac4 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(GSM_PWKEY_GPIO_Port,GSM_PWKEY_Pin,0);
 8001800:	2380      	movs	r3, #128	; 0x80
 8001802:	0059      	lsls	r1, r3, #1
 8001804:	23a0      	movs	r3, #160	; 0xa0
 8001806:	05db      	lsls	r3, r3, #23
 8001808:	2200      	movs	r2, #0
 800180a:	0018      	movs	r0, r3
 800180c:	f001 f95a 	bl	8002ac4 <HAL_GPIO_WritePin>
			step++;
 8001810:	4b3f      	ldr	r3, [pc, #252]	; (8001910 <GSM_Turn_on_Power+0x154>)
 8001812:	781b      	ldrb	r3, [r3, #0]
 8001814:	3301      	adds	r3, #1
 8001816:	b2da      	uxtb	r2, r3
 8001818:	4b3d      	ldr	r3, [pc, #244]	; (8001910 <GSM_Turn_on_Power+0x154>)
 800181a:	701a      	strb	r2, [r3, #0]
			break;
 800181c:	e074      	b.n	8001908 <GSM_Turn_on_Power+0x14c>
		case 1:
			HAL_GPIO_WritePin(GSM_RESET_GPIO_Port,GSM_RESET_Pin,0);
 800181e:	2380      	movs	r3, #128	; 0x80
 8001820:	009b      	lsls	r3, r3, #2
 8001822:	4840      	ldr	r0, [pc, #256]	; (8001924 <GSM_Turn_on_Power+0x168>)
 8001824:	2200      	movs	r2, #0
 8001826:	0019      	movs	r1, r3
 8001828:	f001 f94c 	bl	8002ac4 <HAL_GPIO_WritePin>
			DEBUG_INFO("GSM power on.\r\n");
 800182c:	f01a ff88 	bl	801c740 <sys_get_tick_ms>
 8001830:	0001      	movs	r1, r0
 8001832:	4a38      	ldr	r2, [pc, #224]	; (8001914 <GSM_Turn_on_Power+0x158>)
 8001834:	4b3c      	ldr	r3, [pc, #240]	; (8001928 <GSM_Turn_on_Power+0x16c>)
 8001836:	0018      	movs	r0, r3
 8001838:	f000 fcc8 	bl	80021cc <app_debug_rtt_raw>
			HAL_GPIO_WritePin(EN_GSM_GPIO_Port,EN_GSM_Pin,1);
 800183c:	4b38      	ldr	r3, [pc, #224]	; (8001920 <GSM_Turn_on_Power+0x164>)
 800183e:	2201      	movs	r2, #1
 8001840:	2140      	movs	r1, #64	; 0x40
 8001842:	0018      	movs	r0, r3
 8001844:	f001 f93e 	bl	8002ac4 <HAL_GPIO_WritePin>
			// Enable nguon 5V
			HAL_GPIO_WritePin(CHARGE_EN_GPIO_Port,CHARGE_EN_Pin,1);
 8001848:	4b35      	ldr	r3, [pc, #212]	; (8001920 <GSM_Turn_on_Power+0x164>)
 800184a:	2201      	movs	r2, #1
 800184c:	2110      	movs	r1, #16
 800184e:	0018      	movs	r0, r3
 8001850:	f001 f938 	bl	8002ac4 <HAL_GPIO_WritePin>
			// Enable nguon 4.2V
			HAL_GPIO_WritePin(GSM_EN_GPIO_Port,GSM_EN_Pin,1);
 8001854:	2380      	movs	r3, #128	; 0x80
 8001856:	0219      	lsls	r1, r3, #8
 8001858:	23a0      	movs	r3, #160	; 0xa0
 800185a:	05db      	lsls	r3, r3, #23
 800185c:	2201      	movs	r2, #1
 800185e:	0018      	movs	r0, r3
 8001860:	f001 f930 	bl	8002ac4 <HAL_GPIO_WritePin>
			step++;
 8001864:	4b2a      	ldr	r3, [pc, #168]	; (8001910 <GSM_Turn_on_Power+0x154>)
 8001866:	781b      	ldrb	r3, [r3, #0]
 8001868:	3301      	adds	r3, #1
 800186a:	b2da      	uxtb	r2, r3
 800186c:	4b28      	ldr	r3, [pc, #160]	; (8001910 <GSM_Turn_on_Power+0x154>)
 800186e:	701a      	strb	r2, [r3, #0]
			break;
 8001870:	e04a      	b.n	8001908 <GSM_Turn_on_Power+0x14c>
		case 2:
			step++;
 8001872:	4b27      	ldr	r3, [pc, #156]	; (8001910 <GSM_Turn_on_Power+0x154>)
 8001874:	781b      	ldrb	r3, [r3, #0]
 8001876:	3301      	adds	r3, #1
 8001878:	b2da      	uxtb	r2, r3
 800187a:	4b25      	ldr	r3, [pc, #148]	; (8001910 <GSM_Turn_on_Power+0x154>)
 800187c:	701a      	strb	r2, [r3, #0]
			break;
 800187e:	e043      	b.n	8001908 <GSM_Turn_on_Power+0x14c>
		case 3: 
			/* Generate pulse from (1-0-1) |_| to Power On module */
			DEBUG_INFO("Pulse power key.\r\n");
 8001880:	f01a ff5e 	bl	801c740 <sys_get_tick_ms>
 8001884:	0001      	movs	r1, r0
 8001886:	4a23      	ldr	r2, [pc, #140]	; (8001914 <GSM_Turn_on_Power+0x158>)
 8001888:	4b28      	ldr	r3, [pc, #160]	; (800192c <GSM_Turn_on_Power+0x170>)
 800188a:	0018      	movs	r0, r3
 800188c:	f000 fc9e 	bl	80021cc <app_debug_rtt_raw>
			HAL_GPIO_WritePin(GSM_PWKEY_GPIO_Port,GSM_PWKEY_Pin,1);
 8001890:	2380      	movs	r3, #128	; 0x80
 8001892:	0059      	lsls	r1, r3, #1
 8001894:	23a0      	movs	r3, #160	; 0xa0
 8001896:	05db      	lsls	r3, r3, #23
 8001898:	2201      	movs	r2, #1
 800189a:	0018      	movs	r0, r3
 800189c:	f001 f912 	bl	8002ac4 <HAL_GPIO_WritePin>
			step++;
 80018a0:	4b1b      	ldr	r3, [pc, #108]	; (8001910 <GSM_Turn_on_Power+0x154>)
 80018a2:	781b      	ldrb	r3, [r3, #0]
 80018a4:	3301      	adds	r3, #1
 80018a6:	b2da      	uxtb	r2, r3
 80018a8:	4b19      	ldr	r3, [pc, #100]	; (8001910 <GSM_Turn_on_Power+0x154>)
 80018aa:	701a      	strb	r2, [r3, #0]
			break;
 80018ac:	e02c      	b.n	8001908 <GSM_Turn_on_Power+0x14c>
		case 4:
			HAL_GPIO_WritePin(GSM_PWKEY_GPIO_Port,GSM_PWKEY_Pin,0);
 80018ae:	2380      	movs	r3, #128	; 0x80
 80018b0:	0059      	lsls	r1, r3, #1
 80018b2:	23a0      	movs	r3, #160	; 0xa0
 80018b4:	05db      	lsls	r3, r3, #23
 80018b6:	2200      	movs	r2, #0
 80018b8:	0018      	movs	r0, r3
 80018ba:	f001 f903 	bl	8002ac4 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(GSM_RESET_GPIO_Port,GSM_RESET_Pin,0);
 80018be:	2380      	movs	r3, #128	; 0x80
 80018c0:	009b      	lsls	r3, r3, #2
 80018c2:	4818      	ldr	r0, [pc, #96]	; (8001924 <GSM_Turn_on_Power+0x168>)
 80018c4:	2200      	movs	r2, #0
 80018c6:	0019      	movs	r1, r3
 80018c8:	f001 f8fc 	bl	8002ac4 <HAL_GPIO_WritePin>
			step++;
 80018cc:	4b10      	ldr	r3, [pc, #64]	; (8001910 <GSM_Turn_on_Power+0x154>)
 80018ce:	781b      	ldrb	r3, [r3, #0]
 80018d0:	3301      	adds	r3, #1
 80018d2:	b2da      	uxtb	r2, r3
 80018d4:	4b0e      	ldr	r3, [pc, #56]	; (8001910 <GSM_Turn_on_Power+0x154>)
 80018d6:	701a      	strb	r2, [r3, #0]
			break;
 80018d8:	e016      	b.n	8001908 <GSM_Turn_on_Power+0x14c>
		case 5:
		case 6:
			step++;
 80018da:	4b0d      	ldr	r3, [pc, #52]	; (8001910 <GSM_Turn_on_Power+0x154>)
 80018dc:	781b      	ldrb	r3, [r3, #0]
 80018de:	3301      	adds	r3, #1
 80018e0:	b2da      	uxtb	r2, r3
 80018e2:	4b0b      	ldr	r3, [pc, #44]	; (8001910 <GSM_Turn_on_Power+0x154>)
 80018e4:	701a      	strb	r2, [r3, #0]
			break;
 80018e6:	e00f      	b.n	8001908 <GSM_Turn_on_Power+0x14c>
		case 7:
			step = 0;
 80018e8:	4b09      	ldr	r3, [pc, #36]	; (8001910 <GSM_Turn_on_Power+0x154>)
 80018ea:	2200      	movs	r2, #0
 80018ec:	701a      	strb	r2, [r3, #0]
			DEBUG_INFO("GSM Hard reset DONE.\r\n");
 80018ee:	f01a ff27 	bl	801c740 <sys_get_tick_ms>
 80018f2:	0001      	movs	r1, r0
 80018f4:	4a07      	ldr	r2, [pc, #28]	; (8001914 <GSM_Turn_on_Power+0x158>)
 80018f6:	4b0e      	ldr	r3, [pc, #56]	; (8001930 <GSM_Turn_on_Power+0x174>)
 80018f8:	0018      	movs	r0, r3
 80018fa:	f000 fc67 	bl	80021cc <app_debug_rtt_raw>
			GSM_Manager_ChangeState(GSM_STATE_POWER_ON); // GSM turn on Power Finish-> active GSM by AT Cmd
 80018fe:	2000      	movs	r0, #0
 8001900:	f7ff fcde 	bl	80012c0 <GSM_Manager_ChangeState>
			break;
 8001904:	e000      	b.n	8001908 <GSM_Turn_on_Power+0x14c>
		default:
		break;
 8001906:	46c0      	nop			; (mov r8, r8)
	}
}
 8001908:	46c0      	nop			; (mov r8, r8)
 800190a:	46bd      	mov	sp, r7
 800190c:	bd80      	pop	{r7, pc}
 800190e:	46c0      	nop			; (mov r8, r8)
 8001910:	20000d40 	.word	0x20000d40
 8001914:	0801dd64 	.word	0x0801dd64
 8001918:	0801ddb0 	.word	0x0801ddb0
 800191c:	080218fc 	.word	0x080218fc
 8001920:	50000800 	.word	0x50000800
 8001924:	50000400 	.word	0x50000400
 8001928:	0801dde4 	.word	0x0801dde4
 800192c:	0801de10 	.word	0x0801de10
 8001930:	0801de3c 	.word	0x0801de3c

08001934 <GSM_SendCommand_AT>:
void GSM_SendCommand_AT (GSM_ATCommand_Table_TypDef AT_Cmd)
{
 8001934:	b084      	sub	sp, #16
 8001936:	b5b0      	push	{r4, r5, r7, lr}
 8001938:	af00      	add	r7, sp, #0
 800193a:	2510      	movs	r5, #16
 800193c:	197c      	adds	r4, r7, r5
 800193e:	6020      	str	r0, [r4, #0]
 8001940:	6061      	str	r1, [r4, #4]
 8001942:	60a2      	str	r2, [r4, #8]
 8001944:	60e3      	str	r3, [r4, #12]
	if(AT_Cmd.Timeout_atc_ms == 0 || AT_Cmd.Send_at_Callback == NULL)
 8001946:	002a      	movs	r2, r5
 8001948:	18bb      	adds	r3, r7, r2
 800194a:	695b      	ldr	r3, [r3, #20]
 800194c:	2b00      	cmp	r3, #0
 800194e:	d003      	beq.n	8001958 <GSM_SendCommand_AT+0x24>
 8001950:	18bb      	adds	r3, r7, r2
 8001952:	69db      	ldr	r3, [r3, #28]
 8001954:	2b00      	cmp	r3, #0
 8001956:	d11a      	bne.n	800198e <GSM_SendCommand_AT+0x5a>
	{
		memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 8001958:	2380      	movs	r3, #128	; 0x80
 800195a:	00da      	lsls	r2, r3, #3
 800195c:	4b32      	ldr	r3, [pc, #200]	; (8001a28 <GSM_SendCommand_AT+0xf4>)
 800195e:	2100      	movs	r1, #0
 8001960:	0018      	movs	r0, r3
 8001962:	f01a ff63 	bl	801c82c <memset>
		m_gsm_atc.atc.Recv_Buffer.index = 0;
 8001966:	4b31      	ldr	r3, [pc, #196]	; (8001a2c <GSM_SendCommand_AT+0xf8>)
 8001968:	4a31      	ldr	r2, [pc, #196]	; (8001a30 <GSM_SendCommand_AT+0xfc>)
 800196a:	2100      	movs	r1, #0
 800196c:	5299      	strh	r1, [r3, r2]
		//HAL_UART_Transmit(&huart1, (uint8_t *)AT_Cmd.cmd, strlen(AT_Cmd.cmd), 200);
		GSM_UART_TX((uint8_t *)AT_Cmd.cmd, strlen(AT_Cmd.cmd), 200);
 800196e:	2210      	movs	r2, #16
 8001970:	18bb      	adds	r3, r7, r2
 8001972:	681c      	ldr	r4, [r3, #0]
 8001974:	18bb      	adds	r3, r7, r2
 8001976:	681b      	ldr	r3, [r3, #0]
 8001978:	0018      	movs	r0, r3
 800197a:	f7fe fbc5 	bl	8000108 <strlen>
 800197e:	0003      	movs	r3, r0
 8001980:	b29a      	uxth	r2, r3
 8001982:	482c      	ldr	r0, [pc, #176]	; (8001a34 <GSM_SendCommand_AT+0x100>)
 8001984:	23c8      	movs	r3, #200	; 0xc8
 8001986:	0021      	movs	r1, r4
 8001988:	f001 fff4 	bl	8003974 <HAL_UART_Transmit>
		return;
 800198c:	e046      	b.n	8001a1c <GSM_SendCommand_AT+0xe8>
	}
	if(strlen(AT_Cmd.cmd) < 64)
 800198e:	2410      	movs	r4, #16
 8001990:	193b      	adds	r3, r7, r4
 8001992:	681b      	ldr	r3, [r3, #0]
 8001994:	0018      	movs	r0, r3
 8001996:	f7fe fbb7 	bl	8000108 <strlen>
	{

	}
	m_gsm_atc.atc.cmd = AT_Cmd.cmd;
 800199a:	193b      	adds	r3, r7, r4
 800199c:	681a      	ldr	r2, [r3, #0]
 800199e:	4b23      	ldr	r3, [pc, #140]	; (8001a2c <GSM_SendCommand_AT+0xf8>)
 80019a0:	601a      	str	r2, [r3, #0]
	m_gsm_atc.atc.expect_resp = AT_Cmd.expect_resp;
 80019a2:	193b      	adds	r3, r7, r4
 80019a4:	685a      	ldr	r2, [r3, #4]
 80019a6:	4b21      	ldr	r3, [pc, #132]	; (8001a2c <GSM_SendCommand_AT+0xf8>)
 80019a8:	605a      	str	r2, [r3, #4]
	m_gsm_atc.atc.expected_response_at_the_end = AT_Cmd.expected_response_at_the_end;
 80019aa:	193b      	adds	r3, r7, r4
 80019ac:	689a      	ldr	r2, [r3, #8]
 80019ae:	4b1f      	ldr	r3, [pc, #124]	; (8001a2c <GSM_SendCommand_AT+0xf8>)
 80019b0:	609a      	str	r2, [r3, #8]
	m_gsm_atc.atc.expect_error = AT_Cmd.expect_error;
 80019b2:	193b      	adds	r3, r7, r4
 80019b4:	68da      	ldr	r2, [r3, #12]
 80019b6:	4b1d      	ldr	r3, [pc, #116]	; (8001a2c <GSM_SendCommand_AT+0xf8>)
 80019b8:	60da      	str	r2, [r3, #12]
	m_gsm_atc.atc.expect_error_at_the_end = AT_Cmd.expect_error_at_the_end;
 80019ba:	193b      	adds	r3, r7, r4
 80019bc:	691a      	ldr	r2, [r3, #16]
 80019be:	4b1b      	ldr	r3, [pc, #108]	; (8001a2c <GSM_SendCommand_AT+0xf8>)
 80019c0:	611a      	str	r2, [r3, #16]
	m_gsm_atc.atc.Timeout_atc_ms = AT_Cmd.Timeout_atc_ms;
 80019c2:	193b      	adds	r3, r7, r4
 80019c4:	695a      	ldr	r2, [r3, #20]
 80019c6:	4b19      	ldr	r3, [pc, #100]	; (8001a2c <GSM_SendCommand_AT+0xf8>)
 80019c8:	615a      	str	r2, [r3, #20]
	m_gsm_atc.atc.Last_time_send_atc_ms = sys_get_tick_ms();
 80019ca:	f01a feb9 	bl	801c740 <sys_get_tick_ms>
 80019ce:	0002      	movs	r2, r0
 80019d0:	4b16      	ldr	r3, [pc, #88]	; (8001a2c <GSM_SendCommand_AT+0xf8>)
 80019d2:	619a      	str	r2, [r3, #24]
	m_gsm_atc.atc.Retry_Count_atc = AT_Cmd.Retry_Count_atc;
 80019d4:	193b      	adds	r3, r7, r4
 80019d6:	7e1a      	ldrb	r2, [r3, #24]
 80019d8:	4b14      	ldr	r3, [pc, #80]	; (8001a2c <GSM_SendCommand_AT+0xf8>)
 80019da:	771a      	strb	r2, [r3, #28]
	m_gsm_atc.atc.Send_at_Callback = AT_Cmd.Send_at_Callback;
 80019dc:	193b      	adds	r3, r7, r4
 80019de:	69d9      	ldr	r1, [r3, #28]
 80019e0:	4a12      	ldr	r2, [pc, #72]	; (8001a2c <GSM_SendCommand_AT+0xf8>)
 80019e2:	2384      	movs	r3, #132	; 0x84
 80019e4:	00db      	lsls	r3, r3, #3
 80019e6:	50d1      	str	r1, [r2, r3]

	memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 80019e8:	2380      	movs	r3, #128	; 0x80
 80019ea:	00da      	lsls	r2, r3, #3
 80019ec:	4b0e      	ldr	r3, [pc, #56]	; (8001a28 <GSM_SendCommand_AT+0xf4>)
 80019ee:	2100      	movs	r1, #0
 80019f0:	0018      	movs	r0, r3
 80019f2:	f01a ff1b 	bl	801c82c <memset>
	m_gsm_atc.atc.Recv_Buffer.index = 0;
 80019f6:	4b0d      	ldr	r3, [pc, #52]	; (8001a2c <GSM_SendCommand_AT+0xf8>)
 80019f8:	4a0d      	ldr	r2, [pc, #52]	; (8001a30 <GSM_SendCommand_AT+0xfc>)
 80019fa:	2100      	movs	r1, #0
 80019fc:	5299      	strh	r1, [r3, r2]
	//HAL_UART_Transmit(&huart1, (uint8_t *)AT_Cmd.cmd, strlen(AT_Cmd.cmd), 200);
	GSM_UART_TX((uint8_t *)AT_Cmd.cmd, strlen(AT_Cmd.cmd), 200);
 80019fe:	0022      	movs	r2, r4
 8001a00:	18bb      	adds	r3, r7, r2
 8001a02:	681c      	ldr	r4, [r3, #0]
 8001a04:	18bb      	adds	r3, r7, r2
 8001a06:	681b      	ldr	r3, [r3, #0]
 8001a08:	0018      	movs	r0, r3
 8001a0a:	f7fe fb7d 	bl	8000108 <strlen>
 8001a0e:	0003      	movs	r3, r0
 8001a10:	b29a      	uxth	r2, r3
 8001a12:	4808      	ldr	r0, [pc, #32]	; (8001a34 <GSM_SendCommand_AT+0x100>)
 8001a14:	23c8      	movs	r3, #200	; 0xc8
 8001a16:	0021      	movs	r1, r4
 8001a18:	f001 ffac 	bl	8003974 <HAL_UART_Transmit>

}
 8001a1c:	46bd      	mov	sp, r7
 8001a1e:	bcb0      	pop	{r4, r5, r7}
 8001a20:	bc08      	pop	{r3}
 8001a22:	b004      	add	sp, #16
 8001a24:	4718      	bx	r3
 8001a26:	46c0      	nop			; (mov r8, r8)
 8001a28:	20000332 	.word	0x20000332
 8001a2c:	20000314 	.word	0x20000314
 8001a30:	0000041e 	.word	0x0000041e
 8001a34:	200013c8 	.word	0x200013c8

08001a38 <sio_read>:
uint32_t sio_read(sio_fd_t fd, u8_t *data, u32_t len)
{
 8001a38:	b580      	push	{r7, lr}
 8001a3a:	b084      	sub	sp, #16
 8001a3c:	af00      	add	r7, sp, #0
 8001a3e:	60f8      	str	r0, [r7, #12]
 8001a40:	60b9      	str	r1, [r7, #8]
 8001a42:	607a      	str	r2, [r7, #4]
    return GSM_Hardware_layer_Copy_ppp_Buffer(data, len);
 8001a44:	687a      	ldr	r2, [r7, #4]
 8001a46:	68bb      	ldr	r3, [r7, #8]
 8001a48:	0011      	movs	r1, r2
 8001a4a:	0018      	movs	r0, r3
 8001a4c:	f000 f8f8 	bl	8001c40 <GSM_Hardware_layer_Copy_ppp_Buffer>
 8001a50:	0003      	movs	r3, r0
}
 8001a52:	0018      	movs	r0, r3
 8001a54:	46bd      	mov	sp, r7
 8001a56:	b004      	add	sp, #16
 8001a58:	bd80      	pop	{r7, pc}
	...

08001a5c <GSM_Hardware_pppos_Polling>:
static uint8_t m_ppp_rx_buffer[512];
void GSM_Hardware_pppos_Polling(void)
{
 8001a5c:	b590      	push	{r4, r7, lr}
 8001a5e:	4c26      	ldr	r4, [pc, #152]	; (8001af8 <GSM_Hardware_pppos_Polling+0x9c>)
 8001a60:	44a5      	add	sp, r4
 8001a62:	af00      	add	r7, sp, #0
    uint32_t sio_size;
    sys_check_timeouts();
 8001a64:	f010 f95a 	bl	8011d1c <sys_check_timeouts>
	uint8_t buffer[512] = {0};
 8001a68:	4b24      	ldr	r3, [pc, #144]	; (8001afc <GSM_Hardware_pppos_Polling+0xa0>)
 8001a6a:	2282      	movs	r2, #130	; 0x82
 8001a6c:	0092      	lsls	r2, r2, #2
 8001a6e:	4694      	mov	ip, r2
 8001a70:	44bc      	add	ip, r7
 8001a72:	4463      	add	r3, ip
 8001a74:	2200      	movs	r2, #0
 8001a76:	601a      	str	r2, [r3, #0]
 8001a78:	3304      	adds	r3, #4
 8001a7a:	22fe      	movs	r2, #254	; 0xfe
 8001a7c:	0052      	lsls	r2, r2, #1
 8001a7e:	2100      	movs	r1, #0
 8001a80:	0018      	movs	r0, r3
 8001a82:	f01a fed3 	bl	801c82c <memset>
	uint16_t dataLength = 0;
 8001a86:	4b1e      	ldr	r3, [pc, #120]	; (8001b00 <GSM_Hardware_pppos_Polling+0xa4>)
 8001a88:	2282      	movs	r2, #130	; 0x82
 8001a8a:	0092      	lsls	r2, r2, #2
 8001a8c:	4694      	mov	ip, r2
 8001a8e:	44bc      	add	ip, r7
 8001a90:	4463      	add	r3, ip
 8001a92:	2200      	movs	r2, #0
 8001a94:	801a      	strh	r2, [r3, #0]

	RingBuffer_GetBuffer(buffer, &dataLength, &Rx_Buffer);
 8001a96:	4a1b      	ldr	r2, [pc, #108]	; (8001b04 <GSM_Hardware_pppos_Polling+0xa8>)
 8001a98:	1cb9      	adds	r1, r7, #2
 8001a9a:	1d3b      	adds	r3, r7, #4
 8001a9c:	0018      	movs	r0, r3
 8001a9e:	f000 fc4c 	bl	800233a <RingBuffer_GetBuffer>
	GSM_HwLayer_Fill_Rx_Buffer(buffer, dataLength);
 8001aa2:	4b17      	ldr	r3, [pc, #92]	; (8001b00 <GSM_Hardware_pppos_Polling+0xa4>)
 8001aa4:	2282      	movs	r2, #130	; 0x82
 8001aa6:	0092      	lsls	r2, r2, #2
 8001aa8:	4694      	mov	ip, r2
 8001aaa:	44bc      	add	ip, r7
 8001aac:	4463      	add	r3, ip
 8001aae:	881b      	ldrh	r3, [r3, #0]
 8001ab0:	001a      	movs	r2, r3
 8001ab2:	1d3b      	adds	r3, r7, #4
 8001ab4:	0011      	movs	r1, r2
 8001ab6:	0018      	movs	r0, r3
 8001ab8:	f000 f84c 	bl	8001b54 <GSM_HwLayer_Fill_Rx_Buffer>

    sio_size = sio_read(0, m_ppp_rx_buffer, 512);
 8001abc:	2380      	movs	r3, #128	; 0x80
 8001abe:	009a      	lsls	r2, r3, #2
 8001ac0:	4b11      	ldr	r3, [pc, #68]	; (8001b08 <GSM_Hardware_pppos_Polling+0xac>)
 8001ac2:	0019      	movs	r1, r3
 8001ac4:	2000      	movs	r0, #0
 8001ac6:	f7ff ffb7 	bl	8001a38 <sio_read>
 8001aca:	0003      	movs	r3, r0
 8001acc:	2481      	movs	r4, #129	; 0x81
 8001ace:	00a4      	lsls	r4, r4, #2
 8001ad0:	193a      	adds	r2, r7, r4
 8001ad2:	6013      	str	r3, [r2, #0]
	if(sio_size > 0)
 8001ad4:	193b      	adds	r3, r7, r4
 8001ad6:	681b      	ldr	r3, [r3, #0]
 8001ad8:	2b00      	cmp	r3, #0
 8001ada:	d007      	beq.n	8001aec <GSM_Hardware_pppos_Polling+0x90>
	{
		// Bypass data into ppp stack
		pppos_input(gsm_data_layer_get_ppp_control_block(), m_ppp_rx_buffer, sio_size);
 8001adc:	f7ff f9f2 	bl	8000ec4 <gsm_data_layer_get_ppp_control_block>
 8001ae0:	193b      	adds	r3, r7, r4
 8001ae2:	681a      	ldr	r2, [r3, #0]
 8001ae4:	4b08      	ldr	r3, [pc, #32]	; (8001b08 <GSM_Hardware_pppos_Polling+0xac>)
 8001ae6:	0019      	movs	r1, r3
 8001ae8:	f018 fbb0 	bl	801a24c <pppos_input>
	}

}
 8001aec:	46c0      	nop			; (mov r8, r8)
 8001aee:	46bd      	mov	sp, r7
 8001af0:	2383      	movs	r3, #131	; 0x83
 8001af2:	009b      	lsls	r3, r3, #2
 8001af4:	449d      	add	sp, r3
 8001af6:	bd90      	pop	{r4, r7, pc}
 8001af8:	fffffdf4 	.word	0xfffffdf4
 8001afc:	fffffdfc 	.word	0xfffffdfc
 8001b00:	fffffdfa 	.word	0xfffffdfa
 8001b04:	20001460 	.word	0x20001460
 8001b08:	20000b3c 	.word	0x20000b3c

08001b0c <GSM_HwLayer_Reset_Rx_Buffer>:
void GSM_HwLayer_Reset_Rx_Buffer(void)
{
 8001b0c:	b580      	push	{r7, lr}
 8001b0e:	af00      	add	r7, sp, #0
	memset(&m_gsm_atc.atc.Recv_Buffer.u8Buffer, 0, sizeof(m_gsm_atc.atc.Recv_Buffer.u8Buffer));
 8001b10:	2380      	movs	r3, #128	; 0x80
 8001b12:	00da      	lsls	r2, r3, #3
 8001b14:	4b0a      	ldr	r3, [pc, #40]	; (8001b40 <GSM_HwLayer_Reset_Rx_Buffer+0x34>)
 8001b16:	2100      	movs	r1, #0
 8001b18:	0018      	movs	r0, r3
 8001b1a:	f01a fe87 	bl	801c82c <memset>
	m_gsm_atc.atc.Recv_Buffer.index = 0;
 8001b1e:	4b09      	ldr	r3, [pc, #36]	; (8001b44 <GSM_HwLayer_Reset_Rx_Buffer+0x38>)
 8001b20:	4a09      	ldr	r2, [pc, #36]	; (8001b48 <GSM_HwLayer_Reset_Rx_Buffer+0x3c>)
 8001b22:	2100      	movs	r1, #0
 8001b24:	5299      	strh	r1, [r3, r2]
	memset(&m_gsm_modem_buffer, 0, sizeof(m_gsm_modem_buffer));
 8001b26:	4a09      	ldr	r2, [pc, #36]	; (8001b4c <GSM_HwLayer_Reset_Rx_Buffer+0x40>)
 8001b28:	4b09      	ldr	r3, [pc, #36]	; (8001b50 <GSM_HwLayer_Reset_Rx_Buffer+0x44>)
 8001b2a:	2100      	movs	r1, #0
 8001b2c:	0018      	movs	r0, r3
 8001b2e:	f01a fe7d 	bl	801c82c <memset>
	m_gsm_atc.atc.Retry_Count_atc = 0;
 8001b32:	4b04      	ldr	r3, [pc, #16]	; (8001b44 <GSM_HwLayer_Reset_Rx_Buffer+0x38>)
 8001b34:	2200      	movs	r2, #0
 8001b36:	771a      	strb	r2, [r3, #28]
}
 8001b38:	46c0      	nop			; (mov r8, r8)
 8001b3a:	46bd      	mov	sp, r7
 8001b3c:	bd80      	pop	{r7, pc}
 8001b3e:	46c0      	nop			; (mov r8, r8)
 8001b40:	20000332 	.word	0x20000332
 8001b44:	20000314 	.word	0x20000314
 8001b48:	0000041e 	.word	0x0000041e
 8001b4c:	00000404 	.word	0x00000404
 8001b50:	20000738 	.word	0x20000738

08001b54 <GSM_HwLayer_Fill_Rx_Buffer>:
void GSM_HwLayer_Fill_Rx_Buffer(uint8_t* data, uint32_t length)
{
 8001b54:	b580      	push	{r7, lr}
 8001b56:	b084      	sub	sp, #16
 8001b58:	af00      	add	r7, sp, #0
 8001b5a:	6078      	str	r0, [r7, #4]
 8001b5c:	6039      	str	r1, [r7, #0]
	if(length)
 8001b5e:	683b      	ldr	r3, [r7, #0]
 8001b60:	2b00      	cmp	r3, #0
 8001b62:	d060      	beq.n	8001c26 <GSM_HwLayer_Fill_Rx_Buffer+0xd2>
	{
		// Device do not enter AT mode =>> bypass data into PPP stack
		if(gsm_is_in_ppp_mode())
 8001b64:	f7ff fb94 	bl	8001290 <gsm_is_in_ppp_mode>
 8001b68:	1e03      	subs	r3, r0, #0
 8001b6a:	d028      	beq.n	8001bbe <GSM_HwLayer_Fill_Rx_Buffer+0x6a>
		{
			for(int CountByte = 0; CountByte < length; CountByte ++)
 8001b6c:	2300      	movs	r3, #0
 8001b6e:	60fb      	str	r3, [r7, #12]
 8001b70:	e010      	b.n	8001b94 <GSM_HwLayer_Fill_Rx_Buffer+0x40>
			{
				m_gsm_modem_buffer.u8Buffer[m_gsm_modem_buffer.idx_in++] = data[CountByte];
 8001b72:	68fb      	ldr	r3, [r7, #12]
 8001b74:	687a      	ldr	r2, [r7, #4]
 8001b76:	18d2      	adds	r2, r2, r3
 8001b78:	4b2c      	ldr	r3, [pc, #176]	; (8001c2c <GSM_HwLayer_Fill_Rx_Buffer+0xd8>)
 8001b7a:	881b      	ldrh	r3, [r3, #0]
 8001b7c:	1c59      	adds	r1, r3, #1
 8001b7e:	b288      	uxth	r0, r1
 8001b80:	492a      	ldr	r1, [pc, #168]	; (8001c2c <GSM_HwLayer_Fill_Rx_Buffer+0xd8>)
 8001b82:	8008      	strh	r0, [r1, #0]
 8001b84:	0019      	movs	r1, r3
 8001b86:	7812      	ldrb	r2, [r2, #0]
 8001b88:	4b28      	ldr	r3, [pc, #160]	; (8001c2c <GSM_HwLayer_Fill_Rx_Buffer+0xd8>)
 8001b8a:	185b      	adds	r3, r3, r1
 8001b8c:	711a      	strb	r2, [r3, #4]
			for(int CountByte = 0; CountByte < length; CountByte ++)
 8001b8e:	68fb      	ldr	r3, [r7, #12]
 8001b90:	3301      	adds	r3, #1
 8001b92:	60fb      	str	r3, [r7, #12]
 8001b94:	68fb      	ldr	r3, [r7, #12]
 8001b96:	683a      	ldr	r2, [r7, #0]
 8001b98:	429a      	cmp	r2, r3
 8001b9a:	d8ea      	bhi.n	8001b72 <GSM_HwLayer_Fill_Rx_Buffer+0x1e>
			}
			if(m_gsm_modem_buffer.idx_in >= GSM_PPP_MODEM_BUFFER_SIZE)
 8001b9c:	4b23      	ldr	r3, [pc, #140]	; (8001c2c <GSM_HwLayer_Fill_Rx_Buffer+0xd8>)
 8001b9e:	881a      	ldrh	r2, [r3, #0]
 8001ba0:	2380      	movs	r3, #128	; 0x80
 8001ba2:	00db      	lsls	r3, r3, #3
 8001ba4:	429a      	cmp	r2, r3
 8001ba6:	d302      	bcc.n	8001bae <GSM_HwLayer_Fill_Rx_Buffer+0x5a>
			{
				m_gsm_modem_buffer.idx_in = 0;
 8001ba8:	4b20      	ldr	r3, [pc, #128]	; (8001c2c <GSM_HwLayer_Fill_Rx_Buffer+0xd8>)
 8001baa:	2200      	movs	r2, #0
 8001bac:	801a      	strh	r2, [r3, #0]
			}
			m_gsm_modem_buffer.u8Buffer[m_gsm_modem_buffer.idx_in] = 0;
 8001bae:	4b1f      	ldr	r3, [pc, #124]	; (8001c2c <GSM_HwLayer_Fill_Rx_Buffer+0xd8>)
 8001bb0:	881b      	ldrh	r3, [r3, #0]
 8001bb2:	001a      	movs	r2, r3
 8001bb4:	4b1d      	ldr	r3, [pc, #116]	; (8001c2c <GSM_HwLayer_Fill_Rx_Buffer+0xd8>)
 8001bb6:	189b      	adds	r3, r3, r2
 8001bb8:	2200      	movs	r2, #0
 8001bba:	711a      	strb	r2, [r3, #4]
 8001bbc:	e033      	b.n	8001c26 <GSM_HwLayer_Fill_Rx_Buffer+0xd2>
		}
		else
		{
			for(int CountByte = 0; CountByte < length; CountByte ++)
 8001bbe:	2300      	movs	r3, #0
 8001bc0:	60bb      	str	r3, [r7, #8]
 8001bc2:	e02c      	b.n	8001c1e <GSM_HwLayer_Fill_Rx_Buffer+0xca>
			{
				m_gsm_atc.atc.Recv_Buffer.u8Buffer[m_gsm_atc.atc.Recv_Buffer.index] = data[CountByte];
 8001bc4:	68bb      	ldr	r3, [r7, #8]
 8001bc6:	687a      	ldr	r2, [r7, #4]
 8001bc8:	18d3      	adds	r3, r2, r3
 8001bca:	4a19      	ldr	r2, [pc, #100]	; (8001c30 <GSM_HwLayer_Fill_Rx_Buffer+0xdc>)
 8001bcc:	4919      	ldr	r1, [pc, #100]	; (8001c34 <GSM_HwLayer_Fill_Rx_Buffer+0xe0>)
 8001bce:	5a52      	ldrh	r2, [r2, r1]
 8001bd0:	0011      	movs	r1, r2
 8001bd2:	781a      	ldrb	r2, [r3, #0]
 8001bd4:	4b16      	ldr	r3, [pc, #88]	; (8001c30 <GSM_HwLayer_Fill_Rx_Buffer+0xdc>)
 8001bd6:	185b      	adds	r3, r3, r1
 8001bd8:	779a      	strb	r2, [r3, #30]
				m_gsm_atc.atc.Recv_Buffer.index ++;
 8001bda:	4b15      	ldr	r3, [pc, #84]	; (8001c30 <GSM_HwLayer_Fill_Rx_Buffer+0xdc>)
 8001bdc:	4a15      	ldr	r2, [pc, #84]	; (8001c34 <GSM_HwLayer_Fill_Rx_Buffer+0xe0>)
 8001bde:	5a9b      	ldrh	r3, [r3, r2]
 8001be0:	3301      	adds	r3, #1
 8001be2:	b299      	uxth	r1, r3
 8001be4:	4b12      	ldr	r3, [pc, #72]	; (8001c30 <GSM_HwLayer_Fill_Rx_Buffer+0xdc>)
 8001be6:	4a13      	ldr	r2, [pc, #76]	; (8001c34 <GSM_HwLayer_Fill_Rx_Buffer+0xe0>)
 8001be8:	5299      	strh	r1, [r3, r2]
				if(m_gsm_atc.atc.Recv_Buffer.index >= GSM_ATC_BUFFER_SIZE)
 8001bea:	4b11      	ldr	r3, [pc, #68]	; (8001c30 <GSM_HwLayer_Fill_Rx_Buffer+0xdc>)
 8001bec:	4a11      	ldr	r2, [pc, #68]	; (8001c34 <GSM_HwLayer_Fill_Rx_Buffer+0xe0>)
 8001bee:	5a9a      	ldrh	r2, [r3, r2]
 8001bf0:	2380      	movs	r3, #128	; 0x80
 8001bf2:	00db      	lsls	r3, r3, #3
 8001bf4:	429a      	cmp	r2, r3
 8001bf6:	d30f      	bcc.n	8001c18 <GSM_HwLayer_Fill_Rx_Buffer+0xc4>
				{
					DEBUG_ERROR("GSM ATC RX Buffer out of range!\r\n");
 8001bf8:	f01a fda2 	bl	801c740 <sys_get_tick_ms>
 8001bfc:	0001      	movs	r1, r0
 8001bfe:	4a0e      	ldr	r2, [pc, #56]	; (8001c38 <GSM_HwLayer_Fill_Rx_Buffer+0xe4>)
 8001c00:	4b0e      	ldr	r3, [pc, #56]	; (8001c3c <GSM_HwLayer_Fill_Rx_Buffer+0xe8>)
 8001c02:	0018      	movs	r0, r3
 8001c04:	f000 fae2 	bl	80021cc <app_debug_rtt_raw>
                    m_gsm_atc.atc.Recv_Buffer.index = 0;
 8001c08:	4b09      	ldr	r3, [pc, #36]	; (8001c30 <GSM_HwLayer_Fill_Rx_Buffer+0xdc>)
 8001c0a:	4a0a      	ldr	r2, [pc, #40]	; (8001c34 <GSM_HwLayer_Fill_Rx_Buffer+0xe0>)
 8001c0c:	2100      	movs	r1, #0
 8001c0e:	5299      	strh	r1, [r3, r2]
                    m_gsm_atc.atc.Recv_Buffer.u8Buffer[0] = 0;
 8001c10:	4b07      	ldr	r3, [pc, #28]	; (8001c30 <GSM_HwLayer_Fill_Rx_Buffer+0xdc>)
 8001c12:	2200      	movs	r2, #0
 8001c14:	779a      	strb	r2, [r3, #30]
                    return;
 8001c16:	e006      	b.n	8001c26 <GSM_HwLayer_Fill_Rx_Buffer+0xd2>
			for(int CountByte = 0; CountByte < length; CountByte ++)
 8001c18:	68bb      	ldr	r3, [r7, #8]
 8001c1a:	3301      	adds	r3, #1
 8001c1c:	60bb      	str	r3, [r7, #8]
 8001c1e:	68bb      	ldr	r3, [r7, #8]
 8001c20:	683a      	ldr	r2, [r7, #0]
 8001c22:	429a      	cmp	r2, r3
 8001c24:	d8ce      	bhi.n	8001bc4 <GSM_HwLayer_Fill_Rx_Buffer+0x70>
				}
			}
		}
	}
}
 8001c26:	46bd      	mov	sp, r7
 8001c28:	b004      	add	sp, #16
 8001c2a:	bd80      	pop	{r7, pc}
 8001c2c:	20000738 	.word	0x20000738
 8001c30:	20000314 	.word	0x20000314
 8001c34:	0000041e 	.word	0x0000041e
 8001c38:	0801dd64 	.word	0x0801dd64
 8001c3c:	0801de6c 	.word	0x0801de6c

08001c40 <GSM_Hardware_layer_Copy_ppp_Buffer>:
uint32_t GSM_Hardware_layer_Copy_ppp_Buffer(uint8_t* data, uint32_t length)
{
 8001c40:	b580      	push	{r7, lr}
 8001c42:	b084      	sub	sp, #16
 8001c44:	af00      	add	r7, sp, #0
 8001c46:	6078      	str	r0, [r7, #4]
 8001c48:	6039      	str	r1, [r7, #0]
	int CountByte = 0;
 8001c4a:	2300      	movs	r3, #0
 8001c4c:	60fb      	str	r3, [r7, #12]
	for(CountByte = 0; CountByte < length; CountByte++)
 8001c4e:	2300      	movs	r3, #0
 8001c50:	60fb      	str	r3, [r7, #12]
 8001c52:	e023      	b.n	8001c9c <GSM_Hardware_layer_Copy_ppp_Buffer+0x5c>
	{
		if(m_gsm_modem_buffer.idx_out == m_gsm_modem_buffer.idx_in)
 8001c54:	4b16      	ldr	r3, [pc, #88]	; (8001cb0 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001c56:	885a      	ldrh	r2, [r3, #2]
 8001c58:	4b15      	ldr	r3, [pc, #84]	; (8001cb0 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001c5a:	881b      	ldrh	r3, [r3, #0]
 8001c5c:	429a      	cmp	r2, r3
 8001c5e:	d101      	bne.n	8001c64 <GSM_Hardware_layer_Copy_ppp_Buffer+0x24>
		{
			return CountByte; // Da quet het Buffer Modem
 8001c60:	68fb      	ldr	r3, [r7, #12]
 8001c62:	e020      	b.n	8001ca6 <GSM_Hardware_layer_Copy_ppp_Buffer+0x66>
		}
		data[CountByte] = m_gsm_modem_buffer.u8Buffer[m_gsm_modem_buffer.idx_out];
 8001c64:	4b12      	ldr	r3, [pc, #72]	; (8001cb0 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001c66:	885b      	ldrh	r3, [r3, #2]
 8001c68:	0019      	movs	r1, r3
 8001c6a:	68fb      	ldr	r3, [r7, #12]
 8001c6c:	687a      	ldr	r2, [r7, #4]
 8001c6e:	18d3      	adds	r3, r2, r3
 8001c70:	4a0f      	ldr	r2, [pc, #60]	; (8001cb0 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001c72:	1852      	adds	r2, r2, r1
 8001c74:	7912      	ldrb	r2, [r2, #4]
 8001c76:	701a      	strb	r2, [r3, #0]
		m_gsm_modem_buffer.idx_out ++;
 8001c78:	4b0d      	ldr	r3, [pc, #52]	; (8001cb0 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001c7a:	885b      	ldrh	r3, [r3, #2]
 8001c7c:	3301      	adds	r3, #1
 8001c7e:	b29a      	uxth	r2, r3
 8001c80:	4b0b      	ldr	r3, [pc, #44]	; (8001cb0 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001c82:	805a      	strh	r2, [r3, #2]
		if(m_gsm_modem_buffer.idx_out >= GSM_PPP_MODEM_BUFFER_SIZE)
 8001c84:	4b0a      	ldr	r3, [pc, #40]	; (8001cb0 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001c86:	885a      	ldrh	r2, [r3, #2]
 8001c88:	2380      	movs	r3, #128	; 0x80
 8001c8a:	00db      	lsls	r3, r3, #3
 8001c8c:	429a      	cmp	r2, r3
 8001c8e:	d302      	bcc.n	8001c96 <GSM_Hardware_layer_Copy_ppp_Buffer+0x56>
		{
			m_gsm_modem_buffer.idx_out = 0;
 8001c90:	4b07      	ldr	r3, [pc, #28]	; (8001cb0 <GSM_Hardware_layer_Copy_ppp_Buffer+0x70>)
 8001c92:	2200      	movs	r2, #0
 8001c94:	805a      	strh	r2, [r3, #2]
	for(CountByte = 0; CountByte < length; CountByte++)
 8001c96:	68fb      	ldr	r3, [r7, #12]
 8001c98:	3301      	adds	r3, #1
 8001c9a:	60fb      	str	r3, [r7, #12]
 8001c9c:	68fb      	ldr	r3, [r7, #12]
 8001c9e:	683a      	ldr	r2, [r7, #0]
 8001ca0:	429a      	cmp	r2, r3
 8001ca2:	d8d7      	bhi.n	8001c54 <GSM_Hardware_layer_Copy_ppp_Buffer+0x14>
		}
	}
	return CountByte;
 8001ca4:	68fb      	ldr	r3, [r7, #12]
}
 8001ca6:	0018      	movs	r0, r3
 8001ca8:	46bd      	mov	sp, r7
 8001caa:	b004      	add	sp, #16
 8001cac:	bd80      	pop	{r7, pc}
 8001cae:	46c0      	nop			; (mov r8, r8)
 8001cb0:	20000738 	.word	0x20000738

08001cb4 <GSM_Utilities_Get_IMEI>:
#include "gsm_utilities.h"

void GSM_Utilities_Get_IMEI(uint8_t *recv_Buffer, uint8_t* IMEI_Buffer, uint8_t Max_IMEI_Length)
{
 8001cb4:	b580      	push	{r7, lr}
 8001cb6:	b086      	sub	sp, #24
 8001cb8:	af00      	add	r7, sp, #0
 8001cba:	60f8      	str	r0, [r7, #12]
 8001cbc:	60b9      	str	r1, [r7, #8]
 8001cbe:	1dfb      	adds	r3, r7, #7
 8001cc0:	701a      	strb	r2, [r3, #0]
    int IMEI_Index = 0;
 8001cc2:	2300      	movs	r3, #0
 8001cc4:	617b      	str	r3, [r7, #20]
    for(int CountByte = 0; CountByte < strlen((char*)recv_Buffer); CountByte++)
 8001cc6:	2300      	movs	r3, #0
 8001cc8:	613b      	str	r3, [r7, #16]
 8001cca:	e025      	b.n	8001d18 <GSM_Utilities_Get_IMEI+0x64>
    {
        if((recv_Buffer[CountByte] >= '0') && (recv_Buffer[CountByte] <= '9'))
 8001ccc:	693b      	ldr	r3, [r7, #16]
 8001cce:	68fa      	ldr	r2, [r7, #12]
 8001cd0:	18d3      	adds	r3, r2, r3
 8001cd2:	781b      	ldrb	r3, [r3, #0]
 8001cd4:	2b2f      	cmp	r3, #47	; 0x2f
 8001cd6:	d91c      	bls.n	8001d12 <GSM_Utilities_Get_IMEI+0x5e>
 8001cd8:	693b      	ldr	r3, [r7, #16]
 8001cda:	68fa      	ldr	r2, [r7, #12]
 8001cdc:	18d3      	adds	r3, r2, r3
 8001cde:	781b      	ldrb	r3, [r3, #0]
 8001ce0:	2b39      	cmp	r3, #57	; 0x39
 8001ce2:	d816      	bhi.n	8001d12 <GSM_Utilities_Get_IMEI+0x5e>
        {
            if(IMEI_Index < Max_IMEI_Length)
 8001ce4:	1dfb      	adds	r3, r7, #7
 8001ce6:	781b      	ldrb	r3, [r3, #0]
 8001ce8:	697a      	ldr	r2, [r7, #20]
 8001cea:	429a      	cmp	r2, r3
 8001cec:	da0b      	bge.n	8001d06 <GSM_Utilities_Get_IMEI+0x52>
            {
                IMEI_Buffer[IMEI_Index++] = recv_Buffer[CountByte];
 8001cee:	693b      	ldr	r3, [r7, #16]
 8001cf0:	68fa      	ldr	r2, [r7, #12]
 8001cf2:	18d2      	adds	r2, r2, r3
 8001cf4:	697b      	ldr	r3, [r7, #20]
 8001cf6:	1c59      	adds	r1, r3, #1
 8001cf8:	6179      	str	r1, [r7, #20]
 8001cfa:	0019      	movs	r1, r3
 8001cfc:	68bb      	ldr	r3, [r7, #8]
 8001cfe:	185b      	adds	r3, r3, r1
 8001d00:	7812      	ldrb	r2, [r2, #0]
 8001d02:	701a      	strb	r2, [r3, #0]
 8001d04:	e005      	b.n	8001d12 <GSM_Utilities_Get_IMEI+0x5e>
            }
            else
            {
                IMEI_Buffer[IMEI_Index] = 0;
 8001d06:	697b      	ldr	r3, [r7, #20]
 8001d08:	68ba      	ldr	r2, [r7, #8]
 8001d0a:	18d3      	adds	r3, r2, r3
 8001d0c:	2200      	movs	r2, #0
 8001d0e:	701a      	strb	r2, [r3, #0]
                break;
 8001d10:	e00a      	b.n	8001d28 <GSM_Utilities_Get_IMEI+0x74>
    for(int CountByte = 0; CountByte < strlen((char*)recv_Buffer); CountByte++)
 8001d12:	693b      	ldr	r3, [r7, #16]
 8001d14:	3301      	adds	r3, #1
 8001d16:	613b      	str	r3, [r7, #16]
 8001d18:	68fb      	ldr	r3, [r7, #12]
 8001d1a:	0018      	movs	r0, r3
 8001d1c:	f7fe f9f4 	bl	8000108 <strlen>
 8001d20:	0002      	movs	r2, r0
 8001d22:	693b      	ldr	r3, [r7, #16]
 8001d24:	429a      	cmp	r2, r3
 8001d26:	d8d1      	bhi.n	8001ccc <GSM_Utilities_Get_IMEI+0x18>
            }
        }
    }
    IMEI_Buffer[IMEI_Index] = 0;
 8001d28:	697b      	ldr	r3, [r7, #20]
 8001d2a:	68ba      	ldr	r2, [r7, #8]
 8001d2c:	18d3      	adds	r3, r2, r3
 8001d2e:	2200      	movs	r2, #0
 8001d30:	701a      	strb	r2, [r3, #0]
}
 8001d32:	46c0      	nop			; (mov r8, r8)
 8001d34:	46bd      	mov	sp, r7
 8001d36:	b006      	add	sp, #24
 8001d38:	bd80      	pop	{r7, pc}
	...

08001d3c <gsm_utilities_get_signal_strength_from_buffer>:
bool gsm_utilities_get_signal_strength_from_buffer(uint8_t *buffer, uint16_t *csq)
{
 8001d3c:	b580      	push	{r7, lr}
 8001d3e:	b084      	sub	sp, #16
 8001d40:	af00      	add	r7, sp, #0
 8001d42:	6078      	str	r0, [r7, #4]
 8001d44:	6039      	str	r1, [r7, #0]
    char *tmp_buff = strstr((char *)buffer, "+CSQ:");
 8001d46:	4a0d      	ldr	r2, [pc, #52]	; (8001d7c <gsm_utilities_get_signal_strength_from_buffer+0x40>)
 8001d48:	687b      	ldr	r3, [r7, #4]
 8001d4a:	0011      	movs	r1, r2
 8001d4c:	0018      	movs	r0, r3
 8001d4e:	f01a fe77 	bl	801ca40 <strstr>
 8001d52:	0003      	movs	r3, r0
 8001d54:	60fb      	str	r3, [r7, #12]

    if (tmp_buff == NULL)
 8001d56:	68fb      	ldr	r3, [r7, #12]
 8001d58:	2b00      	cmp	r3, #0
 8001d5a:	d101      	bne.n	8001d60 <gsm_utilities_get_signal_strength_from_buffer+0x24>
    {
        return false;
 8001d5c:	2300      	movs	r3, #0
 8001d5e:	e009      	b.n	8001d74 <gsm_utilities_get_signal_strength_from_buffer+0x38>
    }

    *csq = gsm_utilities_get_number_from_string((uint16_t)6, tmp_buff);
 8001d60:	68fb      	ldr	r3, [r7, #12]
 8001d62:	0019      	movs	r1, r3
 8001d64:	2006      	movs	r0, #6
 8001d66:	f000 f80b 	bl	8001d80 <gsm_utilities_get_number_from_string>
 8001d6a:	0003      	movs	r3, r0
 8001d6c:	001a      	movs	r2, r3
 8001d6e:	683b      	ldr	r3, [r7, #0]
 8001d70:	801a      	strh	r2, [r3, #0]
    return true;
 8001d72:	2301      	movs	r3, #1
}
 8001d74:	0018      	movs	r0, r3
 8001d76:	46bd      	mov	sp, r7
 8001d78:	b004      	add	sp, #16
 8001d7a:	bd80      	pop	{r7, pc}
 8001d7c:	0801dea8 	.word	0x0801dea8

08001d80 <gsm_utilities_get_number_from_string>:
 * 	Ham doc mot so trong chuoi bat dau tu dia chi nao do.
 *	Buffer = abc124mff thi gsm_utilities_get_number_from_string(3,Buffer) = 123
 *
 */
uint16_t gsm_utilities_get_number_from_string(uint16_t begin_index, char *buffer)
{
 8001d80:	b590      	push	{r4, r7, lr}
 8001d82:	b085      	sub	sp, #20
 8001d84:	af00      	add	r7, sp, #0
 8001d86:	0002      	movs	r2, r0
 8001d88:	6039      	str	r1, [r7, #0]
 8001d8a:	1dbb      	adds	r3, r7, #6
 8001d8c:	801a      	strh	r2, [r3, #0]
    // assert(buffer);

	uint16_t value = 0;
 8001d8e:	230e      	movs	r3, #14
 8001d90:	18fb      	adds	r3, r7, r3
 8001d92:	2200      	movs	r2, #0
 8001d94:	801a      	strh	r2, [r3, #0]
    uint16_t tmp = begin_index;
 8001d96:	230c      	movs	r3, #12
 8001d98:	18fb      	adds	r3, r7, r3
 8001d9a:	1dba      	adds	r2, r7, #6
 8001d9c:	8812      	ldrh	r2, [r2, #0]
 8001d9e:	801a      	strh	r2, [r3, #0]
    uint32_t len = strlen(buffer);
 8001da0:	683b      	ldr	r3, [r7, #0]
 8001da2:	0018      	movs	r0, r3
 8001da4:	f7fe f9b0 	bl	8000108 <strlen>
 8001da8:	0003      	movs	r3, r0
 8001daa:	60bb      	str	r3, [r7, #8]
    while (buffer[tmp] && tmp < len)
 8001dac:	e029      	b.n	8001e02 <gsm_utilities_get_number_from_string+0x82>
    {
        if (buffer[tmp] >= '0' && buffer[tmp] <= '9')
 8001dae:	200c      	movs	r0, #12
 8001db0:	183b      	adds	r3, r7, r0
 8001db2:	881b      	ldrh	r3, [r3, #0]
 8001db4:	683a      	ldr	r2, [r7, #0]
 8001db6:	18d3      	adds	r3, r2, r3
 8001db8:	781b      	ldrb	r3, [r3, #0]
 8001dba:	2b2f      	cmp	r3, #47	; 0x2f
 8001dbc:	d92e      	bls.n	8001e1c <gsm_utilities_get_number_from_string+0x9c>
 8001dbe:	183b      	adds	r3, r7, r0
 8001dc0:	881b      	ldrh	r3, [r3, #0]
 8001dc2:	683a      	ldr	r2, [r7, #0]
 8001dc4:	18d3      	adds	r3, r2, r3
 8001dc6:	781b      	ldrb	r3, [r3, #0]
 8001dc8:	2b39      	cmp	r3, #57	; 0x39
 8001dca:	d827      	bhi.n	8001e1c <gsm_utilities_get_number_from_string+0x9c>
        {
            value *= 10;
 8001dcc:	240e      	movs	r4, #14
 8001dce:	193a      	adds	r2, r7, r4
 8001dd0:	193b      	adds	r3, r7, r4
 8001dd2:	881b      	ldrh	r3, [r3, #0]
 8001dd4:	1c19      	adds	r1, r3, #0
 8001dd6:	0089      	lsls	r1, r1, #2
 8001dd8:	18cb      	adds	r3, r1, r3
 8001dda:	18db      	adds	r3, r3, r3
 8001ddc:	8013      	strh	r3, [r2, #0]
            value += buffer[tmp] - 48;
 8001dde:	183b      	adds	r3, r7, r0
 8001de0:	881b      	ldrh	r3, [r3, #0]
 8001de2:	683a      	ldr	r2, [r7, #0]
 8001de4:	18d3      	adds	r3, r2, r3
 8001de6:	781b      	ldrb	r3, [r3, #0]
 8001de8:	b29a      	uxth	r2, r3
 8001dea:	193b      	adds	r3, r7, r4
 8001dec:	881b      	ldrh	r3, [r3, #0]
 8001dee:	18d3      	adds	r3, r2, r3
 8001df0:	b29a      	uxth	r2, r3
 8001df2:	193b      	adds	r3, r7, r4
 8001df4:	3a30      	subs	r2, #48	; 0x30
 8001df6:	801a      	strh	r2, [r3, #0]
        }
        else
        {
            break;
        }
        tmp++;
 8001df8:	183b      	adds	r3, r7, r0
 8001dfa:	881a      	ldrh	r2, [r3, #0]
 8001dfc:	183b      	adds	r3, r7, r0
 8001dfe:	3201      	adds	r2, #1
 8001e00:	801a      	strh	r2, [r3, #0]
    while (buffer[tmp] && tmp < len)
 8001e02:	210c      	movs	r1, #12
 8001e04:	187b      	adds	r3, r7, r1
 8001e06:	881b      	ldrh	r3, [r3, #0]
 8001e08:	683a      	ldr	r2, [r7, #0]
 8001e0a:	18d3      	adds	r3, r2, r3
 8001e0c:	781b      	ldrb	r3, [r3, #0]
 8001e0e:	2b00      	cmp	r3, #0
 8001e10:	d004      	beq.n	8001e1c <gsm_utilities_get_number_from_string+0x9c>
 8001e12:	187b      	adds	r3, r7, r1
 8001e14:	881b      	ldrh	r3, [r3, #0]
 8001e16:	68ba      	ldr	r2, [r7, #8]
 8001e18:	429a      	cmp	r2, r3
 8001e1a:	d8c8      	bhi.n	8001dae <gsm_utilities_get_number_from_string+0x2e>
    }

    return value;
 8001e1c:	230e      	movs	r3, #14
 8001e1e:	18fb      	adds	r3, r7, r3
 8001e20:	881b      	ldrh	r3, [r3, #0]
}
 8001e22:	0018      	movs	r0, r3
 8001e24:	46bd      	mov	sp, r7
 8001e26:	b005      	add	sp, #20
 8001e28:	bd90      	pop	{r4, r7, pc}
	...

08001e2c <DEBUG_PrintResult_ATC>:
void DEBUG_PrintResult_ATC(char* cmd, char* result)
{
 8001e2c:	b5b0      	push	{r4, r5, r7, lr}
 8001e2e:	b094      	sub	sp, #80	; 0x50
 8001e30:	af02      	add	r7, sp, #8
 8001e32:	6078      	str	r0, [r7, #4]
 8001e34:	6039      	str	r1, [r7, #0]
    // In ket qua: "AT cmd: OK/FAIL " trong debug
    char sub_cmd[64] = "";
 8001e36:	2408      	movs	r4, #8
 8001e38:	193b      	adds	r3, r7, r4
 8001e3a:	2200      	movs	r2, #0
 8001e3c:	601a      	str	r2, [r3, #0]
 8001e3e:	3304      	adds	r3, #4
 8001e40:	223c      	movs	r2, #60	; 0x3c
 8001e42:	2100      	movs	r1, #0
 8001e44:	0018      	movs	r0, r3
 8001e46:	f01a fcf1 	bl	801c82c <memset>
    strncpy(sub_cmd, cmd + 0, strlen(cmd) - 2);
 8001e4a:	687b      	ldr	r3, [r7, #4]
 8001e4c:	0018      	movs	r0, r3
 8001e4e:	f7fe f95b 	bl	8000108 <strlen>
 8001e52:	0003      	movs	r3, r0
 8001e54:	1e9a      	subs	r2, r3, #2
 8001e56:	6879      	ldr	r1, [r7, #4]
 8001e58:	0025      	movs	r5, r4
 8001e5a:	193b      	adds	r3, r7, r4
 8001e5c:	0018      	movs	r0, r3
 8001e5e:	f01a fddb 	bl	801ca18 <strncpy>
    DEBUG_INFO("%s : %s\r\n", sub_cmd, result);
 8001e62:	f01a fc6d 	bl	801c740 <sys_get_tick_ms>
 8001e66:	0004      	movs	r4, r0
 8001e68:	1979      	adds	r1, r7, r5
 8001e6a:	4a06      	ldr	r2, [pc, #24]	; (8001e84 <DEBUG_PrintResult_ATC+0x58>)
 8001e6c:	4806      	ldr	r0, [pc, #24]	; (8001e88 <DEBUG_PrintResult_ATC+0x5c>)
 8001e6e:	683b      	ldr	r3, [r7, #0]
 8001e70:	9300      	str	r3, [sp, #0]
 8001e72:	000b      	movs	r3, r1
 8001e74:	0021      	movs	r1, r4
 8001e76:	f000 f9a9 	bl	80021cc <app_debug_rtt_raw>
}
 8001e7a:	46c0      	nop			; (mov r8, r8)
 8001e7c:	46bd      	mov	sp, r7
 8001e7e:	b012      	add	sp, #72	; 0x48
 8001e80:	bdb0      	pop	{r4, r5, r7, pc}
 8001e82:	46c0      	nop			; (mov r8, r8)
 8001e84:	0801deb0 	.word	0x0801deb0
 8001e88:	0801deb4 	.word	0x0801deb4

08001e8c <_DoInit>:
                      _DoInit();                                                                     \
                    }                                                                                \
                  } while (0);                                                                       \
                }

static void _DoInit(void) {
 8001e8c:	b580      	push	{r7, lr}
 8001e8e:	b082      	sub	sp, #8
 8001e90:	af00      	add	r7, sp, #0
  volatile SEGGER_RTT_CB* p;   // Volatile to make sure that compiler cannot change the order of accesses to the control block
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
 8001e92:	4b22      	ldr	r3, [pc, #136]	; (8001f1c <_DoInit+0x90>)
 8001e94:	607b      	str	r3, [r7, #4]
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
 8001e96:	687b      	ldr	r3, [r7, #4]
 8001e98:	2201      	movs	r2, #1
 8001e9a:	611a      	str	r2, [r3, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
 8001e9c:	687b      	ldr	r3, [r7, #4]
 8001e9e:	2201      	movs	r2, #1
 8001ea0:	615a      	str	r2, [r3, #20]
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
 8001ea2:	687b      	ldr	r3, [r7, #4]
 8001ea4:	4a1e      	ldr	r2, [pc, #120]	; (8001f20 <_DoInit+0x94>)
 8001ea6:	619a      	str	r2, [r3, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
 8001ea8:	687b      	ldr	r3, [r7, #4]
 8001eaa:	4a1e      	ldr	r2, [pc, #120]	; (8001f24 <_DoInit+0x98>)
 8001eac:	61da      	str	r2, [r3, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
 8001eae:	687b      	ldr	r3, [r7, #4]
 8001eb0:	2280      	movs	r2, #128	; 0x80
 8001eb2:	0052      	lsls	r2, r2, #1
 8001eb4:	621a      	str	r2, [r3, #32]
  p->aUp[0].RdOff         = 0u;
 8001eb6:	687b      	ldr	r3, [r7, #4]
 8001eb8:	2200      	movs	r2, #0
 8001eba:	629a      	str	r2, [r3, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
 8001ebc:	687b      	ldr	r3, [r7, #4]
 8001ebe:	2200      	movs	r2, #0
 8001ec0:	625a      	str	r2, [r3, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
 8001ec2:	687b      	ldr	r3, [r7, #4]
 8001ec4:	2200      	movs	r2, #0
 8001ec6:	62da      	str	r2, [r3, #44]	; 0x2c
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
 8001ec8:	687b      	ldr	r3, [r7, #4]
 8001eca:	4a15      	ldr	r2, [pc, #84]	; (8001f20 <_DoInit+0x94>)
 8001ecc:	631a      	str	r2, [r3, #48]	; 0x30
  p->aDown[0].pBuffer       = _acDownBuffer;
 8001ece:	687b      	ldr	r3, [r7, #4]
 8001ed0:	4a15      	ldr	r2, [pc, #84]	; (8001f28 <_DoInit+0x9c>)
 8001ed2:	635a      	str	r2, [r3, #52]	; 0x34
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
 8001ed4:	687b      	ldr	r3, [r7, #4]
 8001ed6:	2240      	movs	r2, #64	; 0x40
 8001ed8:	639a      	str	r2, [r3, #56]	; 0x38
  p->aDown[0].RdOff         = 0u;
 8001eda:	687b      	ldr	r3, [r7, #4]
 8001edc:	2200      	movs	r2, #0
 8001ede:	641a      	str	r2, [r3, #64]	; 0x40
  p->aDown[0].WrOff         = 0u;
 8001ee0:	687b      	ldr	r3, [r7, #4]
 8001ee2:	2200      	movs	r2, #0
 8001ee4:	63da      	str	r2, [r3, #60]	; 0x3c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
 8001ee6:	687b      	ldr	r3, [r7, #4]
 8001ee8:	2200      	movs	r2, #0
 8001eea:	645a      	str	r2, [r3, #68]	; 0x44
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  STRCPY((char*)&p->acID[7], "RTT");
 8001eec:	687b      	ldr	r3, [r7, #4]
 8001eee:	1dda      	adds	r2, r3, #7
 8001ef0:	4b0e      	ldr	r3, [pc, #56]	; (8001f2c <_DoInit+0xa0>)
 8001ef2:	0010      	movs	r0, r2
 8001ef4:	0019      	movs	r1, r3
 8001ef6:	2304      	movs	r3, #4
 8001ef8:	001a      	movs	r2, r3
 8001efa:	f01a fc7b 	bl	801c7f4 <memcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  STRCPY((char*)&p->acID[0], "SEGGER");
 8001efe:	687a      	ldr	r2, [r7, #4]
 8001f00:	4b0b      	ldr	r3, [pc, #44]	; (8001f30 <_DoInit+0xa4>)
 8001f02:	0010      	movs	r0, r2
 8001f04:	0019      	movs	r1, r3
 8001f06:	2307      	movs	r3, #7
 8001f08:	001a      	movs	r2, r3
 8001f0a:	f01a fc73 	bl	801c7f4 <memcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  p->acID[6] = ' ';
 8001f0e:	687b      	ldr	r3, [r7, #4]
 8001f10:	2220      	movs	r2, #32
 8001f12:	719a      	strb	r2, [r3, #6]
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
}
 8001f14:	46c0      	nop			; (mov r8, r8)
 8001f16:	46bd      	mov	sp, r7
 8001f18:	b002      	add	sp, #8
 8001f1a:	bd80      	pop	{r7, pc}
 8001f1c:	20001478 	.word	0x20001478
 8001f20:	0801ded8 	.word	0x0801ded8
 8001f24:	20000d44 	.word	0x20000d44
 8001f28:	20000e44 	.word	0x20000e44
 8001f2c:	0801dee4 	.word	0x0801dee4
 8001f30:	0801dee8 	.word	0x0801dee8

08001f34 <_WriteBlocking>:
*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
*
*  Return value
*    >= 0 - Number of bytes written into buffer.
*/
static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
 8001f34:	b580      	push	{r7, lr}
 8001f36:	b08a      	sub	sp, #40	; 0x28
 8001f38:	af00      	add	r7, sp, #0
 8001f3a:	60f8      	str	r0, [r7, #12]
 8001f3c:	60b9      	str	r1, [r7, #8]
 8001f3e:	607a      	str	r2, [r7, #4]
  unsigned WrOff;
  volatile char* pDst;
  //
  // Write data to buffer and handle wrap-around if necessary
  //
  NumBytesWritten = 0u;
 8001f40:	2300      	movs	r3, #0
 8001f42:	623b      	str	r3, [r7, #32]
  WrOff = pRing->WrOff;
 8001f44:	68fb      	ldr	r3, [r7, #12]
 8001f46:	68db      	ldr	r3, [r3, #12]
 8001f48:	61fb      	str	r3, [r7, #28]
  do {
    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
 8001f4a:	68fb      	ldr	r3, [r7, #12]
 8001f4c:	691b      	ldr	r3, [r3, #16]
 8001f4e:	61bb      	str	r3, [r7, #24]
    if (RdOff > WrOff) {
 8001f50:	69ba      	ldr	r2, [r7, #24]
 8001f52:	69fb      	ldr	r3, [r7, #28]
 8001f54:	429a      	cmp	r2, r3
 8001f56:	d905      	bls.n	8001f64 <_WriteBlocking+0x30>
      NumBytesToWrite = RdOff - WrOff - 1u;
 8001f58:	69ba      	ldr	r2, [r7, #24]
 8001f5a:	69fb      	ldr	r3, [r7, #28]
 8001f5c:	1ad3      	subs	r3, r2, r3
 8001f5e:	3b01      	subs	r3, #1
 8001f60:	627b      	str	r3, [r7, #36]	; 0x24
 8001f62:	e007      	b.n	8001f74 <_WriteBlocking+0x40>
    } else {
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
 8001f64:	68fb      	ldr	r3, [r7, #12]
 8001f66:	689a      	ldr	r2, [r3, #8]
 8001f68:	69b9      	ldr	r1, [r7, #24]
 8001f6a:	69fb      	ldr	r3, [r7, #28]
 8001f6c:	1acb      	subs	r3, r1, r3
 8001f6e:	18d3      	adds	r3, r2, r3
 8001f70:	3b01      	subs	r3, #1
 8001f72:	627b      	str	r3, [r7, #36]	; 0x24
    }
    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
 8001f74:	68fb      	ldr	r3, [r7, #12]
 8001f76:	689a      	ldr	r2, [r3, #8]
 8001f78:	69fb      	ldr	r3, [r7, #28]
 8001f7a:	1ad2      	subs	r2, r2, r3
 8001f7c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001f7e:	4293      	cmp	r3, r2
 8001f80:	d900      	bls.n	8001f84 <_WriteBlocking+0x50>
 8001f82:	0013      	movs	r3, r2
 8001f84:	627b      	str	r3, [r7, #36]	; 0x24
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
 8001f86:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8001f88:	687b      	ldr	r3, [r7, #4]
 8001f8a:	4293      	cmp	r3, r2
 8001f8c:	d900      	bls.n	8001f90 <_WriteBlocking+0x5c>
 8001f8e:	0013      	movs	r3, r2
 8001f90:	627b      	str	r3, [r7, #36]	; 0x24
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
 8001f92:	68fb      	ldr	r3, [r7, #12]
 8001f94:	685a      	ldr	r2, [r3, #4]
 8001f96:	69fb      	ldr	r3, [r7, #28]
 8001f98:	18d3      	adds	r3, r2, r3
 8001f9a:	617b      	str	r3, [r7, #20]
    WrOff           += NumBytesToWrite;
    while (NumBytesToWrite--) {
      *pDst++ = *pBuffer++;
    };
#else
    SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
 8001f9c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8001f9e:	68b9      	ldr	r1, [r7, #8]
 8001fa0:	697b      	ldr	r3, [r7, #20]
 8001fa2:	0018      	movs	r0, r3
 8001fa4:	f01a fc26 	bl	801c7f4 <memcpy>
    NumBytesWritten += NumBytesToWrite;
 8001fa8:	6a3a      	ldr	r2, [r7, #32]
 8001faa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001fac:	18d3      	adds	r3, r2, r3
 8001fae:	623b      	str	r3, [r7, #32]
    pBuffer         += NumBytesToWrite;
 8001fb0:	68ba      	ldr	r2, [r7, #8]
 8001fb2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001fb4:	18d3      	adds	r3, r2, r3
 8001fb6:	60bb      	str	r3, [r7, #8]
    NumBytes        -= NumBytesToWrite;
 8001fb8:	687a      	ldr	r2, [r7, #4]
 8001fba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001fbc:	1ad3      	subs	r3, r2, r3
 8001fbe:	607b      	str	r3, [r7, #4]
    WrOff           += NumBytesToWrite;
 8001fc0:	69fa      	ldr	r2, [r7, #28]
 8001fc2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001fc4:	18d3      	adds	r3, r2, r3
 8001fc6:	61fb      	str	r3, [r7, #28]
#endif
    if (WrOff == pRing->SizeOfBuffer) {
 8001fc8:	68fb      	ldr	r3, [r7, #12]
 8001fca:	689b      	ldr	r3, [r3, #8]
 8001fcc:	69fa      	ldr	r2, [r7, #28]
 8001fce:	429a      	cmp	r2, r3
 8001fd0:	d101      	bne.n	8001fd6 <_WriteBlocking+0xa2>
      WrOff = 0u;
 8001fd2:	2300      	movs	r3, #0
 8001fd4:	61fb      	str	r3, [r7, #28]
    }
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = WrOff;
 8001fd6:	68fb      	ldr	r3, [r7, #12]
 8001fd8:	69fa      	ldr	r2, [r7, #28]
 8001fda:	60da      	str	r2, [r3, #12]
  } while (NumBytes);
 8001fdc:	687b      	ldr	r3, [r7, #4]
 8001fde:	2b00      	cmp	r3, #0
 8001fe0:	d1b3      	bne.n	8001f4a <_WriteBlocking+0x16>
  return NumBytesWritten;
 8001fe2:	6a3b      	ldr	r3, [r7, #32]
}
 8001fe4:	0018      	movs	r0, r3
 8001fe6:	46bd      	mov	sp, r7
 8001fe8:	b00a      	add	sp, #40	; 0x28
 8001fea:	bd80      	pop	{r7, pc}

08001fec <_WriteNoCheck>:
*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
*
*  Notes
*    (1) If there might not be enough space in the "Up"-buffer, call _WriteBlocking
*/
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
 8001fec:	b580      	push	{r7, lr}
 8001fee:	b088      	sub	sp, #32
 8001ff0:	af00      	add	r7, sp, #0
 8001ff2:	60f8      	str	r0, [r7, #12]
 8001ff4:	60b9      	str	r1, [r7, #8]
 8001ff6:	607a      	str	r2, [r7, #4]
  unsigned NumBytesAtOnce;
  unsigned WrOff;
  unsigned Rem;
  volatile char* pDst;

  WrOff = pRing->WrOff;
 8001ff8:	68fb      	ldr	r3, [r7, #12]
 8001ffa:	68db      	ldr	r3, [r3, #12]
 8001ffc:	61fb      	str	r3, [r7, #28]
  Rem = pRing->SizeOfBuffer - WrOff;
 8001ffe:	68fb      	ldr	r3, [r7, #12]
 8002000:	689a      	ldr	r2, [r3, #8]
 8002002:	69fb      	ldr	r3, [r7, #28]
 8002004:	1ad3      	subs	r3, r2, r3
 8002006:	61bb      	str	r3, [r7, #24]
  if (Rem > NumBytes) {
 8002008:	69ba      	ldr	r2, [r7, #24]
 800200a:	687b      	ldr	r3, [r7, #4]
 800200c:	429a      	cmp	r2, r3
 800200e:	d910      	bls.n	8002032 <_WriteNoCheck+0x46>
    //
    // All data fits before wrap around
    //
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
 8002010:	68fb      	ldr	r3, [r7, #12]
 8002012:	685a      	ldr	r2, [r3, #4]
 8002014:	69fb      	ldr	r3, [r7, #28]
 8002016:	18d3      	adds	r3, r2, r3
 8002018:	613b      	str	r3, [r7, #16]
      *pDst++ = *pData++;
    };
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = WrOff;
#else
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
 800201a:	687a      	ldr	r2, [r7, #4]
 800201c:	68b9      	ldr	r1, [r7, #8]
 800201e:	693b      	ldr	r3, [r7, #16]
 8002020:	0018      	movs	r0, r3
 8002022:	f01a fbe7 	bl	801c7f4 <memcpy>
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = WrOff + NumBytes;
 8002026:	69fa      	ldr	r2, [r7, #28]
 8002028:	687b      	ldr	r3, [r7, #4]
 800202a:	18d2      	adds	r2, r2, r3
 800202c:	68fb      	ldr	r3, [r7, #12]
 800202e:	60da      	str	r2, [r3, #12]
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = NumBytesAtOnce;
#endif
  }
}
 8002030:	e01e      	b.n	8002070 <_WriteNoCheck+0x84>
    NumBytesAtOnce = Rem;
 8002032:	69bb      	ldr	r3, [r7, #24]
 8002034:	617b      	str	r3, [r7, #20]
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
 8002036:	68fb      	ldr	r3, [r7, #12]
 8002038:	685a      	ldr	r2, [r3, #4]
 800203a:	69fb      	ldr	r3, [r7, #28]
 800203c:	18d3      	adds	r3, r2, r3
 800203e:	613b      	str	r3, [r7, #16]
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
 8002040:	697a      	ldr	r2, [r7, #20]
 8002042:	68b9      	ldr	r1, [r7, #8]
 8002044:	693b      	ldr	r3, [r7, #16]
 8002046:	0018      	movs	r0, r3
 8002048:	f01a fbd4 	bl	801c7f4 <memcpy>
    NumBytesAtOnce = NumBytes - Rem;
 800204c:	687a      	ldr	r2, [r7, #4]
 800204e:	69bb      	ldr	r3, [r7, #24]
 8002050:	1ad3      	subs	r3, r2, r3
 8002052:	617b      	str	r3, [r7, #20]
    pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
 8002054:	68fb      	ldr	r3, [r7, #12]
 8002056:	685b      	ldr	r3, [r3, #4]
 8002058:	613b      	str	r3, [r7, #16]
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
 800205a:	68ba      	ldr	r2, [r7, #8]
 800205c:	69bb      	ldr	r3, [r7, #24]
 800205e:	18d1      	adds	r1, r2, r3
 8002060:	697a      	ldr	r2, [r7, #20]
 8002062:	693b      	ldr	r3, [r7, #16]
 8002064:	0018      	movs	r0, r3
 8002066:	f01a fbc5 	bl	801c7f4 <memcpy>
    pRing->WrOff = NumBytesAtOnce;
 800206a:	68fb      	ldr	r3, [r7, #12]
 800206c:	697a      	ldr	r2, [r7, #20]
 800206e:	60da      	str	r2, [r3, #12]
}
 8002070:	46c0      	nop			; (mov r8, r8)
 8002072:	46bd      	mov	sp, r7
 8002074:	b008      	add	sp, #32
 8002076:	bd80      	pop	{r7, pc}

08002078 <_GetAvailWriteSpace>:
*    pRing        Ring buffer to check.
*
*  Return value
*    Number of bytes that are free in the buffer.
*/
static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
 8002078:	b580      	push	{r7, lr}
 800207a:	b086      	sub	sp, #24
 800207c:	af00      	add	r7, sp, #0
 800207e:	6078      	str	r0, [r7, #4]
  unsigned r;
  //
  // Avoid warnings regarding volatile access order.  It's not a problem
  // in this case, but dampen compiler enthusiasm.
  //
  RdOff = pRing->RdOff;
 8002080:	687b      	ldr	r3, [r7, #4]
 8002082:	691b      	ldr	r3, [r3, #16]
 8002084:	613b      	str	r3, [r7, #16]
  WrOff = pRing->WrOff;
 8002086:	687b      	ldr	r3, [r7, #4]
 8002088:	68db      	ldr	r3, [r3, #12]
 800208a:	60fb      	str	r3, [r7, #12]
  if (RdOff <= WrOff) {
 800208c:	693a      	ldr	r2, [r7, #16]
 800208e:	68fb      	ldr	r3, [r7, #12]
 8002090:	429a      	cmp	r2, r3
 8002092:	d808      	bhi.n	80020a6 <_GetAvailWriteSpace+0x2e>
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
 8002094:	687b      	ldr	r3, [r7, #4]
 8002096:	689a      	ldr	r2, [r3, #8]
 8002098:	68fb      	ldr	r3, [r7, #12]
 800209a:	1ad2      	subs	r2, r2, r3
 800209c:	693b      	ldr	r3, [r7, #16]
 800209e:	18d3      	adds	r3, r2, r3
 80020a0:	3b01      	subs	r3, #1
 80020a2:	617b      	str	r3, [r7, #20]
 80020a4:	e004      	b.n	80020b0 <_GetAvailWriteSpace+0x38>
  } else {
    r = RdOff - WrOff - 1u;
 80020a6:	693a      	ldr	r2, [r7, #16]
 80020a8:	68fb      	ldr	r3, [r7, #12]
 80020aa:	1ad3      	subs	r3, r2, r3
 80020ac:	3b01      	subs	r3, #1
 80020ae:	617b      	str	r3, [r7, #20]
  }
  return r;
 80020b0:	697b      	ldr	r3, [r7, #20]
}
 80020b2:	0018      	movs	r0, r3
 80020b4:	46bd      	mov	sp, r7
 80020b6:	b006      	add	sp, #24
 80020b8:	bd80      	pop	{r7, pc}
	...

080020bc <SEGGER_RTT_WriteNoLock>:
*    (1) Data is stored according to buffer flags.
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
 80020bc:	b580      	push	{r7, lr}
 80020be:	b088      	sub	sp, #32
 80020c0:	af00      	add	r7, sp, #0
 80020c2:	60f8      	str	r0, [r7, #12]
 80020c4:	60b9      	str	r1, [r7, #8]
 80020c6:	607a      	str	r2, [r7, #4]
  const char*           pData;
  SEGGER_RTT_BUFFER_UP* pRing;
  //
  // Get "to-host" ring buffer.
  //
  pData = (const char *)pBuffer;
 80020c8:	68bb      	ldr	r3, [r7, #8]
 80020ca:	61bb      	str	r3, [r7, #24]
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
 80020cc:	68fb      	ldr	r3, [r7, #12]
 80020ce:	1c5a      	adds	r2, r3, #1
 80020d0:	0013      	movs	r3, r2
 80020d2:	005b      	lsls	r3, r3, #1
 80020d4:	189b      	adds	r3, r3, r2
 80020d6:	00db      	lsls	r3, r3, #3
 80020d8:	4a23      	ldr	r2, [pc, #140]	; (8002168 <SEGGER_RTT_WriteNoLock+0xac>)
 80020da:	189b      	adds	r3, r3, r2
 80020dc:	617b      	str	r3, [r7, #20]
  //
  // How we output depends upon the mode...
  //
  switch (pRing->Flags) {
 80020de:	697b      	ldr	r3, [r7, #20]
 80020e0:	695b      	ldr	r3, [r3, #20]
 80020e2:	2b02      	cmp	r3, #2
 80020e4:	d02e      	beq.n	8002144 <SEGGER_RTT_WriteNoLock+0x88>
 80020e6:	d836      	bhi.n	8002156 <SEGGER_RTT_WriteNoLock+0x9a>
 80020e8:	2b00      	cmp	r3, #0
 80020ea:	d002      	beq.n	80020f2 <SEGGER_RTT_WriteNoLock+0x36>
 80020ec:	2b01      	cmp	r3, #1
 80020ee:	d016      	beq.n	800211e <SEGGER_RTT_WriteNoLock+0x62>
 80020f0:	e031      	b.n	8002156 <SEGGER_RTT_WriteNoLock+0x9a>
  case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
    //
    // If we are in skip mode and there is no space for the whole
    // of this output, don't bother.
    //
    Avail = _GetAvailWriteSpace(pRing);
 80020f2:	697b      	ldr	r3, [r7, #20]
 80020f4:	0018      	movs	r0, r3
 80020f6:	f7ff ffbf 	bl	8002078 <_GetAvailWriteSpace>
 80020fa:	0003      	movs	r3, r0
 80020fc:	613b      	str	r3, [r7, #16]
    if (Avail < NumBytes) {
 80020fe:	693a      	ldr	r2, [r7, #16]
 8002100:	687b      	ldr	r3, [r7, #4]
 8002102:	429a      	cmp	r2, r3
 8002104:	d202      	bcs.n	800210c <SEGGER_RTT_WriteNoLock+0x50>
      Status = 0u;
 8002106:	2300      	movs	r3, #0
 8002108:	61fb      	str	r3, [r7, #28]
    } else {
      Status = NumBytes;
      _WriteNoCheck(pRing, pData, NumBytes);
    }
    break;
 800210a:	e027      	b.n	800215c <SEGGER_RTT_WriteNoLock+0xa0>
      Status = NumBytes;
 800210c:	687b      	ldr	r3, [r7, #4]
 800210e:	61fb      	str	r3, [r7, #28]
      _WriteNoCheck(pRing, pData, NumBytes);
 8002110:	687a      	ldr	r2, [r7, #4]
 8002112:	69b9      	ldr	r1, [r7, #24]
 8002114:	697b      	ldr	r3, [r7, #20]
 8002116:	0018      	movs	r0, r3
 8002118:	f7ff ff68 	bl	8001fec <_WriteNoCheck>
    break;
 800211c:	e01e      	b.n	800215c <SEGGER_RTT_WriteNoLock+0xa0>
  case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
    //
    // If we are in trim mode, trim to what we can output without blocking.
    //
    Avail = _GetAvailWriteSpace(pRing);
 800211e:	697b      	ldr	r3, [r7, #20]
 8002120:	0018      	movs	r0, r3
 8002122:	f7ff ffa9 	bl	8002078 <_GetAvailWriteSpace>
 8002126:	0003      	movs	r3, r0
 8002128:	613b      	str	r3, [r7, #16]
    Status = Avail < NumBytes ? Avail : NumBytes;
 800212a:	693a      	ldr	r2, [r7, #16]
 800212c:	687b      	ldr	r3, [r7, #4]
 800212e:	4293      	cmp	r3, r2
 8002130:	d900      	bls.n	8002134 <SEGGER_RTT_WriteNoLock+0x78>
 8002132:	0013      	movs	r3, r2
 8002134:	61fb      	str	r3, [r7, #28]
    _WriteNoCheck(pRing, pData, Status);
 8002136:	69fa      	ldr	r2, [r7, #28]
 8002138:	69b9      	ldr	r1, [r7, #24]
 800213a:	697b      	ldr	r3, [r7, #20]
 800213c:	0018      	movs	r0, r3
 800213e:	f7ff ff55 	bl	8001fec <_WriteNoCheck>
    break;
 8002142:	e00b      	b.n	800215c <SEGGER_RTT_WriteNoLock+0xa0>
  case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
    //
    // If we are in blocking mode, output everything.
    //
    Status = _WriteBlocking(pRing, pData, NumBytes);
 8002144:	687a      	ldr	r2, [r7, #4]
 8002146:	69b9      	ldr	r1, [r7, #24]
 8002148:	697b      	ldr	r3, [r7, #20]
 800214a:	0018      	movs	r0, r3
 800214c:	f7ff fef2 	bl	8001f34 <_WriteBlocking>
 8002150:	0003      	movs	r3, r0
 8002152:	61fb      	str	r3, [r7, #28]
    break;
 8002154:	e002      	b.n	800215c <SEGGER_RTT_WriteNoLock+0xa0>
  default:
    Status = 0u;
 8002156:	2300      	movs	r3, #0
 8002158:	61fb      	str	r3, [r7, #28]
    break;
 800215a:	46c0      	nop			; (mov r8, r8)
  }
  //
  // Finish up.
  //
  return Status;
 800215c:	69fb      	ldr	r3, [r7, #28]
}
 800215e:	0018      	movs	r0, r3
 8002160:	46bd      	mov	sp, r7
 8002162:	b008      	add	sp, #32
 8002164:	bd80      	pop	{r7, pc}
 8002166:	46c0      	nop			; (mov r8, r8)
 8002168:	20001478 	.word	0x20001478

0800216c <SEGGER_RTT_Write>:
*    Number of bytes which have been stored in the "Up"-buffer.
*
*  Notes
*    (1) Data is stored according to buffer flags.
*/
unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
 800216c:	b580      	push	{r7, lr}
 800216e:	b088      	sub	sp, #32
 8002170:	af00      	add	r7, sp, #0
 8002172:	60f8      	str	r0, [r7, #12]
 8002174:	60b9      	str	r1, [r7, #8]
 8002176:	607a      	str	r2, [r7, #4]
  unsigned Status;

  INIT();
 8002178:	4b0f      	ldr	r3, [pc, #60]	; (80021b8 <SEGGER_RTT_Write+0x4c>)
 800217a:	61fb      	str	r3, [r7, #28]
 800217c:	69fb      	ldr	r3, [r7, #28]
 800217e:	781b      	ldrb	r3, [r3, #0]
 8002180:	b2db      	uxtb	r3, r3
 8002182:	2b00      	cmp	r3, #0
 8002184:	d101      	bne.n	800218a <SEGGER_RTT_Write+0x1e>
 8002186:	f7ff fe81 	bl	8001e8c <_DoInit>
  SEGGER_RTT_LOCK();
 800218a:	f3ef 8310 	mrs	r3, PRIMASK
 800218e:	2101      	movs	r1, #1
 8002190:	f381 8810 	msr	PRIMASK, r1
 8002194:	61bb      	str	r3, [r7, #24]
  Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);  // Call the non-locking write function
 8002196:	687a      	ldr	r2, [r7, #4]
 8002198:	68b9      	ldr	r1, [r7, #8]
 800219a:	68fb      	ldr	r3, [r7, #12]
 800219c:	0018      	movs	r0, r3
 800219e:	f7ff ff8d 	bl	80020bc <SEGGER_RTT_WriteNoLock>
 80021a2:	0003      	movs	r3, r0
 80021a4:	617b      	str	r3, [r7, #20]
  SEGGER_RTT_UNLOCK();
 80021a6:	69bb      	ldr	r3, [r7, #24]
 80021a8:	f383 8810 	msr	PRIMASK, r3
  return Status;
 80021ac:	697b      	ldr	r3, [r7, #20]
}
 80021ae:	0018      	movs	r0, r3
 80021b0:	46bd      	mov	sp, r7
 80021b2:	b008      	add	sp, #32
 80021b4:	bd80      	pop	{r7, pc}
 80021b6:	46c0      	nop			; (mov r8, r8)
 80021b8:	20001478 	.word	0x20001478

080021bc <SEGGER_RTT_Init>:
*  Function description
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
 80021bc:	b580      	push	{r7, lr}
 80021be:	af00      	add	r7, sp, #0
  _DoInit();
 80021c0:	f7ff fe64 	bl	8001e8c <_DoInit>
}
 80021c4:	46c0      	nop			; (mov r8, r8)
 80021c6:	46bd      	mov	sp, r7
 80021c8:	bd80      	pop	{r7, pc}
	...

080021cc <app_debug_rtt_raw>:
    
    return n;
}

int32_t app_debug_rtt_raw(const char *fmt,...)
{
 80021cc:	b40f      	push	{r0, r1, r2, r3}
 80021ce:	b580      	push	{r7, lr}
 80021d0:	b084      	sub	sp, #16
 80021d2:	af00      	add	r7, sp, #0
    int32_t     n;

    char *p = &m_debug_buffer[0];
 80021d4:	4b15      	ldr	r3, [pc, #84]	; (800222c <app_debug_rtt_raw+0x60>)
 80021d6:	60fb      	str	r3, [r7, #12]
    int32_t size = SEGGER_RTT_PRINTF_BUFFER_SIZE;
 80021d8:	2380      	movs	r3, #128	; 0x80
 80021da:	60bb      	str	r3, [r7, #8]
    va_list args;

    va_start (args, fmt);
 80021dc:	231c      	movs	r3, #28
 80021de:	18fb      	adds	r3, r7, r3
 80021e0:	603b      	str	r3, [r7, #0]
    n = vsnprintf(p, size, fmt, args);
 80021e2:	68b9      	ldr	r1, [r7, #8]
 80021e4:	683b      	ldr	r3, [r7, #0]
 80021e6:	69ba      	ldr	r2, [r7, #24]
 80021e8:	68f8      	ldr	r0, [r7, #12]
 80021ea:	f01a fd05 	bl	801cbf8 <vsniprintf>
 80021ee:	0003      	movs	r3, r0
 80021f0:	607b      	str	r3, [r7, #4]
    if (n > (int)size) 
 80021f2:	687a      	ldr	r2, [r7, #4]
 80021f4:	68bb      	ldr	r3, [r7, #8]
 80021f6:	429a      	cmp	r2, r3
 80021f8:	dd06      	ble.n	8002208 <app_debug_rtt_raw+0x3c>
    {
        SEGGER_RTT_Write(0, m_debug_buffer, size);
 80021fa:	68ba      	ldr	r2, [r7, #8]
 80021fc:	4b0b      	ldr	r3, [pc, #44]	; (800222c <app_debug_rtt_raw+0x60>)
 80021fe:	0019      	movs	r1, r3
 8002200:	2000      	movs	r0, #0
 8002202:	f7ff ffb3 	bl	800216c <SEGGER_RTT_Write>
 8002206:	e008      	b.n	800221a <app_debug_rtt_raw+0x4e>
    } 
    else if (n > 0) 
 8002208:	687b      	ldr	r3, [r7, #4]
 800220a:	2b00      	cmp	r3, #0
 800220c:	dd05      	ble.n	800221a <app_debug_rtt_raw+0x4e>
    {
        SEGGER_RTT_Write(0, m_debug_buffer, n);
 800220e:	687a      	ldr	r2, [r7, #4]
 8002210:	4b06      	ldr	r3, [pc, #24]	; (800222c <app_debug_rtt_raw+0x60>)
 8002212:	0019      	movs	r1, r3
 8002214:	2000      	movs	r0, #0
 8002216:	f7ff ffa9 	bl	800216c <SEGGER_RTT_Write>
    }
    va_end(args);
    
    return n;
 800221a:	687b      	ldr	r3, [r7, #4]
}
 800221c:	0018      	movs	r0, r3
 800221e:	46bd      	mov	sp, r7
 8002220:	b004      	add	sp, #16
 8002222:	bc80      	pop	{r7}
 8002224:	bc08      	pop	{r3}
 8002226:	b004      	add	sp, #16
 8002228:	4718      	bx	r3
 800222a:	46c0      	nop			; (mov r8, r8)
 800222c:	20000e84 	.word	0x20000e84

08002230 <RingBuffer_Init>:
#include "ringbuffer.h"


void RingBuffer_Init(RingBuffer_Types* ringbuffer, int BufferSize)
{
 8002230:	b580      	push	{r7, lr}
 8002232:	b082      	sub	sp, #8
 8002234:	af00      	add	r7, sp, #0
 8002236:	6078      	str	r0, [r7, #4]
 8002238:	6039      	str	r1, [r7, #0]
    ringbuffer->BufferSize = BufferSize;
 800223a:	687b      	ldr	r3, [r7, #4]
 800223c:	683a      	ldr	r2, [r7, #0]
 800223e:	601a      	str	r2, [r3, #0]
    ringbuffer->Head = 0;
 8002240:	687b      	ldr	r3, [r7, #4]
 8002242:	2200      	movs	r2, #0
 8002244:	605a      	str	r2, [r3, #4]
    ringbuffer->Tail = 0;
 8002246:	687b      	ldr	r3, [r7, #4]
 8002248:	2200      	movs	r2, #0
 800224a:	609a      	str	r2, [r3, #8]
    ringbuffer->u8Buffer = (uint8_t*)malloc(BufferSize*sizeof(uint8_t));
 800224c:	683b      	ldr	r3, [r7, #0]
 800224e:	0018      	movs	r0, r3
 8002250:	f01a fab8 	bl	801c7c4 <malloc>
 8002254:	0003      	movs	r3, r0
 8002256:	001a      	movs	r2, r3
 8002258:	687b      	ldr	r3, [r7, #4]
 800225a:	60da      	str	r2, [r3, #12]
}
 800225c:	46c0      	nop			; (mov r8, r8)
 800225e:	46bd      	mov	sp, r7
 8002260:	b002      	add	sp, #8
 8002262:	bd80      	pop	{r7, pc}

08002264 <RingBuffer_Push>:

// Day 1 Byte vào RingBuffer
uint8_t RingBuffer_Push(RingBuffer_Types* ringbuffer, uint8_t BytePush)
{
 8002264:	b580      	push	{r7, lr}
 8002266:	b082      	sub	sp, #8
 8002268:	af00      	add	r7, sp, #0
 800226a:	6078      	str	r0, [r7, #4]
 800226c:	000a      	movs	r2, r1
 800226e:	1cfb      	adds	r3, r7, #3
 8002270:	701a      	strb	r2, [r3, #0]
    if((ringbuffer->Head - ringbuffer->Tail == (ringbuffer->BufferSize - 1))
 8002272:	687b      	ldr	r3, [r7, #4]
 8002274:	685a      	ldr	r2, [r3, #4]
 8002276:	687b      	ldr	r3, [r7, #4]
 8002278:	689b      	ldr	r3, [r3, #8]
 800227a:	1ad2      	subs	r2, r2, r3
 800227c:	687b      	ldr	r3, [r7, #4]
 800227e:	681b      	ldr	r3, [r3, #0]
 8002280:	3b01      	subs	r3, #1
 8002282:	429a      	cmp	r2, r3
 8002284:	d009      	beq.n	800229a <RingBuffer_Push+0x36>
       || (ringbuffer->Tail - ringbuffer->Head == (ringbuffer->BufferSize - 1)))
 8002286:	687b      	ldr	r3, [r7, #4]
 8002288:	689a      	ldr	r2, [r3, #8]
 800228a:	687b      	ldr	r3, [r7, #4]
 800228c:	685b      	ldr	r3, [r3, #4]
 800228e:	1ad2      	subs	r2, r2, r3
 8002290:	687b      	ldr	r3, [r7, #4]
 8002292:	681b      	ldr	r3, [r3, #0]
 8002294:	3b01      	subs	r3, #1
 8002296:	429a      	cmp	r2, r3
 8002298:	d101      	bne.n	800229e <RingBuffer_Push+0x3a>
       {
        return E_NOT_OK; // return E_NOT_OK khi bo nho Full
 800229a:	2300      	movs	r3, #0
 800229c:	e018      	b.n	80022d0 <RingBuffer_Push+0x6c>
       }
    ringbuffer->u8Buffer[ringbuffer->Head] = BytePush;
 800229e:	687b      	ldr	r3, [r7, #4]
 80022a0:	68da      	ldr	r2, [r3, #12]
 80022a2:	687b      	ldr	r3, [r7, #4]
 80022a4:	685b      	ldr	r3, [r3, #4]
 80022a6:	18d3      	adds	r3, r2, r3
 80022a8:	1cfa      	adds	r2, r7, #3
 80022aa:	7812      	ldrb	r2, [r2, #0]
 80022ac:	701a      	strb	r2, [r3, #0]
    if(ringbuffer->Head == (ringbuffer->BufferSize - 1))
 80022ae:	687b      	ldr	r3, [r7, #4]
 80022b0:	685a      	ldr	r2, [r3, #4]
 80022b2:	687b      	ldr	r3, [r7, #4]
 80022b4:	681b      	ldr	r3, [r3, #0]
 80022b6:	3b01      	subs	r3, #1
 80022b8:	429a      	cmp	r2, r3
 80022ba:	d103      	bne.n	80022c4 <RingBuffer_Push+0x60>
    {
        ringbuffer->Head = 0;
 80022bc:	687b      	ldr	r3, [r7, #4]
 80022be:	2200      	movs	r2, #0
 80022c0:	605a      	str	r2, [r3, #4]
 80022c2:	e004      	b.n	80022ce <RingBuffer_Push+0x6a>
    }
    else
    {
        ringbuffer->Head += 1;
 80022c4:	687b      	ldr	r3, [r7, #4]
 80022c6:	685b      	ldr	r3, [r3, #4]
 80022c8:	1c5a      	adds	r2, r3, #1
 80022ca:	687b      	ldr	r3, [r7, #4]
 80022cc:	605a      	str	r2, [r3, #4]
    }
    return E_OK;
 80022ce:	2301      	movs	r3, #1
}
 80022d0:	0018      	movs	r0, r3
 80022d2:	46bd      	mov	sp, r7
 80022d4:	b002      	add	sp, #8
 80022d6:	bd80      	pop	{r7, pc}

080022d8 <RingBuffer_Pop>:

// Doc 1 byte tư RingBuffer
uint8_t RingBuffer_Pop(RingBuffer_Types* ringbuffer)
{
 80022d8:	b580      	push	{r7, lr}
 80022da:	b084      	sub	sp, #16
 80022dc:	af00      	add	r7, sp, #0
 80022de:	6078      	str	r0, [r7, #4]
    uint8_t BytePush = 0;
 80022e0:	210f      	movs	r1, #15
 80022e2:	187b      	adds	r3, r7, r1
 80022e4:	2200      	movs	r2, #0
 80022e6:	701a      	strb	r2, [r3, #0]
    if(ringbuffer->Head == ringbuffer->Tail)
 80022e8:	687b      	ldr	r3, [r7, #4]
 80022ea:	685a      	ldr	r2, [r3, #4]
 80022ec:	687b      	ldr	r3, [r7, #4]
 80022ee:	689b      	ldr	r3, [r3, #8]
 80022f0:	429a      	cmp	r2, r3
 80022f2:	d102      	bne.n	80022fa <RingBuffer_Pop+0x22>
    {
        return BytePush; // Return Null khi bo nho Empty
 80022f4:	187b      	adds	r3, r7, r1
 80022f6:	781b      	ldrb	r3, [r3, #0]
 80022f8:	e01b      	b.n	8002332 <RingBuffer_Pop+0x5a>
    }
    BytePush = ringbuffer->u8Buffer[ringbuffer->Tail];
 80022fa:	687b      	ldr	r3, [r7, #4]
 80022fc:	68da      	ldr	r2, [r3, #12]
 80022fe:	687b      	ldr	r3, [r7, #4]
 8002300:	689b      	ldr	r3, [r3, #8]
 8002302:	18d2      	adds	r2, r2, r3
 8002304:	230f      	movs	r3, #15
 8002306:	18fb      	adds	r3, r7, r3
 8002308:	7812      	ldrb	r2, [r2, #0]
 800230a:	701a      	strb	r2, [r3, #0]
    if(ringbuffer->Tail == (ringbuffer->BufferSize - 1))
 800230c:	687b      	ldr	r3, [r7, #4]
 800230e:	689a      	ldr	r2, [r3, #8]
 8002310:	687b      	ldr	r3, [r7, #4]
 8002312:	681b      	ldr	r3, [r3, #0]
 8002314:	3b01      	subs	r3, #1
 8002316:	429a      	cmp	r2, r3
 8002318:	d103      	bne.n	8002322 <RingBuffer_Pop+0x4a>
    {
        ringbuffer->Tail = 0;
 800231a:	687b      	ldr	r3, [r7, #4]
 800231c:	2200      	movs	r2, #0
 800231e:	609a      	str	r2, [r3, #8]
 8002320:	e004      	b.n	800232c <RingBuffer_Pop+0x54>
    }
    else
    {
        ringbuffer->Tail += 1;
 8002322:	687b      	ldr	r3, [r7, #4]
 8002324:	689b      	ldr	r3, [r3, #8]
 8002326:	1c5a      	adds	r2, r3, #1
 8002328:	687b      	ldr	r3, [r7, #4]
 800232a:	609a      	str	r2, [r3, #8]
    }
    return BytePush;
 800232c:	230f      	movs	r3, #15
 800232e:	18fb      	adds	r3, r7, r3
 8002330:	781b      	ldrb	r3, [r3, #0]
}
 8002332:	0018      	movs	r0, r3
 8002334:	46bd      	mov	sp, r7
 8002336:	b004      	add	sp, #16
 8002338:	bd80      	pop	{r7, pc}

0800233a <RingBuffer_GetBuffer>:
// Doc toan bo du lieu trong RingBuffer gán vào return Buffer
void RingBuffer_GetBuffer(uint8_t* retBuffer, uint16_t* dataLength, RingBuffer_Types* ringbuffer)
{
 800233a:	b590      	push	{r4, r7, lr}
 800233c:	b087      	sub	sp, #28
 800233e:	af00      	add	r7, sp, #0
 8002340:	60f8      	str	r0, [r7, #12]
 8002342:	60b9      	str	r1, [r7, #8]
 8002344:	607a      	str	r2, [r7, #4]
    int Num_Elements = RingBuffer_GetNumberElements(ringbuffer);
 8002346:	687b      	ldr	r3, [r7, #4]
 8002348:	0018      	movs	r0, r3
 800234a:	f000 f821 	bl	8002390 <RingBuffer_GetNumberElements>
 800234e:	0003      	movs	r3, r0
 8002350:	613b      	str	r3, [r7, #16]
    if(Num_Elements == 0)
 8002352:	693b      	ldr	r3, [r7, #16]
 8002354:	2b00      	cmp	r3, #0
 8002356:	d017      	beq.n	8002388 <RingBuffer_GetBuffer+0x4e>
    {
    	return;
    }
    for(int CountByte = 0; CountByte < Num_Elements; CountByte ++)
 8002358:	2300      	movs	r3, #0
 800235a:	617b      	str	r3, [r7, #20]
 800235c:	e00b      	b.n	8002376 <RingBuffer_GetBuffer+0x3c>
    {
        retBuffer[CountByte] = RingBuffer_Pop(ringbuffer);
 800235e:	697b      	ldr	r3, [r7, #20]
 8002360:	68fa      	ldr	r2, [r7, #12]
 8002362:	18d4      	adds	r4, r2, r3
 8002364:	687b      	ldr	r3, [r7, #4]
 8002366:	0018      	movs	r0, r3
 8002368:	f7ff ffb6 	bl	80022d8 <RingBuffer_Pop>
 800236c:	0003      	movs	r3, r0
 800236e:	7023      	strb	r3, [r4, #0]
    for(int CountByte = 0; CountByte < Num_Elements; CountByte ++)
 8002370:	697b      	ldr	r3, [r7, #20]
 8002372:	3301      	adds	r3, #1
 8002374:	617b      	str	r3, [r7, #20]
 8002376:	697a      	ldr	r2, [r7, #20]
 8002378:	693b      	ldr	r3, [r7, #16]
 800237a:	429a      	cmp	r2, r3
 800237c:	dbef      	blt.n	800235e <RingBuffer_GetBuffer+0x24>
    }
    *dataLength = Num_Elements;
 800237e:	693b      	ldr	r3, [r7, #16]
 8002380:	b29a      	uxth	r2, r3
 8002382:	68bb      	ldr	r3, [r7, #8]
 8002384:	801a      	strh	r2, [r3, #0]
 8002386:	e000      	b.n	800238a <RingBuffer_GetBuffer+0x50>
    	return;
 8002388:	46c0      	nop			; (mov r8, r8)
}
 800238a:	46bd      	mov	sp, r7
 800238c:	b007      	add	sp, #28
 800238e:	bd90      	pop	{r4, r7, pc}

08002390 <RingBuffer_GetNumberElements>:

// Lay tong so byte du lieu trong RingBuffer
int RingBuffer_GetNumberElements(RingBuffer_Types* ringbuffer)
{
 8002390:	b580      	push	{r7, lr}
 8002392:	b084      	sub	sp, #16
 8002394:	af00      	add	r7, sp, #0
 8002396:	6078      	str	r0, [r7, #4]
    int Num_Element = 0;
 8002398:	2300      	movs	r3, #0
 800239a:	60fb      	str	r3, [r7, #12]
    if (ringbuffer->Head >= ringbuffer->Tail)
 800239c:	687b      	ldr	r3, [r7, #4]
 800239e:	685a      	ldr	r2, [r3, #4]
 80023a0:	687b      	ldr	r3, [r7, #4]
 80023a2:	689b      	ldr	r3, [r3, #8]
 80023a4:	429a      	cmp	r2, r3
 80023a6:	db06      	blt.n	80023b6 <RingBuffer_GetNumberElements+0x26>
    {
        Num_Element = ringbuffer->Head - ringbuffer->Tail;
 80023a8:	687b      	ldr	r3, [r7, #4]
 80023aa:	685a      	ldr	r2, [r3, #4]
 80023ac:	687b      	ldr	r3, [r7, #4]
 80023ae:	689b      	ldr	r3, [r3, #8]
 80023b0:	1ad3      	subs	r3, r2, r3
 80023b2:	60fb      	str	r3, [r7, #12]
 80023b4:	e008      	b.n	80023c8 <RingBuffer_GetNumberElements+0x38>
    }
    else
    {
        Num_Element = ringbuffer->BufferSize - ringbuffer->Tail + ringbuffer->Head;
 80023b6:	687b      	ldr	r3, [r7, #4]
 80023b8:	681a      	ldr	r2, [r3, #0]
 80023ba:	687b      	ldr	r3, [r7, #4]
 80023bc:	689b      	ldr	r3, [r3, #8]
 80023be:	1ad2      	subs	r2, r2, r3
 80023c0:	687b      	ldr	r3, [r7, #4]
 80023c2:	685b      	ldr	r3, [r3, #4]
 80023c4:	18d3      	adds	r3, r2, r3
 80023c6:	60fb      	str	r3, [r7, #12]
    }
    return Num_Element;
 80023c8:	68fb      	ldr	r3, [r7, #12]
}
 80023ca:	0018      	movs	r0, r3
 80023cc:	46bd      	mov	sp, r7
 80023ce:	b004      	add	sp, #16
 80023d0:	bd80      	pop	{r7, pc}
	...

080023d4 <HAL_Init>:
  *        In the default implementation,Systick is used as source of time base.
  *        the tick variable is incremented each 1ms in its ISR.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 80023d4:	b580      	push	{r7, lr}
 80023d6:	b082      	sub	sp, #8
 80023d8:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 80023da:	1dfb      	adds	r3, r7, #7
 80023dc:	2200      	movs	r2, #0
 80023de:	701a      	strb	r2, [r3, #0]
#if (BUFFER_CACHE_DISABLE != 0)
  __HAL_FLASH_BUFFER_CACHE_DISABLE();
#endif /* BUFFER_CACHE_DISABLE */

#if (PREREAD_ENABLE != 0)
  __HAL_FLASH_PREREAD_BUFFER_ENABLE();
 80023e0:	4b0b      	ldr	r3, [pc, #44]	; (8002410 <HAL_Init+0x3c>)
 80023e2:	681a      	ldr	r2, [r3, #0]
 80023e4:	4b0a      	ldr	r3, [pc, #40]	; (8002410 <HAL_Init+0x3c>)
 80023e6:	2140      	movs	r1, #64	; 0x40
 80023e8:	430a      	orrs	r2, r1
 80023ea:	601a      	str	r2, [r3, #0]
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 80023ec:	2003      	movs	r0, #3
 80023ee:	f000 f811 	bl	8002414 <HAL_InitTick>
 80023f2:	1e03      	subs	r3, r0, #0
 80023f4:	d003      	beq.n	80023fe <HAL_Init+0x2a>
  {
    status = HAL_ERROR;
 80023f6:	1dfb      	adds	r3, r7, #7
 80023f8:	2201      	movs	r2, #1
 80023fa:	701a      	strb	r2, [r3, #0]
 80023fc:	e001      	b.n	8002402 <HAL_Init+0x2e>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 80023fe:	f7fe f9dd 	bl	80007bc <HAL_MspInit>
  }

  /* Return function status */
  return status;
 8002402:	1dfb      	adds	r3, r7, #7
 8002404:	781b      	ldrb	r3, [r3, #0]
}
 8002406:	0018      	movs	r0, r3
 8002408:	46bd      	mov	sp, r7
 800240a:	b002      	add	sp, #8
 800240c:	bd80      	pop	{r7, pc}
 800240e:	46c0      	nop			; (mov r8, r8)
 8002410:	40022000 	.word	0x40022000

08002414 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8002414:	b590      	push	{r4, r7, lr}
 8002416:	b083      	sub	sp, #12
 8002418:	af00      	add	r7, sp, #0
 800241a:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 800241c:	4b14      	ldr	r3, [pc, #80]	; (8002470 <HAL_InitTick+0x5c>)
 800241e:	681c      	ldr	r4, [r3, #0]
 8002420:	4b14      	ldr	r3, [pc, #80]	; (8002474 <HAL_InitTick+0x60>)
 8002422:	781b      	ldrb	r3, [r3, #0]
 8002424:	0019      	movs	r1, r3
 8002426:	23fa      	movs	r3, #250	; 0xfa
 8002428:	0098      	lsls	r0, r3, #2
 800242a:	f7fd fe7f 	bl	800012c <__udivsi3>
 800242e:	0003      	movs	r3, r0
 8002430:	0019      	movs	r1, r3
 8002432:	0020      	movs	r0, r4
 8002434:	f7fd fe7a 	bl	800012c <__udivsi3>
 8002438:	0003      	movs	r3, r0
 800243a:	0018      	movs	r0, r3
 800243c:	f000 f92f 	bl	800269e <HAL_SYSTICK_Config>
 8002440:	1e03      	subs	r3, r0, #0
 8002442:	d001      	beq.n	8002448 <HAL_InitTick+0x34>
  {
    return HAL_ERROR;
 8002444:	2301      	movs	r3, #1
 8002446:	e00f      	b.n	8002468 <HAL_InitTick+0x54>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8002448:	687b      	ldr	r3, [r7, #4]
 800244a:	2b03      	cmp	r3, #3
 800244c:	d80b      	bhi.n	8002466 <HAL_InitTick+0x52>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800244e:	6879      	ldr	r1, [r7, #4]
 8002450:	2301      	movs	r3, #1
 8002452:	425b      	negs	r3, r3
 8002454:	2200      	movs	r2, #0
 8002456:	0018      	movs	r0, r3
 8002458:	f000 f8fc 	bl	8002654 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 800245c:	4b06      	ldr	r3, [pc, #24]	; (8002478 <HAL_InitTick+0x64>)
 800245e:	687a      	ldr	r2, [r7, #4]
 8002460:	601a      	str	r2, [r3, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 8002462:	2300      	movs	r3, #0
 8002464:	e000      	b.n	8002468 <HAL_InitTick+0x54>
    return HAL_ERROR;
 8002466:	2301      	movs	r3, #1
}
 8002468:	0018      	movs	r0, r3
 800246a:	46bd      	mov	sp, r7
 800246c:	b003      	add	sp, #12
 800246e:	bd90      	pop	{r4, r7, pc}
 8002470:	20000204 	.word	0x20000204
 8002474:	2000020c 	.word	0x2000020c
 8002478:	20000208 	.word	0x20000208

0800247c <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 800247c:	b580      	push	{r7, lr}
 800247e:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 8002480:	4b05      	ldr	r3, [pc, #20]	; (8002498 <HAL_IncTick+0x1c>)
 8002482:	781b      	ldrb	r3, [r3, #0]
 8002484:	001a      	movs	r2, r3
 8002486:	4b05      	ldr	r3, [pc, #20]	; (800249c <HAL_IncTick+0x20>)
 8002488:	681b      	ldr	r3, [r3, #0]
 800248a:	18d2      	adds	r2, r2, r3
 800248c:	4b03      	ldr	r3, [pc, #12]	; (800249c <HAL_IncTick+0x20>)
 800248e:	601a      	str	r2, [r3, #0]
}
 8002490:	46c0      	nop			; (mov r8, r8)
 8002492:	46bd      	mov	sp, r7
 8002494:	bd80      	pop	{r7, pc}
 8002496:	46c0      	nop			; (mov r8, r8)
 8002498:	2000020c 	.word	0x2000020c
 800249c:	200014c0 	.word	0x200014c0

080024a0 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 80024a0:	b580      	push	{r7, lr}
 80024a2:	af00      	add	r7, sp, #0
  return uwTick;
 80024a4:	4b02      	ldr	r3, [pc, #8]	; (80024b0 <HAL_GetTick+0x10>)
 80024a6:	681b      	ldr	r3, [r3, #0]
}
 80024a8:	0018      	movs	r0, r3
 80024aa:	46bd      	mov	sp, r7
 80024ac:	bd80      	pop	{r7, pc}
 80024ae:	46c0      	nop			; (mov r8, r8)
 80024b0:	200014c0 	.word	0x200014c0

080024b4 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 80024b4:	b580      	push	{r7, lr}
 80024b6:	b084      	sub	sp, #16
 80024b8:	af00      	add	r7, sp, #0
 80024ba:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 80024bc:	f7ff fff0 	bl	80024a0 <HAL_GetTick>
 80024c0:	0003      	movs	r3, r0
 80024c2:	60bb      	str	r3, [r7, #8]
  uint32_t wait = Delay;
 80024c4:	687b      	ldr	r3, [r7, #4]
 80024c6:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 80024c8:	68fb      	ldr	r3, [r7, #12]
 80024ca:	3301      	adds	r3, #1
 80024cc:	d005      	beq.n	80024da <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 80024ce:	4b0a      	ldr	r3, [pc, #40]	; (80024f8 <HAL_Delay+0x44>)
 80024d0:	781b      	ldrb	r3, [r3, #0]
 80024d2:	001a      	movs	r2, r3
 80024d4:	68fb      	ldr	r3, [r7, #12]
 80024d6:	189b      	adds	r3, r3, r2
 80024d8:	60fb      	str	r3, [r7, #12]
  }

  while((HAL_GetTick() - tickstart) < wait)
 80024da:	46c0      	nop			; (mov r8, r8)
 80024dc:	f7ff ffe0 	bl	80024a0 <HAL_GetTick>
 80024e0:	0002      	movs	r2, r0
 80024e2:	68bb      	ldr	r3, [r7, #8]
 80024e4:	1ad3      	subs	r3, r2, r3
 80024e6:	68fa      	ldr	r2, [r7, #12]
 80024e8:	429a      	cmp	r2, r3
 80024ea:	d8f7      	bhi.n	80024dc <HAL_Delay+0x28>
  {
  }
}
 80024ec:	46c0      	nop			; (mov r8, r8)
 80024ee:	46c0      	nop			; (mov r8, r8)
 80024f0:	46bd      	mov	sp, r7
 80024f2:	b004      	add	sp, #16
 80024f4:	bd80      	pop	{r7, pc}
 80024f6:	46c0      	nop			; (mov r8, r8)
 80024f8:	2000020c 	.word	0x2000020c

080024fc <__NVIC_EnableIRQ>:
{
 80024fc:	b580      	push	{r7, lr}
 80024fe:	b082      	sub	sp, #8
 8002500:	af00      	add	r7, sp, #0
 8002502:	0002      	movs	r2, r0
 8002504:	1dfb      	adds	r3, r7, #7
 8002506:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
 8002508:	1dfb      	adds	r3, r7, #7
 800250a:	781b      	ldrb	r3, [r3, #0]
 800250c:	2b7f      	cmp	r3, #127	; 0x7f
 800250e:	d809      	bhi.n	8002524 <__NVIC_EnableIRQ+0x28>
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8002510:	1dfb      	adds	r3, r7, #7
 8002512:	781b      	ldrb	r3, [r3, #0]
 8002514:	001a      	movs	r2, r3
 8002516:	231f      	movs	r3, #31
 8002518:	401a      	ands	r2, r3
 800251a:	4b04      	ldr	r3, [pc, #16]	; (800252c <__NVIC_EnableIRQ+0x30>)
 800251c:	2101      	movs	r1, #1
 800251e:	4091      	lsls	r1, r2
 8002520:	000a      	movs	r2, r1
 8002522:	601a      	str	r2, [r3, #0]
}
 8002524:	46c0      	nop			; (mov r8, r8)
 8002526:	46bd      	mov	sp, r7
 8002528:	b002      	add	sp, #8
 800252a:	bd80      	pop	{r7, pc}
 800252c:	e000e100 	.word	0xe000e100

08002530 <__NVIC_SetPriority>:
{
 8002530:	b590      	push	{r4, r7, lr}
 8002532:	b083      	sub	sp, #12
 8002534:	af00      	add	r7, sp, #0
 8002536:	0002      	movs	r2, r0
 8002538:	6039      	str	r1, [r7, #0]
 800253a:	1dfb      	adds	r3, r7, #7
 800253c:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
 800253e:	1dfb      	adds	r3, r7, #7
 8002540:	781b      	ldrb	r3, [r3, #0]
 8002542:	2b7f      	cmp	r3, #127	; 0x7f
 8002544:	d828      	bhi.n	8002598 <__NVIC_SetPriority+0x68>
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002546:	4a2f      	ldr	r2, [pc, #188]	; (8002604 <__NVIC_SetPriority+0xd4>)
 8002548:	1dfb      	adds	r3, r7, #7
 800254a:	781b      	ldrb	r3, [r3, #0]
 800254c:	b25b      	sxtb	r3, r3
 800254e:	089b      	lsrs	r3, r3, #2
 8002550:	33c0      	adds	r3, #192	; 0xc0
 8002552:	009b      	lsls	r3, r3, #2
 8002554:	589b      	ldr	r3, [r3, r2]
 8002556:	1dfa      	adds	r2, r7, #7
 8002558:	7812      	ldrb	r2, [r2, #0]
 800255a:	0011      	movs	r1, r2
 800255c:	2203      	movs	r2, #3
 800255e:	400a      	ands	r2, r1
 8002560:	00d2      	lsls	r2, r2, #3
 8002562:	21ff      	movs	r1, #255	; 0xff
 8002564:	4091      	lsls	r1, r2
 8002566:	000a      	movs	r2, r1
 8002568:	43d2      	mvns	r2, r2
 800256a:	401a      	ands	r2, r3
 800256c:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 800256e:	683b      	ldr	r3, [r7, #0]
 8002570:	019b      	lsls	r3, r3, #6
 8002572:	22ff      	movs	r2, #255	; 0xff
 8002574:	401a      	ands	r2, r3
 8002576:	1dfb      	adds	r3, r7, #7
 8002578:	781b      	ldrb	r3, [r3, #0]
 800257a:	0018      	movs	r0, r3
 800257c:	2303      	movs	r3, #3
 800257e:	4003      	ands	r3, r0
 8002580:	00db      	lsls	r3, r3, #3
 8002582:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002584:	481f      	ldr	r0, [pc, #124]	; (8002604 <__NVIC_SetPriority+0xd4>)
 8002586:	1dfb      	adds	r3, r7, #7
 8002588:	781b      	ldrb	r3, [r3, #0]
 800258a:	b25b      	sxtb	r3, r3
 800258c:	089b      	lsrs	r3, r3, #2
 800258e:	430a      	orrs	r2, r1
 8002590:	33c0      	adds	r3, #192	; 0xc0
 8002592:	009b      	lsls	r3, r3, #2
 8002594:	501a      	str	r2, [r3, r0]
}
 8002596:	e031      	b.n	80025fc <__NVIC_SetPriority+0xcc>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002598:	4a1b      	ldr	r2, [pc, #108]	; (8002608 <__NVIC_SetPriority+0xd8>)
 800259a:	1dfb      	adds	r3, r7, #7
 800259c:	781b      	ldrb	r3, [r3, #0]
 800259e:	0019      	movs	r1, r3
 80025a0:	230f      	movs	r3, #15
 80025a2:	400b      	ands	r3, r1
 80025a4:	3b08      	subs	r3, #8
 80025a6:	089b      	lsrs	r3, r3, #2
 80025a8:	3306      	adds	r3, #6
 80025aa:	009b      	lsls	r3, r3, #2
 80025ac:	18d3      	adds	r3, r2, r3
 80025ae:	3304      	adds	r3, #4
 80025b0:	681b      	ldr	r3, [r3, #0]
 80025b2:	1dfa      	adds	r2, r7, #7
 80025b4:	7812      	ldrb	r2, [r2, #0]
 80025b6:	0011      	movs	r1, r2
 80025b8:	2203      	movs	r2, #3
 80025ba:	400a      	ands	r2, r1
 80025bc:	00d2      	lsls	r2, r2, #3
 80025be:	21ff      	movs	r1, #255	; 0xff
 80025c0:	4091      	lsls	r1, r2
 80025c2:	000a      	movs	r2, r1
 80025c4:	43d2      	mvns	r2, r2
 80025c6:	401a      	ands	r2, r3
 80025c8:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 80025ca:	683b      	ldr	r3, [r7, #0]
 80025cc:	019b      	lsls	r3, r3, #6
 80025ce:	22ff      	movs	r2, #255	; 0xff
 80025d0:	401a      	ands	r2, r3
 80025d2:	1dfb      	adds	r3, r7, #7
 80025d4:	781b      	ldrb	r3, [r3, #0]
 80025d6:	0018      	movs	r0, r3
 80025d8:	2303      	movs	r3, #3
 80025da:	4003      	ands	r3, r0
 80025dc:	00db      	lsls	r3, r3, #3
 80025de:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80025e0:	4809      	ldr	r0, [pc, #36]	; (8002608 <__NVIC_SetPriority+0xd8>)
 80025e2:	1dfb      	adds	r3, r7, #7
 80025e4:	781b      	ldrb	r3, [r3, #0]
 80025e6:	001c      	movs	r4, r3
 80025e8:	230f      	movs	r3, #15
 80025ea:	4023      	ands	r3, r4
 80025ec:	3b08      	subs	r3, #8
 80025ee:	089b      	lsrs	r3, r3, #2
 80025f0:	430a      	orrs	r2, r1
 80025f2:	3306      	adds	r3, #6
 80025f4:	009b      	lsls	r3, r3, #2
 80025f6:	18c3      	adds	r3, r0, r3
 80025f8:	3304      	adds	r3, #4
 80025fa:	601a      	str	r2, [r3, #0]
}
 80025fc:	46c0      	nop			; (mov r8, r8)
 80025fe:	46bd      	mov	sp, r7
 8002600:	b003      	add	sp, #12
 8002602:	bd90      	pop	{r4, r7, pc}
 8002604:	e000e100 	.word	0xe000e100
 8002608:	e000ed00 	.word	0xe000ed00

0800260c <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 800260c:	b580      	push	{r7, lr}
 800260e:	b082      	sub	sp, #8
 8002610:	af00      	add	r7, sp, #0
 8002612:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8002614:	687b      	ldr	r3, [r7, #4]
 8002616:	1e5a      	subs	r2, r3, #1
 8002618:	2380      	movs	r3, #128	; 0x80
 800261a:	045b      	lsls	r3, r3, #17
 800261c:	429a      	cmp	r2, r3
 800261e:	d301      	bcc.n	8002624 <SysTick_Config+0x18>
  {
    return (1UL);                                                   /* Reload value impossible */
 8002620:	2301      	movs	r3, #1
 8002622:	e010      	b.n	8002646 <SysTick_Config+0x3a>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8002624:	4b0a      	ldr	r3, [pc, #40]	; (8002650 <SysTick_Config+0x44>)
 8002626:	687a      	ldr	r2, [r7, #4]
 8002628:	3a01      	subs	r2, #1
 800262a:	605a      	str	r2, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 800262c:	2301      	movs	r3, #1
 800262e:	425b      	negs	r3, r3
 8002630:	2103      	movs	r1, #3
 8002632:	0018      	movs	r0, r3
 8002634:	f7ff ff7c 	bl	8002530 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8002638:	4b05      	ldr	r3, [pc, #20]	; (8002650 <SysTick_Config+0x44>)
 800263a:	2200      	movs	r2, #0
 800263c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800263e:	4b04      	ldr	r3, [pc, #16]	; (8002650 <SysTick_Config+0x44>)
 8002640:	2207      	movs	r2, #7
 8002642:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8002644:	2300      	movs	r3, #0
}
 8002646:	0018      	movs	r0, r3
 8002648:	46bd      	mov	sp, r7
 800264a:	b002      	add	sp, #8
 800264c:	bd80      	pop	{r7, pc}
 800264e:	46c0      	nop			; (mov r8, r8)
 8002650:	e000e010 	.word	0xe000e010

08002654 <HAL_NVIC_SetPriority>:
  *         with stm32l0xx devices, this parameter is a dummy value and it is ignored, because 
  *         no subpriority supported in Cortex M0+ based products.   
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8002654:	b580      	push	{r7, lr}
 8002656:	b084      	sub	sp, #16
 8002658:	af00      	add	r7, sp, #0
 800265a:	60b9      	str	r1, [r7, #8]
 800265c:	607a      	str	r2, [r7, #4]
 800265e:	210f      	movs	r1, #15
 8002660:	187b      	adds	r3, r7, r1
 8002662:	1c02      	adds	r2, r0, #0
 8002664:	701a      	strb	r2, [r3, #0]
    /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn,PreemptPriority);
 8002666:	68ba      	ldr	r2, [r7, #8]
 8002668:	187b      	adds	r3, r7, r1
 800266a:	781b      	ldrb	r3, [r3, #0]
 800266c:	b25b      	sxtb	r3, r3
 800266e:	0011      	movs	r1, r2
 8002670:	0018      	movs	r0, r3
 8002672:	f7ff ff5d 	bl	8002530 <__NVIC_SetPriority>
}
 8002676:	46c0      	nop			; (mov r8, r8)
 8002678:	46bd      	mov	sp, r7
 800267a:	b004      	add	sp, #16
 800267c:	bd80      	pop	{r7, pc}

0800267e <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of  IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to stm32l0xx.h file)  
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800267e:	b580      	push	{r7, lr}
 8002680:	b082      	sub	sp, #8
 8002682:	af00      	add	r7, sp, #0
 8002684:	0002      	movs	r2, r0
 8002686:	1dfb      	adds	r3, r7, #7
 8002688:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 800268a:	1dfb      	adds	r3, r7, #7
 800268c:	781b      	ldrb	r3, [r3, #0]
 800268e:	b25b      	sxtb	r3, r3
 8002690:	0018      	movs	r0, r3
 8002692:	f7ff ff33 	bl	80024fc <__NVIC_EnableIRQ>
}
 8002696:	46c0      	nop			; (mov r8, r8)
 8002698:	46bd      	mov	sp, r7
 800269a:	b002      	add	sp, #8
 800269c:	bd80      	pop	{r7, pc}

0800269e <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800269e:	b580      	push	{r7, lr}
 80026a0:	b082      	sub	sp, #8
 80026a2:	af00      	add	r7, sp, #0
 80026a4:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 80026a6:	687b      	ldr	r3, [r7, #4]
 80026a8:	0018      	movs	r0, r3
 80026aa:	f7ff ffaf 	bl	800260c <SysTick_Config>
 80026ae:	0003      	movs	r3, r0
}
 80026b0:	0018      	movs	r0, r3
 80026b2:	46bd      	mov	sp, r7
 80026b4:	b002      	add	sp, #8
 80026b6:	bd80      	pop	{r7, pc}

080026b8 <HAL_DMA_Abort>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
    * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
 80026b8:	b580      	push	{r7, lr}
 80026ba:	b084      	sub	sp, #16
 80026bc:	af00      	add	r7, sp, #0
 80026be:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 80026c0:	230f      	movs	r3, #15
 80026c2:	18fb      	adds	r3, r7, r3
 80026c4:	2200      	movs	r2, #0
 80026c6:	701a      	strb	r2, [r3, #0]

  /* Check the DMA peripheral state */
  if(hdma->State != HAL_DMA_STATE_BUSY)
 80026c8:	687b      	ldr	r3, [r7, #4]
 80026ca:	2225      	movs	r2, #37	; 0x25
 80026cc:	5c9b      	ldrb	r3, [r3, r2]
 80026ce:	b2db      	uxtb	r3, r3
 80026d0:	2b02      	cmp	r3, #2
 80026d2:	d008      	beq.n	80026e6 <HAL_DMA_Abort+0x2e>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80026d4:	687b      	ldr	r3, [r7, #4]
 80026d6:	2204      	movs	r2, #4
 80026d8:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 80026da:	687b      	ldr	r3, [r7, #4]
 80026dc:	2224      	movs	r2, #36	; 0x24
 80026de:	2100      	movs	r1, #0
 80026e0:	5499      	strb	r1, [r3, r2]

    return HAL_ERROR;
 80026e2:	2301      	movs	r3, #1
 80026e4:	e024      	b.n	8002730 <HAL_DMA_Abort+0x78>
  }
  else
  {
    /* Disable DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80026e6:	687b      	ldr	r3, [r7, #4]
 80026e8:	681b      	ldr	r3, [r3, #0]
 80026ea:	681a      	ldr	r2, [r3, #0]
 80026ec:	687b      	ldr	r3, [r7, #4]
 80026ee:	681b      	ldr	r3, [r3, #0]
 80026f0:	210e      	movs	r1, #14
 80026f2:	438a      	bics	r2, r1
 80026f4:	601a      	str	r2, [r3, #0]

    /* Disable the channel */
    __HAL_DMA_DISABLE(hdma);
 80026f6:	687b      	ldr	r3, [r7, #4]
 80026f8:	681b      	ldr	r3, [r3, #0]
 80026fa:	681a      	ldr	r2, [r3, #0]
 80026fc:	687b      	ldr	r3, [r7, #4]
 80026fe:	681b      	ldr	r3, [r3, #0]
 8002700:	2101      	movs	r1, #1
 8002702:	438a      	bics	r2, r1
 8002704:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
 8002706:	687b      	ldr	r3, [r7, #4]
 8002708:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800270a:	221c      	movs	r2, #28
 800270c:	401a      	ands	r2, r3
 800270e:	687b      	ldr	r3, [r7, #4]
 8002710:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002712:	2101      	movs	r1, #1
 8002714:	4091      	lsls	r1, r2
 8002716:	000a      	movs	r2, r1
 8002718:	605a      	str	r2, [r3, #4]

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 800271a:	687b      	ldr	r3, [r7, #4]
 800271c:	2225      	movs	r2, #37	; 0x25
 800271e:	2101      	movs	r1, #1
 8002720:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8002722:	687b      	ldr	r3, [r7, #4]
 8002724:	2224      	movs	r2, #36	; 0x24
 8002726:	2100      	movs	r1, #0
 8002728:	5499      	strb	r1, [r3, r2]

    return status;
 800272a:	230f      	movs	r3, #15
 800272c:	18fb      	adds	r3, r7, r3
 800272e:	781b      	ldrb	r3, [r3, #0]
  }
}
 8002730:	0018      	movs	r0, r3
 8002732:	46bd      	mov	sp, r7
 8002734:	b004      	add	sp, #16
 8002736:	bd80      	pop	{r7, pc}

08002738 <HAL_DMA_Abort_IT>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
 8002738:	b580      	push	{r7, lr}
 800273a:	b084      	sub	sp, #16
 800273c:	af00      	add	r7, sp, #0
 800273e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8002740:	210f      	movs	r1, #15
 8002742:	187b      	adds	r3, r7, r1
 8002744:	2200      	movs	r2, #0
 8002746:	701a      	strb	r2, [r3, #0]

  if(HAL_DMA_STATE_BUSY != hdma->State)
 8002748:	687b      	ldr	r3, [r7, #4]
 800274a:	2225      	movs	r2, #37	; 0x25
 800274c:	5c9b      	ldrb	r3, [r3, r2]
 800274e:	b2db      	uxtb	r3, r3
 8002750:	2b02      	cmp	r3, #2
 8002752:	d006      	beq.n	8002762 <HAL_DMA_Abort_IT+0x2a>
  {
    /* no transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8002754:	687b      	ldr	r3, [r7, #4]
 8002756:	2204      	movs	r2, #4
 8002758:	63da      	str	r2, [r3, #60]	; 0x3c

    status = HAL_ERROR;
 800275a:	187b      	adds	r3, r7, r1
 800275c:	2201      	movs	r2, #1
 800275e:	701a      	strb	r2, [r3, #0]
 8002760:	e02a      	b.n	80027b8 <HAL_DMA_Abort_IT+0x80>
  }
  else
  {
    /* Disable DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8002762:	687b      	ldr	r3, [r7, #4]
 8002764:	681b      	ldr	r3, [r3, #0]
 8002766:	681a      	ldr	r2, [r3, #0]
 8002768:	687b      	ldr	r3, [r7, #4]
 800276a:	681b      	ldr	r3, [r3, #0]
 800276c:	210e      	movs	r1, #14
 800276e:	438a      	bics	r2, r1
 8002770:	601a      	str	r2, [r3, #0]

    /* Disable the channel */
    __HAL_DMA_DISABLE(hdma);
 8002772:	687b      	ldr	r3, [r7, #4]
 8002774:	681b      	ldr	r3, [r3, #0]
 8002776:	681a      	ldr	r2, [r3, #0]
 8002778:	687b      	ldr	r3, [r7, #4]
 800277a:	681b      	ldr	r3, [r3, #0]
 800277c:	2101      	movs	r1, #1
 800277e:	438a      	bics	r2, r1
 8002780:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
 8002782:	687b      	ldr	r3, [r7, #4]
 8002784:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002786:	221c      	movs	r2, #28
 8002788:	401a      	ands	r2, r3
 800278a:	687b      	ldr	r3, [r7, #4]
 800278c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800278e:	2101      	movs	r1, #1
 8002790:	4091      	lsls	r1, r2
 8002792:	000a      	movs	r2, r1
 8002794:	605a      	str	r2, [r3, #4]

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 8002796:	687b      	ldr	r3, [r7, #4]
 8002798:	2225      	movs	r2, #37	; 0x25
 800279a:	2101      	movs	r1, #1
 800279c:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 800279e:	687b      	ldr	r3, [r7, #4]
 80027a0:	2224      	movs	r2, #36	; 0x24
 80027a2:	2100      	movs	r1, #0
 80027a4:	5499      	strb	r1, [r3, r2]

    /* Call User Abort callback */
    if(hdma->XferAbortCallback != NULL)
 80027a6:	687b      	ldr	r3, [r7, #4]
 80027a8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80027aa:	2b00      	cmp	r3, #0
 80027ac:	d004      	beq.n	80027b8 <HAL_DMA_Abort_IT+0x80>
    {
      hdma->XferAbortCallback(hdma);
 80027ae:	687b      	ldr	r3, [r7, #4]
 80027b0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80027b2:	687a      	ldr	r2, [r7, #4]
 80027b4:	0010      	movs	r0, r2
 80027b6:	4798      	blx	r3
    }
  }
  return status;
 80027b8:	230f      	movs	r3, #15
 80027ba:	18fb      	adds	r3, r7, r3
 80027bc:	781b      	ldrb	r3, [r3, #0]
}
 80027be:	0018      	movs	r0, r3
 80027c0:	46bd      	mov	sp, r7
 80027c2:	b004      	add	sp, #16
 80027c4:	bd80      	pop	{r7, pc}
	...

080027c8 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *                    the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80027c8:	b580      	push	{r7, lr}
 80027ca:	b086      	sub	sp, #24
 80027cc:	af00      	add	r7, sp, #0
 80027ce:	6078      	str	r0, [r7, #4]
 80027d0:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
 80027d2:	2300      	movs	r3, #0
 80027d4:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 80027d6:	2300      	movs	r3, #0
 80027d8:	60fb      	str	r3, [r7, #12]
  uint32_t temp = 0x00U;
 80027da:	2300      	movs	r3, #0
 80027dc:	613b      	str	r3, [r7, #16]
  /* Check the parameters */
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx, (GPIO_Init->Pin)));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0)
 80027de:	e155      	b.n	8002a8c <HAL_GPIO_Init+0x2c4>
  {
    /* Get the IO position */
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 80027e0:	683b      	ldr	r3, [r7, #0]
 80027e2:	681b      	ldr	r3, [r3, #0]
 80027e4:	2101      	movs	r1, #1
 80027e6:	697a      	ldr	r2, [r7, #20]
 80027e8:	4091      	lsls	r1, r2
 80027ea:	000a      	movs	r2, r1
 80027ec:	4013      	ands	r3, r2
 80027ee:	60fb      	str	r3, [r7, #12]

    if (iocurrent)
 80027f0:	68fb      	ldr	r3, [r7, #12]
 80027f2:	2b00      	cmp	r3, #0
 80027f4:	d100      	bne.n	80027f8 <HAL_GPIO_Init+0x30>
 80027f6:	e146      	b.n	8002a86 <HAL_GPIO_Init+0x2be>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 80027f8:	683b      	ldr	r3, [r7, #0]
 80027fa:	685b      	ldr	r3, [r3, #4]
 80027fc:	2203      	movs	r2, #3
 80027fe:	4013      	ands	r3, r2
 8002800:	2b01      	cmp	r3, #1
 8002802:	d005      	beq.n	8002810 <HAL_GPIO_Init+0x48>
          ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8002804:	683b      	ldr	r3, [r7, #0]
 8002806:	685b      	ldr	r3, [r3, #4]
 8002808:	2203      	movs	r2, #3
 800280a:	4013      	ands	r3, r2
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) ||
 800280c:	2b02      	cmp	r3, #2
 800280e:	d130      	bne.n	8002872 <HAL_GPIO_Init+0xaa>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8002810:	687b      	ldr	r3, [r7, #4]
 8002812:	689b      	ldr	r3, [r3, #8]
 8002814:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDER_OSPEED0 << (position * 2U));
 8002816:	697b      	ldr	r3, [r7, #20]
 8002818:	005b      	lsls	r3, r3, #1
 800281a:	2203      	movs	r2, #3
 800281c:	409a      	lsls	r2, r3
 800281e:	0013      	movs	r3, r2
 8002820:	43da      	mvns	r2, r3
 8002822:	693b      	ldr	r3, [r7, #16]
 8002824:	4013      	ands	r3, r2
 8002826:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8002828:	683b      	ldr	r3, [r7, #0]
 800282a:	68da      	ldr	r2, [r3, #12]
 800282c:	697b      	ldr	r3, [r7, #20]
 800282e:	005b      	lsls	r3, r3, #1
 8002830:	409a      	lsls	r2, r3
 8002832:	0013      	movs	r3, r2
 8002834:	693a      	ldr	r2, [r7, #16]
 8002836:	4313      	orrs	r3, r2
 8002838:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 800283a:	687b      	ldr	r3, [r7, #4]
 800283c:	693a      	ldr	r2, [r7, #16]
 800283e:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8002840:	687b      	ldr	r3, [r7, #4]
 8002842:	685b      	ldr	r3, [r3, #4]
 8002844:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8002846:	2201      	movs	r2, #1
 8002848:	697b      	ldr	r3, [r7, #20]
 800284a:	409a      	lsls	r2, r3
 800284c:	0013      	movs	r3, r2
 800284e:	43da      	mvns	r2, r3
 8002850:	693b      	ldr	r3, [r7, #16]
 8002852:	4013      	ands	r3, r2
 8002854:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8002856:	683b      	ldr	r3, [r7, #0]
 8002858:	685b      	ldr	r3, [r3, #4]
 800285a:	091b      	lsrs	r3, r3, #4
 800285c:	2201      	movs	r2, #1
 800285e:	401a      	ands	r2, r3
 8002860:	697b      	ldr	r3, [r7, #20]
 8002862:	409a      	lsls	r2, r3
 8002864:	0013      	movs	r3, r2
 8002866:	693a      	ldr	r2, [r7, #16]
 8002868:	4313      	orrs	r3, r2
 800286a:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 800286c:	687b      	ldr	r3, [r7, #4]
 800286e:	693a      	ldr	r2, [r7, #16]
 8002870:	605a      	str	r2, [r3, #4]
      }

      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8002872:	683b      	ldr	r3, [r7, #0]
 8002874:	685b      	ldr	r3, [r3, #4]
 8002876:	2203      	movs	r2, #3
 8002878:	4013      	ands	r3, r2
 800287a:	2b03      	cmp	r3, #3
 800287c:	d017      	beq.n	80028ae <HAL_GPIO_Init+0xe6>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
 800287e:	687b      	ldr	r3, [r7, #4]
 8002880:	68db      	ldr	r3, [r3, #12]
 8002882:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8002884:	697b      	ldr	r3, [r7, #20]
 8002886:	005b      	lsls	r3, r3, #1
 8002888:	2203      	movs	r2, #3
 800288a:	409a      	lsls	r2, r3
 800288c:	0013      	movs	r3, r2
 800288e:	43da      	mvns	r2, r3
 8002890:	693b      	ldr	r3, [r7, #16]
 8002892:	4013      	ands	r3, r2
 8002894:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8002896:	683b      	ldr	r3, [r7, #0]
 8002898:	689a      	ldr	r2, [r3, #8]
 800289a:	697b      	ldr	r3, [r7, #20]
 800289c:	005b      	lsls	r3, r3, #1
 800289e:	409a      	lsls	r2, r3
 80028a0:	0013      	movs	r3, r2
 80028a2:	693a      	ldr	r2, [r7, #16]
 80028a4:	4313      	orrs	r3, r2
 80028a6:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
 80028a8:	687b      	ldr	r3, [r7, #4]
 80028aa:	693a      	ldr	r2, [r7, #16]
 80028ac:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 80028ae:	683b      	ldr	r3, [r7, #0]
 80028b0:	685b      	ldr	r3, [r3, #4]
 80028b2:	2203      	movs	r2, #3
 80028b4:	4013      	ands	r3, r2
 80028b6:	2b02      	cmp	r3, #2
 80028b8:	d123      	bne.n	8002902 <HAL_GPIO_Init+0x13a>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 80028ba:	697b      	ldr	r3, [r7, #20]
 80028bc:	08da      	lsrs	r2, r3, #3
 80028be:	687b      	ldr	r3, [r7, #4]
 80028c0:	3208      	adds	r2, #8
 80028c2:	0092      	lsls	r2, r2, #2
 80028c4:	58d3      	ldr	r3, [r2, r3]
 80028c6:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFUL << ((uint32_t)(position & 0x07UL) * 4U));
 80028c8:	697b      	ldr	r3, [r7, #20]
 80028ca:	2207      	movs	r2, #7
 80028cc:	4013      	ands	r3, r2
 80028ce:	009b      	lsls	r3, r3, #2
 80028d0:	220f      	movs	r2, #15
 80028d2:	409a      	lsls	r2, r3
 80028d4:	0013      	movs	r3, r2
 80028d6:	43da      	mvns	r2, r3
 80028d8:	693b      	ldr	r3, [r7, #16]
 80028da:	4013      	ands	r3, r2
 80028dc:	613b      	str	r3, [r7, #16]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
 80028de:	683b      	ldr	r3, [r7, #0]
 80028e0:	691a      	ldr	r2, [r3, #16]
 80028e2:	697b      	ldr	r3, [r7, #20]
 80028e4:	2107      	movs	r1, #7
 80028e6:	400b      	ands	r3, r1
 80028e8:	009b      	lsls	r3, r3, #2
 80028ea:	409a      	lsls	r2, r3
 80028ec:	0013      	movs	r3, r2
 80028ee:	693a      	ldr	r2, [r7, #16]
 80028f0:	4313      	orrs	r3, r2
 80028f2:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3U] = temp;
 80028f4:	697b      	ldr	r3, [r7, #20]
 80028f6:	08da      	lsrs	r2, r3, #3
 80028f8:	687b      	ldr	r3, [r7, #4]
 80028fa:	3208      	adds	r2, #8
 80028fc:	0092      	lsls	r2, r2, #2
 80028fe:	6939      	ldr	r1, [r7, #16]
 8002900:	50d1      	str	r1, [r2, r3]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8002902:	687b      	ldr	r3, [r7, #4]
 8002904:	681b      	ldr	r3, [r3, #0]
 8002906:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8002908:	697b      	ldr	r3, [r7, #20]
 800290a:	005b      	lsls	r3, r3, #1
 800290c:	2203      	movs	r2, #3
 800290e:	409a      	lsls	r2, r3
 8002910:	0013      	movs	r3, r2
 8002912:	43da      	mvns	r2, r3
 8002914:	693b      	ldr	r3, [r7, #16]
 8002916:	4013      	ands	r3, r2
 8002918:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800291a:	683b      	ldr	r3, [r7, #0]
 800291c:	685b      	ldr	r3, [r3, #4]
 800291e:	2203      	movs	r2, #3
 8002920:	401a      	ands	r2, r3
 8002922:	697b      	ldr	r3, [r7, #20]
 8002924:	005b      	lsls	r3, r3, #1
 8002926:	409a      	lsls	r2, r3
 8002928:	0013      	movs	r3, r2
 800292a:	693a      	ldr	r2, [r7, #16]
 800292c:	4313      	orrs	r3, r2
 800292e:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 8002930:	687b      	ldr	r3, [r7, #4]
 8002932:	693a      	ldr	r2, [r7, #16]
 8002934:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 8002936:	683b      	ldr	r3, [r7, #0]
 8002938:	685a      	ldr	r2, [r3, #4]
 800293a:	23c0      	movs	r3, #192	; 0xc0
 800293c:	029b      	lsls	r3, r3, #10
 800293e:	4013      	ands	r3, r2
 8002940:	d100      	bne.n	8002944 <HAL_GPIO_Init+0x17c>
 8002942:	e0a0      	b.n	8002a86 <HAL_GPIO_Init+0x2be>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8002944:	4b57      	ldr	r3, [pc, #348]	; (8002aa4 <HAL_GPIO_Init+0x2dc>)
 8002946:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002948:	4b56      	ldr	r3, [pc, #344]	; (8002aa4 <HAL_GPIO_Init+0x2dc>)
 800294a:	2101      	movs	r1, #1
 800294c:	430a      	orrs	r2, r1
 800294e:	635a      	str	r2, [r3, #52]	; 0x34

        temp = SYSCFG->EXTICR[position >> 2U];
 8002950:	4a55      	ldr	r2, [pc, #340]	; (8002aa8 <HAL_GPIO_Init+0x2e0>)
 8002952:	697b      	ldr	r3, [r7, #20]
 8002954:	089b      	lsrs	r3, r3, #2
 8002956:	3302      	adds	r3, #2
 8002958:	009b      	lsls	r3, r3, #2
 800295a:	589b      	ldr	r3, [r3, r2]
 800295c:	613b      	str	r3, [r7, #16]
        CLEAR_BIT(temp, (0x0FUL) << (4U * (position & 0x03U)));
 800295e:	697b      	ldr	r3, [r7, #20]
 8002960:	2203      	movs	r2, #3
 8002962:	4013      	ands	r3, r2
 8002964:	009b      	lsls	r3, r3, #2
 8002966:	220f      	movs	r2, #15
 8002968:	409a      	lsls	r2, r3
 800296a:	0013      	movs	r3, r2
 800296c:	43da      	mvns	r2, r3
 800296e:	693b      	ldr	r3, [r7, #16]
 8002970:	4013      	ands	r3, r2
 8002972:	613b      	str	r3, [r7, #16]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03U)));
 8002974:	687a      	ldr	r2, [r7, #4]
 8002976:	23a0      	movs	r3, #160	; 0xa0
 8002978:	05db      	lsls	r3, r3, #23
 800297a:	429a      	cmp	r2, r3
 800297c:	d01f      	beq.n	80029be <HAL_GPIO_Init+0x1f6>
 800297e:	687b      	ldr	r3, [r7, #4]
 8002980:	4a4a      	ldr	r2, [pc, #296]	; (8002aac <HAL_GPIO_Init+0x2e4>)
 8002982:	4293      	cmp	r3, r2
 8002984:	d019      	beq.n	80029ba <HAL_GPIO_Init+0x1f2>
 8002986:	687b      	ldr	r3, [r7, #4]
 8002988:	4a49      	ldr	r2, [pc, #292]	; (8002ab0 <HAL_GPIO_Init+0x2e8>)
 800298a:	4293      	cmp	r3, r2
 800298c:	d013      	beq.n	80029b6 <HAL_GPIO_Init+0x1ee>
 800298e:	687b      	ldr	r3, [r7, #4]
 8002990:	4a48      	ldr	r2, [pc, #288]	; (8002ab4 <HAL_GPIO_Init+0x2ec>)
 8002992:	4293      	cmp	r3, r2
 8002994:	d00d      	beq.n	80029b2 <HAL_GPIO_Init+0x1ea>
 8002996:	687b      	ldr	r3, [r7, #4]
 8002998:	4a47      	ldr	r2, [pc, #284]	; (8002ab8 <HAL_GPIO_Init+0x2f0>)
 800299a:	4293      	cmp	r3, r2
 800299c:	d007      	beq.n	80029ae <HAL_GPIO_Init+0x1e6>
 800299e:	687b      	ldr	r3, [r7, #4]
 80029a0:	4a46      	ldr	r2, [pc, #280]	; (8002abc <HAL_GPIO_Init+0x2f4>)
 80029a2:	4293      	cmp	r3, r2
 80029a4:	d101      	bne.n	80029aa <HAL_GPIO_Init+0x1e2>
 80029a6:	2305      	movs	r3, #5
 80029a8:	e00a      	b.n	80029c0 <HAL_GPIO_Init+0x1f8>
 80029aa:	2306      	movs	r3, #6
 80029ac:	e008      	b.n	80029c0 <HAL_GPIO_Init+0x1f8>
 80029ae:	2304      	movs	r3, #4
 80029b0:	e006      	b.n	80029c0 <HAL_GPIO_Init+0x1f8>
 80029b2:	2303      	movs	r3, #3
 80029b4:	e004      	b.n	80029c0 <HAL_GPIO_Init+0x1f8>
 80029b6:	2302      	movs	r3, #2
 80029b8:	e002      	b.n	80029c0 <HAL_GPIO_Init+0x1f8>
 80029ba:	2301      	movs	r3, #1
 80029bc:	e000      	b.n	80029c0 <HAL_GPIO_Init+0x1f8>
 80029be:	2300      	movs	r3, #0
 80029c0:	697a      	ldr	r2, [r7, #20]
 80029c2:	2103      	movs	r1, #3
 80029c4:	400a      	ands	r2, r1
 80029c6:	0092      	lsls	r2, r2, #2
 80029c8:	4093      	lsls	r3, r2
 80029ca:	693a      	ldr	r2, [r7, #16]
 80029cc:	4313      	orrs	r3, r2
 80029ce:	613b      	str	r3, [r7, #16]
        SYSCFG->EXTICR[position >> 2U] = temp;
 80029d0:	4935      	ldr	r1, [pc, #212]	; (8002aa8 <HAL_GPIO_Init+0x2e0>)
 80029d2:	697b      	ldr	r3, [r7, #20]
 80029d4:	089b      	lsrs	r3, r3, #2
 80029d6:	3302      	adds	r3, #2
 80029d8:	009b      	lsls	r3, r3, #2
 80029da:	693a      	ldr	r2, [r7, #16]
 80029dc:	505a      	str	r2, [r3, r1]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 80029de:	4b38      	ldr	r3, [pc, #224]	; (8002ac0 <HAL_GPIO_Init+0x2f8>)
 80029e0:	681b      	ldr	r3, [r3, #0]
 80029e2:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 80029e4:	68fb      	ldr	r3, [r7, #12]
 80029e6:	43da      	mvns	r2, r3
 80029e8:	693b      	ldr	r3, [r7, #16]
 80029ea:	4013      	ands	r3, r2
 80029ec:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 80029ee:	683b      	ldr	r3, [r7, #0]
 80029f0:	685a      	ldr	r2, [r3, #4]
 80029f2:	2380      	movs	r3, #128	; 0x80
 80029f4:	025b      	lsls	r3, r3, #9
 80029f6:	4013      	ands	r3, r2
 80029f8:	d003      	beq.n	8002a02 <HAL_GPIO_Init+0x23a>
        {
          temp |= iocurrent;
 80029fa:	693a      	ldr	r2, [r7, #16]
 80029fc:	68fb      	ldr	r3, [r7, #12]
 80029fe:	4313      	orrs	r3, r2
 8002a00:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR = temp;
 8002a02:	4b2f      	ldr	r3, [pc, #188]	; (8002ac0 <HAL_GPIO_Init+0x2f8>)
 8002a04:	693a      	ldr	r2, [r7, #16]
 8002a06:	601a      	str	r2, [r3, #0]

        temp = EXTI->EMR;
 8002a08:	4b2d      	ldr	r3, [pc, #180]	; (8002ac0 <HAL_GPIO_Init+0x2f8>)
 8002a0a:	685b      	ldr	r3, [r3, #4]
 8002a0c:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 8002a0e:	68fb      	ldr	r3, [r7, #12]
 8002a10:	43da      	mvns	r2, r3
 8002a12:	693b      	ldr	r3, [r7, #16]
 8002a14:	4013      	ands	r3, r2
 8002a16:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 8002a18:	683b      	ldr	r3, [r7, #0]
 8002a1a:	685a      	ldr	r2, [r3, #4]
 8002a1c:	2380      	movs	r3, #128	; 0x80
 8002a1e:	029b      	lsls	r3, r3, #10
 8002a20:	4013      	ands	r3, r2
 8002a22:	d003      	beq.n	8002a2c <HAL_GPIO_Init+0x264>
        {
          temp |= iocurrent;
 8002a24:	693a      	ldr	r2, [r7, #16]
 8002a26:	68fb      	ldr	r3, [r7, #12]
 8002a28:	4313      	orrs	r3, r2
 8002a2a:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR = temp;
 8002a2c:	4b24      	ldr	r3, [pc, #144]	; (8002ac0 <HAL_GPIO_Init+0x2f8>)
 8002a2e:	693a      	ldr	r2, [r7, #16]
 8002a30:	605a      	str	r2, [r3, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8002a32:	4b23      	ldr	r3, [pc, #140]	; (8002ac0 <HAL_GPIO_Init+0x2f8>)
 8002a34:	689b      	ldr	r3, [r3, #8]
 8002a36:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 8002a38:	68fb      	ldr	r3, [r7, #12]
 8002a3a:	43da      	mvns	r2, r3
 8002a3c:	693b      	ldr	r3, [r7, #16]
 8002a3e:	4013      	ands	r3, r2
 8002a40:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 8002a42:	683b      	ldr	r3, [r7, #0]
 8002a44:	685a      	ldr	r2, [r3, #4]
 8002a46:	2380      	movs	r3, #128	; 0x80
 8002a48:	035b      	lsls	r3, r3, #13
 8002a4a:	4013      	ands	r3, r2
 8002a4c:	d003      	beq.n	8002a56 <HAL_GPIO_Init+0x28e>
        {
          temp |= iocurrent;
 8002a4e:	693a      	ldr	r2, [r7, #16]
 8002a50:	68fb      	ldr	r3, [r7, #12]
 8002a52:	4313      	orrs	r3, r2
 8002a54:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR = temp;
 8002a56:	4b1a      	ldr	r3, [pc, #104]	; (8002ac0 <HAL_GPIO_Init+0x2f8>)
 8002a58:	693a      	ldr	r2, [r7, #16]
 8002a5a:	609a      	str	r2, [r3, #8]

        temp = EXTI->FTSR;
 8002a5c:	4b18      	ldr	r3, [pc, #96]	; (8002ac0 <HAL_GPIO_Init+0x2f8>)
 8002a5e:	68db      	ldr	r3, [r3, #12]
 8002a60:	613b      	str	r3, [r7, #16]
        temp &= ~((uint32_t)iocurrent);
 8002a62:	68fb      	ldr	r3, [r7, #12]
 8002a64:	43da      	mvns	r2, r3
 8002a66:	693b      	ldr	r3, [r7, #16]
 8002a68:	4013      	ands	r3, r2
 8002a6a:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8002a6c:	683b      	ldr	r3, [r7, #0]
 8002a6e:	685a      	ldr	r2, [r3, #4]
 8002a70:	2380      	movs	r3, #128	; 0x80
 8002a72:	039b      	lsls	r3, r3, #14
 8002a74:	4013      	ands	r3, r2
 8002a76:	d003      	beq.n	8002a80 <HAL_GPIO_Init+0x2b8>
        {
          temp |= iocurrent;
 8002a78:	693a      	ldr	r2, [r7, #16]
 8002a7a:	68fb      	ldr	r3, [r7, #12]
 8002a7c:	4313      	orrs	r3, r2
 8002a7e:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR = temp;
 8002a80:	4b0f      	ldr	r3, [pc, #60]	; (8002ac0 <HAL_GPIO_Init+0x2f8>)
 8002a82:	693a      	ldr	r2, [r7, #16]
 8002a84:	60da      	str	r2, [r3, #12]
      }
    }
    position++;
 8002a86:	697b      	ldr	r3, [r7, #20]
 8002a88:	3301      	adds	r3, #1
 8002a8a:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0)
 8002a8c:	683b      	ldr	r3, [r7, #0]
 8002a8e:	681a      	ldr	r2, [r3, #0]
 8002a90:	697b      	ldr	r3, [r7, #20]
 8002a92:	40da      	lsrs	r2, r3
 8002a94:	1e13      	subs	r3, r2, #0
 8002a96:	d000      	beq.n	8002a9a <HAL_GPIO_Init+0x2d2>
 8002a98:	e6a2      	b.n	80027e0 <HAL_GPIO_Init+0x18>
  }
}
 8002a9a:	46c0      	nop			; (mov r8, r8)
 8002a9c:	46c0      	nop			; (mov r8, r8)
 8002a9e:	46bd      	mov	sp, r7
 8002aa0:	b006      	add	sp, #24
 8002aa2:	bd80      	pop	{r7, pc}
 8002aa4:	40021000 	.word	0x40021000
 8002aa8:	40010000 	.word	0x40010000
 8002aac:	50000400 	.word	0x50000400
 8002ab0:	50000800 	.word	0x50000800
 8002ab4:	50000c00 	.word	0x50000c00
 8002ab8:	50001000 	.word	0x50001000
 8002abc:	50001c00 	.word	0x50001c00
 8002ac0:	40010400 	.word	0x40010400

08002ac4 <HAL_GPIO_WritePin>:
  *                        GPIO_PIN_RESET: to clear the port pin
  *                        GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8002ac4:	b580      	push	{r7, lr}
 8002ac6:	b082      	sub	sp, #8
 8002ac8:	af00      	add	r7, sp, #0
 8002aca:	6078      	str	r0, [r7, #4]
 8002acc:	0008      	movs	r0, r1
 8002ace:	0011      	movs	r1, r2
 8002ad0:	1cbb      	adds	r3, r7, #2
 8002ad2:	1c02      	adds	r2, r0, #0
 8002ad4:	801a      	strh	r2, [r3, #0]
 8002ad6:	1c7b      	adds	r3, r7, #1
 8002ad8:	1c0a      	adds	r2, r1, #0
 8002ada:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN_AVAILABLE(GPIOx, GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8002adc:	1c7b      	adds	r3, r7, #1
 8002ade:	781b      	ldrb	r3, [r3, #0]
 8002ae0:	2b00      	cmp	r3, #0
 8002ae2:	d004      	beq.n	8002aee <HAL_GPIO_WritePin+0x2a>
  {
    GPIOx->BSRR = GPIO_Pin;
 8002ae4:	1cbb      	adds	r3, r7, #2
 8002ae6:	881a      	ldrh	r2, [r3, #0]
 8002ae8:	687b      	ldr	r3, [r7, #4]
 8002aea:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = GPIO_Pin ;
  }
}
 8002aec:	e003      	b.n	8002af6 <HAL_GPIO_WritePin+0x32>
    GPIOx->BRR = GPIO_Pin ;
 8002aee:	1cbb      	adds	r3, r7, #2
 8002af0:	881a      	ldrh	r2, [r3, #0]
 8002af2:	687b      	ldr	r3, [r7, #4]
 8002af4:	629a      	str	r2, [r3, #40]	; 0x28
}
 8002af6:	46c0      	nop			; (mov r8, r8)
 8002af8:	46bd      	mov	sp, r7
 8002afa:	b002      	add	sp, #8
 8002afc:	bd80      	pop	{r7, pc}
	...

08002b00 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8002b00:	b5b0      	push	{r4, r5, r7, lr}
 8002b02:	b08a      	sub	sp, #40	; 0x28
 8002b04:	af00      	add	r7, sp, #0
 8002b06:	6078      	str	r0, [r7, #4]
  uint32_t hsi_state;
  HAL_StatusTypeDef status;
  uint32_t sysclk_source, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8002b08:	687b      	ldr	r3, [r7, #4]
 8002b0a:	2b00      	cmp	r3, #0
 8002b0c:	d102      	bne.n	8002b14 <HAL_RCC_OscConfig+0x14>
  {
    return HAL_ERROR;
 8002b0e:	2301      	movs	r3, #1
 8002b10:	f000 fb6c 	bl	80031ec <HAL_RCC_OscConfig+0x6ec>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8002b14:	4bc8      	ldr	r3, [pc, #800]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002b16:	68db      	ldr	r3, [r3, #12]
 8002b18:	220c      	movs	r2, #12
 8002b1a:	4013      	ands	r3, r2
 8002b1c:	61fb      	str	r3, [r7, #28]
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 8002b1e:	4bc6      	ldr	r3, [pc, #792]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002b20:	68da      	ldr	r2, [r3, #12]
 8002b22:	2380      	movs	r3, #128	; 0x80
 8002b24:	025b      	lsls	r3, r3, #9
 8002b26:	4013      	ands	r3, r2
 8002b28:	61bb      	str	r3, [r7, #24]

  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8002b2a:	687b      	ldr	r3, [r7, #4]
 8002b2c:	681b      	ldr	r3, [r3, #0]
 8002b2e:	2201      	movs	r2, #1
 8002b30:	4013      	ands	r3, r2
 8002b32:	d100      	bne.n	8002b36 <HAL_RCC_OscConfig+0x36>
 8002b34:	e07d      	b.n	8002c32 <HAL_RCC_OscConfig+0x132>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 8002b36:	69fb      	ldr	r3, [r7, #28]
 8002b38:	2b08      	cmp	r3, #8
 8002b3a:	d007      	beq.n	8002b4c <HAL_RCC_OscConfig+0x4c>
       || ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 8002b3c:	69fb      	ldr	r3, [r7, #28]
 8002b3e:	2b0c      	cmp	r3, #12
 8002b40:	d112      	bne.n	8002b68 <HAL_RCC_OscConfig+0x68>
 8002b42:	69ba      	ldr	r2, [r7, #24]
 8002b44:	2380      	movs	r3, #128	; 0x80
 8002b46:	025b      	lsls	r3, r3, #9
 8002b48:	429a      	cmp	r2, r3
 8002b4a:	d10d      	bne.n	8002b68 <HAL_RCC_OscConfig+0x68>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8002b4c:	4bba      	ldr	r3, [pc, #744]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002b4e:	681a      	ldr	r2, [r3, #0]
 8002b50:	2380      	movs	r3, #128	; 0x80
 8002b52:	029b      	lsls	r3, r3, #10
 8002b54:	4013      	ands	r3, r2
 8002b56:	d100      	bne.n	8002b5a <HAL_RCC_OscConfig+0x5a>
 8002b58:	e06a      	b.n	8002c30 <HAL_RCC_OscConfig+0x130>
 8002b5a:	687b      	ldr	r3, [r7, #4]
 8002b5c:	685b      	ldr	r3, [r3, #4]
 8002b5e:	2b00      	cmp	r3, #0
 8002b60:	d166      	bne.n	8002c30 <HAL_RCC_OscConfig+0x130>
      {
        return HAL_ERROR;
 8002b62:	2301      	movs	r3, #1
 8002b64:	f000 fb42 	bl	80031ec <HAL_RCC_OscConfig+0x6ec>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002b68:	687b      	ldr	r3, [r7, #4]
 8002b6a:	685a      	ldr	r2, [r3, #4]
 8002b6c:	2380      	movs	r3, #128	; 0x80
 8002b6e:	025b      	lsls	r3, r3, #9
 8002b70:	429a      	cmp	r2, r3
 8002b72:	d107      	bne.n	8002b84 <HAL_RCC_OscConfig+0x84>
 8002b74:	4bb0      	ldr	r3, [pc, #704]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002b76:	681a      	ldr	r2, [r3, #0]
 8002b78:	4baf      	ldr	r3, [pc, #700]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002b7a:	2180      	movs	r1, #128	; 0x80
 8002b7c:	0249      	lsls	r1, r1, #9
 8002b7e:	430a      	orrs	r2, r1
 8002b80:	601a      	str	r2, [r3, #0]
 8002b82:	e027      	b.n	8002bd4 <HAL_RCC_OscConfig+0xd4>
 8002b84:	687b      	ldr	r3, [r7, #4]
 8002b86:	685a      	ldr	r2, [r3, #4]
 8002b88:	23a0      	movs	r3, #160	; 0xa0
 8002b8a:	02db      	lsls	r3, r3, #11
 8002b8c:	429a      	cmp	r2, r3
 8002b8e:	d10e      	bne.n	8002bae <HAL_RCC_OscConfig+0xae>
 8002b90:	4ba9      	ldr	r3, [pc, #676]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002b92:	681a      	ldr	r2, [r3, #0]
 8002b94:	4ba8      	ldr	r3, [pc, #672]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002b96:	2180      	movs	r1, #128	; 0x80
 8002b98:	02c9      	lsls	r1, r1, #11
 8002b9a:	430a      	orrs	r2, r1
 8002b9c:	601a      	str	r2, [r3, #0]
 8002b9e:	4ba6      	ldr	r3, [pc, #664]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002ba0:	681a      	ldr	r2, [r3, #0]
 8002ba2:	4ba5      	ldr	r3, [pc, #660]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002ba4:	2180      	movs	r1, #128	; 0x80
 8002ba6:	0249      	lsls	r1, r1, #9
 8002ba8:	430a      	orrs	r2, r1
 8002baa:	601a      	str	r2, [r3, #0]
 8002bac:	e012      	b.n	8002bd4 <HAL_RCC_OscConfig+0xd4>
 8002bae:	4ba2      	ldr	r3, [pc, #648]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002bb0:	681a      	ldr	r2, [r3, #0]
 8002bb2:	4ba1      	ldr	r3, [pc, #644]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002bb4:	49a1      	ldr	r1, [pc, #644]	; (8002e3c <HAL_RCC_OscConfig+0x33c>)
 8002bb6:	400a      	ands	r2, r1
 8002bb8:	601a      	str	r2, [r3, #0]
 8002bba:	4b9f      	ldr	r3, [pc, #636]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002bbc:	681a      	ldr	r2, [r3, #0]
 8002bbe:	2380      	movs	r3, #128	; 0x80
 8002bc0:	025b      	lsls	r3, r3, #9
 8002bc2:	4013      	ands	r3, r2
 8002bc4:	60fb      	str	r3, [r7, #12]
 8002bc6:	68fb      	ldr	r3, [r7, #12]
 8002bc8:	4b9b      	ldr	r3, [pc, #620]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002bca:	681a      	ldr	r2, [r3, #0]
 8002bcc:	4b9a      	ldr	r3, [pc, #616]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002bce:	499c      	ldr	r1, [pc, #624]	; (8002e40 <HAL_RCC_OscConfig+0x340>)
 8002bd0:	400a      	ands	r2, r1
 8002bd2:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8002bd4:	687b      	ldr	r3, [r7, #4]
 8002bd6:	685b      	ldr	r3, [r3, #4]
 8002bd8:	2b00      	cmp	r3, #0
 8002bda:	d014      	beq.n	8002c06 <HAL_RCC_OscConfig+0x106>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8002bdc:	f7ff fc60 	bl	80024a0 <HAL_GetTick>
 8002be0:	0003      	movs	r3, r0
 8002be2:	617b      	str	r3, [r7, #20]

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8002be4:	e008      	b.n	8002bf8 <HAL_RCC_OscConfig+0xf8>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8002be6:	f7ff fc5b 	bl	80024a0 <HAL_GetTick>
 8002bea:	0002      	movs	r2, r0
 8002bec:	697b      	ldr	r3, [r7, #20]
 8002bee:	1ad3      	subs	r3, r2, r3
 8002bf0:	2b64      	cmp	r3, #100	; 0x64
 8002bf2:	d901      	bls.n	8002bf8 <HAL_RCC_OscConfig+0xf8>
          {
            return HAL_TIMEOUT;
 8002bf4:	2303      	movs	r3, #3
 8002bf6:	e2f9      	b.n	80031ec <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8002bf8:	4b8f      	ldr	r3, [pc, #572]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002bfa:	681a      	ldr	r2, [r3, #0]
 8002bfc:	2380      	movs	r3, #128	; 0x80
 8002bfe:	029b      	lsls	r3, r3, #10
 8002c00:	4013      	ands	r3, r2
 8002c02:	d0f0      	beq.n	8002be6 <HAL_RCC_OscConfig+0xe6>
 8002c04:	e015      	b.n	8002c32 <HAL_RCC_OscConfig+0x132>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8002c06:	f7ff fc4b 	bl	80024a0 <HAL_GetTick>
 8002c0a:	0003      	movs	r3, r0
 8002c0c:	617b      	str	r3, [r7, #20]

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 8002c0e:	e008      	b.n	8002c22 <HAL_RCC_OscConfig+0x122>
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8002c10:	f7ff fc46 	bl	80024a0 <HAL_GetTick>
 8002c14:	0002      	movs	r2, r0
 8002c16:	697b      	ldr	r3, [r7, #20]
 8002c18:	1ad3      	subs	r3, r2, r3
 8002c1a:	2b64      	cmp	r3, #100	; 0x64
 8002c1c:	d901      	bls.n	8002c22 <HAL_RCC_OscConfig+0x122>
          {
            return HAL_TIMEOUT;
 8002c1e:	2303      	movs	r3, #3
 8002c20:	e2e4      	b.n	80031ec <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 8002c22:	4b85      	ldr	r3, [pc, #532]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002c24:	681a      	ldr	r2, [r3, #0]
 8002c26:	2380      	movs	r3, #128	; 0x80
 8002c28:	029b      	lsls	r3, r3, #10
 8002c2a:	4013      	ands	r3, r2
 8002c2c:	d1f0      	bne.n	8002c10 <HAL_RCC_OscConfig+0x110>
 8002c2e:	e000      	b.n	8002c32 <HAL_RCC_OscConfig+0x132>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8002c30:	46c0      	nop			; (mov r8, r8)
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8002c32:	687b      	ldr	r3, [r7, #4]
 8002c34:	681b      	ldr	r3, [r3, #0]
 8002c36:	2202      	movs	r2, #2
 8002c38:	4013      	ands	r3, r2
 8002c3a:	d100      	bne.n	8002c3e <HAL_RCC_OscConfig+0x13e>
 8002c3c:	e099      	b.n	8002d72 <HAL_RCC_OscConfig+0x272>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    hsi_state = RCC_OscInitStruct->HSIState;
 8002c3e:	687b      	ldr	r3, [r7, #4]
 8002c40:	68db      	ldr	r3, [r3, #12]
 8002c42:	627b      	str	r3, [r7, #36]	; 0x24

#if defined(RCC_CR_HSIOUTEN)
    if((hsi_state & RCC_HSI_OUTEN) != 0U)
 8002c44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002c46:	2220      	movs	r2, #32
 8002c48:	4013      	ands	r3, r2
 8002c4a:	d009      	beq.n	8002c60 <HAL_RCC_OscConfig+0x160>
    {
      /* HSI Output enable for timer requested */
      SET_BIT(RCC->CR, RCC_CR_HSIOUTEN);
 8002c4c:	4b7a      	ldr	r3, [pc, #488]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002c4e:	681a      	ldr	r2, [r3, #0]
 8002c50:	4b79      	ldr	r3, [pc, #484]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002c52:	2120      	movs	r1, #32
 8002c54:	430a      	orrs	r2, r1
 8002c56:	601a      	str	r2, [r3, #0]

      hsi_state &= ~RCC_CR_HSIOUTEN;
 8002c58:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002c5a:	2220      	movs	r2, #32
 8002c5c:	4393      	bics	r3, r2
 8002c5e:	627b      	str	r3, [r7, #36]	; 0x24
    }
#endif

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 8002c60:	69fb      	ldr	r3, [r7, #28]
 8002c62:	2b04      	cmp	r3, #4
 8002c64:	d005      	beq.n	8002c72 <HAL_RCC_OscConfig+0x172>
       || ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 8002c66:	69fb      	ldr	r3, [r7, #28]
 8002c68:	2b0c      	cmp	r3, #12
 8002c6a:	d13e      	bne.n	8002cea <HAL_RCC_OscConfig+0x1ea>
 8002c6c:	69bb      	ldr	r3, [r7, #24]
 8002c6e:	2b00      	cmp	r3, #0
 8002c70:	d13b      	bne.n	8002cea <HAL_RCC_OscConfig+0x1ea>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (hsi_state == RCC_HSI_OFF))
 8002c72:	4b71      	ldr	r3, [pc, #452]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002c74:	681b      	ldr	r3, [r3, #0]
 8002c76:	2204      	movs	r2, #4
 8002c78:	4013      	ands	r3, r2
 8002c7a:	d004      	beq.n	8002c86 <HAL_RCC_OscConfig+0x186>
 8002c7c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002c7e:	2b00      	cmp	r3, #0
 8002c80:	d101      	bne.n	8002c86 <HAL_RCC_OscConfig+0x186>
      {
        return HAL_ERROR;
 8002c82:	2301      	movs	r3, #1
 8002c84:	e2b2      	b.n	80031ec <HAL_RCC_OscConfig+0x6ec>
      }
      /* Otherwise, just the calibration and HSI or HSIdiv4 are allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002c86:	4b6c      	ldr	r3, [pc, #432]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002c88:	685b      	ldr	r3, [r3, #4]
 8002c8a:	4a6e      	ldr	r2, [pc, #440]	; (8002e44 <HAL_RCC_OscConfig+0x344>)
 8002c8c:	4013      	ands	r3, r2
 8002c8e:	0019      	movs	r1, r3
 8002c90:	687b      	ldr	r3, [r7, #4]
 8002c92:	691b      	ldr	r3, [r3, #16]
 8002c94:	021a      	lsls	r2, r3, #8
 8002c96:	4b68      	ldr	r3, [pc, #416]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002c98:	430a      	orrs	r2, r1
 8002c9a:	605a      	str	r2, [r3, #4]

        /* Enable the Internal High Speed oscillator (HSI or HSIdiv4) */
        __HAL_RCC_HSI_CONFIG(hsi_state);
 8002c9c:	4b66      	ldr	r3, [pc, #408]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002c9e:	681b      	ldr	r3, [r3, #0]
 8002ca0:	2209      	movs	r2, #9
 8002ca2:	4393      	bics	r3, r2
 8002ca4:	0019      	movs	r1, r3
 8002ca6:	4b64      	ldr	r3, [pc, #400]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002ca8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002caa:	430a      	orrs	r2, r1
 8002cac:	601a      	str	r2, [r3, #0]
      }

      /* Update the SystemCoreClock global variable */
      SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8002cae:	f000 fbeb 	bl	8003488 <HAL_RCC_GetSysClockFreq>
 8002cb2:	0001      	movs	r1, r0
 8002cb4:	4b60      	ldr	r3, [pc, #384]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002cb6:	68db      	ldr	r3, [r3, #12]
 8002cb8:	091b      	lsrs	r3, r3, #4
 8002cba:	220f      	movs	r2, #15
 8002cbc:	4013      	ands	r3, r2
 8002cbe:	4a62      	ldr	r2, [pc, #392]	; (8002e48 <HAL_RCC_OscConfig+0x348>)
 8002cc0:	5cd3      	ldrb	r3, [r2, r3]
 8002cc2:	000a      	movs	r2, r1
 8002cc4:	40da      	lsrs	r2, r3
 8002cc6:	4b61      	ldr	r3, [pc, #388]	; (8002e4c <HAL_RCC_OscConfig+0x34c>)
 8002cc8:	601a      	str	r2, [r3, #0]

      /* Configure the source of time base considering new system clocks settings*/
      status = HAL_InitTick (uwTickPrio);
 8002cca:	4b61      	ldr	r3, [pc, #388]	; (8002e50 <HAL_RCC_OscConfig+0x350>)
 8002ccc:	681b      	ldr	r3, [r3, #0]
 8002cce:	2513      	movs	r5, #19
 8002cd0:	197c      	adds	r4, r7, r5
 8002cd2:	0018      	movs	r0, r3
 8002cd4:	f7ff fb9e 	bl	8002414 <HAL_InitTick>
 8002cd8:	0003      	movs	r3, r0
 8002cda:	7023      	strb	r3, [r4, #0]
      if(status != HAL_OK)
 8002cdc:	197b      	adds	r3, r7, r5
 8002cde:	781b      	ldrb	r3, [r3, #0]
 8002ce0:	2b00      	cmp	r3, #0
 8002ce2:	d046      	beq.n	8002d72 <HAL_RCC_OscConfig+0x272>
      {
        return status;
 8002ce4:	197b      	adds	r3, r7, r5
 8002ce6:	781b      	ldrb	r3, [r3, #0]
 8002ce8:	e280      	b.n	80031ec <HAL_RCC_OscConfig+0x6ec>
      }
    }
    else
    {
      /* Check the HSI State */
      if(hsi_state != RCC_HSI_OFF)
 8002cea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002cec:	2b00      	cmp	r3, #0
 8002cee:	d027      	beq.n	8002d40 <HAL_RCC_OscConfig+0x240>
      {
        /* Enable the Internal High Speed oscillator (HSI or HSIdiv4) */
        __HAL_RCC_HSI_CONFIG(hsi_state);
 8002cf0:	4b51      	ldr	r3, [pc, #324]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002cf2:	681b      	ldr	r3, [r3, #0]
 8002cf4:	2209      	movs	r2, #9
 8002cf6:	4393      	bics	r3, r2
 8002cf8:	0019      	movs	r1, r3
 8002cfa:	4b4f      	ldr	r3, [pc, #316]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002cfc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002cfe:	430a      	orrs	r2, r1
 8002d00:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8002d02:	f7ff fbcd 	bl	80024a0 <HAL_GetTick>
 8002d06:	0003      	movs	r3, r0
 8002d08:	617b      	str	r3, [r7, #20]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8002d0a:	e008      	b.n	8002d1e <HAL_RCC_OscConfig+0x21e>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8002d0c:	f7ff fbc8 	bl	80024a0 <HAL_GetTick>
 8002d10:	0002      	movs	r2, r0
 8002d12:	697b      	ldr	r3, [r7, #20]
 8002d14:	1ad3      	subs	r3, r2, r3
 8002d16:	2b02      	cmp	r3, #2
 8002d18:	d901      	bls.n	8002d1e <HAL_RCC_OscConfig+0x21e>
          {
            return HAL_TIMEOUT;
 8002d1a:	2303      	movs	r3, #3
 8002d1c:	e266      	b.n	80031ec <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8002d1e:	4b46      	ldr	r3, [pc, #280]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002d20:	681b      	ldr	r3, [r3, #0]
 8002d22:	2204      	movs	r2, #4
 8002d24:	4013      	ands	r3, r2
 8002d26:	d0f1      	beq.n	8002d0c <HAL_RCC_OscConfig+0x20c>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002d28:	4b43      	ldr	r3, [pc, #268]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002d2a:	685b      	ldr	r3, [r3, #4]
 8002d2c:	4a45      	ldr	r2, [pc, #276]	; (8002e44 <HAL_RCC_OscConfig+0x344>)
 8002d2e:	4013      	ands	r3, r2
 8002d30:	0019      	movs	r1, r3
 8002d32:	687b      	ldr	r3, [r7, #4]
 8002d34:	691b      	ldr	r3, [r3, #16]
 8002d36:	021a      	lsls	r2, r3, #8
 8002d38:	4b3f      	ldr	r3, [pc, #252]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002d3a:	430a      	orrs	r2, r1
 8002d3c:	605a      	str	r2, [r3, #4]
 8002d3e:	e018      	b.n	8002d72 <HAL_RCC_OscConfig+0x272>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8002d40:	4b3d      	ldr	r3, [pc, #244]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002d42:	681a      	ldr	r2, [r3, #0]
 8002d44:	4b3c      	ldr	r3, [pc, #240]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002d46:	2101      	movs	r1, #1
 8002d48:	438a      	bics	r2, r1
 8002d4a:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8002d4c:	f7ff fba8 	bl	80024a0 <HAL_GetTick>
 8002d50:	0003      	movs	r3, r0
 8002d52:	617b      	str	r3, [r7, #20]

        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 8002d54:	e008      	b.n	8002d68 <HAL_RCC_OscConfig+0x268>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8002d56:	f7ff fba3 	bl	80024a0 <HAL_GetTick>
 8002d5a:	0002      	movs	r2, r0
 8002d5c:	697b      	ldr	r3, [r7, #20]
 8002d5e:	1ad3      	subs	r3, r2, r3
 8002d60:	2b02      	cmp	r3, #2
 8002d62:	d901      	bls.n	8002d68 <HAL_RCC_OscConfig+0x268>
          {
            return HAL_TIMEOUT;
 8002d64:	2303      	movs	r3, #3
 8002d66:	e241      	b.n	80031ec <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 8002d68:	4b33      	ldr	r3, [pc, #204]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002d6a:	681b      	ldr	r3, [r3, #0]
 8002d6c:	2204      	movs	r2, #4
 8002d6e:	4013      	ands	r3, r2
 8002d70:	d1f1      	bne.n	8002d56 <HAL_RCC_OscConfig+0x256>
        }
      }
    }
  }
  /*----------------------------- MSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8002d72:	687b      	ldr	r3, [r7, #4]
 8002d74:	681b      	ldr	r3, [r3, #0]
 8002d76:	2210      	movs	r2, #16
 8002d78:	4013      	ands	r3, r2
 8002d7a:	d100      	bne.n	8002d7e <HAL_RCC_OscConfig+0x27e>
 8002d7c:	e0a1      	b.n	8002ec2 <HAL_RCC_OscConfig+0x3c2>
  {
    /* When the MSI is used as system clock it will not be disabled */
    if(sysclk_source == RCC_CFGR_SWS_MSI)
 8002d7e:	69fb      	ldr	r3, [r7, #28]
 8002d80:	2b00      	cmp	r3, #0
 8002d82:	d140      	bne.n	8002e06 <HAL_RCC_OscConfig+0x306>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8002d84:	4b2c      	ldr	r3, [pc, #176]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002d86:	681a      	ldr	r2, [r3, #0]
 8002d88:	2380      	movs	r3, #128	; 0x80
 8002d8a:	009b      	lsls	r3, r3, #2
 8002d8c:	4013      	ands	r3, r2
 8002d8e:	d005      	beq.n	8002d9c <HAL_RCC_OscConfig+0x29c>
 8002d90:	687b      	ldr	r3, [r7, #4]
 8002d92:	699b      	ldr	r3, [r3, #24]
 8002d94:	2b00      	cmp	r3, #0
 8002d96:	d101      	bne.n	8002d9c <HAL_RCC_OscConfig+0x29c>
      {
        return HAL_ERROR;
 8002d98:	2301      	movs	r3, #1
 8002d9a:	e227      	b.n	80031ec <HAL_RCC_OscConfig+0x6ec>
        /* Check MSICalibrationValue and MSIClockRange input parameters */
        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8002d9c:	4b26      	ldr	r3, [pc, #152]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002d9e:	685b      	ldr	r3, [r3, #4]
 8002da0:	4a2c      	ldr	r2, [pc, #176]	; (8002e54 <HAL_RCC_OscConfig+0x354>)
 8002da2:	4013      	ands	r3, r2
 8002da4:	0019      	movs	r1, r3
 8002da6:	687b      	ldr	r3, [r7, #4]
 8002da8:	6a1a      	ldr	r2, [r3, #32]
 8002daa:	4b23      	ldr	r3, [pc, #140]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002dac:	430a      	orrs	r2, r1
 8002dae:	605a      	str	r2, [r3, #4]
        /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8002db0:	4b21      	ldr	r3, [pc, #132]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002db2:	685b      	ldr	r3, [r3, #4]
 8002db4:	021b      	lsls	r3, r3, #8
 8002db6:	0a19      	lsrs	r1, r3, #8
 8002db8:	687b      	ldr	r3, [r7, #4]
 8002dba:	69db      	ldr	r3, [r3, #28]
 8002dbc:	061a      	lsls	r2, r3, #24
 8002dbe:	4b1e      	ldr	r3, [pc, #120]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002dc0:	430a      	orrs	r2, r1
 8002dc2:	605a      	str	r2, [r3, #4]


        /* Update the SystemCoreClock global variable */
        SystemCoreClock =  (32768U * (1UL << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_Pos) + 1U)))
 8002dc4:	687b      	ldr	r3, [r7, #4]
 8002dc6:	6a1b      	ldr	r3, [r3, #32]
 8002dc8:	0b5b      	lsrs	r3, r3, #13
 8002dca:	3301      	adds	r3, #1
 8002dcc:	2280      	movs	r2, #128	; 0x80
 8002dce:	0212      	lsls	r2, r2, #8
 8002dd0:	409a      	lsls	r2, r3
                           >> AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos)];
 8002dd2:	4b19      	ldr	r3, [pc, #100]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002dd4:	68db      	ldr	r3, [r3, #12]
 8002dd6:	091b      	lsrs	r3, r3, #4
 8002dd8:	210f      	movs	r1, #15
 8002dda:	400b      	ands	r3, r1
 8002ddc:	491a      	ldr	r1, [pc, #104]	; (8002e48 <HAL_RCC_OscConfig+0x348>)
 8002dde:	5ccb      	ldrb	r3, [r1, r3]
 8002de0:	40da      	lsrs	r2, r3
        SystemCoreClock =  (32768U * (1UL << ((RCC_OscInitStruct->MSIClockRange >> RCC_ICSCR_MSIRANGE_Pos) + 1U)))
 8002de2:	4b1a      	ldr	r3, [pc, #104]	; (8002e4c <HAL_RCC_OscConfig+0x34c>)
 8002de4:	601a      	str	r2, [r3, #0]

        /* Configure the source of time base considering new system clocks settings*/
        status = HAL_InitTick (uwTickPrio);
 8002de6:	4b1a      	ldr	r3, [pc, #104]	; (8002e50 <HAL_RCC_OscConfig+0x350>)
 8002de8:	681b      	ldr	r3, [r3, #0]
 8002dea:	2513      	movs	r5, #19
 8002dec:	197c      	adds	r4, r7, r5
 8002dee:	0018      	movs	r0, r3
 8002df0:	f7ff fb10 	bl	8002414 <HAL_InitTick>
 8002df4:	0003      	movs	r3, r0
 8002df6:	7023      	strb	r3, [r4, #0]
        if(status != HAL_OK)
 8002df8:	197b      	adds	r3, r7, r5
 8002dfa:	781b      	ldrb	r3, [r3, #0]
 8002dfc:	2b00      	cmp	r3, #0
 8002dfe:	d060      	beq.n	8002ec2 <HAL_RCC_OscConfig+0x3c2>
        {
          return status;
 8002e00:	197b      	adds	r3, r7, r5
 8002e02:	781b      	ldrb	r3, [r3, #0]
 8002e04:	e1f2      	b.n	80031ec <HAL_RCC_OscConfig+0x6ec>
    {
      /* Check MSI State */
      assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));

      /* Check the MSI State */
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8002e06:	687b      	ldr	r3, [r7, #4]
 8002e08:	699b      	ldr	r3, [r3, #24]
 8002e0a:	2b00      	cmp	r3, #0
 8002e0c:	d03f      	beq.n	8002e8e <HAL_RCC_OscConfig+0x38e>
      {
        /* Enable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 8002e0e:	4b0a      	ldr	r3, [pc, #40]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002e10:	681a      	ldr	r2, [r3, #0]
 8002e12:	4b09      	ldr	r3, [pc, #36]	; (8002e38 <HAL_RCC_OscConfig+0x338>)
 8002e14:	2180      	movs	r1, #128	; 0x80
 8002e16:	0049      	lsls	r1, r1, #1
 8002e18:	430a      	orrs	r2, r1
 8002e1a:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8002e1c:	f7ff fb40 	bl	80024a0 <HAL_GetTick>
 8002e20:	0003      	movs	r3, r0
 8002e22:	617b      	str	r3, [r7, #20]

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 8002e24:	e018      	b.n	8002e58 <HAL_RCC_OscConfig+0x358>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8002e26:	f7ff fb3b 	bl	80024a0 <HAL_GetTick>
 8002e2a:	0002      	movs	r2, r0
 8002e2c:	697b      	ldr	r3, [r7, #20]
 8002e2e:	1ad3      	subs	r3, r2, r3
 8002e30:	2b02      	cmp	r3, #2
 8002e32:	d911      	bls.n	8002e58 <HAL_RCC_OscConfig+0x358>
          {
            return HAL_TIMEOUT;
 8002e34:	2303      	movs	r3, #3
 8002e36:	e1d9      	b.n	80031ec <HAL_RCC_OscConfig+0x6ec>
 8002e38:	40021000 	.word	0x40021000
 8002e3c:	fffeffff 	.word	0xfffeffff
 8002e40:	fffbffff 	.word	0xfffbffff
 8002e44:	ffffe0ff 	.word	0xffffe0ff
 8002e48:	080214f0 	.word	0x080214f0
 8002e4c:	20000204 	.word	0x20000204
 8002e50:	20000208 	.word	0x20000208
 8002e54:	ffff1fff 	.word	0xffff1fff
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 8002e58:	4bc9      	ldr	r3, [pc, #804]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002e5a:	681a      	ldr	r2, [r3, #0]
 8002e5c:	2380      	movs	r3, #128	; 0x80
 8002e5e:	009b      	lsls	r3, r3, #2
 8002e60:	4013      	ands	r3, r2
 8002e62:	d0e0      	beq.n	8002e26 <HAL_RCC_OscConfig+0x326>
        /* Check MSICalibrationValue and MSIClockRange input parameters */
        assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
        assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8002e64:	4bc6      	ldr	r3, [pc, #792]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002e66:	685b      	ldr	r3, [r3, #4]
 8002e68:	4ac6      	ldr	r2, [pc, #792]	; (8003184 <HAL_RCC_OscConfig+0x684>)
 8002e6a:	4013      	ands	r3, r2
 8002e6c:	0019      	movs	r1, r3
 8002e6e:	687b      	ldr	r3, [r7, #4]
 8002e70:	6a1a      	ldr	r2, [r3, #32]
 8002e72:	4bc3      	ldr	r3, [pc, #780]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002e74:	430a      	orrs	r2, r1
 8002e76:	605a      	str	r2, [r3, #4]
         /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8002e78:	4bc1      	ldr	r3, [pc, #772]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002e7a:	685b      	ldr	r3, [r3, #4]
 8002e7c:	021b      	lsls	r3, r3, #8
 8002e7e:	0a19      	lsrs	r1, r3, #8
 8002e80:	687b      	ldr	r3, [r7, #4]
 8002e82:	69db      	ldr	r3, [r3, #28]
 8002e84:	061a      	lsls	r2, r3, #24
 8002e86:	4bbe      	ldr	r3, [pc, #760]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002e88:	430a      	orrs	r2, r1
 8002e8a:	605a      	str	r2, [r3, #4]
 8002e8c:	e019      	b.n	8002ec2 <HAL_RCC_OscConfig+0x3c2>
      }
      else
      {
        /* Disable the Multi Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 8002e8e:	4bbc      	ldr	r3, [pc, #752]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002e90:	681a      	ldr	r2, [r3, #0]
 8002e92:	4bbb      	ldr	r3, [pc, #748]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002e94:	49bc      	ldr	r1, [pc, #752]	; (8003188 <HAL_RCC_OscConfig+0x688>)
 8002e96:	400a      	ands	r2, r1
 8002e98:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8002e9a:	f7ff fb01 	bl	80024a0 <HAL_GetTick>
 8002e9e:	0003      	movs	r3, r0
 8002ea0:	617b      	str	r3, [r7, #20]

        /* Wait till MSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U)
 8002ea2:	e008      	b.n	8002eb6 <HAL_RCC_OscConfig+0x3b6>
        {
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8002ea4:	f7ff fafc 	bl	80024a0 <HAL_GetTick>
 8002ea8:	0002      	movs	r2, r0
 8002eaa:	697b      	ldr	r3, [r7, #20]
 8002eac:	1ad3      	subs	r3, r2, r3
 8002eae:	2b02      	cmp	r3, #2
 8002eb0:	d901      	bls.n	8002eb6 <HAL_RCC_OscConfig+0x3b6>
          {
            return HAL_TIMEOUT;
 8002eb2:	2303      	movs	r3, #3
 8002eb4:	e19a      	b.n	80031ec <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) != 0U)
 8002eb6:	4bb2      	ldr	r3, [pc, #712]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002eb8:	681a      	ldr	r2, [r3, #0]
 8002eba:	2380      	movs	r3, #128	; 0x80
 8002ebc:	009b      	lsls	r3, r3, #2
 8002ebe:	4013      	ands	r3, r2
 8002ec0:	d1f0      	bne.n	8002ea4 <HAL_RCC_OscConfig+0x3a4>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8002ec2:	687b      	ldr	r3, [r7, #4]
 8002ec4:	681b      	ldr	r3, [r3, #0]
 8002ec6:	2208      	movs	r2, #8
 8002ec8:	4013      	ands	r3, r2
 8002eca:	d036      	beq.n	8002f3a <HAL_RCC_OscConfig+0x43a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8002ecc:	687b      	ldr	r3, [r7, #4]
 8002ece:	695b      	ldr	r3, [r3, #20]
 8002ed0:	2b00      	cmp	r3, #0
 8002ed2:	d019      	beq.n	8002f08 <HAL_RCC_OscConfig+0x408>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8002ed4:	4baa      	ldr	r3, [pc, #680]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002ed6:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8002ed8:	4ba9      	ldr	r3, [pc, #676]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002eda:	2101      	movs	r1, #1
 8002edc:	430a      	orrs	r2, r1
 8002ede:	651a      	str	r2, [r3, #80]	; 0x50

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8002ee0:	f7ff fade 	bl	80024a0 <HAL_GetTick>
 8002ee4:	0003      	movs	r3, r0
 8002ee6:	617b      	str	r3, [r7, #20]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8002ee8:	e008      	b.n	8002efc <HAL_RCC_OscConfig+0x3fc>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8002eea:	f7ff fad9 	bl	80024a0 <HAL_GetTick>
 8002eee:	0002      	movs	r2, r0
 8002ef0:	697b      	ldr	r3, [r7, #20]
 8002ef2:	1ad3      	subs	r3, r2, r3
 8002ef4:	2b02      	cmp	r3, #2
 8002ef6:	d901      	bls.n	8002efc <HAL_RCC_OscConfig+0x3fc>
        {
          return HAL_TIMEOUT;
 8002ef8:	2303      	movs	r3, #3
 8002efa:	e177      	b.n	80031ec <HAL_RCC_OscConfig+0x6ec>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8002efc:	4ba0      	ldr	r3, [pc, #640]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002efe:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8002f00:	2202      	movs	r2, #2
 8002f02:	4013      	ands	r3, r2
 8002f04:	d0f1      	beq.n	8002eea <HAL_RCC_OscConfig+0x3ea>
 8002f06:	e018      	b.n	8002f3a <HAL_RCC_OscConfig+0x43a>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8002f08:	4b9d      	ldr	r3, [pc, #628]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002f0a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8002f0c:	4b9c      	ldr	r3, [pc, #624]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002f0e:	2101      	movs	r1, #1
 8002f10:	438a      	bics	r2, r1
 8002f12:	651a      	str	r2, [r3, #80]	; 0x50

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8002f14:	f7ff fac4 	bl	80024a0 <HAL_GetTick>
 8002f18:	0003      	movs	r3, r0
 8002f1a:	617b      	str	r3, [r7, #20]

      /* Wait till LSI is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 8002f1c:	e008      	b.n	8002f30 <HAL_RCC_OscConfig+0x430>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8002f1e:	f7ff fabf 	bl	80024a0 <HAL_GetTick>
 8002f22:	0002      	movs	r2, r0
 8002f24:	697b      	ldr	r3, [r7, #20]
 8002f26:	1ad3      	subs	r3, r2, r3
 8002f28:	2b02      	cmp	r3, #2
 8002f2a:	d901      	bls.n	8002f30 <HAL_RCC_OscConfig+0x430>
        {
          return HAL_TIMEOUT;
 8002f2c:	2303      	movs	r3, #3
 8002f2e:	e15d      	b.n	80031ec <HAL_RCC_OscConfig+0x6ec>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 8002f30:	4b93      	ldr	r3, [pc, #588]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002f32:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8002f34:	2202      	movs	r2, #2
 8002f36:	4013      	ands	r3, r2
 8002f38:	d1f1      	bne.n	8002f1e <HAL_RCC_OscConfig+0x41e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8002f3a:	687b      	ldr	r3, [r7, #4]
 8002f3c:	681b      	ldr	r3, [r3, #0]
 8002f3e:	2204      	movs	r2, #4
 8002f40:	4013      	ands	r3, r2
 8002f42:	d100      	bne.n	8002f46 <HAL_RCC_OscConfig+0x446>
 8002f44:	e0ae      	b.n	80030a4 <HAL_RCC_OscConfig+0x5a4>
  {
    FlagStatus       pwrclkchanged = RESET;
 8002f46:	2023      	movs	r0, #35	; 0x23
 8002f48:	183b      	adds	r3, r7, r0
 8002f4a:	2200      	movs	r2, #0
 8002f4c:	701a      	strb	r2, [r3, #0]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8002f4e:	4b8c      	ldr	r3, [pc, #560]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002f50:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002f52:	2380      	movs	r3, #128	; 0x80
 8002f54:	055b      	lsls	r3, r3, #21
 8002f56:	4013      	ands	r3, r2
 8002f58:	d109      	bne.n	8002f6e <HAL_RCC_OscConfig+0x46e>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8002f5a:	4b89      	ldr	r3, [pc, #548]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002f5c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002f5e:	4b88      	ldr	r3, [pc, #544]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002f60:	2180      	movs	r1, #128	; 0x80
 8002f62:	0549      	lsls	r1, r1, #21
 8002f64:	430a      	orrs	r2, r1
 8002f66:	639a      	str	r2, [r3, #56]	; 0x38
      pwrclkchanged = SET;
 8002f68:	183b      	adds	r3, r7, r0
 8002f6a:	2201      	movs	r2, #1
 8002f6c:	701a      	strb	r2, [r3, #0]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002f6e:	4b87      	ldr	r3, [pc, #540]	; (800318c <HAL_RCC_OscConfig+0x68c>)
 8002f70:	681a      	ldr	r2, [r3, #0]
 8002f72:	2380      	movs	r3, #128	; 0x80
 8002f74:	005b      	lsls	r3, r3, #1
 8002f76:	4013      	ands	r3, r2
 8002f78:	d11a      	bne.n	8002fb0 <HAL_RCC_OscConfig+0x4b0>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8002f7a:	4b84      	ldr	r3, [pc, #528]	; (800318c <HAL_RCC_OscConfig+0x68c>)
 8002f7c:	681a      	ldr	r2, [r3, #0]
 8002f7e:	4b83      	ldr	r3, [pc, #524]	; (800318c <HAL_RCC_OscConfig+0x68c>)
 8002f80:	2180      	movs	r1, #128	; 0x80
 8002f82:	0049      	lsls	r1, r1, #1
 8002f84:	430a      	orrs	r2, r1
 8002f86:	601a      	str	r2, [r3, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8002f88:	f7ff fa8a 	bl	80024a0 <HAL_GetTick>
 8002f8c:	0003      	movs	r3, r0
 8002f8e:	617b      	str	r3, [r7, #20]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002f90:	e008      	b.n	8002fa4 <HAL_RCC_OscConfig+0x4a4>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8002f92:	f7ff fa85 	bl	80024a0 <HAL_GetTick>
 8002f96:	0002      	movs	r2, r0
 8002f98:	697b      	ldr	r3, [r7, #20]
 8002f9a:	1ad3      	subs	r3, r2, r3
 8002f9c:	2b64      	cmp	r3, #100	; 0x64
 8002f9e:	d901      	bls.n	8002fa4 <HAL_RCC_OscConfig+0x4a4>
        {
          return HAL_TIMEOUT;
 8002fa0:	2303      	movs	r3, #3
 8002fa2:	e123      	b.n	80031ec <HAL_RCC_OscConfig+0x6ec>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002fa4:	4b79      	ldr	r3, [pc, #484]	; (800318c <HAL_RCC_OscConfig+0x68c>)
 8002fa6:	681a      	ldr	r2, [r3, #0]
 8002fa8:	2380      	movs	r3, #128	; 0x80
 8002faa:	005b      	lsls	r3, r3, #1
 8002fac:	4013      	ands	r3, r2
 8002fae:	d0f0      	beq.n	8002f92 <HAL_RCC_OscConfig+0x492>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002fb0:	687b      	ldr	r3, [r7, #4]
 8002fb2:	689a      	ldr	r2, [r3, #8]
 8002fb4:	2380      	movs	r3, #128	; 0x80
 8002fb6:	005b      	lsls	r3, r3, #1
 8002fb8:	429a      	cmp	r2, r3
 8002fba:	d107      	bne.n	8002fcc <HAL_RCC_OscConfig+0x4cc>
 8002fbc:	4b70      	ldr	r3, [pc, #448]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002fbe:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8002fc0:	4b6f      	ldr	r3, [pc, #444]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002fc2:	2180      	movs	r1, #128	; 0x80
 8002fc4:	0049      	lsls	r1, r1, #1
 8002fc6:	430a      	orrs	r2, r1
 8002fc8:	651a      	str	r2, [r3, #80]	; 0x50
 8002fca:	e031      	b.n	8003030 <HAL_RCC_OscConfig+0x530>
 8002fcc:	687b      	ldr	r3, [r7, #4]
 8002fce:	689b      	ldr	r3, [r3, #8]
 8002fd0:	2b00      	cmp	r3, #0
 8002fd2:	d10c      	bne.n	8002fee <HAL_RCC_OscConfig+0x4ee>
 8002fd4:	4b6a      	ldr	r3, [pc, #424]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002fd6:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8002fd8:	4b69      	ldr	r3, [pc, #420]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002fda:	496b      	ldr	r1, [pc, #428]	; (8003188 <HAL_RCC_OscConfig+0x688>)
 8002fdc:	400a      	ands	r2, r1
 8002fde:	651a      	str	r2, [r3, #80]	; 0x50
 8002fe0:	4b67      	ldr	r3, [pc, #412]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002fe2:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8002fe4:	4b66      	ldr	r3, [pc, #408]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002fe6:	496a      	ldr	r1, [pc, #424]	; (8003190 <HAL_RCC_OscConfig+0x690>)
 8002fe8:	400a      	ands	r2, r1
 8002fea:	651a      	str	r2, [r3, #80]	; 0x50
 8002fec:	e020      	b.n	8003030 <HAL_RCC_OscConfig+0x530>
 8002fee:	687b      	ldr	r3, [r7, #4]
 8002ff0:	689a      	ldr	r2, [r3, #8]
 8002ff2:	23a0      	movs	r3, #160	; 0xa0
 8002ff4:	00db      	lsls	r3, r3, #3
 8002ff6:	429a      	cmp	r2, r3
 8002ff8:	d10e      	bne.n	8003018 <HAL_RCC_OscConfig+0x518>
 8002ffa:	4b61      	ldr	r3, [pc, #388]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8002ffc:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8002ffe:	4b60      	ldr	r3, [pc, #384]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8003000:	2180      	movs	r1, #128	; 0x80
 8003002:	00c9      	lsls	r1, r1, #3
 8003004:	430a      	orrs	r2, r1
 8003006:	651a      	str	r2, [r3, #80]	; 0x50
 8003008:	4b5d      	ldr	r3, [pc, #372]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 800300a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800300c:	4b5c      	ldr	r3, [pc, #368]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 800300e:	2180      	movs	r1, #128	; 0x80
 8003010:	0049      	lsls	r1, r1, #1
 8003012:	430a      	orrs	r2, r1
 8003014:	651a      	str	r2, [r3, #80]	; 0x50
 8003016:	e00b      	b.n	8003030 <HAL_RCC_OscConfig+0x530>
 8003018:	4b59      	ldr	r3, [pc, #356]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 800301a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800301c:	4b58      	ldr	r3, [pc, #352]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 800301e:	495a      	ldr	r1, [pc, #360]	; (8003188 <HAL_RCC_OscConfig+0x688>)
 8003020:	400a      	ands	r2, r1
 8003022:	651a      	str	r2, [r3, #80]	; 0x50
 8003024:	4b56      	ldr	r3, [pc, #344]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8003026:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003028:	4b55      	ldr	r3, [pc, #340]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 800302a:	4959      	ldr	r1, [pc, #356]	; (8003190 <HAL_RCC_OscConfig+0x690>)
 800302c:	400a      	ands	r2, r1
 800302e:	651a      	str	r2, [r3, #80]	; 0x50

    /* Check the LSE State */
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8003030:	687b      	ldr	r3, [r7, #4]
 8003032:	689b      	ldr	r3, [r3, #8]
 8003034:	2b00      	cmp	r3, #0
 8003036:	d015      	beq.n	8003064 <HAL_RCC_OscConfig+0x564>
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8003038:	f7ff fa32 	bl	80024a0 <HAL_GetTick>
 800303c:	0003      	movs	r3, r0
 800303e:	617b      	str	r3, [r7, #20]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8003040:	e009      	b.n	8003056 <HAL_RCC_OscConfig+0x556>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8003042:	f7ff fa2d 	bl	80024a0 <HAL_GetTick>
 8003046:	0002      	movs	r2, r0
 8003048:	697b      	ldr	r3, [r7, #20]
 800304a:	1ad3      	subs	r3, r2, r3
 800304c:	4a51      	ldr	r2, [pc, #324]	; (8003194 <HAL_RCC_OscConfig+0x694>)
 800304e:	4293      	cmp	r3, r2
 8003050:	d901      	bls.n	8003056 <HAL_RCC_OscConfig+0x556>
        {
          return HAL_TIMEOUT;
 8003052:	2303      	movs	r3, #3
 8003054:	e0ca      	b.n	80031ec <HAL_RCC_OscConfig+0x6ec>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8003056:	4b4a      	ldr	r3, [pc, #296]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8003058:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800305a:	2380      	movs	r3, #128	; 0x80
 800305c:	009b      	lsls	r3, r3, #2
 800305e:	4013      	ands	r3, r2
 8003060:	d0ef      	beq.n	8003042 <HAL_RCC_OscConfig+0x542>
 8003062:	e014      	b.n	800308e <HAL_RCC_OscConfig+0x58e>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8003064:	f7ff fa1c 	bl	80024a0 <HAL_GetTick>
 8003068:	0003      	movs	r3, r0
 800306a:	617b      	str	r3, [r7, #20]

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 800306c:	e009      	b.n	8003082 <HAL_RCC_OscConfig+0x582>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800306e:	f7ff fa17 	bl	80024a0 <HAL_GetTick>
 8003072:	0002      	movs	r2, r0
 8003074:	697b      	ldr	r3, [r7, #20]
 8003076:	1ad3      	subs	r3, r2, r3
 8003078:	4a46      	ldr	r2, [pc, #280]	; (8003194 <HAL_RCC_OscConfig+0x694>)
 800307a:	4293      	cmp	r3, r2
 800307c:	d901      	bls.n	8003082 <HAL_RCC_OscConfig+0x582>
        {
          return HAL_TIMEOUT;
 800307e:	2303      	movs	r3, #3
 8003080:	e0b4      	b.n	80031ec <HAL_RCC_OscConfig+0x6ec>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 8003082:	4b3f      	ldr	r3, [pc, #252]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8003084:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003086:	2380      	movs	r3, #128	; 0x80
 8003088:	009b      	lsls	r3, r3, #2
 800308a:	4013      	ands	r3, r2
 800308c:	d1ef      	bne.n	800306e <HAL_RCC_OscConfig+0x56e>
        }
      }
    }

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 800308e:	2323      	movs	r3, #35	; 0x23
 8003090:	18fb      	adds	r3, r7, r3
 8003092:	781b      	ldrb	r3, [r3, #0]
 8003094:	2b01      	cmp	r3, #1
 8003096:	d105      	bne.n	80030a4 <HAL_RCC_OscConfig+0x5a4>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8003098:	4b39      	ldr	r3, [pc, #228]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 800309a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800309c:	4b38      	ldr	r3, [pc, #224]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 800309e:	493e      	ldr	r1, [pc, #248]	; (8003198 <HAL_RCC_OscConfig+0x698>)
 80030a0:	400a      	ands	r2, r1
 80030a2:	639a      	str	r2, [r3, #56]	; 0x38
#endif /* RCC_HSI48_SUPPORT */

  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80030a4:	687b      	ldr	r3, [r7, #4]
 80030a6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80030a8:	2b00      	cmp	r3, #0
 80030aa:	d100      	bne.n	80030ae <HAL_RCC_OscConfig+0x5ae>
 80030ac:	e09d      	b.n	80031ea <HAL_RCC_OscConfig+0x6ea>
  {
    /* Check if the PLL is used as system clock or not */
    if(sysclk_source != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80030ae:	69fb      	ldr	r3, [r7, #28]
 80030b0:	2b0c      	cmp	r3, #12
 80030b2:	d100      	bne.n	80030b6 <HAL_RCC_OscConfig+0x5b6>
 80030b4:	e076      	b.n	80031a4 <HAL_RCC_OscConfig+0x6a4>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80030b6:	687b      	ldr	r3, [r7, #4]
 80030b8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80030ba:	2b02      	cmp	r3, #2
 80030bc:	d145      	bne.n	800314a <HAL_RCC_OscConfig+0x64a>
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
        assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
        assert_param(IS_RCC_PLL_DIV(RCC_OscInitStruct->PLL.PLLDIV));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80030be:	4b30      	ldr	r3, [pc, #192]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 80030c0:	681a      	ldr	r2, [r3, #0]
 80030c2:	4b2f      	ldr	r3, [pc, #188]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 80030c4:	4935      	ldr	r1, [pc, #212]	; (800319c <HAL_RCC_OscConfig+0x69c>)
 80030c6:	400a      	ands	r2, r1
 80030c8:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80030ca:	f7ff f9e9 	bl	80024a0 <HAL_GetTick>
 80030ce:	0003      	movs	r3, r0
 80030d0:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 80030d2:	e008      	b.n	80030e6 <HAL_RCC_OscConfig+0x5e6>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80030d4:	f7ff f9e4 	bl	80024a0 <HAL_GetTick>
 80030d8:	0002      	movs	r2, r0
 80030da:	697b      	ldr	r3, [r7, #20]
 80030dc:	1ad3      	subs	r3, r2, r3
 80030de:	2b02      	cmp	r3, #2
 80030e0:	d901      	bls.n	80030e6 <HAL_RCC_OscConfig+0x5e6>
          {
            return HAL_TIMEOUT;
 80030e2:	2303      	movs	r3, #3
 80030e4:	e082      	b.n	80031ec <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 80030e6:	4b26      	ldr	r3, [pc, #152]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 80030e8:	681a      	ldr	r2, [r3, #0]
 80030ea:	2380      	movs	r3, #128	; 0x80
 80030ec:	049b      	lsls	r3, r3, #18
 80030ee:	4013      	ands	r3, r2
 80030f0:	d1f0      	bne.n	80030d4 <HAL_RCC_OscConfig+0x5d4>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80030f2:	4b23      	ldr	r3, [pc, #140]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 80030f4:	68db      	ldr	r3, [r3, #12]
 80030f6:	4a2a      	ldr	r2, [pc, #168]	; (80031a0 <HAL_RCC_OscConfig+0x6a0>)
 80030f8:	4013      	ands	r3, r2
 80030fa:	0019      	movs	r1, r3
 80030fc:	687b      	ldr	r3, [r7, #4]
 80030fe:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8003100:	687b      	ldr	r3, [r7, #4]
 8003102:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003104:	431a      	orrs	r2, r3
 8003106:	687b      	ldr	r3, [r7, #4]
 8003108:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800310a:	431a      	orrs	r2, r3
 800310c:	4b1c      	ldr	r3, [pc, #112]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 800310e:	430a      	orrs	r2, r1
 8003110:	60da      	str	r2, [r3, #12]
                             RCC_OscInitStruct->PLL.PLLMUL,
                             RCC_OscInitStruct->PLL.PLLDIV);
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8003112:	4b1b      	ldr	r3, [pc, #108]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8003114:	681a      	ldr	r2, [r3, #0]
 8003116:	4b1a      	ldr	r3, [pc, #104]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8003118:	2180      	movs	r1, #128	; 0x80
 800311a:	0449      	lsls	r1, r1, #17
 800311c:	430a      	orrs	r2, r1
 800311e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003120:	f7ff f9be 	bl	80024a0 <HAL_GetTick>
 8003124:	0003      	movs	r3, r0
 8003126:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == 0U)
 8003128:	e008      	b.n	800313c <HAL_RCC_OscConfig+0x63c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800312a:	f7ff f9b9 	bl	80024a0 <HAL_GetTick>
 800312e:	0002      	movs	r2, r0
 8003130:	697b      	ldr	r3, [r7, #20]
 8003132:	1ad3      	subs	r3, r2, r3
 8003134:	2b02      	cmp	r3, #2
 8003136:	d901      	bls.n	800313c <HAL_RCC_OscConfig+0x63c>
          {
            return HAL_TIMEOUT;
 8003138:	2303      	movs	r3, #3
 800313a:	e057      	b.n	80031ec <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == 0U)
 800313c:	4b10      	ldr	r3, [pc, #64]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 800313e:	681a      	ldr	r2, [r3, #0]
 8003140:	2380      	movs	r3, #128	; 0x80
 8003142:	049b      	lsls	r3, r3, #18
 8003144:	4013      	ands	r3, r2
 8003146:	d0f0      	beq.n	800312a <HAL_RCC_OscConfig+0x62a>
 8003148:	e04f      	b.n	80031ea <HAL_RCC_OscConfig+0x6ea>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800314a:	4b0d      	ldr	r3, [pc, #52]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 800314c:	681a      	ldr	r2, [r3, #0]
 800314e:	4b0c      	ldr	r3, [pc, #48]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8003150:	4912      	ldr	r1, [pc, #72]	; (800319c <HAL_RCC_OscConfig+0x69c>)
 8003152:	400a      	ands	r2, r1
 8003154:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003156:	f7ff f9a3 	bl	80024a0 <HAL_GetTick>
 800315a:	0003      	movs	r3, r0
 800315c:	617b      	str	r3, [r7, #20]

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 800315e:	e008      	b.n	8003172 <HAL_RCC_OscConfig+0x672>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8003160:	f7ff f99e 	bl	80024a0 <HAL_GetTick>
 8003164:	0002      	movs	r2, r0
 8003166:	697b      	ldr	r3, [r7, #20]
 8003168:	1ad3      	subs	r3, r2, r3
 800316a:	2b02      	cmp	r3, #2
 800316c:	d901      	bls.n	8003172 <HAL_RCC_OscConfig+0x672>
          {
            return HAL_TIMEOUT;
 800316e:	2303      	movs	r3, #3
 8003170:	e03c      	b.n	80031ec <HAL_RCC_OscConfig+0x6ec>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != 0U)
 8003172:	4b03      	ldr	r3, [pc, #12]	; (8003180 <HAL_RCC_OscConfig+0x680>)
 8003174:	681a      	ldr	r2, [r3, #0]
 8003176:	2380      	movs	r3, #128	; 0x80
 8003178:	049b      	lsls	r3, r3, #18
 800317a:	4013      	ands	r3, r2
 800317c:	d1f0      	bne.n	8003160 <HAL_RCC_OscConfig+0x660>
 800317e:	e034      	b.n	80031ea <HAL_RCC_OscConfig+0x6ea>
 8003180:	40021000 	.word	0x40021000
 8003184:	ffff1fff 	.word	0xffff1fff
 8003188:	fffffeff 	.word	0xfffffeff
 800318c:	40007000 	.word	0x40007000
 8003190:	fffffbff 	.word	0xfffffbff
 8003194:	00001388 	.word	0x00001388
 8003198:	efffffff 	.word	0xefffffff
 800319c:	feffffff 	.word	0xfeffffff
 80031a0:	ff02ffff 	.word	0xff02ffff
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 80031a4:	687b      	ldr	r3, [r7, #4]
 80031a6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80031a8:	2b01      	cmp	r3, #1
 80031aa:	d101      	bne.n	80031b0 <HAL_RCC_OscConfig+0x6b0>
      {
        return HAL_ERROR;
 80031ac:	2301      	movs	r3, #1
 80031ae:	e01d      	b.n	80031ec <HAL_RCC_OscConfig+0x6ec>
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->CFGR;
 80031b0:	4b10      	ldr	r3, [pc, #64]	; (80031f4 <HAL_RCC_OscConfig+0x6f4>)
 80031b2:	68db      	ldr	r3, [r3, #12]
 80031b4:	61bb      	str	r3, [r7, #24]
        if((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80031b6:	69ba      	ldr	r2, [r7, #24]
 80031b8:	2380      	movs	r3, #128	; 0x80
 80031ba:	025b      	lsls	r3, r3, #9
 80031bc:	401a      	ands	r2, r3
 80031be:	687b      	ldr	r3, [r7, #4]
 80031c0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80031c2:	429a      	cmp	r2, r3
 80031c4:	d10f      	bne.n	80031e6 <HAL_RCC_OscConfig+0x6e6>
           (READ_BIT(pll_config, RCC_CFGR_PLLMUL) != RCC_OscInitStruct->PLL.PLLMUL) ||
 80031c6:	69ba      	ldr	r2, [r7, #24]
 80031c8:	23f0      	movs	r3, #240	; 0xf0
 80031ca:	039b      	lsls	r3, r3, #14
 80031cc:	401a      	ands	r2, r3
 80031ce:	687b      	ldr	r3, [r7, #4]
 80031d0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
        if((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80031d2:	429a      	cmp	r2, r3
 80031d4:	d107      	bne.n	80031e6 <HAL_RCC_OscConfig+0x6e6>
           (READ_BIT(pll_config, RCC_CFGR_PLLDIV) != RCC_OscInitStruct->PLL.PLLDIV))
 80031d6:	69ba      	ldr	r2, [r7, #24]
 80031d8:	23c0      	movs	r3, #192	; 0xc0
 80031da:	041b      	lsls	r3, r3, #16
 80031dc:	401a      	ands	r2, r3
 80031de:	687b      	ldr	r3, [r7, #4]
 80031e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
           (READ_BIT(pll_config, RCC_CFGR_PLLMUL) != RCC_OscInitStruct->PLL.PLLMUL) ||
 80031e2:	429a      	cmp	r2, r3
 80031e4:	d001      	beq.n	80031ea <HAL_RCC_OscConfig+0x6ea>
        {
          return HAL_ERROR;
 80031e6:	2301      	movs	r3, #1
 80031e8:	e000      	b.n	80031ec <HAL_RCC_OscConfig+0x6ec>
        }
      }
    }
  }
  return HAL_OK;
 80031ea:	2300      	movs	r3, #0
}
 80031ec:	0018      	movs	r0, r3
 80031ee:	46bd      	mov	sp, r7
 80031f0:	b00a      	add	sp, #40	; 0x28
 80031f2:	bdb0      	pop	{r4, r5, r7, pc}
 80031f4:	40021000 	.word	0x40021000

080031f8 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 80031f8:	b5b0      	push	{r4, r5, r7, lr}
 80031fa:	b084      	sub	sp, #16
 80031fc:	af00      	add	r7, sp, #0
 80031fe:	6078      	str	r0, [r7, #4]
 8003200:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 8003202:	687b      	ldr	r3, [r7, #4]
 8003204:	2b00      	cmp	r3, #0
 8003206:	d101      	bne.n	800320c <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8003208:	2301      	movs	r3, #1
 800320a:	e128      	b.n	800345e <HAL_RCC_ClockConfig+0x266>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
  must be correctly programmed according to the frequency of the CPU clock
  (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 800320c:	4b96      	ldr	r3, [pc, #600]	; (8003468 <HAL_RCC_ClockConfig+0x270>)
 800320e:	681b      	ldr	r3, [r3, #0]
 8003210:	2201      	movs	r2, #1
 8003212:	4013      	ands	r3, r2
 8003214:	683a      	ldr	r2, [r7, #0]
 8003216:	429a      	cmp	r2, r3
 8003218:	d91e      	bls.n	8003258 <HAL_RCC_ClockConfig+0x60>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800321a:	4b93      	ldr	r3, [pc, #588]	; (8003468 <HAL_RCC_ClockConfig+0x270>)
 800321c:	681b      	ldr	r3, [r3, #0]
 800321e:	2201      	movs	r2, #1
 8003220:	4393      	bics	r3, r2
 8003222:	0019      	movs	r1, r3
 8003224:	4b90      	ldr	r3, [pc, #576]	; (8003468 <HAL_RCC_ClockConfig+0x270>)
 8003226:	683a      	ldr	r2, [r7, #0]
 8003228:	430a      	orrs	r2, r1
 800322a:	601a      	str	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by polling the FLASH_ACR register */
    tickstart = HAL_GetTick();
 800322c:	f7ff f938 	bl	80024a0 <HAL_GetTick>
 8003230:	0003      	movs	r3, r0
 8003232:	60fb      	str	r3, [r7, #12]

    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8003234:	e009      	b.n	800324a <HAL_RCC_ClockConfig+0x52>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003236:	f7ff f933 	bl	80024a0 <HAL_GetTick>
 800323a:	0002      	movs	r2, r0
 800323c:	68fb      	ldr	r3, [r7, #12]
 800323e:	1ad3      	subs	r3, r2, r3
 8003240:	4a8a      	ldr	r2, [pc, #552]	; (800346c <HAL_RCC_ClockConfig+0x274>)
 8003242:	4293      	cmp	r3, r2
 8003244:	d901      	bls.n	800324a <HAL_RCC_ClockConfig+0x52>
      {
        return HAL_TIMEOUT;
 8003246:	2303      	movs	r3, #3
 8003248:	e109      	b.n	800345e <HAL_RCC_ClockConfig+0x266>
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 800324a:	4b87      	ldr	r3, [pc, #540]	; (8003468 <HAL_RCC_ClockConfig+0x270>)
 800324c:	681b      	ldr	r3, [r3, #0]
 800324e:	2201      	movs	r2, #1
 8003250:	4013      	ands	r3, r2
 8003252:	683a      	ldr	r2, [r7, #0]
 8003254:	429a      	cmp	r2, r3
 8003256:	d1ee      	bne.n	8003236 <HAL_RCC_ClockConfig+0x3e>
      }
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8003258:	687b      	ldr	r3, [r7, #4]
 800325a:	681b      	ldr	r3, [r3, #0]
 800325c:	2202      	movs	r2, #2
 800325e:	4013      	ands	r3, r2
 8003260:	d009      	beq.n	8003276 <HAL_RCC_ClockConfig+0x7e>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8003262:	4b83      	ldr	r3, [pc, #524]	; (8003470 <HAL_RCC_ClockConfig+0x278>)
 8003264:	68db      	ldr	r3, [r3, #12]
 8003266:	22f0      	movs	r2, #240	; 0xf0
 8003268:	4393      	bics	r3, r2
 800326a:	0019      	movs	r1, r3
 800326c:	687b      	ldr	r3, [r7, #4]
 800326e:	689a      	ldr	r2, [r3, #8]
 8003270:	4b7f      	ldr	r3, [pc, #508]	; (8003470 <HAL_RCC_ClockConfig+0x278>)
 8003272:	430a      	orrs	r2, r1
 8003274:	60da      	str	r2, [r3, #12]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8003276:	687b      	ldr	r3, [r7, #4]
 8003278:	681b      	ldr	r3, [r3, #0]
 800327a:	2201      	movs	r2, #1
 800327c:	4013      	ands	r3, r2
 800327e:	d100      	bne.n	8003282 <HAL_RCC_ClockConfig+0x8a>
 8003280:	e089      	b.n	8003396 <HAL_RCC_ClockConfig+0x19e>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8003282:	687b      	ldr	r3, [r7, #4]
 8003284:	685b      	ldr	r3, [r3, #4]
 8003286:	2b02      	cmp	r3, #2
 8003288:	d107      	bne.n	800329a <HAL_RCC_ClockConfig+0xa2>
    {
      /* Check the HSE ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800328a:	4b79      	ldr	r3, [pc, #484]	; (8003470 <HAL_RCC_ClockConfig+0x278>)
 800328c:	681a      	ldr	r2, [r3, #0]
 800328e:	2380      	movs	r3, #128	; 0x80
 8003290:	029b      	lsls	r3, r3, #10
 8003292:	4013      	ands	r3, r2
 8003294:	d120      	bne.n	80032d8 <HAL_RCC_ClockConfig+0xe0>
      {
        return HAL_ERROR;
 8003296:	2301      	movs	r3, #1
 8003298:	e0e1      	b.n	800345e <HAL_RCC_ClockConfig+0x266>
      }
    }
    /* PLL is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800329a:	687b      	ldr	r3, [r7, #4]
 800329c:	685b      	ldr	r3, [r3, #4]
 800329e:	2b03      	cmp	r3, #3
 80032a0:	d107      	bne.n	80032b2 <HAL_RCC_ClockConfig+0xba>
    {
      /* Check the PLL ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 80032a2:	4b73      	ldr	r3, [pc, #460]	; (8003470 <HAL_RCC_ClockConfig+0x278>)
 80032a4:	681a      	ldr	r2, [r3, #0]
 80032a6:	2380      	movs	r3, #128	; 0x80
 80032a8:	049b      	lsls	r3, r3, #18
 80032aa:	4013      	ands	r3, r2
 80032ac:	d114      	bne.n	80032d8 <HAL_RCC_ClockConfig+0xe0>
      {
        return HAL_ERROR;
 80032ae:	2301      	movs	r3, #1
 80032b0:	e0d5      	b.n	800345e <HAL_RCC_ClockConfig+0x266>
      }
    }
    /* HSI is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 80032b2:	687b      	ldr	r3, [r7, #4]
 80032b4:	685b      	ldr	r3, [r3, #4]
 80032b6:	2b01      	cmp	r3, #1
 80032b8:	d106      	bne.n	80032c8 <HAL_RCC_ClockConfig+0xd0>
    {
      /* Check the HSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 80032ba:	4b6d      	ldr	r3, [pc, #436]	; (8003470 <HAL_RCC_ClockConfig+0x278>)
 80032bc:	681b      	ldr	r3, [r3, #0]
 80032be:	2204      	movs	r2, #4
 80032c0:	4013      	ands	r3, r2
 80032c2:	d109      	bne.n	80032d8 <HAL_RCC_ClockConfig+0xe0>
      {
        return HAL_ERROR;
 80032c4:	2301      	movs	r3, #1
 80032c6:	e0ca      	b.n	800345e <HAL_RCC_ClockConfig+0x266>
    }
    /* MSI is selected as System Clock Source */
    else
    {
      /* Check the MSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_MSIRDY) == 0U)
 80032c8:	4b69      	ldr	r3, [pc, #420]	; (8003470 <HAL_RCC_ClockConfig+0x278>)
 80032ca:	681a      	ldr	r2, [r3, #0]
 80032cc:	2380      	movs	r3, #128	; 0x80
 80032ce:	009b      	lsls	r3, r3, #2
 80032d0:	4013      	ands	r3, r2
 80032d2:	d101      	bne.n	80032d8 <HAL_RCC_ClockConfig+0xe0>
      {
        return HAL_ERROR;
 80032d4:	2301      	movs	r3, #1
 80032d6:	e0c2      	b.n	800345e <HAL_RCC_ClockConfig+0x266>
      }
    }
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80032d8:	4b65      	ldr	r3, [pc, #404]	; (8003470 <HAL_RCC_ClockConfig+0x278>)
 80032da:	68db      	ldr	r3, [r3, #12]
 80032dc:	2203      	movs	r2, #3
 80032de:	4393      	bics	r3, r2
 80032e0:	0019      	movs	r1, r3
 80032e2:	687b      	ldr	r3, [r7, #4]
 80032e4:	685a      	ldr	r2, [r3, #4]
 80032e6:	4b62      	ldr	r3, [pc, #392]	; (8003470 <HAL_RCC_ClockConfig+0x278>)
 80032e8:	430a      	orrs	r2, r1
 80032ea:	60da      	str	r2, [r3, #12]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 80032ec:	f7ff f8d8 	bl	80024a0 <HAL_GetTick>
 80032f0:	0003      	movs	r3, r0
 80032f2:	60fb      	str	r3, [r7, #12]

    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80032f4:	687b      	ldr	r3, [r7, #4]
 80032f6:	685b      	ldr	r3, [r3, #4]
 80032f8:	2b02      	cmp	r3, #2
 80032fa:	d111      	bne.n	8003320 <HAL_RCC_ClockConfig+0x128>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 80032fc:	e009      	b.n	8003312 <HAL_RCC_ClockConfig+0x11a>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80032fe:	f7ff f8cf 	bl	80024a0 <HAL_GetTick>
 8003302:	0002      	movs	r2, r0
 8003304:	68fb      	ldr	r3, [r7, #12]
 8003306:	1ad3      	subs	r3, r2, r3
 8003308:	4a58      	ldr	r2, [pc, #352]	; (800346c <HAL_RCC_ClockConfig+0x274>)
 800330a:	4293      	cmp	r3, r2
 800330c:	d901      	bls.n	8003312 <HAL_RCC_ClockConfig+0x11a>
        {
          return HAL_TIMEOUT;
 800330e:	2303      	movs	r3, #3
 8003310:	e0a5      	b.n	800345e <HAL_RCC_ClockConfig+0x266>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8003312:	4b57      	ldr	r3, [pc, #348]	; (8003470 <HAL_RCC_ClockConfig+0x278>)
 8003314:	68db      	ldr	r3, [r3, #12]
 8003316:	220c      	movs	r2, #12
 8003318:	4013      	ands	r3, r2
 800331a:	2b08      	cmp	r3, #8
 800331c:	d1ef      	bne.n	80032fe <HAL_RCC_ClockConfig+0x106>
 800331e:	e03a      	b.n	8003396 <HAL_RCC_ClockConfig+0x19e>
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8003320:	687b      	ldr	r3, [r7, #4]
 8003322:	685b      	ldr	r3, [r3, #4]
 8003324:	2b03      	cmp	r3, #3
 8003326:	d111      	bne.n	800334c <HAL_RCC_ClockConfig+0x154>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8003328:	e009      	b.n	800333e <HAL_RCC_ClockConfig+0x146>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800332a:	f7ff f8b9 	bl	80024a0 <HAL_GetTick>
 800332e:	0002      	movs	r2, r0
 8003330:	68fb      	ldr	r3, [r7, #12]
 8003332:	1ad3      	subs	r3, r2, r3
 8003334:	4a4d      	ldr	r2, [pc, #308]	; (800346c <HAL_RCC_ClockConfig+0x274>)
 8003336:	4293      	cmp	r3, r2
 8003338:	d901      	bls.n	800333e <HAL_RCC_ClockConfig+0x146>
        {
          return HAL_TIMEOUT;
 800333a:	2303      	movs	r3, #3
 800333c:	e08f      	b.n	800345e <HAL_RCC_ClockConfig+0x266>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800333e:	4b4c      	ldr	r3, [pc, #304]	; (8003470 <HAL_RCC_ClockConfig+0x278>)
 8003340:	68db      	ldr	r3, [r3, #12]
 8003342:	220c      	movs	r2, #12
 8003344:	4013      	ands	r3, r2
 8003346:	2b0c      	cmp	r3, #12
 8003348:	d1ef      	bne.n	800332a <HAL_RCC_ClockConfig+0x132>
 800334a:	e024      	b.n	8003396 <HAL_RCC_ClockConfig+0x19e>
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 800334c:	687b      	ldr	r3, [r7, #4]
 800334e:	685b      	ldr	r3, [r3, #4]
 8003350:	2b01      	cmp	r3, #1
 8003352:	d11b      	bne.n	800338c <HAL_RCC_ClockConfig+0x194>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8003354:	e009      	b.n	800336a <HAL_RCC_ClockConfig+0x172>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003356:	f7ff f8a3 	bl	80024a0 <HAL_GetTick>
 800335a:	0002      	movs	r2, r0
 800335c:	68fb      	ldr	r3, [r7, #12]
 800335e:	1ad3      	subs	r3, r2, r3
 8003360:	4a42      	ldr	r2, [pc, #264]	; (800346c <HAL_RCC_ClockConfig+0x274>)
 8003362:	4293      	cmp	r3, r2
 8003364:	d901      	bls.n	800336a <HAL_RCC_ClockConfig+0x172>
        {
          return HAL_TIMEOUT;
 8003366:	2303      	movs	r3, #3
 8003368:	e079      	b.n	800345e <HAL_RCC_ClockConfig+0x266>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800336a:	4b41      	ldr	r3, [pc, #260]	; (8003470 <HAL_RCC_ClockConfig+0x278>)
 800336c:	68db      	ldr	r3, [r3, #12]
 800336e:	220c      	movs	r2, #12
 8003370:	4013      	ands	r3, r2
 8003372:	2b04      	cmp	r3, #4
 8003374:	d1ef      	bne.n	8003356 <HAL_RCC_ClockConfig+0x15e>
 8003376:	e00e      	b.n	8003396 <HAL_RCC_ClockConfig+0x19e>
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003378:	f7ff f892 	bl	80024a0 <HAL_GetTick>
 800337c:	0002      	movs	r2, r0
 800337e:	68fb      	ldr	r3, [r7, #12]
 8003380:	1ad3      	subs	r3, r2, r3
 8003382:	4a3a      	ldr	r2, [pc, #232]	; (800346c <HAL_RCC_ClockConfig+0x274>)
 8003384:	4293      	cmp	r3, r2
 8003386:	d901      	bls.n	800338c <HAL_RCC_ClockConfig+0x194>
        {
          return HAL_TIMEOUT;
 8003388:	2303      	movs	r3, #3
 800338a:	e068      	b.n	800345e <HAL_RCC_ClockConfig+0x266>
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_MSI)
 800338c:	4b38      	ldr	r3, [pc, #224]	; (8003470 <HAL_RCC_ClockConfig+0x278>)
 800338e:	68db      	ldr	r3, [r3, #12]
 8003390:	220c      	movs	r2, #12
 8003392:	4013      	ands	r3, r2
 8003394:	d1f0      	bne.n	8003378 <HAL_RCC_ClockConfig+0x180>
        }
      }
    }
  }
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8003396:	4b34      	ldr	r3, [pc, #208]	; (8003468 <HAL_RCC_ClockConfig+0x270>)
 8003398:	681b      	ldr	r3, [r3, #0]
 800339a:	2201      	movs	r2, #1
 800339c:	4013      	ands	r3, r2
 800339e:	683a      	ldr	r2, [r7, #0]
 80033a0:	429a      	cmp	r2, r3
 80033a2:	d21e      	bcs.n	80033e2 <HAL_RCC_ClockConfig+0x1ea>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80033a4:	4b30      	ldr	r3, [pc, #192]	; (8003468 <HAL_RCC_ClockConfig+0x270>)
 80033a6:	681b      	ldr	r3, [r3, #0]
 80033a8:	2201      	movs	r2, #1
 80033aa:	4393      	bics	r3, r2
 80033ac:	0019      	movs	r1, r3
 80033ae:	4b2e      	ldr	r3, [pc, #184]	; (8003468 <HAL_RCC_ClockConfig+0x270>)
 80033b0:	683a      	ldr	r2, [r7, #0]
 80033b2:	430a      	orrs	r2, r1
 80033b4:	601a      	str	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by polling the FLASH_ACR register */
    tickstart = HAL_GetTick();
 80033b6:	f7ff f873 	bl	80024a0 <HAL_GetTick>
 80033ba:	0003      	movs	r3, r0
 80033bc:	60fb      	str	r3, [r7, #12]

    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 80033be:	e009      	b.n	80033d4 <HAL_RCC_ClockConfig+0x1dc>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80033c0:	f7ff f86e 	bl	80024a0 <HAL_GetTick>
 80033c4:	0002      	movs	r2, r0
 80033c6:	68fb      	ldr	r3, [r7, #12]
 80033c8:	1ad3      	subs	r3, r2, r3
 80033ca:	4a28      	ldr	r2, [pc, #160]	; (800346c <HAL_RCC_ClockConfig+0x274>)
 80033cc:	4293      	cmp	r3, r2
 80033ce:	d901      	bls.n	80033d4 <HAL_RCC_ClockConfig+0x1dc>
      {
        return HAL_TIMEOUT;
 80033d0:	2303      	movs	r3, #3
 80033d2:	e044      	b.n	800345e <HAL_RCC_ClockConfig+0x266>
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 80033d4:	4b24      	ldr	r3, [pc, #144]	; (8003468 <HAL_RCC_ClockConfig+0x270>)
 80033d6:	681b      	ldr	r3, [r3, #0]
 80033d8:	2201      	movs	r2, #1
 80033da:	4013      	ands	r3, r2
 80033dc:	683a      	ldr	r2, [r7, #0]
 80033de:	429a      	cmp	r2, r3
 80033e0:	d1ee      	bne.n	80033c0 <HAL_RCC_ClockConfig+0x1c8>
      }
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80033e2:	687b      	ldr	r3, [r7, #4]
 80033e4:	681b      	ldr	r3, [r3, #0]
 80033e6:	2204      	movs	r2, #4
 80033e8:	4013      	ands	r3, r2
 80033ea:	d009      	beq.n	8003400 <HAL_RCC_ClockConfig+0x208>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80033ec:	4b20      	ldr	r3, [pc, #128]	; (8003470 <HAL_RCC_ClockConfig+0x278>)
 80033ee:	68db      	ldr	r3, [r3, #12]
 80033f0:	4a20      	ldr	r2, [pc, #128]	; (8003474 <HAL_RCC_ClockConfig+0x27c>)
 80033f2:	4013      	ands	r3, r2
 80033f4:	0019      	movs	r1, r3
 80033f6:	687b      	ldr	r3, [r7, #4]
 80033f8:	68da      	ldr	r2, [r3, #12]
 80033fa:	4b1d      	ldr	r3, [pc, #116]	; (8003470 <HAL_RCC_ClockConfig+0x278>)
 80033fc:	430a      	orrs	r2, r1
 80033fe:	60da      	str	r2, [r3, #12]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8003400:	687b      	ldr	r3, [r7, #4]
 8003402:	681b      	ldr	r3, [r3, #0]
 8003404:	2208      	movs	r2, #8
 8003406:	4013      	ands	r3, r2
 8003408:	d00a      	beq.n	8003420 <HAL_RCC_ClockConfig+0x228>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 800340a:	4b19      	ldr	r3, [pc, #100]	; (8003470 <HAL_RCC_ClockConfig+0x278>)
 800340c:	68db      	ldr	r3, [r3, #12]
 800340e:	4a1a      	ldr	r2, [pc, #104]	; (8003478 <HAL_RCC_ClockConfig+0x280>)
 8003410:	4013      	ands	r3, r2
 8003412:	0019      	movs	r1, r3
 8003414:	687b      	ldr	r3, [r7, #4]
 8003416:	691b      	ldr	r3, [r3, #16]
 8003418:	00da      	lsls	r2, r3, #3
 800341a:	4b15      	ldr	r3, [pc, #84]	; (8003470 <HAL_RCC_ClockConfig+0x278>)
 800341c:	430a      	orrs	r2, r1
 800341e:	60da      	str	r2, [r3, #12]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8003420:	f000 f832 	bl	8003488 <HAL_RCC_GetSysClockFreq>
 8003424:	0001      	movs	r1, r0
 8003426:	4b12      	ldr	r3, [pc, #72]	; (8003470 <HAL_RCC_ClockConfig+0x278>)
 8003428:	68db      	ldr	r3, [r3, #12]
 800342a:	091b      	lsrs	r3, r3, #4
 800342c:	220f      	movs	r2, #15
 800342e:	4013      	ands	r3, r2
 8003430:	4a12      	ldr	r2, [pc, #72]	; (800347c <HAL_RCC_ClockConfig+0x284>)
 8003432:	5cd3      	ldrb	r3, [r2, r3]
 8003434:	000a      	movs	r2, r1
 8003436:	40da      	lsrs	r2, r3
 8003438:	4b11      	ldr	r3, [pc, #68]	; (8003480 <HAL_RCC_ClockConfig+0x288>)
 800343a:	601a      	str	r2, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  status = HAL_InitTick(uwTickPrio);
 800343c:	4b11      	ldr	r3, [pc, #68]	; (8003484 <HAL_RCC_ClockConfig+0x28c>)
 800343e:	681b      	ldr	r3, [r3, #0]
 8003440:	250b      	movs	r5, #11
 8003442:	197c      	adds	r4, r7, r5
 8003444:	0018      	movs	r0, r3
 8003446:	f7fe ffe5 	bl	8002414 <HAL_InitTick>
 800344a:	0003      	movs	r3, r0
 800344c:	7023      	strb	r3, [r4, #0]
  if(status != HAL_OK)
 800344e:	197b      	adds	r3, r7, r5
 8003450:	781b      	ldrb	r3, [r3, #0]
 8003452:	2b00      	cmp	r3, #0
 8003454:	d002      	beq.n	800345c <HAL_RCC_ClockConfig+0x264>
  {
    return status;
 8003456:	197b      	adds	r3, r7, r5
 8003458:	781b      	ldrb	r3, [r3, #0]
 800345a:	e000      	b.n	800345e <HAL_RCC_ClockConfig+0x266>
  }

  return HAL_OK;
 800345c:	2300      	movs	r3, #0
}
 800345e:	0018      	movs	r0, r3
 8003460:	46bd      	mov	sp, r7
 8003462:	b004      	add	sp, #16
 8003464:	bdb0      	pop	{r4, r5, r7, pc}
 8003466:	46c0      	nop			; (mov r8, r8)
 8003468:	40022000 	.word	0x40022000
 800346c:	00001388 	.word	0x00001388
 8003470:	40021000 	.word	0x40021000
 8003474:	fffff8ff 	.word	0xfffff8ff
 8003478:	ffffc7ff 	.word	0xffffc7ff
 800347c:	080214f0 	.word	0x080214f0
 8003480:	20000204 	.word	0x20000204
 8003484:	20000208 	.word	0x20000208

08003488 <HAL_RCC_GetSysClockFreq>:
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8003488:	b5b0      	push	{r4, r5, r7, lr}
 800348a:	b08e      	sub	sp, #56	; 0x38
 800348c:	af00      	add	r7, sp, #0
  uint32_t tmpreg, pllm, plld, pllvco, msiclkrange;    /* no init needed */
  uint32_t sysclockfreq;

  tmpreg = RCC->CFGR;
 800348e:	4b4c      	ldr	r3, [pc, #304]	; (80035c0 <HAL_RCC_GetSysClockFreq+0x138>)
 8003490:	68db      	ldr	r3, [r3, #12]
 8003492:	62fb      	str	r3, [r7, #44]	; 0x2c

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 8003494:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8003496:	230c      	movs	r3, #12
 8003498:	4013      	ands	r3, r2
 800349a:	2b0c      	cmp	r3, #12
 800349c:	d014      	beq.n	80034c8 <HAL_RCC_GetSysClockFreq+0x40>
 800349e:	d900      	bls.n	80034a2 <HAL_RCC_GetSysClockFreq+0x1a>
 80034a0:	e07b      	b.n	800359a <HAL_RCC_GetSysClockFreq+0x112>
 80034a2:	2b04      	cmp	r3, #4
 80034a4:	d002      	beq.n	80034ac <HAL_RCC_GetSysClockFreq+0x24>
 80034a6:	2b08      	cmp	r3, #8
 80034a8:	d00b      	beq.n	80034c2 <HAL_RCC_GetSysClockFreq+0x3a>
 80034aa:	e076      	b.n	800359a <HAL_RCC_GetSysClockFreq+0x112>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      if ((RCC->CR & RCC_CR_HSIDIVF) != 0U)
 80034ac:	4b44      	ldr	r3, [pc, #272]	; (80035c0 <HAL_RCC_GetSysClockFreq+0x138>)
 80034ae:	681b      	ldr	r3, [r3, #0]
 80034b0:	2210      	movs	r2, #16
 80034b2:	4013      	ands	r3, r2
 80034b4:	d002      	beq.n	80034bc <HAL_RCC_GetSysClockFreq+0x34>
      {
        sysclockfreq =  (HSI_VALUE >> 2);
 80034b6:	4b43      	ldr	r3, [pc, #268]	; (80035c4 <HAL_RCC_GetSysClockFreq+0x13c>)
 80034b8:	633b      	str	r3, [r7, #48]	; 0x30
      }
      else
      {
        sysclockfreq =  HSI_VALUE;
      }
      break;
 80034ba:	e07c      	b.n	80035b6 <HAL_RCC_GetSysClockFreq+0x12e>
        sysclockfreq =  HSI_VALUE;
 80034bc:	4b42      	ldr	r3, [pc, #264]	; (80035c8 <HAL_RCC_GetSysClockFreq+0x140>)
 80034be:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 80034c0:	e079      	b.n	80035b6 <HAL_RCC_GetSysClockFreq+0x12e>
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
    {
      sysclockfreq = HSE_VALUE;
 80034c2:	4b42      	ldr	r3, [pc, #264]	; (80035cc <HAL_RCC_GetSysClockFreq+0x144>)
 80034c4:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 80034c6:	e076      	b.n	80035b6 <HAL_RCC_GetSysClockFreq+0x12e>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllm = PLLMulTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_Pos];
 80034c8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80034ca:	0c9a      	lsrs	r2, r3, #18
 80034cc:	230f      	movs	r3, #15
 80034ce:	401a      	ands	r2, r3
 80034d0:	4b3f      	ldr	r3, [pc, #252]	; (80035d0 <HAL_RCC_GetSysClockFreq+0x148>)
 80034d2:	5c9b      	ldrb	r3, [r3, r2]
 80034d4:	62bb      	str	r3, [r7, #40]	; 0x28
      plld = ((uint32_t)(tmpreg & RCC_CFGR_PLLDIV) >> RCC_CFGR_PLLDIV_Pos) + 1U;
 80034d6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80034d8:	0d9a      	lsrs	r2, r3, #22
 80034da:	2303      	movs	r3, #3
 80034dc:	4013      	ands	r3, r2
 80034de:	3301      	adds	r3, #1
 80034e0:	627b      	str	r3, [r7, #36]	; 0x24
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 80034e2:	4b37      	ldr	r3, [pc, #220]	; (80035c0 <HAL_RCC_GetSysClockFreq+0x138>)
 80034e4:	68da      	ldr	r2, [r3, #12]
 80034e6:	2380      	movs	r3, #128	; 0x80
 80034e8:	025b      	lsls	r3, r3, #9
 80034ea:	4013      	ands	r3, r2
 80034ec:	d01a      	beq.n	8003524 <HAL_RCC_GetSysClockFreq+0x9c>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t)(((uint64_t)HSE_VALUE * (uint64_t)pllm) / (uint64_t)plld);
 80034ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80034f0:	61bb      	str	r3, [r7, #24]
 80034f2:	2300      	movs	r3, #0
 80034f4:	61fb      	str	r3, [r7, #28]
 80034f6:	4a35      	ldr	r2, [pc, #212]	; (80035cc <HAL_RCC_GetSysClockFreq+0x144>)
 80034f8:	2300      	movs	r3, #0
 80034fa:	69b8      	ldr	r0, [r7, #24]
 80034fc:	69f9      	ldr	r1, [r7, #28]
 80034fe:	f7fc fec1 	bl	8000284 <__aeabi_lmul>
 8003502:	0002      	movs	r2, r0
 8003504:	000b      	movs	r3, r1
 8003506:	0010      	movs	r0, r2
 8003508:	0019      	movs	r1, r3
 800350a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800350c:	613b      	str	r3, [r7, #16]
 800350e:	2300      	movs	r3, #0
 8003510:	617b      	str	r3, [r7, #20]
 8003512:	693a      	ldr	r2, [r7, #16]
 8003514:	697b      	ldr	r3, [r7, #20]
 8003516:	f7fc fe95 	bl	8000244 <__aeabi_uldivmod>
 800351a:	0002      	movs	r2, r0
 800351c:	000b      	movs	r3, r1
 800351e:	0013      	movs	r3, r2
 8003520:	637b      	str	r3, [r7, #52]	; 0x34
 8003522:	e037      	b.n	8003594 <HAL_RCC_GetSysClockFreq+0x10c>
      }
      else
      {
        if ((RCC->CR & RCC_CR_HSIDIVF) != 0U)
 8003524:	4b26      	ldr	r3, [pc, #152]	; (80035c0 <HAL_RCC_GetSysClockFreq+0x138>)
 8003526:	681b      	ldr	r3, [r3, #0]
 8003528:	2210      	movs	r2, #16
 800352a:	4013      	ands	r3, r2
 800352c:	d01a      	beq.n	8003564 <HAL_RCC_GetSysClockFreq+0xdc>
        {
          pllvco = (uint32_t)((((uint64_t)(HSI_VALUE >> 2)) * (uint64_t)pllm) / (uint64_t)plld);
 800352e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003530:	60bb      	str	r3, [r7, #8]
 8003532:	2300      	movs	r3, #0
 8003534:	60fb      	str	r3, [r7, #12]
 8003536:	4a23      	ldr	r2, [pc, #140]	; (80035c4 <HAL_RCC_GetSysClockFreq+0x13c>)
 8003538:	2300      	movs	r3, #0
 800353a:	68b8      	ldr	r0, [r7, #8]
 800353c:	68f9      	ldr	r1, [r7, #12]
 800353e:	f7fc fea1 	bl	8000284 <__aeabi_lmul>
 8003542:	0002      	movs	r2, r0
 8003544:	000b      	movs	r3, r1
 8003546:	0010      	movs	r0, r2
 8003548:	0019      	movs	r1, r3
 800354a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800354c:	603b      	str	r3, [r7, #0]
 800354e:	2300      	movs	r3, #0
 8003550:	607b      	str	r3, [r7, #4]
 8003552:	683a      	ldr	r2, [r7, #0]
 8003554:	687b      	ldr	r3, [r7, #4]
 8003556:	f7fc fe75 	bl	8000244 <__aeabi_uldivmod>
 800355a:	0002      	movs	r2, r0
 800355c:	000b      	movs	r3, r1
 800355e:	0013      	movs	r3, r2
 8003560:	637b      	str	r3, [r7, #52]	; 0x34
 8003562:	e017      	b.n	8003594 <HAL_RCC_GetSysClockFreq+0x10c>
        }
        else
        {
         pllvco = (uint32_t)(((uint64_t)HSI_VALUE * (uint64_t)pllm) / (uint64_t)plld);
 8003564:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003566:	0018      	movs	r0, r3
 8003568:	2300      	movs	r3, #0
 800356a:	0019      	movs	r1, r3
 800356c:	4a16      	ldr	r2, [pc, #88]	; (80035c8 <HAL_RCC_GetSysClockFreq+0x140>)
 800356e:	2300      	movs	r3, #0
 8003570:	f7fc fe88 	bl	8000284 <__aeabi_lmul>
 8003574:	0002      	movs	r2, r0
 8003576:	000b      	movs	r3, r1
 8003578:	0010      	movs	r0, r2
 800357a:	0019      	movs	r1, r3
 800357c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800357e:	001c      	movs	r4, r3
 8003580:	2300      	movs	r3, #0
 8003582:	001d      	movs	r5, r3
 8003584:	0022      	movs	r2, r4
 8003586:	002b      	movs	r3, r5
 8003588:	f7fc fe5c 	bl	8000244 <__aeabi_uldivmod>
 800358c:	0002      	movs	r2, r0
 800358e:	000b      	movs	r3, r1
 8003590:	0013      	movs	r3, r2
 8003592:	637b      	str	r3, [r7, #52]	; 0x34
        }
      }
      sysclockfreq = pllvco;
 8003594:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003596:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 8003598:	e00d      	b.n	80035b6 <HAL_RCC_GetSysClockFreq+0x12e>
    }
    case RCC_SYSCLKSOURCE_STATUS_MSI:  /* MSI used as system clock source */
    default: /* MSI used as system clock */
    {
      msiclkrange = (RCC->ICSCR & RCC_ICSCR_MSIRANGE ) >> RCC_ICSCR_MSIRANGE_Pos;
 800359a:	4b09      	ldr	r3, [pc, #36]	; (80035c0 <HAL_RCC_GetSysClockFreq+0x138>)
 800359c:	685b      	ldr	r3, [r3, #4]
 800359e:	0b5b      	lsrs	r3, r3, #13
 80035a0:	2207      	movs	r2, #7
 80035a2:	4013      	ands	r3, r2
 80035a4:	623b      	str	r3, [r7, #32]
      sysclockfreq = (32768U * (1UL << (msiclkrange + 1U)));
 80035a6:	6a3b      	ldr	r3, [r7, #32]
 80035a8:	3301      	adds	r3, #1
 80035aa:	2280      	movs	r2, #128	; 0x80
 80035ac:	0212      	lsls	r2, r2, #8
 80035ae:	409a      	lsls	r2, r3
 80035b0:	0013      	movs	r3, r2
 80035b2:	633b      	str	r3, [r7, #48]	; 0x30
      break;
 80035b4:	46c0      	nop			; (mov r8, r8)
    }
  }
  return sysclockfreq;
 80035b6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
}
 80035b8:	0018      	movs	r0, r3
 80035ba:	46bd      	mov	sp, r7
 80035bc:	b00e      	add	sp, #56	; 0x38
 80035be:	bdb0      	pop	{r4, r5, r7, pc}
 80035c0:	40021000 	.word	0x40021000
 80035c4:	003d0900 	.word	0x003d0900
 80035c8:	00f42400 	.word	0x00f42400
 80035cc:	007a1200 	.word	0x007a1200
 80035d0:	08021508 	.word	0x08021508

080035d4 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 80035d4:	b580      	push	{r7, lr}
 80035d6:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 80035d8:	4b02      	ldr	r3, [pc, #8]	; (80035e4 <HAL_RCC_GetHCLKFreq+0x10>)
 80035da:	681b      	ldr	r3, [r3, #0]
}
 80035dc:	0018      	movs	r0, r3
 80035de:	46bd      	mov	sp, r7
 80035e0:	bd80      	pop	{r7, pc}
 80035e2:	46c0      	nop			; (mov r8, r8)
 80035e4:	20000204 	.word	0x20000204

080035e8 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 80035e8:	b580      	push	{r7, lr}
 80035ea:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 80035ec:	f7ff fff2 	bl	80035d4 <HAL_RCC_GetHCLKFreq>
 80035f0:	0001      	movs	r1, r0
 80035f2:	4b06      	ldr	r3, [pc, #24]	; (800360c <HAL_RCC_GetPCLK1Freq+0x24>)
 80035f4:	68db      	ldr	r3, [r3, #12]
 80035f6:	0a1b      	lsrs	r3, r3, #8
 80035f8:	2207      	movs	r2, #7
 80035fa:	4013      	ands	r3, r2
 80035fc:	4a04      	ldr	r2, [pc, #16]	; (8003610 <HAL_RCC_GetPCLK1Freq+0x28>)
 80035fe:	5cd3      	ldrb	r3, [r2, r3]
 8003600:	40d9      	lsrs	r1, r3
 8003602:	000b      	movs	r3, r1
}
 8003604:	0018      	movs	r0, r3
 8003606:	46bd      	mov	sp, r7
 8003608:	bd80      	pop	{r7, pc}
 800360a:	46c0      	nop			; (mov r8, r8)
 800360c:	40021000 	.word	0x40021000
 8003610:	08021500 	.word	0x08021500

08003614 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 8003614:	b580      	push	{r7, lr}
 8003616:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 8003618:	f7ff ffdc 	bl	80035d4 <HAL_RCC_GetHCLKFreq>
 800361c:	0001      	movs	r1, r0
 800361e:	4b06      	ldr	r3, [pc, #24]	; (8003638 <HAL_RCC_GetPCLK2Freq+0x24>)
 8003620:	68db      	ldr	r3, [r3, #12]
 8003622:	0adb      	lsrs	r3, r3, #11
 8003624:	2207      	movs	r2, #7
 8003626:	4013      	ands	r3, r2
 8003628:	4a04      	ldr	r2, [pc, #16]	; (800363c <HAL_RCC_GetPCLK2Freq+0x28>)
 800362a:	5cd3      	ldrb	r3, [r2, r3]
 800362c:	40d9      	lsrs	r1, r3
 800362e:	000b      	movs	r3, r1
}
 8003630:	0018      	movs	r0, r3
 8003632:	46bd      	mov	sp, r7
 8003634:	bd80      	pop	{r7, pc}
 8003636:	46c0      	nop			; (mov r8, r8)
 8003638:	40021000 	.word	0x40021000
 800363c:	08021500 	.word	0x08021500

08003640 <HAL_RCCEx_PeriphCLKConfig>:
  * @retval HAL status
  * @note   If HAL_ERROR returned, first switch-OFF HSE clock oscillator with @ref HAL_RCC_OscConfig()
  *         to possibly update HSE divider.
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8003640:	b580      	push	{r7, lr}
 8003642:	b086      	sub	sp, #24
 8003644:	af00      	add	r7, sp, #0
 8003646:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t temp_reg;
  FlagStatus       pwrclkchanged = RESET;
 8003648:	2017      	movs	r0, #23
 800364a:	183b      	adds	r3, r7, r0
 800364c:	2200      	movs	r2, #0
 800364e:	701a      	strb	r2, [r3, #0]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*------------------------------- RTC/LCD Configuration ------------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8003650:	687b      	ldr	r3, [r7, #4]
 8003652:	681b      	ldr	r3, [r3, #0]
 8003654:	2220      	movs	r2, #32
 8003656:	4013      	ands	r3, r2
 8003658:	d100      	bne.n	800365c <HAL_RCCEx_PeriphCLKConfig+0x1c>
 800365a:	e0c2      	b.n	80037e2 <HAL_RCCEx_PeriphCLKConfig+0x1a2>
#endif /* LCD */

    /* As soon as function is called to change RTC clock source, activation of the
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800365c:	4b91      	ldr	r3, [pc, #580]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800365e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8003660:	2380      	movs	r3, #128	; 0x80
 8003662:	055b      	lsls	r3, r3, #21
 8003664:	4013      	ands	r3, r2
 8003666:	d109      	bne.n	800367c <HAL_RCCEx_PeriphCLKConfig+0x3c>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8003668:	4b8e      	ldr	r3, [pc, #568]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800366a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800366c:	4b8d      	ldr	r3, [pc, #564]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800366e:	2180      	movs	r1, #128	; 0x80
 8003670:	0549      	lsls	r1, r1, #21
 8003672:	430a      	orrs	r2, r1
 8003674:	639a      	str	r2, [r3, #56]	; 0x38
      pwrclkchanged = SET;
 8003676:	183b      	adds	r3, r7, r0
 8003678:	2201      	movs	r2, #1
 800367a:	701a      	strb	r2, [r3, #0]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800367c:	4b8a      	ldr	r3, [pc, #552]	; (80038a8 <HAL_RCCEx_PeriphCLKConfig+0x268>)
 800367e:	681a      	ldr	r2, [r3, #0]
 8003680:	2380      	movs	r3, #128	; 0x80
 8003682:	005b      	lsls	r3, r3, #1
 8003684:	4013      	ands	r3, r2
 8003686:	d11a      	bne.n	80036be <HAL_RCCEx_PeriphCLKConfig+0x7e>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8003688:	4b87      	ldr	r3, [pc, #540]	; (80038a8 <HAL_RCCEx_PeriphCLKConfig+0x268>)
 800368a:	681a      	ldr	r2, [r3, #0]
 800368c:	4b86      	ldr	r3, [pc, #536]	; (80038a8 <HAL_RCCEx_PeriphCLKConfig+0x268>)
 800368e:	2180      	movs	r1, #128	; 0x80
 8003690:	0049      	lsls	r1, r1, #1
 8003692:	430a      	orrs	r2, r1
 8003694:	601a      	str	r2, [r3, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8003696:	f7fe ff03 	bl	80024a0 <HAL_GetTick>
 800369a:	0003      	movs	r3, r0
 800369c:	613b      	str	r3, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800369e:	e008      	b.n	80036b2 <HAL_RCCEx_PeriphCLKConfig+0x72>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80036a0:	f7fe fefe 	bl	80024a0 <HAL_GetTick>
 80036a4:	0002      	movs	r2, r0
 80036a6:	693b      	ldr	r3, [r7, #16]
 80036a8:	1ad3      	subs	r3, r2, r3
 80036aa:	2b64      	cmp	r3, #100	; 0x64
 80036ac:	d901      	bls.n	80036b2 <HAL_RCCEx_PeriphCLKConfig+0x72>
        {
          return HAL_TIMEOUT;
 80036ae:	2303      	movs	r3, #3
 80036b0:	e0f3      	b.n	800389a <HAL_RCCEx_PeriphCLKConfig+0x25a>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80036b2:	4b7d      	ldr	r3, [pc, #500]	; (80038a8 <HAL_RCCEx_PeriphCLKConfig+0x268>)
 80036b4:	681a      	ldr	r2, [r3, #0]
 80036b6:	2380      	movs	r3, #128	; 0x80
 80036b8:	005b      	lsls	r3, r3, #1
 80036ba:	4013      	ands	r3, r2
 80036bc:	d0f0      	beq.n	80036a0 <HAL_RCCEx_PeriphCLKConfig+0x60>
        }
      }
    }

    /* Check if user wants to change HSE RTC prescaler whereas HSE is enabled */
    temp_reg = (RCC->CR & RCC_CR_RTCPRE);
 80036be:	4b79      	ldr	r3, [pc, #484]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80036c0:	681a      	ldr	r2, [r3, #0]
 80036c2:	23c0      	movs	r3, #192	; 0xc0
 80036c4:	039b      	lsls	r3, r3, #14
 80036c6:	4013      	ands	r3, r2
 80036c8:	60fb      	str	r3, [r7, #12]
    if ((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CR_RTCPRE))
 80036ca:	687b      	ldr	r3, [r7, #4]
 80036cc:	685a      	ldr	r2, [r3, #4]
 80036ce:	23c0      	movs	r3, #192	; 0xc0
 80036d0:	039b      	lsls	r3, r3, #14
 80036d2:	4013      	ands	r3, r2
 80036d4:	68fa      	ldr	r2, [r7, #12]
 80036d6:	429a      	cmp	r2, r3
 80036d8:	d013      	beq.n	8003702 <HAL_RCCEx_PeriphCLKConfig+0xc2>
#if defined (LCD)
     || (temp_reg != (PeriphClkInit->LCDClockSelection & RCC_CR_RTCPRE))
#endif /* LCD */
       )
    { /* Check HSE State */
      if ((PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL) == RCC_CSR_RTCSEL_HSE)
 80036da:	687b      	ldr	r3, [r7, #4]
 80036dc:	685a      	ldr	r2, [r3, #4]
 80036de:	23c0      	movs	r3, #192	; 0xc0
 80036e0:	029b      	lsls	r3, r3, #10
 80036e2:	401a      	ands	r2, r3
 80036e4:	23c0      	movs	r3, #192	; 0xc0
 80036e6:	029b      	lsls	r3, r3, #10
 80036e8:	429a      	cmp	r2, r3
 80036ea:	d10a      	bne.n	8003702 <HAL_RCCEx_PeriphCLKConfig+0xc2>
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 80036ec:	4b6d      	ldr	r3, [pc, #436]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80036ee:	681a      	ldr	r2, [r3, #0]
 80036f0:	2380      	movs	r3, #128	; 0x80
 80036f2:	029b      	lsls	r3, r3, #10
 80036f4:	401a      	ands	r2, r3
 80036f6:	2380      	movs	r3, #128	; 0x80
 80036f8:	029b      	lsls	r3, r3, #10
 80036fa:	429a      	cmp	r2, r3
 80036fc:	d101      	bne.n	8003702 <HAL_RCCEx_PeriphCLKConfig+0xc2>
        {
          /* To update HSE divider, first switch-OFF HSE clock oscillator*/
          return HAL_ERROR;
 80036fe:	2301      	movs	r3, #1
 8003700:	e0cb      	b.n	800389a <HAL_RCCEx_PeriphCLKConfig+0x25a>
        }
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
    temp_reg = (RCC->CSR & RCC_CSR_RTCSEL);
 8003702:	4b68      	ldr	r3, [pc, #416]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003704:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003706:	23c0      	movs	r3, #192	; 0xc0
 8003708:	029b      	lsls	r3, r3, #10
 800370a:	4013      	ands	r3, r2
 800370c:	60fb      	str	r3, [r7, #12]

    if((temp_reg != 0x00000000U) && (((temp_reg != (PeriphClkInit->RTCClockSelection & RCC_CSR_RTCSEL)) \
 800370e:	68fb      	ldr	r3, [r7, #12]
 8003710:	2b00      	cmp	r3, #0
 8003712:	d03b      	beq.n	800378c <HAL_RCCEx_PeriphCLKConfig+0x14c>
 8003714:	687b      	ldr	r3, [r7, #4]
 8003716:	685a      	ldr	r2, [r3, #4]
 8003718:	23c0      	movs	r3, #192	; 0xc0
 800371a:	029b      	lsls	r3, r3, #10
 800371c:	4013      	ands	r3, r2
 800371e:	68fa      	ldr	r2, [r7, #12]
 8003720:	429a      	cmp	r2, r3
 8003722:	d033      	beq.n	800378c <HAL_RCCEx_PeriphCLKConfig+0x14c>
      && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
 8003724:	687b      	ldr	r3, [r7, #4]
 8003726:	681b      	ldr	r3, [r3, #0]
 8003728:	2220      	movs	r2, #32
 800372a:	4013      	ands	r3, r2
 800372c:	d02e      	beq.n	800378c <HAL_RCCEx_PeriphCLKConfig+0x14c>
       && (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LCD) == RCC_PERIPHCLK_LCD))
#endif /* LCD */
     ))
    {
      /* Store the content of CSR register before the reset of Backup Domain */
      temp_reg = (RCC->CSR & ~(RCC_CSR_RTCSEL));
 800372e:	4b5d      	ldr	r3, [pc, #372]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003730:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8003732:	4a5e      	ldr	r2, [pc, #376]	; (80038ac <HAL_RCCEx_PeriphCLKConfig+0x26c>)
 8003734:	4013      	ands	r3, r2
 8003736:	60fb      	str	r3, [r7, #12]

      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 8003738:	4b5a      	ldr	r3, [pc, #360]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800373a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800373c:	4b59      	ldr	r3, [pc, #356]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800373e:	2180      	movs	r1, #128	; 0x80
 8003740:	0309      	lsls	r1, r1, #12
 8003742:	430a      	orrs	r2, r1
 8003744:	651a      	str	r2, [r3, #80]	; 0x50
      __HAL_RCC_BACKUPRESET_RELEASE();
 8003746:	4b57      	ldr	r3, [pc, #348]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003748:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800374a:	4b56      	ldr	r3, [pc, #344]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800374c:	4958      	ldr	r1, [pc, #352]	; (80038b0 <HAL_RCCEx_PeriphCLKConfig+0x270>)
 800374e:	400a      	ands	r2, r1
 8003750:	651a      	str	r2, [r3, #80]	; 0x50

      /* Restore the Content of CSR register */
      RCC->CSR = temp_reg;
 8003752:	4b54      	ldr	r3, [pc, #336]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003754:	68fa      	ldr	r2, [r7, #12]
 8003756:	651a      	str	r2, [r3, #80]	; 0x50

       /* Wait for LSERDY if LSE was enabled */
      if (HAL_IS_BIT_SET(temp_reg, RCC_CSR_LSEON))
 8003758:	68fa      	ldr	r2, [r7, #12]
 800375a:	2380      	movs	r3, #128	; 0x80
 800375c:	005b      	lsls	r3, r3, #1
 800375e:	4013      	ands	r3, r2
 8003760:	d014      	beq.n	800378c <HAL_RCCEx_PeriphCLKConfig+0x14c>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003762:	f7fe fe9d 	bl	80024a0 <HAL_GetTick>
 8003766:	0003      	movs	r3, r0
 8003768:	613b      	str	r3, [r7, #16]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800376a:	e009      	b.n	8003780 <HAL_RCCEx_PeriphCLKConfig+0x140>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800376c:	f7fe fe98 	bl	80024a0 <HAL_GetTick>
 8003770:	0002      	movs	r2, r0
 8003772:	693b      	ldr	r3, [r7, #16]
 8003774:	1ad3      	subs	r3, r2, r3
 8003776:	4a4f      	ldr	r2, [pc, #316]	; (80038b4 <HAL_RCCEx_PeriphCLKConfig+0x274>)
 8003778:	4293      	cmp	r3, r2
 800377a:	d901      	bls.n	8003780 <HAL_RCCEx_PeriphCLKConfig+0x140>
          {
            return HAL_TIMEOUT;
 800377c:	2303      	movs	r3, #3
 800377e:	e08c      	b.n	800389a <HAL_RCCEx_PeriphCLKConfig+0x25a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8003780:	4b48      	ldr	r3, [pc, #288]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003782:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8003784:	2380      	movs	r3, #128	; 0x80
 8003786:	009b      	lsls	r3, r3, #2
 8003788:	4013      	ands	r3, r2
 800378a:	d0ef      	beq.n	800376c <HAL_RCCEx_PeriphCLKConfig+0x12c>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 800378c:	687b      	ldr	r3, [r7, #4]
 800378e:	685a      	ldr	r2, [r3, #4]
 8003790:	23c0      	movs	r3, #192	; 0xc0
 8003792:	029b      	lsls	r3, r3, #10
 8003794:	401a      	ands	r2, r3
 8003796:	23c0      	movs	r3, #192	; 0xc0
 8003798:	029b      	lsls	r3, r3, #10
 800379a:	429a      	cmp	r2, r3
 800379c:	d10c      	bne.n	80037b8 <HAL_RCCEx_PeriphCLKConfig+0x178>
 800379e:	4b41      	ldr	r3, [pc, #260]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80037a0:	681b      	ldr	r3, [r3, #0]
 80037a2:	4a45      	ldr	r2, [pc, #276]	; (80038b8 <HAL_RCCEx_PeriphCLKConfig+0x278>)
 80037a4:	4013      	ands	r3, r2
 80037a6:	0019      	movs	r1, r3
 80037a8:	687b      	ldr	r3, [r7, #4]
 80037aa:	685a      	ldr	r2, [r3, #4]
 80037ac:	23c0      	movs	r3, #192	; 0xc0
 80037ae:	039b      	lsls	r3, r3, #14
 80037b0:	401a      	ands	r2, r3
 80037b2:	4b3c      	ldr	r3, [pc, #240]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80037b4:	430a      	orrs	r2, r1
 80037b6:	601a      	str	r2, [r3, #0]
 80037b8:	4b3a      	ldr	r3, [pc, #232]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80037ba:	6d19      	ldr	r1, [r3, #80]	; 0x50
 80037bc:	687b      	ldr	r3, [r7, #4]
 80037be:	685a      	ldr	r2, [r3, #4]
 80037c0:	23c0      	movs	r3, #192	; 0xc0
 80037c2:	029b      	lsls	r3, r3, #10
 80037c4:	401a      	ands	r2, r3
 80037c6:	4b37      	ldr	r3, [pc, #220]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80037c8:	430a      	orrs	r2, r1
 80037ca:	651a      	str	r2, [r3, #80]	; 0x50

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 80037cc:	2317      	movs	r3, #23
 80037ce:	18fb      	adds	r3, r7, r3
 80037d0:	781b      	ldrb	r3, [r3, #0]
 80037d2:	2b01      	cmp	r3, #1
 80037d4:	d105      	bne.n	80037e2 <HAL_RCCEx_PeriphCLKConfig+0x1a2>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 80037d6:	4b33      	ldr	r3, [pc, #204]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80037d8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80037da:	4b32      	ldr	r3, [pc, #200]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80037dc:	4937      	ldr	r1, [pc, #220]	; (80038bc <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 80037de:	400a      	ands	r2, r1
 80037e0:	639a      	str	r2, [r3, #56]	; 0x38
    }
  }

#if defined (RCC_CCIPR_USART1SEL)
  /*------------------------------- USART1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 80037e2:	687b      	ldr	r3, [r7, #4]
 80037e4:	681b      	ldr	r3, [r3, #0]
 80037e6:	2201      	movs	r2, #1
 80037e8:	4013      	ands	r3, r2
 80037ea:	d009      	beq.n	8003800 <HAL_RCCEx_PeriphCLKConfig+0x1c0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 80037ec:	4b2d      	ldr	r3, [pc, #180]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80037ee:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80037f0:	2203      	movs	r2, #3
 80037f2:	4393      	bics	r3, r2
 80037f4:	0019      	movs	r1, r3
 80037f6:	687b      	ldr	r3, [r7, #4]
 80037f8:	689a      	ldr	r2, [r3, #8]
 80037fa:	4b2a      	ldr	r3, [pc, #168]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 80037fc:	430a      	orrs	r2, r1
 80037fe:	64da      	str	r2, [r3, #76]	; 0x4c
  }
#endif /* RCC_CCIPR_USART1SEL */

  /*----------------------------- USART2 Configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8003800:	687b      	ldr	r3, [r7, #4]
 8003802:	681b      	ldr	r3, [r3, #0]
 8003804:	2202      	movs	r2, #2
 8003806:	4013      	ands	r3, r2
 8003808:	d009      	beq.n	800381e <HAL_RCCEx_PeriphCLKConfig+0x1de>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 800380a:	4b26      	ldr	r3, [pc, #152]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800380c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800380e:	220c      	movs	r2, #12
 8003810:	4393      	bics	r3, r2
 8003812:	0019      	movs	r1, r3
 8003814:	687b      	ldr	r3, [r7, #4]
 8003816:	68da      	ldr	r2, [r3, #12]
 8003818:	4b22      	ldr	r3, [pc, #136]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800381a:	430a      	orrs	r2, r1
 800381c:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  /*------------------------------ LPUART1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 800381e:	687b      	ldr	r3, [r7, #4]
 8003820:	681b      	ldr	r3, [r3, #0]
 8003822:	2204      	movs	r2, #4
 8003824:	4013      	ands	r3, r2
 8003826:	d009      	beq.n	800383c <HAL_RCCEx_PeriphCLKConfig+0x1fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8003828:	4b1e      	ldr	r3, [pc, #120]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 800382a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800382c:	4a24      	ldr	r2, [pc, #144]	; (80038c0 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800382e:	4013      	ands	r3, r2
 8003830:	0019      	movs	r1, r3
 8003832:	687b      	ldr	r3, [r7, #4]
 8003834:	691a      	ldr	r2, [r3, #16]
 8003836:	4b1b      	ldr	r3, [pc, #108]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003838:	430a      	orrs	r2, r1
 800383a:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  /*------------------------------ I2C1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 800383c:	687b      	ldr	r3, [r7, #4]
 800383e:	681b      	ldr	r3, [r3, #0]
 8003840:	2208      	movs	r2, #8
 8003842:	4013      	ands	r3, r2
 8003844:	d009      	beq.n	800385a <HAL_RCCEx_PeriphCLKConfig+0x21a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8003846:	4b17      	ldr	r3, [pc, #92]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003848:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800384a:	4a1e      	ldr	r2, [pc, #120]	; (80038c4 <HAL_RCCEx_PeriphCLKConfig+0x284>)
 800384c:	4013      	ands	r3, r2
 800384e:	0019      	movs	r1, r3
 8003850:	687b      	ldr	r3, [r7, #4]
 8003852:	695a      	ldr	r2, [r3, #20]
 8003854:	4b13      	ldr	r3, [pc, #76]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003856:	430a      	orrs	r2, r1
 8003858:	64da      	str	r2, [r3, #76]	; 0x4c
  }

#if defined (RCC_CCIPR_I2C3SEL)
    /*------------------------------ I2C3 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 800385a:	687b      	ldr	r3, [r7, #4]
 800385c:	681a      	ldr	r2, [r3, #0]
 800385e:	2380      	movs	r3, #128	; 0x80
 8003860:	005b      	lsls	r3, r3, #1
 8003862:	4013      	ands	r3, r2
 8003864:	d009      	beq.n	800387a <HAL_RCCEx_PeriphCLKConfig+0x23a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8003866:	4b0f      	ldr	r3, [pc, #60]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003868:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800386a:	4a10      	ldr	r2, [pc, #64]	; (80038ac <HAL_RCCEx_PeriphCLKConfig+0x26c>)
 800386c:	4013      	ands	r3, r2
 800386e:	0019      	movs	r1, r3
 8003870:	687b      	ldr	r3, [r7, #4]
 8003872:	699a      	ldr	r2, [r3, #24]
 8003874:	4b0b      	ldr	r3, [pc, #44]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003876:	430a      	orrs	r2, r1
 8003878:	64da      	str	r2, [r3, #76]	; 0x4c
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
  }
#endif /* USB */

  /*---------------------------- LPTIM1 configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 800387a:	687b      	ldr	r3, [r7, #4]
 800387c:	681b      	ldr	r3, [r3, #0]
 800387e:	2280      	movs	r2, #128	; 0x80
 8003880:	4013      	ands	r3, r2
 8003882:	d009      	beq.n	8003898 <HAL_RCCEx_PeriphCLKConfig+0x258>
  {
    assert_param(IS_RCC_LPTIMCLK(PeriphClkInit->LptimClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->LptimClockSelection);
 8003884:	4b07      	ldr	r3, [pc, #28]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003886:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003888:	4a0f      	ldr	r2, [pc, #60]	; (80038c8 <HAL_RCCEx_PeriphCLKConfig+0x288>)
 800388a:	4013      	ands	r3, r2
 800388c:	0019      	movs	r1, r3
 800388e:	687b      	ldr	r3, [r7, #4]
 8003890:	69da      	ldr	r2, [r3, #28]
 8003892:	4b04      	ldr	r3, [pc, #16]	; (80038a4 <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8003894:	430a      	orrs	r2, r1
 8003896:	64da      	str	r2, [r3, #76]	; 0x4c
  }

  return HAL_OK;
 8003898:	2300      	movs	r3, #0
}
 800389a:	0018      	movs	r0, r3
 800389c:	46bd      	mov	sp, r7
 800389e:	b006      	add	sp, #24
 80038a0:	bd80      	pop	{r7, pc}
 80038a2:	46c0      	nop			; (mov r8, r8)
 80038a4:	40021000 	.word	0x40021000
 80038a8:	40007000 	.word	0x40007000
 80038ac:	fffcffff 	.word	0xfffcffff
 80038b0:	fff7ffff 	.word	0xfff7ffff
 80038b4:	00001388 	.word	0x00001388
 80038b8:	ffcfffff 	.word	0xffcfffff
 80038bc:	efffffff 	.word	0xefffffff
 80038c0:	fffff3ff 	.word	0xfffff3ff
 80038c4:	ffffcfff 	.word	0xffffcfff
 80038c8:	fff3ffff 	.word	0xfff3ffff

080038cc <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 80038cc:	b580      	push	{r7, lr}
 80038ce:	b082      	sub	sp, #8
 80038d0:	af00      	add	r7, sp, #0
 80038d2:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 80038d4:	687b      	ldr	r3, [r7, #4]
 80038d6:	2b00      	cmp	r3, #0
 80038d8:	d101      	bne.n	80038de <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 80038da:	2301      	movs	r3, #1
 80038dc:	e044      	b.n	8003968 <HAL_UART_Init+0x9c>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 80038de:	687b      	ldr	r3, [r7, #4]
 80038e0:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80038e2:	2b00      	cmp	r3, #0
 80038e4:	d107      	bne.n	80038f6 <HAL_UART_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 80038e6:	687b      	ldr	r3, [r7, #4]
 80038e8:	2274      	movs	r2, #116	; 0x74
 80038ea:	2100      	movs	r1, #0
 80038ec:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 80038ee:	687b      	ldr	r3, [r7, #4]
 80038f0:	0018      	movs	r0, r3
 80038f2:	f7fd f807 	bl	8000904 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 80038f6:	687b      	ldr	r3, [r7, #4]
 80038f8:	2224      	movs	r2, #36	; 0x24
 80038fa:	679a      	str	r2, [r3, #120]	; 0x78

  __HAL_UART_DISABLE(huart);
 80038fc:	687b      	ldr	r3, [r7, #4]
 80038fe:	681b      	ldr	r3, [r3, #0]
 8003900:	681a      	ldr	r2, [r3, #0]
 8003902:	687b      	ldr	r3, [r7, #4]
 8003904:	681b      	ldr	r3, [r3, #0]
 8003906:	2101      	movs	r1, #1
 8003908:	438a      	bics	r2, r1
 800390a:	601a      	str	r2, [r3, #0]

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 800390c:	687b      	ldr	r3, [r7, #4]
 800390e:	0018      	movs	r0, r3
 8003910:	f000 fc36 	bl	8004180 <UART_SetConfig>
 8003914:	0003      	movs	r3, r0
 8003916:	2b01      	cmp	r3, #1
 8003918:	d101      	bne.n	800391e <HAL_UART_Init+0x52>
  {
    return HAL_ERROR;
 800391a:	2301      	movs	r3, #1
 800391c:	e024      	b.n	8003968 <HAL_UART_Init+0x9c>
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800391e:	687b      	ldr	r3, [r7, #4]
 8003920:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003922:	2b00      	cmp	r3, #0
 8003924:	d003      	beq.n	800392e <HAL_UART_Init+0x62>
  {
    UART_AdvFeatureConfig(huart);
 8003926:	687b      	ldr	r3, [r7, #4]
 8003928:	0018      	movs	r0, r3
 800392a:	f000 fee7 	bl	80046fc <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800392e:	687b      	ldr	r3, [r7, #4]
 8003930:	681b      	ldr	r3, [r3, #0]
 8003932:	685a      	ldr	r2, [r3, #4]
 8003934:	687b      	ldr	r3, [r7, #4]
 8003936:	681b      	ldr	r3, [r3, #0]
 8003938:	490d      	ldr	r1, [pc, #52]	; (8003970 <HAL_UART_Init+0xa4>)
 800393a:	400a      	ands	r2, r1
 800393c:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800393e:	687b      	ldr	r3, [r7, #4]
 8003940:	681b      	ldr	r3, [r3, #0]
 8003942:	689a      	ldr	r2, [r3, #8]
 8003944:	687b      	ldr	r3, [r7, #4]
 8003946:	681b      	ldr	r3, [r3, #0]
 8003948:	212a      	movs	r1, #42	; 0x2a
 800394a:	438a      	bics	r2, r1
 800394c:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
 800394e:	687b      	ldr	r3, [r7, #4]
 8003950:	681b      	ldr	r3, [r3, #0]
 8003952:	681a      	ldr	r2, [r3, #0]
 8003954:	687b      	ldr	r3, [r7, #4]
 8003956:	681b      	ldr	r3, [r3, #0]
 8003958:	2101      	movs	r1, #1
 800395a:	430a      	orrs	r2, r1
 800395c:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 800395e:	687b      	ldr	r3, [r7, #4]
 8003960:	0018      	movs	r0, r3
 8003962:	f000 ff7f 	bl	8004864 <UART_CheckIdleState>
 8003966:	0003      	movs	r3, r0
}
 8003968:	0018      	movs	r0, r3
 800396a:	46bd      	mov	sp, r7
 800396c:	b002      	add	sp, #8
 800396e:	bd80      	pop	{r7, pc}
 8003970:	ffffb7ff 	.word	0xffffb7ff

08003974 <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8003974:	b580      	push	{r7, lr}
 8003976:	b08a      	sub	sp, #40	; 0x28
 8003978:	af02      	add	r7, sp, #8
 800397a:	60f8      	str	r0, [r7, #12]
 800397c:	60b9      	str	r1, [r7, #8]
 800397e:	603b      	str	r3, [r7, #0]
 8003980:	1dbb      	adds	r3, r7, #6
 8003982:	801a      	strh	r2, [r3, #0]
  uint8_t  *pdata8bits;
  uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 8003984:	68fb      	ldr	r3, [r7, #12]
 8003986:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8003988:	2b20      	cmp	r3, #32
 800398a:	d000      	beq.n	800398e <HAL_UART_Transmit+0x1a>
 800398c:	e095      	b.n	8003aba <HAL_UART_Transmit+0x146>
  {
    if ((pData == NULL) || (Size == 0U))
 800398e:	68bb      	ldr	r3, [r7, #8]
 8003990:	2b00      	cmp	r3, #0
 8003992:	d003      	beq.n	800399c <HAL_UART_Transmit+0x28>
 8003994:	1dbb      	adds	r3, r7, #6
 8003996:	881b      	ldrh	r3, [r3, #0]
 8003998:	2b00      	cmp	r3, #0
 800399a:	d101      	bne.n	80039a0 <HAL_UART_Transmit+0x2c>
    {
      return  HAL_ERROR;
 800399c:	2301      	movs	r3, #1
 800399e:	e08d      	b.n	8003abc <HAL_UART_Transmit+0x148>
    }

    /* In case of 9bits/No Parity transfer, pData buffer provided as input parameter
       should be aligned on a u16 frontier, as data to be filled into TDR will be
       handled through a u16 cast. */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80039a0:	68fb      	ldr	r3, [r7, #12]
 80039a2:	689a      	ldr	r2, [r3, #8]
 80039a4:	2380      	movs	r3, #128	; 0x80
 80039a6:	015b      	lsls	r3, r3, #5
 80039a8:	429a      	cmp	r2, r3
 80039aa:	d109      	bne.n	80039c0 <HAL_UART_Transmit+0x4c>
 80039ac:	68fb      	ldr	r3, [r7, #12]
 80039ae:	691b      	ldr	r3, [r3, #16]
 80039b0:	2b00      	cmp	r3, #0
 80039b2:	d105      	bne.n	80039c0 <HAL_UART_Transmit+0x4c>
    {
      if ((((uint32_t)pData) & 1U) != 0U)
 80039b4:	68bb      	ldr	r3, [r7, #8]
 80039b6:	2201      	movs	r2, #1
 80039b8:	4013      	ands	r3, r2
 80039ba:	d001      	beq.n	80039c0 <HAL_UART_Transmit+0x4c>
      {
        return  HAL_ERROR;
 80039bc:	2301      	movs	r3, #1
 80039be:	e07d      	b.n	8003abc <HAL_UART_Transmit+0x148>
      }
    }

    __HAL_LOCK(huart);
 80039c0:	68fb      	ldr	r3, [r7, #12]
 80039c2:	2274      	movs	r2, #116	; 0x74
 80039c4:	5c9b      	ldrb	r3, [r3, r2]
 80039c6:	2b01      	cmp	r3, #1
 80039c8:	d101      	bne.n	80039ce <HAL_UART_Transmit+0x5a>
 80039ca:	2302      	movs	r3, #2
 80039cc:	e076      	b.n	8003abc <HAL_UART_Transmit+0x148>
 80039ce:	68fb      	ldr	r3, [r7, #12]
 80039d0:	2274      	movs	r2, #116	; 0x74
 80039d2:	2101      	movs	r1, #1
 80039d4:	5499      	strb	r1, [r3, r2]

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 80039d6:	68fb      	ldr	r3, [r7, #12]
 80039d8:	2280      	movs	r2, #128	; 0x80
 80039da:	2100      	movs	r1, #0
 80039dc:	5099      	str	r1, [r3, r2]
    huart->gState = HAL_UART_STATE_BUSY_TX;
 80039de:	68fb      	ldr	r3, [r7, #12]
 80039e0:	2221      	movs	r2, #33	; 0x21
 80039e2:	679a      	str	r2, [r3, #120]	; 0x78

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 80039e4:	f7fe fd5c 	bl	80024a0 <HAL_GetTick>
 80039e8:	0003      	movs	r3, r0
 80039ea:	617b      	str	r3, [r7, #20]

    huart->TxXferSize  = Size;
 80039ec:	68fb      	ldr	r3, [r7, #12]
 80039ee:	1dba      	adds	r2, r7, #6
 80039f0:	2150      	movs	r1, #80	; 0x50
 80039f2:	8812      	ldrh	r2, [r2, #0]
 80039f4:	525a      	strh	r2, [r3, r1]
    huart->TxXferCount = Size;
 80039f6:	68fb      	ldr	r3, [r7, #12]
 80039f8:	1dba      	adds	r2, r7, #6
 80039fa:	2152      	movs	r1, #82	; 0x52
 80039fc:	8812      	ldrh	r2, [r2, #0]
 80039fe:	525a      	strh	r2, [r3, r1]

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8003a00:	68fb      	ldr	r3, [r7, #12]
 8003a02:	689a      	ldr	r2, [r3, #8]
 8003a04:	2380      	movs	r3, #128	; 0x80
 8003a06:	015b      	lsls	r3, r3, #5
 8003a08:	429a      	cmp	r2, r3
 8003a0a:	d108      	bne.n	8003a1e <HAL_UART_Transmit+0xaa>
 8003a0c:	68fb      	ldr	r3, [r7, #12]
 8003a0e:	691b      	ldr	r3, [r3, #16]
 8003a10:	2b00      	cmp	r3, #0
 8003a12:	d104      	bne.n	8003a1e <HAL_UART_Transmit+0xaa>
    {
      pdata8bits  = NULL;
 8003a14:	2300      	movs	r3, #0
 8003a16:	61fb      	str	r3, [r7, #28]
      pdata16bits = (uint16_t *) pData;
 8003a18:	68bb      	ldr	r3, [r7, #8]
 8003a1a:	61bb      	str	r3, [r7, #24]
 8003a1c:	e003      	b.n	8003a26 <HAL_UART_Transmit+0xb2>
    }
    else
    {
      pdata8bits  = pData;
 8003a1e:	68bb      	ldr	r3, [r7, #8]
 8003a20:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 8003a22:	2300      	movs	r3, #0
 8003a24:	61bb      	str	r3, [r7, #24]
    }

    __HAL_UNLOCK(huart);
 8003a26:	68fb      	ldr	r3, [r7, #12]
 8003a28:	2274      	movs	r2, #116	; 0x74
 8003a2a:	2100      	movs	r1, #0
 8003a2c:	5499      	strb	r1, [r3, r2]

    while (huart->TxXferCount > 0U)
 8003a2e:	e02c      	b.n	8003a8a <HAL_UART_Transmit+0x116>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 8003a30:	697a      	ldr	r2, [r7, #20]
 8003a32:	68f8      	ldr	r0, [r7, #12]
 8003a34:	683b      	ldr	r3, [r7, #0]
 8003a36:	9300      	str	r3, [sp, #0]
 8003a38:	0013      	movs	r3, r2
 8003a3a:	2200      	movs	r2, #0
 8003a3c:	2180      	movs	r1, #128	; 0x80
 8003a3e:	f000 ff59 	bl	80048f4 <UART_WaitOnFlagUntilTimeout>
 8003a42:	1e03      	subs	r3, r0, #0
 8003a44:	d001      	beq.n	8003a4a <HAL_UART_Transmit+0xd6>
      {
        return HAL_TIMEOUT;
 8003a46:	2303      	movs	r3, #3
 8003a48:	e038      	b.n	8003abc <HAL_UART_Transmit+0x148>
      }
      if (pdata8bits == NULL)
 8003a4a:	69fb      	ldr	r3, [r7, #28]
 8003a4c:	2b00      	cmp	r3, #0
 8003a4e:	d10b      	bne.n	8003a68 <HAL_UART_Transmit+0xf4>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 8003a50:	69bb      	ldr	r3, [r7, #24]
 8003a52:	881b      	ldrh	r3, [r3, #0]
 8003a54:	001a      	movs	r2, r3
 8003a56:	68fb      	ldr	r3, [r7, #12]
 8003a58:	681b      	ldr	r3, [r3, #0]
 8003a5a:	05d2      	lsls	r2, r2, #23
 8003a5c:	0dd2      	lsrs	r2, r2, #23
 8003a5e:	629a      	str	r2, [r3, #40]	; 0x28
        pdata16bits++;
 8003a60:	69bb      	ldr	r3, [r7, #24]
 8003a62:	3302      	adds	r3, #2
 8003a64:	61bb      	str	r3, [r7, #24]
 8003a66:	e007      	b.n	8003a78 <HAL_UART_Transmit+0x104>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 8003a68:	69fb      	ldr	r3, [r7, #28]
 8003a6a:	781a      	ldrb	r2, [r3, #0]
 8003a6c:	68fb      	ldr	r3, [r7, #12]
 8003a6e:	681b      	ldr	r3, [r3, #0]
 8003a70:	629a      	str	r2, [r3, #40]	; 0x28
        pdata8bits++;
 8003a72:	69fb      	ldr	r3, [r7, #28]
 8003a74:	3301      	adds	r3, #1
 8003a76:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
 8003a78:	68fb      	ldr	r3, [r7, #12]
 8003a7a:	2252      	movs	r2, #82	; 0x52
 8003a7c:	5a9b      	ldrh	r3, [r3, r2]
 8003a7e:	b29b      	uxth	r3, r3
 8003a80:	3b01      	subs	r3, #1
 8003a82:	b299      	uxth	r1, r3
 8003a84:	68fb      	ldr	r3, [r7, #12]
 8003a86:	2252      	movs	r2, #82	; 0x52
 8003a88:	5299      	strh	r1, [r3, r2]
    while (huart->TxXferCount > 0U)
 8003a8a:	68fb      	ldr	r3, [r7, #12]
 8003a8c:	2252      	movs	r2, #82	; 0x52
 8003a8e:	5a9b      	ldrh	r3, [r3, r2]
 8003a90:	b29b      	uxth	r3, r3
 8003a92:	2b00      	cmp	r3, #0
 8003a94:	d1cc      	bne.n	8003a30 <HAL_UART_Transmit+0xbc>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 8003a96:	697a      	ldr	r2, [r7, #20]
 8003a98:	68f8      	ldr	r0, [r7, #12]
 8003a9a:	683b      	ldr	r3, [r7, #0]
 8003a9c:	9300      	str	r3, [sp, #0]
 8003a9e:	0013      	movs	r3, r2
 8003aa0:	2200      	movs	r2, #0
 8003aa2:	2140      	movs	r1, #64	; 0x40
 8003aa4:	f000 ff26 	bl	80048f4 <UART_WaitOnFlagUntilTimeout>
 8003aa8:	1e03      	subs	r3, r0, #0
 8003aaa:	d001      	beq.n	8003ab0 <HAL_UART_Transmit+0x13c>
    {
      return HAL_TIMEOUT;
 8003aac:	2303      	movs	r3, #3
 8003aae:	e005      	b.n	8003abc <HAL_UART_Transmit+0x148>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 8003ab0:	68fb      	ldr	r3, [r7, #12]
 8003ab2:	2220      	movs	r2, #32
 8003ab4:	679a      	str	r2, [r3, #120]	; 0x78

    return HAL_OK;
 8003ab6:	2300      	movs	r3, #0
 8003ab8:	e000      	b.n	8003abc <HAL_UART_Transmit+0x148>
  }
  else
  {
    return HAL_BUSY;
 8003aba:	2302      	movs	r3, #2
  }
}
 8003abc:	0018      	movs	r0, r3
 8003abe:	46bd      	mov	sp, r7
 8003ac0:	b008      	add	sp, #32
 8003ac2:	bd80      	pop	{r7, pc}

08003ac4 <HAL_UART_Receive_IT>:
  * @param pData Pointer to data buffer (u8 or u16 data elements).
  * @param Size  Amount of data elements (u8 or u16) to be received.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 8003ac4:	b580      	push	{r7, lr}
 8003ac6:	b088      	sub	sp, #32
 8003ac8:	af00      	add	r7, sp, #0
 8003aca:	60f8      	str	r0, [r7, #12]
 8003acc:	60b9      	str	r1, [r7, #8]
 8003ace:	1dbb      	adds	r3, r7, #6
 8003ad0:	801a      	strh	r2, [r3, #0]
  /* Check that a Rx process is not already ongoing */
  if (huart->RxState == HAL_UART_STATE_READY)
 8003ad2:	68fb      	ldr	r3, [r7, #12]
 8003ad4:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8003ad6:	2b20      	cmp	r3, #32
 8003ad8:	d155      	bne.n	8003b86 <HAL_UART_Receive_IT+0xc2>
  {
    if ((pData == NULL) || (Size == 0U))
 8003ada:	68bb      	ldr	r3, [r7, #8]
 8003adc:	2b00      	cmp	r3, #0
 8003ade:	d003      	beq.n	8003ae8 <HAL_UART_Receive_IT+0x24>
 8003ae0:	1dbb      	adds	r3, r7, #6
 8003ae2:	881b      	ldrh	r3, [r3, #0]
 8003ae4:	2b00      	cmp	r3, #0
 8003ae6:	d101      	bne.n	8003aec <HAL_UART_Receive_IT+0x28>
    {
      return HAL_ERROR;
 8003ae8:	2301      	movs	r3, #1
 8003aea:	e04d      	b.n	8003b88 <HAL_UART_Receive_IT+0xc4>
    }

    /* In case of 9bits/No Parity transfer, pData buffer provided as input parameter
       should be aligned on a u16 frontier, as data to be received from RDR will be
       handled through a u16 cast. */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8003aec:	68fb      	ldr	r3, [r7, #12]
 8003aee:	689a      	ldr	r2, [r3, #8]
 8003af0:	2380      	movs	r3, #128	; 0x80
 8003af2:	015b      	lsls	r3, r3, #5
 8003af4:	429a      	cmp	r2, r3
 8003af6:	d109      	bne.n	8003b0c <HAL_UART_Receive_IT+0x48>
 8003af8:	68fb      	ldr	r3, [r7, #12]
 8003afa:	691b      	ldr	r3, [r3, #16]
 8003afc:	2b00      	cmp	r3, #0
 8003afe:	d105      	bne.n	8003b0c <HAL_UART_Receive_IT+0x48>
    {
      if ((((uint32_t)pData) & 1U) != 0U)
 8003b00:	68bb      	ldr	r3, [r7, #8]
 8003b02:	2201      	movs	r2, #1
 8003b04:	4013      	ands	r3, r2
 8003b06:	d001      	beq.n	8003b0c <HAL_UART_Receive_IT+0x48>
      {
        return  HAL_ERROR;
 8003b08:	2301      	movs	r3, #1
 8003b0a:	e03d      	b.n	8003b88 <HAL_UART_Receive_IT+0xc4>
      }
    }

    __HAL_LOCK(huart);
 8003b0c:	68fb      	ldr	r3, [r7, #12]
 8003b0e:	2274      	movs	r2, #116	; 0x74
 8003b10:	5c9b      	ldrb	r3, [r3, r2]
 8003b12:	2b01      	cmp	r3, #1
 8003b14:	d101      	bne.n	8003b1a <HAL_UART_Receive_IT+0x56>
 8003b16:	2302      	movs	r3, #2
 8003b18:	e036      	b.n	8003b88 <HAL_UART_Receive_IT+0xc4>
 8003b1a:	68fb      	ldr	r3, [r7, #12]
 8003b1c:	2274      	movs	r2, #116	; 0x74
 8003b1e:	2101      	movs	r1, #1
 8003b20:	5499      	strb	r1, [r3, r2]

    /* Set Reception type to Standard reception */
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8003b22:	68fb      	ldr	r3, [r7, #12]
 8003b24:	2200      	movs	r2, #0
 8003b26:	661a      	str	r2, [r3, #96]	; 0x60

    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 8003b28:	68fb      	ldr	r3, [r7, #12]
 8003b2a:	681b      	ldr	r3, [r3, #0]
 8003b2c:	4a18      	ldr	r2, [pc, #96]	; (8003b90 <HAL_UART_Receive_IT+0xcc>)
 8003b2e:	4293      	cmp	r3, r2
 8003b30:	d020      	beq.n	8003b74 <HAL_UART_Receive_IT+0xb0>
    {
      /* Check that USART RTOEN bit is set */
      if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8003b32:	68fb      	ldr	r3, [r7, #12]
 8003b34:	681b      	ldr	r3, [r3, #0]
 8003b36:	685a      	ldr	r2, [r3, #4]
 8003b38:	2380      	movs	r3, #128	; 0x80
 8003b3a:	041b      	lsls	r3, r3, #16
 8003b3c:	4013      	ands	r3, r2
 8003b3e:	d019      	beq.n	8003b74 <HAL_UART_Receive_IT+0xb0>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003b40:	f3ef 8310 	mrs	r3, PRIMASK
 8003b44:	613b      	str	r3, [r7, #16]
  return(result);
 8003b46:	693b      	ldr	r3, [r7, #16]
      {
        /* Enable the UART Receiver Timeout Interrupt */
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 8003b48:	61fb      	str	r3, [r7, #28]
 8003b4a:	2301      	movs	r3, #1
 8003b4c:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003b4e:	697b      	ldr	r3, [r7, #20]
 8003b50:	f383 8810 	msr	PRIMASK, r3
}
 8003b54:	46c0      	nop			; (mov r8, r8)
 8003b56:	68fb      	ldr	r3, [r7, #12]
 8003b58:	681b      	ldr	r3, [r3, #0]
 8003b5a:	681a      	ldr	r2, [r3, #0]
 8003b5c:	68fb      	ldr	r3, [r7, #12]
 8003b5e:	681b      	ldr	r3, [r3, #0]
 8003b60:	2180      	movs	r1, #128	; 0x80
 8003b62:	04c9      	lsls	r1, r1, #19
 8003b64:	430a      	orrs	r2, r1
 8003b66:	601a      	str	r2, [r3, #0]
 8003b68:	69fb      	ldr	r3, [r7, #28]
 8003b6a:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003b6c:	69bb      	ldr	r3, [r7, #24]
 8003b6e:	f383 8810 	msr	PRIMASK, r3
}
 8003b72:	46c0      	nop			; (mov r8, r8)
      }
    }

    return (UART_Start_Receive_IT(huart, pData, Size));
 8003b74:	1dbb      	adds	r3, r7, #6
 8003b76:	881a      	ldrh	r2, [r3, #0]
 8003b78:	68b9      	ldr	r1, [r7, #8]
 8003b7a:	68fb      	ldr	r3, [r7, #12]
 8003b7c:	0018      	movs	r0, r3
 8003b7e:	f000 ff7d 	bl	8004a7c <UART_Start_Receive_IT>
 8003b82:	0003      	movs	r3, r0
 8003b84:	e000      	b.n	8003b88 <HAL_UART_Receive_IT+0xc4>
  }
  else
  {
    return HAL_BUSY;
 8003b86:	2302      	movs	r3, #2
  }
}
 8003b88:	0018      	movs	r0, r3
 8003b8a:	46bd      	mov	sp, r7
 8003b8c:	b008      	add	sp, #32
 8003b8e:	bd80      	pop	{r7, pc}
 8003b90:	40004800 	.word	0x40004800

08003b94 <HAL_UART_IRQHandler>:
  * @brief Handle UART interrupt request.
  * @param huart UART handle.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 8003b94:	b590      	push	{r4, r7, lr}
 8003b96:	b0ab      	sub	sp, #172	; 0xac
 8003b98:	af00      	add	r7, sp, #0
 8003b9a:	6078      	str	r0, [r7, #4]
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 8003b9c:	687b      	ldr	r3, [r7, #4]
 8003b9e:	681b      	ldr	r3, [r3, #0]
 8003ba0:	69db      	ldr	r3, [r3, #28]
 8003ba2:	22a4      	movs	r2, #164	; 0xa4
 8003ba4:	18b9      	adds	r1, r7, r2
 8003ba6:	600b      	str	r3, [r1, #0]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8003ba8:	687b      	ldr	r3, [r7, #4]
 8003baa:	681b      	ldr	r3, [r3, #0]
 8003bac:	681b      	ldr	r3, [r3, #0]
 8003bae:	20a0      	movs	r0, #160	; 0xa0
 8003bb0:	1839      	adds	r1, r7, r0
 8003bb2:	600b      	str	r3, [r1, #0]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8003bb4:	687b      	ldr	r3, [r7, #4]
 8003bb6:	681b      	ldr	r3, [r3, #0]
 8003bb8:	689b      	ldr	r3, [r3, #8]
 8003bba:	219c      	movs	r1, #156	; 0x9c
 8003bbc:	1879      	adds	r1, r7, r1
 8003bbe:	600b      	str	r3, [r1, #0]

  uint32_t errorflags;
  uint32_t errorcode;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE | USART_ISR_RTOF));
 8003bc0:	0011      	movs	r1, r2
 8003bc2:	18bb      	adds	r3, r7, r2
 8003bc4:	681b      	ldr	r3, [r3, #0]
 8003bc6:	4a99      	ldr	r2, [pc, #612]	; (8003e2c <HAL_UART_IRQHandler+0x298>)
 8003bc8:	4013      	ands	r3, r2
 8003bca:	2298      	movs	r2, #152	; 0x98
 8003bcc:	18bc      	adds	r4, r7, r2
 8003bce:	6023      	str	r3, [r4, #0]
  if (errorflags == 0U)
 8003bd0:	18bb      	adds	r3, r7, r2
 8003bd2:	681b      	ldr	r3, [r3, #0]
 8003bd4:	2b00      	cmp	r3, #0
 8003bd6:	d114      	bne.n	8003c02 <HAL_UART_IRQHandler+0x6e>
  {
    /* UART in mode Receiver ---------------------------------------------------*/
    if (((isrflags & USART_ISR_RXNE) != 0U)
 8003bd8:	187b      	adds	r3, r7, r1
 8003bda:	681b      	ldr	r3, [r3, #0]
 8003bdc:	2220      	movs	r2, #32
 8003bde:	4013      	ands	r3, r2
 8003be0:	d00f      	beq.n	8003c02 <HAL_UART_IRQHandler+0x6e>
        && ((cr1its & USART_CR1_RXNEIE) != 0U))
 8003be2:	183b      	adds	r3, r7, r0
 8003be4:	681b      	ldr	r3, [r3, #0]
 8003be6:	2220      	movs	r2, #32
 8003be8:	4013      	ands	r3, r2
 8003bea:	d00a      	beq.n	8003c02 <HAL_UART_IRQHandler+0x6e>
    {
      if (huart->RxISR != NULL)
 8003bec:	687b      	ldr	r3, [r7, #4]
 8003bee:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8003bf0:	2b00      	cmp	r3, #0
 8003bf2:	d100      	bne.n	8003bf6 <HAL_UART_IRQHandler+0x62>
 8003bf4:	e298      	b.n	8004128 <HAL_UART_IRQHandler+0x594>
      {
        huart->RxISR(huart);
 8003bf6:	687b      	ldr	r3, [r7, #4]
 8003bf8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8003bfa:	687a      	ldr	r2, [r7, #4]
 8003bfc:	0010      	movs	r0, r2
 8003bfe:	4798      	blx	r3
      }
      return;
 8003c00:	e292      	b.n	8004128 <HAL_UART_IRQHandler+0x594>
    }
  }

  /* If some errors occur */
  if ((errorflags != 0U)
 8003c02:	2398      	movs	r3, #152	; 0x98
 8003c04:	18fb      	adds	r3, r7, r3
 8003c06:	681b      	ldr	r3, [r3, #0]
 8003c08:	2b00      	cmp	r3, #0
 8003c0a:	d100      	bne.n	8003c0e <HAL_UART_IRQHandler+0x7a>
 8003c0c:	e114      	b.n	8003e38 <HAL_UART_IRQHandler+0x2a4>
      && (((cr3its & USART_CR3_EIE) != 0U)
 8003c0e:	239c      	movs	r3, #156	; 0x9c
 8003c10:	18fb      	adds	r3, r7, r3
 8003c12:	681b      	ldr	r3, [r3, #0]
 8003c14:	2201      	movs	r2, #1
 8003c16:	4013      	ands	r3, r2
 8003c18:	d106      	bne.n	8003c28 <HAL_UART_IRQHandler+0x94>
          || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U)))
 8003c1a:	23a0      	movs	r3, #160	; 0xa0
 8003c1c:	18fb      	adds	r3, r7, r3
 8003c1e:	681b      	ldr	r3, [r3, #0]
 8003c20:	4a83      	ldr	r2, [pc, #524]	; (8003e30 <HAL_UART_IRQHandler+0x29c>)
 8003c22:	4013      	ands	r3, r2
 8003c24:	d100      	bne.n	8003c28 <HAL_UART_IRQHandler+0x94>
 8003c26:	e107      	b.n	8003e38 <HAL_UART_IRQHandler+0x2a4>
  {
    /* UART parity error interrupt occurred -------------------------------------*/
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 8003c28:	23a4      	movs	r3, #164	; 0xa4
 8003c2a:	18fb      	adds	r3, r7, r3
 8003c2c:	681b      	ldr	r3, [r3, #0]
 8003c2e:	2201      	movs	r2, #1
 8003c30:	4013      	ands	r3, r2
 8003c32:	d012      	beq.n	8003c5a <HAL_UART_IRQHandler+0xc6>
 8003c34:	23a0      	movs	r3, #160	; 0xa0
 8003c36:	18fb      	adds	r3, r7, r3
 8003c38:	681a      	ldr	r2, [r3, #0]
 8003c3a:	2380      	movs	r3, #128	; 0x80
 8003c3c:	005b      	lsls	r3, r3, #1
 8003c3e:	4013      	ands	r3, r2
 8003c40:	d00b      	beq.n	8003c5a <HAL_UART_IRQHandler+0xc6>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 8003c42:	687b      	ldr	r3, [r7, #4]
 8003c44:	681b      	ldr	r3, [r3, #0]
 8003c46:	2201      	movs	r2, #1
 8003c48:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_PE;
 8003c4a:	687b      	ldr	r3, [r7, #4]
 8003c4c:	2280      	movs	r2, #128	; 0x80
 8003c4e:	589b      	ldr	r3, [r3, r2]
 8003c50:	2201      	movs	r2, #1
 8003c52:	431a      	orrs	r2, r3
 8003c54:	687b      	ldr	r3, [r7, #4]
 8003c56:	2180      	movs	r1, #128	; 0x80
 8003c58:	505a      	str	r2, [r3, r1]
    }

    /* UART frame error interrupt occurred --------------------------------------*/
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8003c5a:	23a4      	movs	r3, #164	; 0xa4
 8003c5c:	18fb      	adds	r3, r7, r3
 8003c5e:	681b      	ldr	r3, [r3, #0]
 8003c60:	2202      	movs	r2, #2
 8003c62:	4013      	ands	r3, r2
 8003c64:	d011      	beq.n	8003c8a <HAL_UART_IRQHandler+0xf6>
 8003c66:	239c      	movs	r3, #156	; 0x9c
 8003c68:	18fb      	adds	r3, r7, r3
 8003c6a:	681b      	ldr	r3, [r3, #0]
 8003c6c:	2201      	movs	r2, #1
 8003c6e:	4013      	ands	r3, r2
 8003c70:	d00b      	beq.n	8003c8a <HAL_UART_IRQHandler+0xf6>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 8003c72:	687b      	ldr	r3, [r7, #4]
 8003c74:	681b      	ldr	r3, [r3, #0]
 8003c76:	2202      	movs	r2, #2
 8003c78:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_FE;
 8003c7a:	687b      	ldr	r3, [r7, #4]
 8003c7c:	2280      	movs	r2, #128	; 0x80
 8003c7e:	589b      	ldr	r3, [r3, r2]
 8003c80:	2204      	movs	r2, #4
 8003c82:	431a      	orrs	r2, r3
 8003c84:	687b      	ldr	r3, [r7, #4]
 8003c86:	2180      	movs	r1, #128	; 0x80
 8003c88:	505a      	str	r2, [r3, r1]
    }

    /* UART noise error interrupt occurred --------------------------------------*/
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8003c8a:	23a4      	movs	r3, #164	; 0xa4
 8003c8c:	18fb      	adds	r3, r7, r3
 8003c8e:	681b      	ldr	r3, [r3, #0]
 8003c90:	2204      	movs	r2, #4
 8003c92:	4013      	ands	r3, r2
 8003c94:	d011      	beq.n	8003cba <HAL_UART_IRQHandler+0x126>
 8003c96:	239c      	movs	r3, #156	; 0x9c
 8003c98:	18fb      	adds	r3, r7, r3
 8003c9a:	681b      	ldr	r3, [r3, #0]
 8003c9c:	2201      	movs	r2, #1
 8003c9e:	4013      	ands	r3, r2
 8003ca0:	d00b      	beq.n	8003cba <HAL_UART_IRQHandler+0x126>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 8003ca2:	687b      	ldr	r3, [r7, #4]
 8003ca4:	681b      	ldr	r3, [r3, #0]
 8003ca6:	2204      	movs	r2, #4
 8003ca8:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8003caa:	687b      	ldr	r3, [r7, #4]
 8003cac:	2280      	movs	r2, #128	; 0x80
 8003cae:	589b      	ldr	r3, [r3, r2]
 8003cb0:	2202      	movs	r2, #2
 8003cb2:	431a      	orrs	r2, r3
 8003cb4:	687b      	ldr	r3, [r7, #4]
 8003cb6:	2180      	movs	r1, #128	; 0x80
 8003cb8:	505a      	str	r2, [r3, r1]
    }

    /* UART Over-Run interrupt occurred -----------------------------------------*/
    if (((isrflags & USART_ISR_ORE) != 0U)
 8003cba:	23a4      	movs	r3, #164	; 0xa4
 8003cbc:	18fb      	adds	r3, r7, r3
 8003cbe:	681b      	ldr	r3, [r3, #0]
 8003cc0:	2208      	movs	r2, #8
 8003cc2:	4013      	ands	r3, r2
 8003cc4:	d017      	beq.n	8003cf6 <HAL_UART_IRQHandler+0x162>
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
 8003cc6:	23a0      	movs	r3, #160	; 0xa0
 8003cc8:	18fb      	adds	r3, r7, r3
 8003cca:	681b      	ldr	r3, [r3, #0]
 8003ccc:	2220      	movs	r2, #32
 8003cce:	4013      	ands	r3, r2
 8003cd0:	d105      	bne.n	8003cde <HAL_UART_IRQHandler+0x14a>
            ((cr3its & USART_CR3_EIE) != 0U)))
 8003cd2:	239c      	movs	r3, #156	; 0x9c
 8003cd4:	18fb      	adds	r3, r7, r3
 8003cd6:	681b      	ldr	r3, [r3, #0]
 8003cd8:	2201      	movs	r2, #1
 8003cda:	4013      	ands	r3, r2
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
 8003cdc:	d00b      	beq.n	8003cf6 <HAL_UART_IRQHandler+0x162>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 8003cde:	687b      	ldr	r3, [r7, #4]
 8003ce0:	681b      	ldr	r3, [r3, #0]
 8003ce2:	2208      	movs	r2, #8
 8003ce4:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8003ce6:	687b      	ldr	r3, [r7, #4]
 8003ce8:	2280      	movs	r2, #128	; 0x80
 8003cea:	589b      	ldr	r3, [r3, r2]
 8003cec:	2208      	movs	r2, #8
 8003cee:	431a      	orrs	r2, r3
 8003cf0:	687b      	ldr	r3, [r7, #4]
 8003cf2:	2180      	movs	r1, #128	; 0x80
 8003cf4:	505a      	str	r2, [r3, r1]
    }

    /* UART Receiver Timeout interrupt occurred ---------------------------------*/
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
 8003cf6:	23a4      	movs	r3, #164	; 0xa4
 8003cf8:	18fb      	adds	r3, r7, r3
 8003cfa:	681a      	ldr	r2, [r3, #0]
 8003cfc:	2380      	movs	r3, #128	; 0x80
 8003cfe:	011b      	lsls	r3, r3, #4
 8003d00:	4013      	ands	r3, r2
 8003d02:	d013      	beq.n	8003d2c <HAL_UART_IRQHandler+0x198>
 8003d04:	23a0      	movs	r3, #160	; 0xa0
 8003d06:	18fb      	adds	r3, r7, r3
 8003d08:	681a      	ldr	r2, [r3, #0]
 8003d0a:	2380      	movs	r3, #128	; 0x80
 8003d0c:	04db      	lsls	r3, r3, #19
 8003d0e:	4013      	ands	r3, r2
 8003d10:	d00c      	beq.n	8003d2c <HAL_UART_IRQHandler+0x198>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8003d12:	687b      	ldr	r3, [r7, #4]
 8003d14:	681b      	ldr	r3, [r3, #0]
 8003d16:	2280      	movs	r2, #128	; 0x80
 8003d18:	0112      	lsls	r2, r2, #4
 8003d1a:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_RTO;
 8003d1c:	687b      	ldr	r3, [r7, #4]
 8003d1e:	2280      	movs	r2, #128	; 0x80
 8003d20:	589b      	ldr	r3, [r3, r2]
 8003d22:	2220      	movs	r2, #32
 8003d24:	431a      	orrs	r2, r3
 8003d26:	687b      	ldr	r3, [r7, #4]
 8003d28:	2180      	movs	r1, #128	; 0x80
 8003d2a:	505a      	str	r2, [r3, r1]
    }

    /* Call UART Error Call back function if need be ----------------------------*/
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8003d2c:	687b      	ldr	r3, [r7, #4]
 8003d2e:	2280      	movs	r2, #128	; 0x80
 8003d30:	589b      	ldr	r3, [r3, r2]
 8003d32:	2b00      	cmp	r3, #0
 8003d34:	d100      	bne.n	8003d38 <HAL_UART_IRQHandler+0x1a4>
 8003d36:	e1f9      	b.n	800412c <HAL_UART_IRQHandler+0x598>
    {
      /* UART in mode Receiver --------------------------------------------------*/
      if (((isrflags & USART_ISR_RXNE) != 0U)
 8003d38:	23a4      	movs	r3, #164	; 0xa4
 8003d3a:	18fb      	adds	r3, r7, r3
 8003d3c:	681b      	ldr	r3, [r3, #0]
 8003d3e:	2220      	movs	r2, #32
 8003d40:	4013      	ands	r3, r2
 8003d42:	d00e      	beq.n	8003d62 <HAL_UART_IRQHandler+0x1ce>
          && ((cr1its & USART_CR1_RXNEIE) != 0U))
 8003d44:	23a0      	movs	r3, #160	; 0xa0
 8003d46:	18fb      	adds	r3, r7, r3
 8003d48:	681b      	ldr	r3, [r3, #0]
 8003d4a:	2220      	movs	r2, #32
 8003d4c:	4013      	ands	r3, r2
 8003d4e:	d008      	beq.n	8003d62 <HAL_UART_IRQHandler+0x1ce>
      {
        if (huart->RxISR != NULL)
 8003d50:	687b      	ldr	r3, [r7, #4]
 8003d52:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8003d54:	2b00      	cmp	r3, #0
 8003d56:	d004      	beq.n	8003d62 <HAL_UART_IRQHandler+0x1ce>
        {
          huart->RxISR(huart);
 8003d58:	687b      	ldr	r3, [r7, #4]
 8003d5a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8003d5c:	687a      	ldr	r2, [r7, #4]
 8003d5e:	0010      	movs	r0, r2
 8003d60:	4798      	blx	r3
      /* If Error is to be considered as blocking :
          - Receiver Timeout error in Reception
          - Overrun error in Reception
          - any error occurs in DMA mode reception
      */
      errorcode = huart->ErrorCode;
 8003d62:	687b      	ldr	r3, [r7, #4]
 8003d64:	2280      	movs	r2, #128	; 0x80
 8003d66:	589b      	ldr	r3, [r3, r2]
 8003d68:	2194      	movs	r1, #148	; 0x94
 8003d6a:	187a      	adds	r2, r7, r1
 8003d6c:	6013      	str	r3, [r2, #0]
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8003d6e:	687b      	ldr	r3, [r7, #4]
 8003d70:	681b      	ldr	r3, [r3, #0]
 8003d72:	689b      	ldr	r3, [r3, #8]
 8003d74:	2240      	movs	r2, #64	; 0x40
 8003d76:	4013      	ands	r3, r2
 8003d78:	2b40      	cmp	r3, #64	; 0x40
 8003d7a:	d004      	beq.n	8003d86 <HAL_UART_IRQHandler+0x1f2>
          ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))
 8003d7c:	187b      	adds	r3, r7, r1
 8003d7e:	681b      	ldr	r3, [r3, #0]
 8003d80:	2228      	movs	r2, #40	; 0x28
 8003d82:	4013      	ands	r3, r2
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8003d84:	d047      	beq.n	8003e16 <HAL_UART_IRQHandler+0x282>
      {
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 8003d86:	687b      	ldr	r3, [r7, #4]
 8003d88:	0018      	movs	r0, r3
 8003d8a:	f000 ff27 	bl	8004bdc <UART_EndRxTransfer>

        /* Disable the UART DMA Rx request if enabled */
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8003d8e:	687b      	ldr	r3, [r7, #4]
 8003d90:	681b      	ldr	r3, [r3, #0]
 8003d92:	689b      	ldr	r3, [r3, #8]
 8003d94:	2240      	movs	r2, #64	; 0x40
 8003d96:	4013      	ands	r3, r2
 8003d98:	2b40      	cmp	r3, #64	; 0x40
 8003d9a:	d137      	bne.n	8003e0c <HAL_UART_IRQHandler+0x278>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003d9c:	f3ef 8310 	mrs	r3, PRIMASK
 8003da0:	663b      	str	r3, [r7, #96]	; 0x60
  return(result);
 8003da2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
        {
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8003da4:	2090      	movs	r0, #144	; 0x90
 8003da6:	183a      	adds	r2, r7, r0
 8003da8:	6013      	str	r3, [r2, #0]
 8003daa:	2301      	movs	r3, #1
 8003dac:	667b      	str	r3, [r7, #100]	; 0x64
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003dae:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8003db0:	f383 8810 	msr	PRIMASK, r3
}
 8003db4:	46c0      	nop			; (mov r8, r8)
 8003db6:	687b      	ldr	r3, [r7, #4]
 8003db8:	681b      	ldr	r3, [r3, #0]
 8003dba:	689a      	ldr	r2, [r3, #8]
 8003dbc:	687b      	ldr	r3, [r7, #4]
 8003dbe:	681b      	ldr	r3, [r3, #0]
 8003dc0:	2140      	movs	r1, #64	; 0x40
 8003dc2:	438a      	bics	r2, r1
 8003dc4:	609a      	str	r2, [r3, #8]
 8003dc6:	183b      	adds	r3, r7, r0
 8003dc8:	681b      	ldr	r3, [r3, #0]
 8003dca:	66bb      	str	r3, [r7, #104]	; 0x68
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003dcc:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8003dce:	f383 8810 	msr	PRIMASK, r3
}
 8003dd2:	46c0      	nop			; (mov r8, r8)

          /* Abort the UART DMA Rx channel */
          if (huart->hdmarx != NULL)
 8003dd4:	687b      	ldr	r3, [r7, #4]
 8003dd6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003dd8:	2b00      	cmp	r3, #0
 8003dda:	d012      	beq.n	8003e02 <HAL_UART_IRQHandler+0x26e>
          {
            /* Set the UART DMA Abort callback :
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8003ddc:	687b      	ldr	r3, [r7, #4]
 8003dde:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003de0:	4a14      	ldr	r2, [pc, #80]	; (8003e34 <HAL_UART_IRQHandler+0x2a0>)
 8003de2:	639a      	str	r2, [r3, #56]	; 0x38

            /* Abort DMA RX */
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8003de4:	687b      	ldr	r3, [r7, #4]
 8003de6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003de8:	0018      	movs	r0, r3
 8003dea:	f7fe fca5 	bl	8002738 <HAL_DMA_Abort_IT>
 8003dee:	1e03      	subs	r3, r0, #0
 8003df0:	d01a      	beq.n	8003e28 <HAL_UART_IRQHandler+0x294>
            {
              /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8003df2:	687b      	ldr	r3, [r7, #4]
 8003df4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003df6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8003df8:	687b      	ldr	r3, [r7, #4]
 8003dfa:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003dfc:	0018      	movs	r0, r3
 8003dfe:	4790      	blx	r2
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8003e00:	e012      	b.n	8003e28 <HAL_UART_IRQHandler+0x294>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
            /*Call registered error callback*/
            huart->ErrorCallback(huart);
#else
            /*Call legacy weak error callback*/
            HAL_UART_ErrorCallback(huart);
 8003e02:	687b      	ldr	r3, [r7, #4]
 8003e04:	0018      	movs	r0, r3
 8003e06:	f000 f9a7 	bl	8004158 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8003e0a:	e00d      	b.n	8003e28 <HAL_UART_IRQHandler+0x294>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered error callback*/
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
 8003e0c:	687b      	ldr	r3, [r7, #4]
 8003e0e:	0018      	movs	r0, r3
 8003e10:	f000 f9a2 	bl	8004158 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8003e14:	e008      	b.n	8003e28 <HAL_UART_IRQHandler+0x294>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered error callback*/
        huart->ErrorCallback(huart);
#else
        /*Call legacy weak error callback*/
        HAL_UART_ErrorCallback(huart);
 8003e16:	687b      	ldr	r3, [r7, #4]
 8003e18:	0018      	movs	r0, r3
 8003e1a:	f000 f99d 	bl	8004158 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003e1e:	687b      	ldr	r3, [r7, #4]
 8003e20:	2280      	movs	r2, #128	; 0x80
 8003e22:	2100      	movs	r1, #0
 8003e24:	5099      	str	r1, [r3, r2]
      }
    }
    return;
 8003e26:	e181      	b.n	800412c <HAL_UART_IRQHandler+0x598>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8003e28:	46c0      	nop			; (mov r8, r8)
    return;
 8003e2a:	e17f      	b.n	800412c <HAL_UART_IRQHandler+0x598>
 8003e2c:	0000080f 	.word	0x0000080f
 8003e30:	04000120 	.word	0x04000120
 8003e34:	08004ca1 	.word	0x08004ca1

  } /* End if some error occurs */

  /* Check current reception Mode :
     If Reception till IDLE event has been selected : */
  if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8003e38:	687b      	ldr	r3, [r7, #4]
 8003e3a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8003e3c:	2b01      	cmp	r3, #1
 8003e3e:	d000      	beq.n	8003e42 <HAL_UART_IRQHandler+0x2ae>
 8003e40:	e133      	b.n	80040aa <HAL_UART_IRQHandler+0x516>
      && ((isrflags & USART_ISR_IDLE) != 0U)
 8003e42:	23a4      	movs	r3, #164	; 0xa4
 8003e44:	18fb      	adds	r3, r7, r3
 8003e46:	681b      	ldr	r3, [r3, #0]
 8003e48:	2210      	movs	r2, #16
 8003e4a:	4013      	ands	r3, r2
 8003e4c:	d100      	bne.n	8003e50 <HAL_UART_IRQHandler+0x2bc>
 8003e4e:	e12c      	b.n	80040aa <HAL_UART_IRQHandler+0x516>
      && ((cr1its & USART_ISR_IDLE) != 0U))
 8003e50:	23a0      	movs	r3, #160	; 0xa0
 8003e52:	18fb      	adds	r3, r7, r3
 8003e54:	681b      	ldr	r3, [r3, #0]
 8003e56:	2210      	movs	r2, #16
 8003e58:	4013      	ands	r3, r2
 8003e5a:	d100      	bne.n	8003e5e <HAL_UART_IRQHandler+0x2ca>
 8003e5c:	e125      	b.n	80040aa <HAL_UART_IRQHandler+0x516>
  {
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8003e5e:	687b      	ldr	r3, [r7, #4]
 8003e60:	681b      	ldr	r3, [r3, #0]
 8003e62:	2210      	movs	r2, #16
 8003e64:	621a      	str	r2, [r3, #32]

    /* Check if DMA mode is enabled in UART */
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8003e66:	687b      	ldr	r3, [r7, #4]
 8003e68:	681b      	ldr	r3, [r3, #0]
 8003e6a:	689b      	ldr	r3, [r3, #8]
 8003e6c:	2240      	movs	r2, #64	; 0x40
 8003e6e:	4013      	ands	r3, r2
 8003e70:	2b40      	cmp	r3, #64	; 0x40
 8003e72:	d000      	beq.n	8003e76 <HAL_UART_IRQHandler+0x2e2>
 8003e74:	e09d      	b.n	8003fb2 <HAL_UART_IRQHandler+0x41e>
    {
      /* DMA mode enabled */
      /* Check received length : If all expected data are received, do nothing,
         (DMA cplt callback will be called).
         Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
 8003e76:	687b      	ldr	r3, [r7, #4]
 8003e78:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003e7a:	681b      	ldr	r3, [r3, #0]
 8003e7c:	685a      	ldr	r2, [r3, #4]
 8003e7e:	217e      	movs	r1, #126	; 0x7e
 8003e80:	187b      	adds	r3, r7, r1
 8003e82:	801a      	strh	r2, [r3, #0]
      if ((nb_remaining_rx_data > 0U)
 8003e84:	187b      	adds	r3, r7, r1
 8003e86:	881b      	ldrh	r3, [r3, #0]
 8003e88:	2b00      	cmp	r3, #0
 8003e8a:	d100      	bne.n	8003e8e <HAL_UART_IRQHandler+0x2fa>
 8003e8c:	e150      	b.n	8004130 <HAL_UART_IRQHandler+0x59c>
          && (nb_remaining_rx_data < huart->RxXferSize))
 8003e8e:	687b      	ldr	r3, [r7, #4]
 8003e90:	2258      	movs	r2, #88	; 0x58
 8003e92:	5a9b      	ldrh	r3, [r3, r2]
 8003e94:	187a      	adds	r2, r7, r1
 8003e96:	8812      	ldrh	r2, [r2, #0]
 8003e98:	429a      	cmp	r2, r3
 8003e9a:	d300      	bcc.n	8003e9e <HAL_UART_IRQHandler+0x30a>
 8003e9c:	e148      	b.n	8004130 <HAL_UART_IRQHandler+0x59c>
      {
        /* Reception is not complete */
        huart->RxXferCount = nb_remaining_rx_data;
 8003e9e:	687b      	ldr	r3, [r7, #4]
 8003ea0:	187a      	adds	r2, r7, r1
 8003ea2:	215a      	movs	r1, #90	; 0x5a
 8003ea4:	8812      	ldrh	r2, [r2, #0]
 8003ea6:	525a      	strh	r2, [r3, r1]

        /* In Normal mode, end DMA xfer and HAL UART Rx process*/
        if (HAL_IS_BIT_CLR(huart->hdmarx->Instance->CCR, DMA_CCR_CIRC))
 8003ea8:	687b      	ldr	r3, [r7, #4]
 8003eaa:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003eac:	681b      	ldr	r3, [r3, #0]
 8003eae:	681b      	ldr	r3, [r3, #0]
 8003eb0:	2220      	movs	r2, #32
 8003eb2:	4013      	ands	r3, r2
 8003eb4:	d16e      	bne.n	8003f94 <HAL_UART_IRQHandler+0x400>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003eb6:	f3ef 8310 	mrs	r3, PRIMASK
 8003eba:	633b      	str	r3, [r7, #48]	; 0x30
  return(result);
 8003ebc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
        {
          /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8003ebe:	67bb      	str	r3, [r7, #120]	; 0x78
 8003ec0:	2301      	movs	r3, #1
 8003ec2:	637b      	str	r3, [r7, #52]	; 0x34
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003ec4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003ec6:	f383 8810 	msr	PRIMASK, r3
}
 8003eca:	46c0      	nop			; (mov r8, r8)
 8003ecc:	687b      	ldr	r3, [r7, #4]
 8003ece:	681b      	ldr	r3, [r3, #0]
 8003ed0:	681a      	ldr	r2, [r3, #0]
 8003ed2:	687b      	ldr	r3, [r7, #4]
 8003ed4:	681b      	ldr	r3, [r3, #0]
 8003ed6:	499a      	ldr	r1, [pc, #616]	; (8004140 <HAL_UART_IRQHandler+0x5ac>)
 8003ed8:	400a      	ands	r2, r1
 8003eda:	601a      	str	r2, [r3, #0]
 8003edc:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8003ede:	63bb      	str	r3, [r7, #56]	; 0x38
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003ee0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8003ee2:	f383 8810 	msr	PRIMASK, r3
}
 8003ee6:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003ee8:	f3ef 8310 	mrs	r3, PRIMASK
 8003eec:	63fb      	str	r3, [r7, #60]	; 0x3c
  return(result);
 8003eee:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003ef0:	677b      	str	r3, [r7, #116]	; 0x74
 8003ef2:	2301      	movs	r3, #1
 8003ef4:	643b      	str	r3, [r7, #64]	; 0x40
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003ef6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8003ef8:	f383 8810 	msr	PRIMASK, r3
}
 8003efc:	46c0      	nop			; (mov r8, r8)
 8003efe:	687b      	ldr	r3, [r7, #4]
 8003f00:	681b      	ldr	r3, [r3, #0]
 8003f02:	689a      	ldr	r2, [r3, #8]
 8003f04:	687b      	ldr	r3, [r7, #4]
 8003f06:	681b      	ldr	r3, [r3, #0]
 8003f08:	2101      	movs	r1, #1
 8003f0a:	438a      	bics	r2, r1
 8003f0c:	609a      	str	r2, [r3, #8]
 8003f0e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8003f10:	647b      	str	r3, [r7, #68]	; 0x44
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003f12:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8003f14:	f383 8810 	msr	PRIMASK, r3
}
 8003f18:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003f1a:	f3ef 8310 	mrs	r3, PRIMASK
 8003f1e:	64bb      	str	r3, [r7, #72]	; 0x48
  return(result);
 8003f20:	6cbb      	ldr	r3, [r7, #72]	; 0x48

          /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
             in the UART CR3 register */
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8003f22:	673b      	str	r3, [r7, #112]	; 0x70
 8003f24:	2301      	movs	r3, #1
 8003f26:	64fb      	str	r3, [r7, #76]	; 0x4c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003f28:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8003f2a:	f383 8810 	msr	PRIMASK, r3
}
 8003f2e:	46c0      	nop			; (mov r8, r8)
 8003f30:	687b      	ldr	r3, [r7, #4]
 8003f32:	681b      	ldr	r3, [r3, #0]
 8003f34:	689a      	ldr	r2, [r3, #8]
 8003f36:	687b      	ldr	r3, [r7, #4]
 8003f38:	681b      	ldr	r3, [r3, #0]
 8003f3a:	2140      	movs	r1, #64	; 0x40
 8003f3c:	438a      	bics	r2, r1
 8003f3e:	609a      	str	r2, [r3, #8]
 8003f40:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8003f42:	653b      	str	r3, [r7, #80]	; 0x50
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003f44:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8003f46:	f383 8810 	msr	PRIMASK, r3
}
 8003f4a:	46c0      	nop			; (mov r8, r8)

          /* At end of Rx process, restore huart->RxState to Ready */
          huart->RxState = HAL_UART_STATE_READY;
 8003f4c:	687b      	ldr	r3, [r7, #4]
 8003f4e:	2220      	movs	r2, #32
 8003f50:	67da      	str	r2, [r3, #124]	; 0x7c
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8003f52:	687b      	ldr	r3, [r7, #4]
 8003f54:	2200      	movs	r2, #0
 8003f56:	661a      	str	r2, [r3, #96]	; 0x60
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003f58:	f3ef 8310 	mrs	r3, PRIMASK
 8003f5c:	657b      	str	r3, [r7, #84]	; 0x54
  return(result);
 8003f5e:	6d7b      	ldr	r3, [r7, #84]	; 0x54

          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8003f60:	66fb      	str	r3, [r7, #108]	; 0x6c
 8003f62:	2301      	movs	r3, #1
 8003f64:	65bb      	str	r3, [r7, #88]	; 0x58
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003f66:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8003f68:	f383 8810 	msr	PRIMASK, r3
}
 8003f6c:	46c0      	nop			; (mov r8, r8)
 8003f6e:	687b      	ldr	r3, [r7, #4]
 8003f70:	681b      	ldr	r3, [r3, #0]
 8003f72:	681a      	ldr	r2, [r3, #0]
 8003f74:	687b      	ldr	r3, [r7, #4]
 8003f76:	681b      	ldr	r3, [r3, #0]
 8003f78:	2110      	movs	r1, #16
 8003f7a:	438a      	bics	r2, r1
 8003f7c:	601a      	str	r2, [r3, #0]
 8003f7e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8003f80:	65fb      	str	r3, [r7, #92]	; 0x5c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003f82:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8003f84:	f383 8810 	msr	PRIMASK, r3
}
 8003f88:	46c0      	nop			; (mov r8, r8)

          /* Last bytes received, so no need as the abort is immediate */
          (void)HAL_DMA_Abort(huart->hdmarx);
 8003f8a:	687b      	ldr	r3, [r7, #4]
 8003f8c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003f8e:	0018      	movs	r0, r3
 8003f90:	f7fe fb92 	bl	80026b8 <HAL_DMA_Abort>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 8003f94:	687b      	ldr	r3, [r7, #4]
 8003f96:	2258      	movs	r2, #88	; 0x58
 8003f98:	5a9a      	ldrh	r2, [r3, r2]
 8003f9a:	687b      	ldr	r3, [r7, #4]
 8003f9c:	215a      	movs	r1, #90	; 0x5a
 8003f9e:	5a5b      	ldrh	r3, [r3, r1]
 8003fa0:	b29b      	uxth	r3, r3
 8003fa2:	1ad3      	subs	r3, r2, r3
 8003fa4:	b29a      	uxth	r2, r3
 8003fa6:	687b      	ldr	r3, [r7, #4]
 8003fa8:	0011      	movs	r1, r2
 8003faa:	0018      	movs	r0, r3
 8003fac:	f000 f8dc 	bl	8004168 <HAL_UARTEx_RxEventCallback>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
      }
      return;
 8003fb0:	e0be      	b.n	8004130 <HAL_UART_IRQHandler+0x59c>
    else
    {
      /* DMA mode not enabled */
      /* Check received length : If all expected data are received, do nothing.
         Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 8003fb2:	687b      	ldr	r3, [r7, #4]
 8003fb4:	2258      	movs	r2, #88	; 0x58
 8003fb6:	5a99      	ldrh	r1, [r3, r2]
 8003fb8:	687b      	ldr	r3, [r7, #4]
 8003fba:	225a      	movs	r2, #90	; 0x5a
 8003fbc:	5a9b      	ldrh	r3, [r3, r2]
 8003fbe:	b29a      	uxth	r2, r3
 8003fc0:	208e      	movs	r0, #142	; 0x8e
 8003fc2:	183b      	adds	r3, r7, r0
 8003fc4:	1a8a      	subs	r2, r1, r2
 8003fc6:	801a      	strh	r2, [r3, #0]
      if ((huart->RxXferCount > 0U)
 8003fc8:	687b      	ldr	r3, [r7, #4]
 8003fca:	225a      	movs	r2, #90	; 0x5a
 8003fcc:	5a9b      	ldrh	r3, [r3, r2]
 8003fce:	b29b      	uxth	r3, r3
 8003fd0:	2b00      	cmp	r3, #0
 8003fd2:	d100      	bne.n	8003fd6 <HAL_UART_IRQHandler+0x442>
 8003fd4:	e0ae      	b.n	8004134 <HAL_UART_IRQHandler+0x5a0>
          && (nb_rx_data > 0U))
 8003fd6:	183b      	adds	r3, r7, r0
 8003fd8:	881b      	ldrh	r3, [r3, #0]
 8003fda:	2b00      	cmp	r3, #0
 8003fdc:	d100      	bne.n	8003fe0 <HAL_UART_IRQHandler+0x44c>
 8003fde:	e0a9      	b.n	8004134 <HAL_UART_IRQHandler+0x5a0>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003fe0:	f3ef 8310 	mrs	r3, PRIMASK
 8003fe4:	60fb      	str	r3, [r7, #12]
  return(result);
 8003fe6:	68fb      	ldr	r3, [r7, #12]
      {
        /* Disable the UART Parity Error Interrupt and RXNE interrupts */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8003fe8:	2488      	movs	r4, #136	; 0x88
 8003fea:	193a      	adds	r2, r7, r4
 8003fec:	6013      	str	r3, [r2, #0]
 8003fee:	2301      	movs	r3, #1
 8003ff0:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003ff2:	693b      	ldr	r3, [r7, #16]
 8003ff4:	f383 8810 	msr	PRIMASK, r3
}
 8003ff8:	46c0      	nop			; (mov r8, r8)
 8003ffa:	687b      	ldr	r3, [r7, #4]
 8003ffc:	681b      	ldr	r3, [r3, #0]
 8003ffe:	681a      	ldr	r2, [r3, #0]
 8004000:	687b      	ldr	r3, [r7, #4]
 8004002:	681b      	ldr	r3, [r3, #0]
 8004004:	494f      	ldr	r1, [pc, #316]	; (8004144 <HAL_UART_IRQHandler+0x5b0>)
 8004006:	400a      	ands	r2, r1
 8004008:	601a      	str	r2, [r3, #0]
 800400a:	193b      	adds	r3, r7, r4
 800400c:	681b      	ldr	r3, [r3, #0]
 800400e:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004010:	697b      	ldr	r3, [r7, #20]
 8004012:	f383 8810 	msr	PRIMASK, r3
}
 8004016:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004018:	f3ef 8310 	mrs	r3, PRIMASK
 800401c:	61bb      	str	r3, [r7, #24]
  return(result);
 800401e:	69bb      	ldr	r3, [r7, #24]

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004020:	2484      	movs	r4, #132	; 0x84
 8004022:	193a      	adds	r2, r7, r4
 8004024:	6013      	str	r3, [r2, #0]
 8004026:	2301      	movs	r3, #1
 8004028:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800402a:	69fb      	ldr	r3, [r7, #28]
 800402c:	f383 8810 	msr	PRIMASK, r3
}
 8004030:	46c0      	nop			; (mov r8, r8)
 8004032:	687b      	ldr	r3, [r7, #4]
 8004034:	681b      	ldr	r3, [r3, #0]
 8004036:	689a      	ldr	r2, [r3, #8]
 8004038:	687b      	ldr	r3, [r7, #4]
 800403a:	681b      	ldr	r3, [r3, #0]
 800403c:	2101      	movs	r1, #1
 800403e:	438a      	bics	r2, r1
 8004040:	609a      	str	r2, [r3, #8]
 8004042:	193b      	adds	r3, r7, r4
 8004044:	681b      	ldr	r3, [r3, #0]
 8004046:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004048:	6a3b      	ldr	r3, [r7, #32]
 800404a:	f383 8810 	msr	PRIMASK, r3
}
 800404e:	46c0      	nop			; (mov r8, r8)

        /* Rx process is completed, restore huart->RxState to Ready */
        huart->RxState = HAL_UART_STATE_READY;
 8004050:	687b      	ldr	r3, [r7, #4]
 8004052:	2220      	movs	r2, #32
 8004054:	67da      	str	r2, [r3, #124]	; 0x7c
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8004056:	687b      	ldr	r3, [r7, #4]
 8004058:	2200      	movs	r2, #0
 800405a:	661a      	str	r2, [r3, #96]	; 0x60

        /* Clear RxISR function pointer */
        huart->RxISR = NULL;
 800405c:	687b      	ldr	r3, [r7, #4]
 800405e:	2200      	movs	r2, #0
 8004060:	665a      	str	r2, [r3, #100]	; 0x64
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004062:	f3ef 8310 	mrs	r3, PRIMASK
 8004066:	627b      	str	r3, [r7, #36]	; 0x24
  return(result);
 8004068:	6a7b      	ldr	r3, [r7, #36]	; 0x24

        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800406a:	2480      	movs	r4, #128	; 0x80
 800406c:	193a      	adds	r2, r7, r4
 800406e:	6013      	str	r3, [r2, #0]
 8004070:	2301      	movs	r3, #1
 8004072:	62bb      	str	r3, [r7, #40]	; 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004074:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004076:	f383 8810 	msr	PRIMASK, r3
}
 800407a:	46c0      	nop			; (mov r8, r8)
 800407c:	687b      	ldr	r3, [r7, #4]
 800407e:	681b      	ldr	r3, [r3, #0]
 8004080:	681a      	ldr	r2, [r3, #0]
 8004082:	687b      	ldr	r3, [r7, #4]
 8004084:	681b      	ldr	r3, [r3, #0]
 8004086:	2110      	movs	r1, #16
 8004088:	438a      	bics	r2, r1
 800408a:	601a      	str	r2, [r3, #0]
 800408c:	193b      	adds	r3, r7, r4
 800408e:	681b      	ldr	r3, [r3, #0]
 8004090:	62fb      	str	r3, [r7, #44]	; 0x2c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004092:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004094:	f383 8810 	msr	PRIMASK, r3
}
 8004098:	46c0      	nop			; (mov r8, r8)
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx complete callback*/
        huart->RxEventCallback(huart, nb_rx_data);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
 800409a:	183b      	adds	r3, r7, r0
 800409c:	881a      	ldrh	r2, [r3, #0]
 800409e:	687b      	ldr	r3, [r7, #4]
 80040a0:	0011      	movs	r1, r2
 80040a2:	0018      	movs	r0, r3
 80040a4:	f000 f860 	bl	8004168 <HAL_UARTEx_RxEventCallback>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
      }
      return;
 80040a8:	e044      	b.n	8004134 <HAL_UART_IRQHandler+0x5a0>
    }
  }

  /* UART wakeup from Stop mode interrupt occurred ---------------------------*/
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
 80040aa:	23a4      	movs	r3, #164	; 0xa4
 80040ac:	18fb      	adds	r3, r7, r3
 80040ae:	681a      	ldr	r2, [r3, #0]
 80040b0:	2380      	movs	r3, #128	; 0x80
 80040b2:	035b      	lsls	r3, r3, #13
 80040b4:	4013      	ands	r3, r2
 80040b6:	d010      	beq.n	80040da <HAL_UART_IRQHandler+0x546>
 80040b8:	239c      	movs	r3, #156	; 0x9c
 80040ba:	18fb      	adds	r3, r7, r3
 80040bc:	681a      	ldr	r2, [r3, #0]
 80040be:	2380      	movs	r3, #128	; 0x80
 80040c0:	03db      	lsls	r3, r3, #15
 80040c2:	4013      	ands	r3, r2
 80040c4:	d009      	beq.n	80040da <HAL_UART_IRQHandler+0x546>
  {
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 80040c6:	687b      	ldr	r3, [r7, #4]
 80040c8:	681b      	ldr	r3, [r3, #0]
 80040ca:	2280      	movs	r2, #128	; 0x80
 80040cc:	0352      	lsls	r2, r2, #13
 80040ce:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /* Call registered Wakeup Callback */
    huart->WakeupCallback(huart);
#else
    /* Call legacy weak Wakeup Callback */
    HAL_UARTEx_WakeupCallback(huart);
 80040d0:	687b      	ldr	r3, [r7, #4]
 80040d2:	0018      	movs	r0, r3
 80040d4:	f000 ff8e 	bl	8004ff4 <HAL_UARTEx_WakeupCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
    return;
 80040d8:	e02f      	b.n	800413a <HAL_UART_IRQHandler+0x5a6>
  }

  /* UART in mode Transmitter ------------------------------------------------*/
  if (((isrflags & USART_ISR_TXE) != 0U)
 80040da:	23a4      	movs	r3, #164	; 0xa4
 80040dc:	18fb      	adds	r3, r7, r3
 80040de:	681b      	ldr	r3, [r3, #0]
 80040e0:	2280      	movs	r2, #128	; 0x80
 80040e2:	4013      	ands	r3, r2
 80040e4:	d00f      	beq.n	8004106 <HAL_UART_IRQHandler+0x572>
      && ((cr1its & USART_CR1_TXEIE) != 0U))
 80040e6:	23a0      	movs	r3, #160	; 0xa0
 80040e8:	18fb      	adds	r3, r7, r3
 80040ea:	681b      	ldr	r3, [r3, #0]
 80040ec:	2280      	movs	r2, #128	; 0x80
 80040ee:	4013      	ands	r3, r2
 80040f0:	d009      	beq.n	8004106 <HAL_UART_IRQHandler+0x572>
  {
    if (huart->TxISR != NULL)
 80040f2:	687b      	ldr	r3, [r7, #4]
 80040f4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80040f6:	2b00      	cmp	r3, #0
 80040f8:	d01e      	beq.n	8004138 <HAL_UART_IRQHandler+0x5a4>
    {
      huart->TxISR(huart);
 80040fa:	687b      	ldr	r3, [r7, #4]
 80040fc:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80040fe:	687a      	ldr	r2, [r7, #4]
 8004100:	0010      	movs	r0, r2
 8004102:	4798      	blx	r3
    }
    return;
 8004104:	e018      	b.n	8004138 <HAL_UART_IRQHandler+0x5a4>
  }

  /* UART in mode Transmitter (transmission end) -----------------------------*/
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 8004106:	23a4      	movs	r3, #164	; 0xa4
 8004108:	18fb      	adds	r3, r7, r3
 800410a:	681b      	ldr	r3, [r3, #0]
 800410c:	2240      	movs	r2, #64	; 0x40
 800410e:	4013      	ands	r3, r2
 8004110:	d013      	beq.n	800413a <HAL_UART_IRQHandler+0x5a6>
 8004112:	23a0      	movs	r3, #160	; 0xa0
 8004114:	18fb      	adds	r3, r7, r3
 8004116:	681b      	ldr	r3, [r3, #0]
 8004118:	2240      	movs	r2, #64	; 0x40
 800411a:	4013      	ands	r3, r2
 800411c:	d00d      	beq.n	800413a <HAL_UART_IRQHandler+0x5a6>
  {
    UART_EndTransmit_IT(huart);
 800411e:	687b      	ldr	r3, [r7, #4]
 8004120:	0018      	movs	r0, r3
 8004122:	f000 fdd4 	bl	8004cce <UART_EndTransmit_IT>
    return;
 8004126:	e008      	b.n	800413a <HAL_UART_IRQHandler+0x5a6>
      return;
 8004128:	46c0      	nop			; (mov r8, r8)
 800412a:	e006      	b.n	800413a <HAL_UART_IRQHandler+0x5a6>
    return;
 800412c:	46c0      	nop			; (mov r8, r8)
 800412e:	e004      	b.n	800413a <HAL_UART_IRQHandler+0x5a6>
      return;
 8004130:	46c0      	nop			; (mov r8, r8)
 8004132:	e002      	b.n	800413a <HAL_UART_IRQHandler+0x5a6>
      return;
 8004134:	46c0      	nop			; (mov r8, r8)
 8004136:	e000      	b.n	800413a <HAL_UART_IRQHandler+0x5a6>
    return;
 8004138:	46c0      	nop			; (mov r8, r8)
  }

}
 800413a:	46bd      	mov	sp, r7
 800413c:	b02b      	add	sp, #172	; 0xac
 800413e:	bd90      	pop	{r4, r7, pc}
 8004140:	fffffeff 	.word	0xfffffeff
 8004144:	fffffedf 	.word	0xfffffedf

08004148 <HAL_UART_TxCpltCallback>:
  * @brief Tx Transfer completed callback.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
 8004148:	b580      	push	{r7, lr}
 800414a:	b082      	sub	sp, #8
 800414c:	af00      	add	r7, sp, #0
 800414e:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_TxCpltCallback can be implemented in the user file.
   */
}
 8004150:	46c0      	nop			; (mov r8, r8)
 8004152:	46bd      	mov	sp, r7
 8004154:	b002      	add	sp, #8
 8004156:	bd80      	pop	{r7, pc}

08004158 <HAL_UART_ErrorCallback>:
  * @brief  UART error callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 8004158:	b580      	push	{r7, lr}
 800415a:	b082      	sub	sp, #8
 800415c:	af00      	add	r7, sp, #0
 800415e:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_ErrorCallback can be implemented in the user file.
   */
}
 8004160:	46c0      	nop			; (mov r8, r8)
 8004162:	46bd      	mov	sp, r7
 8004164:	b002      	add	sp, #8
 8004166:	bd80      	pop	{r7, pc}

08004168 <HAL_UARTEx_RxEventCallback>:
  * @param  Size  Number of data available in application reception buffer (indicates a position in
  *               reception buffer until which, data are available)
  * @retval None
  */
__weak void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
{
 8004168:	b580      	push	{r7, lr}
 800416a:	b082      	sub	sp, #8
 800416c:	af00      	add	r7, sp, #0
 800416e:	6078      	str	r0, [r7, #4]
 8004170:	000a      	movs	r2, r1
 8004172:	1cbb      	adds	r3, r7, #2
 8004174:	801a      	strh	r2, [r3, #0]
  UNUSED(Size);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_RxEventCallback can be implemented in the user file.
   */
}
 8004176:	46c0      	nop			; (mov r8, r8)
 8004178:	46bd      	mov	sp, r7
 800417a:	b002      	add	sp, #8
 800417c:	bd80      	pop	{r7, pc}
	...

08004180 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8004180:	b5b0      	push	{r4, r5, r7, lr}
 8004182:	b08e      	sub	sp, #56	; 0x38
 8004184:	af00      	add	r7, sp, #0
 8004186:	61f8      	str	r0, [r7, #28]
  uint32_t tmpreg;
  uint16_t brrtemp;
  UART_ClockSourceTypeDef clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
 8004188:	231a      	movs	r3, #26
 800418a:	2218      	movs	r2, #24
 800418c:	4694      	mov	ip, r2
 800418e:	44bc      	add	ip, r7
 8004190:	4463      	add	r3, ip
 8004192:	2200      	movs	r2, #0
 8004194:	701a      	strb	r2, [r3, #0]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8004196:	69fb      	ldr	r3, [r7, #28]
 8004198:	689a      	ldr	r2, [r3, #8]
 800419a:	69fb      	ldr	r3, [r7, #28]
 800419c:	691b      	ldr	r3, [r3, #16]
 800419e:	431a      	orrs	r2, r3
 80041a0:	69fb      	ldr	r3, [r7, #28]
 80041a2:	695b      	ldr	r3, [r3, #20]
 80041a4:	431a      	orrs	r2, r3
 80041a6:	69fb      	ldr	r3, [r7, #28]
 80041a8:	69db      	ldr	r3, [r3, #28]
 80041aa:	4313      	orrs	r3, r2
 80041ac:	637b      	str	r3, [r7, #52]	; 0x34
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80041ae:	69fb      	ldr	r3, [r7, #28]
 80041b0:	681b      	ldr	r3, [r3, #0]
 80041b2:	681b      	ldr	r3, [r3, #0]
 80041b4:	4ab0      	ldr	r2, [pc, #704]	; (8004478 <UART_SetConfig+0x2f8>)
 80041b6:	4013      	ands	r3, r2
 80041b8:	0019      	movs	r1, r3
 80041ba:	69fb      	ldr	r3, [r7, #28]
 80041bc:	681b      	ldr	r3, [r3, #0]
 80041be:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80041c0:	430a      	orrs	r2, r1
 80041c2:	601a      	str	r2, [r3, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80041c4:	69fb      	ldr	r3, [r7, #28]
 80041c6:	681b      	ldr	r3, [r3, #0]
 80041c8:	685b      	ldr	r3, [r3, #4]
 80041ca:	4aac      	ldr	r2, [pc, #688]	; (800447c <UART_SetConfig+0x2fc>)
 80041cc:	4013      	ands	r3, r2
 80041ce:	0019      	movs	r1, r3
 80041d0:	69fb      	ldr	r3, [r7, #28]
 80041d2:	68da      	ldr	r2, [r3, #12]
 80041d4:	69fb      	ldr	r3, [r7, #28]
 80041d6:	681b      	ldr	r3, [r3, #0]
 80041d8:	430a      	orrs	r2, r1
 80041da:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 80041dc:	69fb      	ldr	r3, [r7, #28]
 80041de:	699b      	ldr	r3, [r3, #24]
 80041e0:	637b      	str	r3, [r7, #52]	; 0x34

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80041e2:	69fb      	ldr	r3, [r7, #28]
 80041e4:	681b      	ldr	r3, [r3, #0]
 80041e6:	4aa6      	ldr	r2, [pc, #664]	; (8004480 <UART_SetConfig+0x300>)
 80041e8:	4293      	cmp	r3, r2
 80041ea:	d004      	beq.n	80041f6 <UART_SetConfig+0x76>
  {
    tmpreg |= huart->Init.OneBitSampling;
 80041ec:	69fb      	ldr	r3, [r7, #28]
 80041ee:	6a1b      	ldr	r3, [r3, #32]
 80041f0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80041f2:	4313      	orrs	r3, r2
 80041f4:	637b      	str	r3, [r7, #52]	; 0x34
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80041f6:	69fb      	ldr	r3, [r7, #28]
 80041f8:	681b      	ldr	r3, [r3, #0]
 80041fa:	689b      	ldr	r3, [r3, #8]
 80041fc:	4aa1      	ldr	r2, [pc, #644]	; (8004484 <UART_SetConfig+0x304>)
 80041fe:	4013      	ands	r3, r2
 8004200:	0019      	movs	r1, r3
 8004202:	69fb      	ldr	r3, [r7, #28]
 8004204:	681b      	ldr	r3, [r3, #0]
 8004206:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8004208:	430a      	orrs	r2, r1
 800420a:	609a      	str	r2, [r3, #8]


  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 800420c:	69fb      	ldr	r3, [r7, #28]
 800420e:	681b      	ldr	r3, [r3, #0]
 8004210:	4a9d      	ldr	r2, [pc, #628]	; (8004488 <UART_SetConfig+0x308>)
 8004212:	4293      	cmp	r3, r2
 8004214:	d136      	bne.n	8004284 <UART_SetConfig+0x104>
 8004216:	4b9d      	ldr	r3, [pc, #628]	; (800448c <UART_SetConfig+0x30c>)
 8004218:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800421a:	2203      	movs	r2, #3
 800421c:	4013      	ands	r3, r2
 800421e:	2b03      	cmp	r3, #3
 8004220:	d020      	beq.n	8004264 <UART_SetConfig+0xe4>
 8004222:	d827      	bhi.n	8004274 <UART_SetConfig+0xf4>
 8004224:	2b02      	cmp	r3, #2
 8004226:	d00d      	beq.n	8004244 <UART_SetConfig+0xc4>
 8004228:	d824      	bhi.n	8004274 <UART_SetConfig+0xf4>
 800422a:	2b00      	cmp	r3, #0
 800422c:	d002      	beq.n	8004234 <UART_SetConfig+0xb4>
 800422e:	2b01      	cmp	r3, #1
 8004230:	d010      	beq.n	8004254 <UART_SetConfig+0xd4>
 8004232:	e01f      	b.n	8004274 <UART_SetConfig+0xf4>
 8004234:	231b      	movs	r3, #27
 8004236:	2218      	movs	r2, #24
 8004238:	4694      	mov	ip, r2
 800423a:	44bc      	add	ip, r7
 800423c:	4463      	add	r3, ip
 800423e:	2201      	movs	r2, #1
 8004240:	701a      	strb	r2, [r3, #0]
 8004242:	e0c5      	b.n	80043d0 <UART_SetConfig+0x250>
 8004244:	231b      	movs	r3, #27
 8004246:	2218      	movs	r2, #24
 8004248:	4694      	mov	ip, r2
 800424a:	44bc      	add	ip, r7
 800424c:	4463      	add	r3, ip
 800424e:	2202      	movs	r2, #2
 8004250:	701a      	strb	r2, [r3, #0]
 8004252:	e0bd      	b.n	80043d0 <UART_SetConfig+0x250>
 8004254:	231b      	movs	r3, #27
 8004256:	2218      	movs	r2, #24
 8004258:	4694      	mov	ip, r2
 800425a:	44bc      	add	ip, r7
 800425c:	4463      	add	r3, ip
 800425e:	2204      	movs	r2, #4
 8004260:	701a      	strb	r2, [r3, #0]
 8004262:	e0b5      	b.n	80043d0 <UART_SetConfig+0x250>
 8004264:	231b      	movs	r3, #27
 8004266:	2218      	movs	r2, #24
 8004268:	4694      	mov	ip, r2
 800426a:	44bc      	add	ip, r7
 800426c:	4463      	add	r3, ip
 800426e:	2208      	movs	r2, #8
 8004270:	701a      	strb	r2, [r3, #0]
 8004272:	e0ad      	b.n	80043d0 <UART_SetConfig+0x250>
 8004274:	231b      	movs	r3, #27
 8004276:	2218      	movs	r2, #24
 8004278:	4694      	mov	ip, r2
 800427a:	44bc      	add	ip, r7
 800427c:	4463      	add	r3, ip
 800427e:	2210      	movs	r2, #16
 8004280:	701a      	strb	r2, [r3, #0]
 8004282:	e0a5      	b.n	80043d0 <UART_SetConfig+0x250>
 8004284:	69fb      	ldr	r3, [r7, #28]
 8004286:	681b      	ldr	r3, [r3, #0]
 8004288:	4a81      	ldr	r2, [pc, #516]	; (8004490 <UART_SetConfig+0x310>)
 800428a:	4293      	cmp	r3, r2
 800428c:	d136      	bne.n	80042fc <UART_SetConfig+0x17c>
 800428e:	4b7f      	ldr	r3, [pc, #508]	; (800448c <UART_SetConfig+0x30c>)
 8004290:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8004292:	220c      	movs	r2, #12
 8004294:	4013      	ands	r3, r2
 8004296:	2b0c      	cmp	r3, #12
 8004298:	d020      	beq.n	80042dc <UART_SetConfig+0x15c>
 800429a:	d827      	bhi.n	80042ec <UART_SetConfig+0x16c>
 800429c:	2b08      	cmp	r3, #8
 800429e:	d00d      	beq.n	80042bc <UART_SetConfig+0x13c>
 80042a0:	d824      	bhi.n	80042ec <UART_SetConfig+0x16c>
 80042a2:	2b00      	cmp	r3, #0
 80042a4:	d002      	beq.n	80042ac <UART_SetConfig+0x12c>
 80042a6:	2b04      	cmp	r3, #4
 80042a8:	d010      	beq.n	80042cc <UART_SetConfig+0x14c>
 80042aa:	e01f      	b.n	80042ec <UART_SetConfig+0x16c>
 80042ac:	231b      	movs	r3, #27
 80042ae:	2218      	movs	r2, #24
 80042b0:	4694      	mov	ip, r2
 80042b2:	44bc      	add	ip, r7
 80042b4:	4463      	add	r3, ip
 80042b6:	2200      	movs	r2, #0
 80042b8:	701a      	strb	r2, [r3, #0]
 80042ba:	e089      	b.n	80043d0 <UART_SetConfig+0x250>
 80042bc:	231b      	movs	r3, #27
 80042be:	2218      	movs	r2, #24
 80042c0:	4694      	mov	ip, r2
 80042c2:	44bc      	add	ip, r7
 80042c4:	4463      	add	r3, ip
 80042c6:	2202      	movs	r2, #2
 80042c8:	701a      	strb	r2, [r3, #0]
 80042ca:	e081      	b.n	80043d0 <UART_SetConfig+0x250>
 80042cc:	231b      	movs	r3, #27
 80042ce:	2218      	movs	r2, #24
 80042d0:	4694      	mov	ip, r2
 80042d2:	44bc      	add	ip, r7
 80042d4:	4463      	add	r3, ip
 80042d6:	2204      	movs	r2, #4
 80042d8:	701a      	strb	r2, [r3, #0]
 80042da:	e079      	b.n	80043d0 <UART_SetConfig+0x250>
 80042dc:	231b      	movs	r3, #27
 80042de:	2218      	movs	r2, #24
 80042e0:	4694      	mov	ip, r2
 80042e2:	44bc      	add	ip, r7
 80042e4:	4463      	add	r3, ip
 80042e6:	2208      	movs	r2, #8
 80042e8:	701a      	strb	r2, [r3, #0]
 80042ea:	e071      	b.n	80043d0 <UART_SetConfig+0x250>
 80042ec:	231b      	movs	r3, #27
 80042ee:	2218      	movs	r2, #24
 80042f0:	4694      	mov	ip, r2
 80042f2:	44bc      	add	ip, r7
 80042f4:	4463      	add	r3, ip
 80042f6:	2210      	movs	r2, #16
 80042f8:	701a      	strb	r2, [r3, #0]
 80042fa:	e069      	b.n	80043d0 <UART_SetConfig+0x250>
 80042fc:	69fb      	ldr	r3, [r7, #28]
 80042fe:	681b      	ldr	r3, [r3, #0]
 8004300:	4a64      	ldr	r2, [pc, #400]	; (8004494 <UART_SetConfig+0x314>)
 8004302:	4293      	cmp	r3, r2
 8004304:	d107      	bne.n	8004316 <UART_SetConfig+0x196>
 8004306:	231b      	movs	r3, #27
 8004308:	2218      	movs	r2, #24
 800430a:	4694      	mov	ip, r2
 800430c:	44bc      	add	ip, r7
 800430e:	4463      	add	r3, ip
 8004310:	2200      	movs	r2, #0
 8004312:	701a      	strb	r2, [r3, #0]
 8004314:	e05c      	b.n	80043d0 <UART_SetConfig+0x250>
 8004316:	69fb      	ldr	r3, [r7, #28]
 8004318:	681b      	ldr	r3, [r3, #0]
 800431a:	4a5f      	ldr	r2, [pc, #380]	; (8004498 <UART_SetConfig+0x318>)
 800431c:	4293      	cmp	r3, r2
 800431e:	d107      	bne.n	8004330 <UART_SetConfig+0x1b0>
 8004320:	231b      	movs	r3, #27
 8004322:	2218      	movs	r2, #24
 8004324:	4694      	mov	ip, r2
 8004326:	44bc      	add	ip, r7
 8004328:	4463      	add	r3, ip
 800432a:	2200      	movs	r2, #0
 800432c:	701a      	strb	r2, [r3, #0]
 800432e:	e04f      	b.n	80043d0 <UART_SetConfig+0x250>
 8004330:	69fb      	ldr	r3, [r7, #28]
 8004332:	681b      	ldr	r3, [r3, #0]
 8004334:	4a52      	ldr	r2, [pc, #328]	; (8004480 <UART_SetConfig+0x300>)
 8004336:	4293      	cmp	r3, r2
 8004338:	d143      	bne.n	80043c2 <UART_SetConfig+0x242>
 800433a:	4b54      	ldr	r3, [pc, #336]	; (800448c <UART_SetConfig+0x30c>)
 800433c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800433e:	23c0      	movs	r3, #192	; 0xc0
 8004340:	011b      	lsls	r3, r3, #4
 8004342:	4013      	ands	r3, r2
 8004344:	22c0      	movs	r2, #192	; 0xc0
 8004346:	0112      	lsls	r2, r2, #4
 8004348:	4293      	cmp	r3, r2
 800434a:	d02a      	beq.n	80043a2 <UART_SetConfig+0x222>
 800434c:	22c0      	movs	r2, #192	; 0xc0
 800434e:	0112      	lsls	r2, r2, #4
 8004350:	4293      	cmp	r3, r2
 8004352:	d82e      	bhi.n	80043b2 <UART_SetConfig+0x232>
 8004354:	2280      	movs	r2, #128	; 0x80
 8004356:	0112      	lsls	r2, r2, #4
 8004358:	4293      	cmp	r3, r2
 800435a:	d012      	beq.n	8004382 <UART_SetConfig+0x202>
 800435c:	2280      	movs	r2, #128	; 0x80
 800435e:	0112      	lsls	r2, r2, #4
 8004360:	4293      	cmp	r3, r2
 8004362:	d826      	bhi.n	80043b2 <UART_SetConfig+0x232>
 8004364:	2b00      	cmp	r3, #0
 8004366:	d004      	beq.n	8004372 <UART_SetConfig+0x1f2>
 8004368:	2280      	movs	r2, #128	; 0x80
 800436a:	00d2      	lsls	r2, r2, #3
 800436c:	4293      	cmp	r3, r2
 800436e:	d010      	beq.n	8004392 <UART_SetConfig+0x212>
 8004370:	e01f      	b.n	80043b2 <UART_SetConfig+0x232>
 8004372:	231b      	movs	r3, #27
 8004374:	2218      	movs	r2, #24
 8004376:	4694      	mov	ip, r2
 8004378:	44bc      	add	ip, r7
 800437a:	4463      	add	r3, ip
 800437c:	2200      	movs	r2, #0
 800437e:	701a      	strb	r2, [r3, #0]
 8004380:	e026      	b.n	80043d0 <UART_SetConfig+0x250>
 8004382:	231b      	movs	r3, #27
 8004384:	2218      	movs	r2, #24
 8004386:	4694      	mov	ip, r2
 8004388:	44bc      	add	ip, r7
 800438a:	4463      	add	r3, ip
 800438c:	2202      	movs	r2, #2
 800438e:	701a      	strb	r2, [r3, #0]
 8004390:	e01e      	b.n	80043d0 <UART_SetConfig+0x250>
 8004392:	231b      	movs	r3, #27
 8004394:	2218      	movs	r2, #24
 8004396:	4694      	mov	ip, r2
 8004398:	44bc      	add	ip, r7
 800439a:	4463      	add	r3, ip
 800439c:	2204      	movs	r2, #4
 800439e:	701a      	strb	r2, [r3, #0]
 80043a0:	e016      	b.n	80043d0 <UART_SetConfig+0x250>
 80043a2:	231b      	movs	r3, #27
 80043a4:	2218      	movs	r2, #24
 80043a6:	4694      	mov	ip, r2
 80043a8:	44bc      	add	ip, r7
 80043aa:	4463      	add	r3, ip
 80043ac:	2208      	movs	r2, #8
 80043ae:	701a      	strb	r2, [r3, #0]
 80043b0:	e00e      	b.n	80043d0 <UART_SetConfig+0x250>
 80043b2:	231b      	movs	r3, #27
 80043b4:	2218      	movs	r2, #24
 80043b6:	4694      	mov	ip, r2
 80043b8:	44bc      	add	ip, r7
 80043ba:	4463      	add	r3, ip
 80043bc:	2210      	movs	r2, #16
 80043be:	701a      	strb	r2, [r3, #0]
 80043c0:	e006      	b.n	80043d0 <UART_SetConfig+0x250>
 80043c2:	231b      	movs	r3, #27
 80043c4:	2218      	movs	r2, #24
 80043c6:	4694      	mov	ip, r2
 80043c8:	44bc      	add	ip, r7
 80043ca:	4463      	add	r3, ip
 80043cc:	2210      	movs	r2, #16
 80043ce:	701a      	strb	r2, [r3, #0]

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
 80043d0:	69fb      	ldr	r3, [r7, #28]
 80043d2:	681b      	ldr	r3, [r3, #0]
 80043d4:	4a2a      	ldr	r2, [pc, #168]	; (8004480 <UART_SetConfig+0x300>)
 80043d6:	4293      	cmp	r3, r2
 80043d8:	d000      	beq.n	80043dc <UART_SetConfig+0x25c>
 80043da:	e09e      	b.n	800451a <UART_SetConfig+0x39a>
  {
    /* Retrieve frequency clock */
    switch (clocksource)
 80043dc:	231b      	movs	r3, #27
 80043de:	2218      	movs	r2, #24
 80043e0:	4694      	mov	ip, r2
 80043e2:	44bc      	add	ip, r7
 80043e4:	4463      	add	r3, ip
 80043e6:	781b      	ldrb	r3, [r3, #0]
 80043e8:	2b08      	cmp	r3, #8
 80043ea:	d01d      	beq.n	8004428 <UART_SetConfig+0x2a8>
 80043ec:	dc20      	bgt.n	8004430 <UART_SetConfig+0x2b0>
 80043ee:	2b04      	cmp	r3, #4
 80043f0:	d015      	beq.n	800441e <UART_SetConfig+0x29e>
 80043f2:	dc1d      	bgt.n	8004430 <UART_SetConfig+0x2b0>
 80043f4:	2b00      	cmp	r3, #0
 80043f6:	d002      	beq.n	80043fe <UART_SetConfig+0x27e>
 80043f8:	2b02      	cmp	r3, #2
 80043fa:	d005      	beq.n	8004408 <UART_SetConfig+0x288>
 80043fc:	e018      	b.n	8004430 <UART_SetConfig+0x2b0>
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 80043fe:	f7ff f8f3 	bl	80035e8 <HAL_RCC_GetPCLK1Freq>
 8004402:	0003      	movs	r3, r0
 8004404:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004406:	e01d      	b.n	8004444 <UART_SetConfig+0x2c4>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8004408:	4b20      	ldr	r3, [pc, #128]	; (800448c <UART_SetConfig+0x30c>)
 800440a:	681b      	ldr	r3, [r3, #0]
 800440c:	2210      	movs	r2, #16
 800440e:	4013      	ands	r3, r2
 8004410:	d002      	beq.n	8004418 <UART_SetConfig+0x298>
        {
          pclk = (uint32_t)(HSI_VALUE >> 2U);
 8004412:	4b22      	ldr	r3, [pc, #136]	; (800449c <UART_SetConfig+0x31c>)
 8004414:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 8004416:	e015      	b.n	8004444 <UART_SetConfig+0x2c4>
          pclk = (uint32_t) HSI_VALUE;
 8004418:	4b21      	ldr	r3, [pc, #132]	; (80044a0 <UART_SetConfig+0x320>)
 800441a:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800441c:	e012      	b.n	8004444 <UART_SetConfig+0x2c4>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 800441e:	f7ff f833 	bl	8003488 <HAL_RCC_GetSysClockFreq>
 8004422:	0003      	movs	r3, r0
 8004424:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004426:	e00d      	b.n	8004444 <UART_SetConfig+0x2c4>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 8004428:	2380      	movs	r3, #128	; 0x80
 800442a:	021b      	lsls	r3, r3, #8
 800442c:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800442e:	e009      	b.n	8004444 <UART_SetConfig+0x2c4>
      default:
        pclk = 0U;
 8004430:	2300      	movs	r3, #0
 8004432:	62fb      	str	r3, [r7, #44]	; 0x2c
        ret = HAL_ERROR;
 8004434:	231a      	movs	r3, #26
 8004436:	2218      	movs	r2, #24
 8004438:	4694      	mov	ip, r2
 800443a:	44bc      	add	ip, r7
 800443c:	4463      	add	r3, ip
 800443e:	2201      	movs	r2, #1
 8004440:	701a      	strb	r2, [r3, #0]
        break;
 8004442:	46c0      	nop			; (mov r8, r8)
    }

    /* If proper clock source reported */
    if (pclk != 0U)
 8004444:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004446:	2b00      	cmp	r3, #0
 8004448:	d100      	bne.n	800444c <UART_SetConfig+0x2cc>
 800444a:	e13c      	b.n	80046c6 <UART_SetConfig+0x546>
    {
      /* No Prescaler applicable */
      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((pclk < (3U * huart->Init.BaudRate)) ||
 800444c:	69fb      	ldr	r3, [r7, #28]
 800444e:	685a      	ldr	r2, [r3, #4]
 8004450:	0013      	movs	r3, r2
 8004452:	005b      	lsls	r3, r3, #1
 8004454:	189b      	adds	r3, r3, r2
 8004456:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004458:	429a      	cmp	r2, r3
 800445a:	d305      	bcc.n	8004468 <UART_SetConfig+0x2e8>
          (pclk > (4096U * huart->Init.BaudRate)))
 800445c:	69fb      	ldr	r3, [r7, #28]
 800445e:	685b      	ldr	r3, [r3, #4]
 8004460:	031b      	lsls	r3, r3, #12
      if ((pclk < (3U * huart->Init.BaudRate)) ||
 8004462:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8004464:	429a      	cmp	r2, r3
 8004466:	d91d      	bls.n	80044a4 <UART_SetConfig+0x324>
      {
        ret = HAL_ERROR;
 8004468:	231a      	movs	r3, #26
 800446a:	2218      	movs	r2, #24
 800446c:	4694      	mov	ip, r2
 800446e:	44bc      	add	ip, r7
 8004470:	4463      	add	r3, ip
 8004472:	2201      	movs	r2, #1
 8004474:	701a      	strb	r2, [r3, #0]
 8004476:	e126      	b.n	80046c6 <UART_SetConfig+0x546>
 8004478:	efff69f3 	.word	0xefff69f3
 800447c:	ffffcfff 	.word	0xffffcfff
 8004480:	40004800 	.word	0x40004800
 8004484:	fffff4ff 	.word	0xfffff4ff
 8004488:	40013800 	.word	0x40013800
 800448c:	40021000 	.word	0x40021000
 8004490:	40004400 	.word	0x40004400
 8004494:	40004c00 	.word	0x40004c00
 8004498:	40005000 	.word	0x40005000
 800449c:	003d0900 	.word	0x003d0900
 80044a0:	00f42400 	.word	0x00f42400
      }
      else
      {
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate));
 80044a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80044a6:	613b      	str	r3, [r7, #16]
 80044a8:	2300      	movs	r3, #0
 80044aa:	617b      	str	r3, [r7, #20]
 80044ac:	6939      	ldr	r1, [r7, #16]
 80044ae:	697a      	ldr	r2, [r7, #20]
 80044b0:	000b      	movs	r3, r1
 80044b2:	0e1b      	lsrs	r3, r3, #24
 80044b4:	0010      	movs	r0, r2
 80044b6:	0205      	lsls	r5, r0, #8
 80044b8:	431d      	orrs	r5, r3
 80044ba:	000b      	movs	r3, r1
 80044bc:	021c      	lsls	r4, r3, #8
 80044be:	69fb      	ldr	r3, [r7, #28]
 80044c0:	685b      	ldr	r3, [r3, #4]
 80044c2:	085b      	lsrs	r3, r3, #1
 80044c4:	60bb      	str	r3, [r7, #8]
 80044c6:	2300      	movs	r3, #0
 80044c8:	60fb      	str	r3, [r7, #12]
 80044ca:	68b8      	ldr	r0, [r7, #8]
 80044cc:	68f9      	ldr	r1, [r7, #12]
 80044ce:	1900      	adds	r0, r0, r4
 80044d0:	4169      	adcs	r1, r5
 80044d2:	69fb      	ldr	r3, [r7, #28]
 80044d4:	685b      	ldr	r3, [r3, #4]
 80044d6:	603b      	str	r3, [r7, #0]
 80044d8:	2300      	movs	r3, #0
 80044da:	607b      	str	r3, [r7, #4]
 80044dc:	683a      	ldr	r2, [r7, #0]
 80044de:	687b      	ldr	r3, [r7, #4]
 80044e0:	f7fb feb0 	bl	8000244 <__aeabi_uldivmod>
 80044e4:	0002      	movs	r2, r0
 80044e6:	000b      	movs	r3, r1
 80044e8:	0013      	movs	r3, r2
 80044ea:	62bb      	str	r3, [r7, #40]	; 0x28
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 80044ec:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80044ee:	23c0      	movs	r3, #192	; 0xc0
 80044f0:	009b      	lsls	r3, r3, #2
 80044f2:	429a      	cmp	r2, r3
 80044f4:	d309      	bcc.n	800450a <UART_SetConfig+0x38a>
 80044f6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80044f8:	2380      	movs	r3, #128	; 0x80
 80044fa:	035b      	lsls	r3, r3, #13
 80044fc:	429a      	cmp	r2, r3
 80044fe:	d204      	bcs.n	800450a <UART_SetConfig+0x38a>
        {
          huart->Instance->BRR = usartdiv;
 8004500:	69fb      	ldr	r3, [r7, #28]
 8004502:	681b      	ldr	r3, [r3, #0]
 8004504:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004506:	60da      	str	r2, [r3, #12]
 8004508:	e0dd      	b.n	80046c6 <UART_SetConfig+0x546>
        }
        else
        {
          ret = HAL_ERROR;
 800450a:	231a      	movs	r3, #26
 800450c:	2218      	movs	r2, #24
 800450e:	4694      	mov	ip, r2
 8004510:	44bc      	add	ip, r7
 8004512:	4463      	add	r3, ip
 8004514:	2201      	movs	r2, #1
 8004516:	701a      	strb	r2, [r3, #0]
 8004518:	e0d5      	b.n	80046c6 <UART_SetConfig+0x546>
        }
      } /* if ( (pclk < (3 * huart->Init.BaudRate) ) || (pclk > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800451a:	69fb      	ldr	r3, [r7, #28]
 800451c:	69da      	ldr	r2, [r3, #28]
 800451e:	2380      	movs	r3, #128	; 0x80
 8004520:	021b      	lsls	r3, r3, #8
 8004522:	429a      	cmp	r2, r3
 8004524:	d000      	beq.n	8004528 <UART_SetConfig+0x3a8>
 8004526:	e074      	b.n	8004612 <UART_SetConfig+0x492>
  {
    switch (clocksource)
 8004528:	231b      	movs	r3, #27
 800452a:	2218      	movs	r2, #24
 800452c:	4694      	mov	ip, r2
 800452e:	44bc      	add	ip, r7
 8004530:	4463      	add	r3, ip
 8004532:	781b      	ldrb	r3, [r3, #0]
 8004534:	2b08      	cmp	r3, #8
 8004536:	d822      	bhi.n	800457e <UART_SetConfig+0x3fe>
 8004538:	009a      	lsls	r2, r3, #2
 800453a:	4b6b      	ldr	r3, [pc, #428]	; (80046e8 <UART_SetConfig+0x568>)
 800453c:	18d3      	adds	r3, r2, r3
 800453e:	681b      	ldr	r3, [r3, #0]
 8004540:	469f      	mov	pc, r3
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 8004542:	f7ff f851 	bl	80035e8 <HAL_RCC_GetPCLK1Freq>
 8004546:	0003      	movs	r3, r0
 8004548:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800454a:	e022      	b.n	8004592 <UART_SetConfig+0x412>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 800454c:	f7ff f862 	bl	8003614 <HAL_RCC_GetPCLK2Freq>
 8004550:	0003      	movs	r3, r0
 8004552:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004554:	e01d      	b.n	8004592 <UART_SetConfig+0x412>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8004556:	4b65      	ldr	r3, [pc, #404]	; (80046ec <UART_SetConfig+0x56c>)
 8004558:	681b      	ldr	r3, [r3, #0]
 800455a:	2210      	movs	r2, #16
 800455c:	4013      	ands	r3, r2
 800455e:	d002      	beq.n	8004566 <UART_SetConfig+0x3e6>
        {
          pclk = (uint32_t)(HSI_VALUE >> 2U);
 8004560:	4b63      	ldr	r3, [pc, #396]	; (80046f0 <UART_SetConfig+0x570>)
 8004562:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 8004564:	e015      	b.n	8004592 <UART_SetConfig+0x412>
          pclk = (uint32_t) HSI_VALUE;
 8004566:	4b63      	ldr	r3, [pc, #396]	; (80046f4 <UART_SetConfig+0x574>)
 8004568:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800456a:	e012      	b.n	8004592 <UART_SetConfig+0x412>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 800456c:	f7fe ff8c 	bl	8003488 <HAL_RCC_GetSysClockFreq>
 8004570:	0003      	movs	r3, r0
 8004572:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004574:	e00d      	b.n	8004592 <UART_SetConfig+0x412>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 8004576:	2380      	movs	r3, #128	; 0x80
 8004578:	021b      	lsls	r3, r3, #8
 800457a:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800457c:	e009      	b.n	8004592 <UART_SetConfig+0x412>
      default:
        pclk = 0U;
 800457e:	2300      	movs	r3, #0
 8004580:	62fb      	str	r3, [r7, #44]	; 0x2c
        ret = HAL_ERROR;
 8004582:	231a      	movs	r3, #26
 8004584:	2218      	movs	r2, #24
 8004586:	4694      	mov	ip, r2
 8004588:	44bc      	add	ip, r7
 800458a:	4463      	add	r3, ip
 800458c:	2201      	movs	r2, #1
 800458e:	701a      	strb	r2, [r3, #0]
        break;
 8004590:	46c0      	nop			; (mov r8, r8)
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
 8004592:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004594:	2b00      	cmp	r3, #0
 8004596:	d100      	bne.n	800459a <UART_SetConfig+0x41a>
 8004598:	e095      	b.n	80046c6 <UART_SetConfig+0x546>
    {
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
 800459a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800459c:	005a      	lsls	r2, r3, #1
 800459e:	69fb      	ldr	r3, [r7, #28]
 80045a0:	685b      	ldr	r3, [r3, #4]
 80045a2:	085b      	lsrs	r3, r3, #1
 80045a4:	18d2      	adds	r2, r2, r3
 80045a6:	69fb      	ldr	r3, [r7, #28]
 80045a8:	685b      	ldr	r3, [r3, #4]
 80045aa:	0019      	movs	r1, r3
 80045ac:	0010      	movs	r0, r2
 80045ae:	f7fb fdbd 	bl	800012c <__udivsi3>
 80045b2:	0003      	movs	r3, r0
 80045b4:	b29b      	uxth	r3, r3
 80045b6:	62bb      	str	r3, [r7, #40]	; 0x28
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80045b8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80045ba:	2b0f      	cmp	r3, #15
 80045bc:	d921      	bls.n	8004602 <UART_SetConfig+0x482>
 80045be:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80045c0:	2380      	movs	r3, #128	; 0x80
 80045c2:	025b      	lsls	r3, r3, #9
 80045c4:	429a      	cmp	r2, r3
 80045c6:	d21c      	bcs.n	8004602 <UART_SetConfig+0x482>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 80045c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80045ca:	b29a      	uxth	r2, r3
 80045cc:	200e      	movs	r0, #14
 80045ce:	2418      	movs	r4, #24
 80045d0:	193b      	adds	r3, r7, r4
 80045d2:	181b      	adds	r3, r3, r0
 80045d4:	210f      	movs	r1, #15
 80045d6:	438a      	bics	r2, r1
 80045d8:	801a      	strh	r2, [r3, #0]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 80045da:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80045dc:	085b      	lsrs	r3, r3, #1
 80045de:	b29b      	uxth	r3, r3
 80045e0:	2207      	movs	r2, #7
 80045e2:	4013      	ands	r3, r2
 80045e4:	b299      	uxth	r1, r3
 80045e6:	193b      	adds	r3, r7, r4
 80045e8:	181b      	adds	r3, r3, r0
 80045ea:	193a      	adds	r2, r7, r4
 80045ec:	1812      	adds	r2, r2, r0
 80045ee:	8812      	ldrh	r2, [r2, #0]
 80045f0:	430a      	orrs	r2, r1
 80045f2:	801a      	strh	r2, [r3, #0]
        huart->Instance->BRR = brrtemp;
 80045f4:	69fb      	ldr	r3, [r7, #28]
 80045f6:	681b      	ldr	r3, [r3, #0]
 80045f8:	193a      	adds	r2, r7, r4
 80045fa:	1812      	adds	r2, r2, r0
 80045fc:	8812      	ldrh	r2, [r2, #0]
 80045fe:	60da      	str	r2, [r3, #12]
 8004600:	e061      	b.n	80046c6 <UART_SetConfig+0x546>
      }
      else
      {
        ret = HAL_ERROR;
 8004602:	231a      	movs	r3, #26
 8004604:	2218      	movs	r2, #24
 8004606:	4694      	mov	ip, r2
 8004608:	44bc      	add	ip, r7
 800460a:	4463      	add	r3, ip
 800460c:	2201      	movs	r2, #1
 800460e:	701a      	strb	r2, [r3, #0]
 8004610:	e059      	b.n	80046c6 <UART_SetConfig+0x546>
      }
    }
  }
  else
  {
    switch (clocksource)
 8004612:	231b      	movs	r3, #27
 8004614:	2218      	movs	r2, #24
 8004616:	4694      	mov	ip, r2
 8004618:	44bc      	add	ip, r7
 800461a:	4463      	add	r3, ip
 800461c:	781b      	ldrb	r3, [r3, #0]
 800461e:	2b08      	cmp	r3, #8
 8004620:	d822      	bhi.n	8004668 <UART_SetConfig+0x4e8>
 8004622:	009a      	lsls	r2, r3, #2
 8004624:	4b34      	ldr	r3, [pc, #208]	; (80046f8 <UART_SetConfig+0x578>)
 8004626:	18d3      	adds	r3, r2, r3
 8004628:	681b      	ldr	r3, [r3, #0]
 800462a:	469f      	mov	pc, r3
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 800462c:	f7fe ffdc 	bl	80035e8 <HAL_RCC_GetPCLK1Freq>
 8004630:	0003      	movs	r3, r0
 8004632:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004634:	e022      	b.n	800467c <UART_SetConfig+0x4fc>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 8004636:	f7fe ffed 	bl	8003614 <HAL_RCC_GetPCLK2Freq>
 800463a:	0003      	movs	r3, r0
 800463c:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800463e:	e01d      	b.n	800467c <UART_SetConfig+0x4fc>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8004640:	4b2a      	ldr	r3, [pc, #168]	; (80046ec <UART_SetConfig+0x56c>)
 8004642:	681b      	ldr	r3, [r3, #0]
 8004644:	2210      	movs	r2, #16
 8004646:	4013      	ands	r3, r2
 8004648:	d002      	beq.n	8004650 <UART_SetConfig+0x4d0>
        {
          pclk = (uint32_t)(HSI_VALUE >> 2U);
 800464a:	4b29      	ldr	r3, [pc, #164]	; (80046f0 <UART_SetConfig+0x570>)
 800464c:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 800464e:	e015      	b.n	800467c <UART_SetConfig+0x4fc>
          pclk = (uint32_t) HSI_VALUE;
 8004650:	4b28      	ldr	r3, [pc, #160]	; (80046f4 <UART_SetConfig+0x574>)
 8004652:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004654:	e012      	b.n	800467c <UART_SetConfig+0x4fc>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 8004656:	f7fe ff17 	bl	8003488 <HAL_RCC_GetSysClockFreq>
 800465a:	0003      	movs	r3, r0
 800465c:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800465e:	e00d      	b.n	800467c <UART_SetConfig+0x4fc>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 8004660:	2380      	movs	r3, #128	; 0x80
 8004662:	021b      	lsls	r3, r3, #8
 8004664:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8004666:	e009      	b.n	800467c <UART_SetConfig+0x4fc>
      default:
        pclk = 0U;
 8004668:	2300      	movs	r3, #0
 800466a:	62fb      	str	r3, [r7, #44]	; 0x2c
        ret = HAL_ERROR;
 800466c:	231a      	movs	r3, #26
 800466e:	2218      	movs	r2, #24
 8004670:	4694      	mov	ip, r2
 8004672:	44bc      	add	ip, r7
 8004674:	4463      	add	r3, ip
 8004676:	2201      	movs	r2, #1
 8004678:	701a      	strb	r2, [r3, #0]
        break;
 800467a:	46c0      	nop			; (mov r8, r8)
    }

    if (pclk != 0U)
 800467c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800467e:	2b00      	cmp	r3, #0
 8004680:	d021      	beq.n	80046c6 <UART_SetConfig+0x546>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
 8004682:	69fb      	ldr	r3, [r7, #28]
 8004684:	685b      	ldr	r3, [r3, #4]
 8004686:	085a      	lsrs	r2, r3, #1
 8004688:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800468a:	18d2      	adds	r2, r2, r3
 800468c:	69fb      	ldr	r3, [r7, #28]
 800468e:	685b      	ldr	r3, [r3, #4]
 8004690:	0019      	movs	r1, r3
 8004692:	0010      	movs	r0, r2
 8004694:	f7fb fd4a 	bl	800012c <__udivsi3>
 8004698:	0003      	movs	r3, r0
 800469a:	b29b      	uxth	r3, r3
 800469c:	62bb      	str	r3, [r7, #40]	; 0x28
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800469e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80046a0:	2b0f      	cmp	r3, #15
 80046a2:	d909      	bls.n	80046b8 <UART_SetConfig+0x538>
 80046a4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80046a6:	2380      	movs	r3, #128	; 0x80
 80046a8:	025b      	lsls	r3, r3, #9
 80046aa:	429a      	cmp	r2, r3
 80046ac:	d204      	bcs.n	80046b8 <UART_SetConfig+0x538>
      {
        huart->Instance->BRR = usartdiv;
 80046ae:	69fb      	ldr	r3, [r7, #28]
 80046b0:	681b      	ldr	r3, [r3, #0]
 80046b2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80046b4:	60da      	str	r2, [r3, #12]
 80046b6:	e006      	b.n	80046c6 <UART_SetConfig+0x546>
      }
      else
      {
        ret = HAL_ERROR;
 80046b8:	231a      	movs	r3, #26
 80046ba:	2218      	movs	r2, #24
 80046bc:	4694      	mov	ip, r2
 80046be:	44bc      	add	ip, r7
 80046c0:	4463      	add	r3, ip
 80046c2:	2201      	movs	r2, #1
 80046c4:	701a      	strb	r2, [r3, #0]
    }
  }


  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 80046c6:	69fb      	ldr	r3, [r7, #28]
 80046c8:	2200      	movs	r2, #0
 80046ca:	665a      	str	r2, [r3, #100]	; 0x64
  huart->TxISR = NULL;
 80046cc:	69fb      	ldr	r3, [r7, #28]
 80046ce:	2200      	movs	r2, #0
 80046d0:	669a      	str	r2, [r3, #104]	; 0x68

  return ret;
 80046d2:	231a      	movs	r3, #26
 80046d4:	2218      	movs	r2, #24
 80046d6:	4694      	mov	ip, r2
 80046d8:	44bc      	add	ip, r7
 80046da:	4463      	add	r3, ip
 80046dc:	781b      	ldrb	r3, [r3, #0]
}
 80046de:	0018      	movs	r0, r3
 80046e0:	46bd      	mov	sp, r7
 80046e2:	b00e      	add	sp, #56	; 0x38
 80046e4:	bdb0      	pop	{r4, r5, r7, pc}
 80046e6:	46c0      	nop			; (mov r8, r8)
 80046e8:	0802191c 	.word	0x0802191c
 80046ec:	40021000 	.word	0x40021000
 80046f0:	003d0900 	.word	0x003d0900
 80046f4:	00f42400 	.word	0x00f42400
 80046f8:	08021940 	.word	0x08021940

080046fc <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 80046fc:	b580      	push	{r7, lr}
 80046fe:	b082      	sub	sp, #8
 8004700:	af00      	add	r7, sp, #0
 8004702:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8004704:	687b      	ldr	r3, [r7, #4]
 8004706:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004708:	2201      	movs	r2, #1
 800470a:	4013      	ands	r3, r2
 800470c:	d00b      	beq.n	8004726 <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 800470e:	687b      	ldr	r3, [r7, #4]
 8004710:	681b      	ldr	r3, [r3, #0]
 8004712:	685b      	ldr	r3, [r3, #4]
 8004714:	4a4a      	ldr	r2, [pc, #296]	; (8004840 <UART_AdvFeatureConfig+0x144>)
 8004716:	4013      	ands	r3, r2
 8004718:	0019      	movs	r1, r3
 800471a:	687b      	ldr	r3, [r7, #4]
 800471c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800471e:	687b      	ldr	r3, [r7, #4]
 8004720:	681b      	ldr	r3, [r3, #0]
 8004722:	430a      	orrs	r2, r1
 8004724:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 8004726:	687b      	ldr	r3, [r7, #4]
 8004728:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800472a:	2202      	movs	r2, #2
 800472c:	4013      	ands	r3, r2
 800472e:	d00b      	beq.n	8004748 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8004730:	687b      	ldr	r3, [r7, #4]
 8004732:	681b      	ldr	r3, [r3, #0]
 8004734:	685b      	ldr	r3, [r3, #4]
 8004736:	4a43      	ldr	r2, [pc, #268]	; (8004844 <UART_AdvFeatureConfig+0x148>)
 8004738:	4013      	ands	r3, r2
 800473a:	0019      	movs	r1, r3
 800473c:	687b      	ldr	r3, [r7, #4]
 800473e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8004740:	687b      	ldr	r3, [r7, #4]
 8004742:	681b      	ldr	r3, [r3, #0]
 8004744:	430a      	orrs	r2, r1
 8004746:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8004748:	687b      	ldr	r3, [r7, #4]
 800474a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800474c:	2204      	movs	r2, #4
 800474e:	4013      	ands	r3, r2
 8004750:	d00b      	beq.n	800476a <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8004752:	687b      	ldr	r3, [r7, #4]
 8004754:	681b      	ldr	r3, [r3, #0]
 8004756:	685b      	ldr	r3, [r3, #4]
 8004758:	4a3b      	ldr	r2, [pc, #236]	; (8004848 <UART_AdvFeatureConfig+0x14c>)
 800475a:	4013      	ands	r3, r2
 800475c:	0019      	movs	r1, r3
 800475e:	687b      	ldr	r3, [r7, #4]
 8004760:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004762:	687b      	ldr	r3, [r7, #4]
 8004764:	681b      	ldr	r3, [r3, #0]
 8004766:	430a      	orrs	r2, r1
 8004768:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800476a:	687b      	ldr	r3, [r7, #4]
 800476c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800476e:	2208      	movs	r2, #8
 8004770:	4013      	ands	r3, r2
 8004772:	d00b      	beq.n	800478c <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8004774:	687b      	ldr	r3, [r7, #4]
 8004776:	681b      	ldr	r3, [r3, #0]
 8004778:	685b      	ldr	r3, [r3, #4]
 800477a:	4a34      	ldr	r2, [pc, #208]	; (800484c <UART_AdvFeatureConfig+0x150>)
 800477c:	4013      	ands	r3, r2
 800477e:	0019      	movs	r1, r3
 8004780:	687b      	ldr	r3, [r7, #4]
 8004782:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8004784:	687b      	ldr	r3, [r7, #4]
 8004786:	681b      	ldr	r3, [r3, #0]
 8004788:	430a      	orrs	r2, r1
 800478a:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 800478c:	687b      	ldr	r3, [r7, #4]
 800478e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004790:	2210      	movs	r2, #16
 8004792:	4013      	ands	r3, r2
 8004794:	d00b      	beq.n	80047ae <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8004796:	687b      	ldr	r3, [r7, #4]
 8004798:	681b      	ldr	r3, [r3, #0]
 800479a:	689b      	ldr	r3, [r3, #8]
 800479c:	4a2c      	ldr	r2, [pc, #176]	; (8004850 <UART_AdvFeatureConfig+0x154>)
 800479e:	4013      	ands	r3, r2
 80047a0:	0019      	movs	r1, r3
 80047a2:	687b      	ldr	r3, [r7, #4]
 80047a4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80047a6:	687b      	ldr	r3, [r7, #4]
 80047a8:	681b      	ldr	r3, [r3, #0]
 80047aa:	430a      	orrs	r2, r1
 80047ac:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 80047ae:	687b      	ldr	r3, [r7, #4]
 80047b0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80047b2:	2220      	movs	r2, #32
 80047b4:	4013      	ands	r3, r2
 80047b6:	d00b      	beq.n	80047d0 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 80047b8:	687b      	ldr	r3, [r7, #4]
 80047ba:	681b      	ldr	r3, [r3, #0]
 80047bc:	689b      	ldr	r3, [r3, #8]
 80047be:	4a25      	ldr	r2, [pc, #148]	; (8004854 <UART_AdvFeatureConfig+0x158>)
 80047c0:	4013      	ands	r3, r2
 80047c2:	0019      	movs	r1, r3
 80047c4:	687b      	ldr	r3, [r7, #4]
 80047c6:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80047c8:	687b      	ldr	r3, [r7, #4]
 80047ca:	681b      	ldr	r3, [r3, #0]
 80047cc:	430a      	orrs	r2, r1
 80047ce:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 80047d0:	687b      	ldr	r3, [r7, #4]
 80047d2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80047d4:	2240      	movs	r2, #64	; 0x40
 80047d6:	4013      	ands	r3, r2
 80047d8:	d01d      	beq.n	8004816 <UART_AdvFeatureConfig+0x11a>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80047da:	687b      	ldr	r3, [r7, #4]
 80047dc:	681b      	ldr	r3, [r3, #0]
 80047de:	685b      	ldr	r3, [r3, #4]
 80047e0:	4a1d      	ldr	r2, [pc, #116]	; (8004858 <UART_AdvFeatureConfig+0x15c>)
 80047e2:	4013      	ands	r3, r2
 80047e4:	0019      	movs	r1, r3
 80047e6:	687b      	ldr	r3, [r7, #4]
 80047e8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80047ea:	687b      	ldr	r3, [r7, #4]
 80047ec:	681b      	ldr	r3, [r3, #0]
 80047ee:	430a      	orrs	r2, r1
 80047f0:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80047f2:	687b      	ldr	r3, [r7, #4]
 80047f4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80047f6:	2380      	movs	r3, #128	; 0x80
 80047f8:	035b      	lsls	r3, r3, #13
 80047fa:	429a      	cmp	r2, r3
 80047fc:	d10b      	bne.n	8004816 <UART_AdvFeatureConfig+0x11a>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 80047fe:	687b      	ldr	r3, [r7, #4]
 8004800:	681b      	ldr	r3, [r3, #0]
 8004802:	685b      	ldr	r3, [r3, #4]
 8004804:	4a15      	ldr	r2, [pc, #84]	; (800485c <UART_AdvFeatureConfig+0x160>)
 8004806:	4013      	ands	r3, r2
 8004808:	0019      	movs	r1, r3
 800480a:	687b      	ldr	r3, [r7, #4]
 800480c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800480e:	687b      	ldr	r3, [r7, #4]
 8004810:	681b      	ldr	r3, [r3, #0]
 8004812:	430a      	orrs	r2, r1
 8004814:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8004816:	687b      	ldr	r3, [r7, #4]
 8004818:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800481a:	2280      	movs	r2, #128	; 0x80
 800481c:	4013      	ands	r3, r2
 800481e:	d00b      	beq.n	8004838 <UART_AdvFeatureConfig+0x13c>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8004820:	687b      	ldr	r3, [r7, #4]
 8004822:	681b      	ldr	r3, [r3, #0]
 8004824:	685b      	ldr	r3, [r3, #4]
 8004826:	4a0e      	ldr	r2, [pc, #56]	; (8004860 <UART_AdvFeatureConfig+0x164>)
 8004828:	4013      	ands	r3, r2
 800482a:	0019      	movs	r1, r3
 800482c:	687b      	ldr	r3, [r7, #4]
 800482e:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8004830:	687b      	ldr	r3, [r7, #4]
 8004832:	681b      	ldr	r3, [r3, #0]
 8004834:	430a      	orrs	r2, r1
 8004836:	605a      	str	r2, [r3, #4]
  }
}
 8004838:	46c0      	nop			; (mov r8, r8)
 800483a:	46bd      	mov	sp, r7
 800483c:	b002      	add	sp, #8
 800483e:	bd80      	pop	{r7, pc}
 8004840:	fffdffff 	.word	0xfffdffff
 8004844:	fffeffff 	.word	0xfffeffff
 8004848:	fffbffff 	.word	0xfffbffff
 800484c:	ffff7fff 	.word	0xffff7fff
 8004850:	ffffefff 	.word	0xffffefff
 8004854:	ffffdfff 	.word	0xffffdfff
 8004858:	ffefffff 	.word	0xffefffff
 800485c:	ff9fffff 	.word	0xff9fffff
 8004860:	fff7ffff 	.word	0xfff7ffff

08004864 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 8004864:	b580      	push	{r7, lr}
 8004866:	b086      	sub	sp, #24
 8004868:	af02      	add	r7, sp, #8
 800486a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800486c:	687b      	ldr	r3, [r7, #4]
 800486e:	2280      	movs	r2, #128	; 0x80
 8004870:	2100      	movs	r1, #0
 8004872:	5099      	str	r1, [r3, r2]

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 8004874:	f7fd fe14 	bl	80024a0 <HAL_GetTick>
 8004878:	0003      	movs	r3, r0
 800487a:	60fb      	str	r3, [r7, #12]

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800487c:	687b      	ldr	r3, [r7, #4]
 800487e:	681b      	ldr	r3, [r3, #0]
 8004880:	681b      	ldr	r3, [r3, #0]
 8004882:	2208      	movs	r2, #8
 8004884:	4013      	ands	r3, r2
 8004886:	2b08      	cmp	r3, #8
 8004888:	d10c      	bne.n	80048a4 <UART_CheckIdleState+0x40>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800488a:	68fb      	ldr	r3, [r7, #12]
 800488c:	2280      	movs	r2, #128	; 0x80
 800488e:	0391      	lsls	r1, r2, #14
 8004890:	6878      	ldr	r0, [r7, #4]
 8004892:	4a17      	ldr	r2, [pc, #92]	; (80048f0 <UART_CheckIdleState+0x8c>)
 8004894:	9200      	str	r2, [sp, #0]
 8004896:	2200      	movs	r2, #0
 8004898:	f000 f82c 	bl	80048f4 <UART_WaitOnFlagUntilTimeout>
 800489c:	1e03      	subs	r3, r0, #0
 800489e:	d001      	beq.n	80048a4 <UART_CheckIdleState+0x40>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 80048a0:	2303      	movs	r3, #3
 80048a2:	e021      	b.n	80048e8 <UART_CheckIdleState+0x84>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 80048a4:	687b      	ldr	r3, [r7, #4]
 80048a6:	681b      	ldr	r3, [r3, #0]
 80048a8:	681b      	ldr	r3, [r3, #0]
 80048aa:	2204      	movs	r2, #4
 80048ac:	4013      	ands	r3, r2
 80048ae:	2b04      	cmp	r3, #4
 80048b0:	d10c      	bne.n	80048cc <UART_CheckIdleState+0x68>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 80048b2:	68fb      	ldr	r3, [r7, #12]
 80048b4:	2280      	movs	r2, #128	; 0x80
 80048b6:	03d1      	lsls	r1, r2, #15
 80048b8:	6878      	ldr	r0, [r7, #4]
 80048ba:	4a0d      	ldr	r2, [pc, #52]	; (80048f0 <UART_CheckIdleState+0x8c>)
 80048bc:	9200      	str	r2, [sp, #0]
 80048be:	2200      	movs	r2, #0
 80048c0:	f000 f818 	bl	80048f4 <UART_WaitOnFlagUntilTimeout>
 80048c4:	1e03      	subs	r3, r0, #0
 80048c6:	d001      	beq.n	80048cc <UART_CheckIdleState+0x68>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 80048c8:	2303      	movs	r3, #3
 80048ca:	e00d      	b.n	80048e8 <UART_CheckIdleState+0x84>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 80048cc:	687b      	ldr	r3, [r7, #4]
 80048ce:	2220      	movs	r2, #32
 80048d0:	679a      	str	r2, [r3, #120]	; 0x78
  huart->RxState = HAL_UART_STATE_READY;
 80048d2:	687b      	ldr	r3, [r7, #4]
 80048d4:	2220      	movs	r2, #32
 80048d6:	67da      	str	r2, [r3, #124]	; 0x7c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80048d8:	687b      	ldr	r3, [r7, #4]
 80048da:	2200      	movs	r2, #0
 80048dc:	661a      	str	r2, [r3, #96]	; 0x60

  __HAL_UNLOCK(huart);
 80048de:	687b      	ldr	r3, [r7, #4]
 80048e0:	2274      	movs	r2, #116	; 0x74
 80048e2:	2100      	movs	r1, #0
 80048e4:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
 80048e6:	2300      	movs	r3, #0
}
 80048e8:	0018      	movs	r0, r3
 80048ea:	46bd      	mov	sp, r7
 80048ec:	b004      	add	sp, #16
 80048ee:	bd80      	pop	{r7, pc}
 80048f0:	01ffffff 	.word	0x01ffffff

080048f4 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 80048f4:	b580      	push	{r7, lr}
 80048f6:	b094      	sub	sp, #80	; 0x50
 80048f8:	af00      	add	r7, sp, #0
 80048fa:	60f8      	str	r0, [r7, #12]
 80048fc:	60b9      	str	r1, [r7, #8]
 80048fe:	603b      	str	r3, [r7, #0]
 8004900:	1dfb      	adds	r3, r7, #7
 8004902:	701a      	strb	r2, [r3, #0]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8004904:	e0a3      	b.n	8004a4e <UART_WaitOnFlagUntilTimeout+0x15a>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8004906:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8004908:	3301      	adds	r3, #1
 800490a:	d100      	bne.n	800490e <UART_WaitOnFlagUntilTimeout+0x1a>
 800490c:	e09f      	b.n	8004a4e <UART_WaitOnFlagUntilTimeout+0x15a>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800490e:	f7fd fdc7 	bl	80024a0 <HAL_GetTick>
 8004912:	0002      	movs	r2, r0
 8004914:	683b      	ldr	r3, [r7, #0]
 8004916:	1ad3      	subs	r3, r2, r3
 8004918:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800491a:	429a      	cmp	r2, r3
 800491c:	d302      	bcc.n	8004924 <UART_WaitOnFlagUntilTimeout+0x30>
 800491e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8004920:	2b00      	cmp	r3, #0
 8004922:	d13d      	bne.n	80049a0 <UART_WaitOnFlagUntilTimeout+0xac>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004924:	f3ef 8310 	mrs	r3, PRIMASK
 8004928:	62bb      	str	r3, [r7, #40]	; 0x28
  return(result);
 800492a:	6abb      	ldr	r3, [r7, #40]	; 0x28
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
           interrupts for the interrupt process */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800492c:	647b      	str	r3, [r7, #68]	; 0x44
 800492e:	2301      	movs	r3, #1
 8004930:	62fb      	str	r3, [r7, #44]	; 0x2c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004932:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004934:	f383 8810 	msr	PRIMASK, r3
}
 8004938:	46c0      	nop			; (mov r8, r8)
 800493a:	68fb      	ldr	r3, [r7, #12]
 800493c:	681b      	ldr	r3, [r3, #0]
 800493e:	681a      	ldr	r2, [r3, #0]
 8004940:	68fb      	ldr	r3, [r7, #12]
 8004942:	681b      	ldr	r3, [r3, #0]
 8004944:	494c      	ldr	r1, [pc, #304]	; (8004a78 <UART_WaitOnFlagUntilTimeout+0x184>)
 8004946:	400a      	ands	r2, r1
 8004948:	601a      	str	r2, [r3, #0]
 800494a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800494c:	633b      	str	r3, [r7, #48]	; 0x30
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800494e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004950:	f383 8810 	msr	PRIMASK, r3
}
 8004954:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004956:	f3ef 8310 	mrs	r3, PRIMASK
 800495a:	637b      	str	r3, [r7, #52]	; 0x34
  return(result);
 800495c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800495e:	643b      	str	r3, [r7, #64]	; 0x40
 8004960:	2301      	movs	r3, #1
 8004962:	63bb      	str	r3, [r7, #56]	; 0x38
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004964:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004966:	f383 8810 	msr	PRIMASK, r3
}
 800496a:	46c0      	nop			; (mov r8, r8)
 800496c:	68fb      	ldr	r3, [r7, #12]
 800496e:	681b      	ldr	r3, [r3, #0]
 8004970:	689a      	ldr	r2, [r3, #8]
 8004972:	68fb      	ldr	r3, [r7, #12]
 8004974:	681b      	ldr	r3, [r3, #0]
 8004976:	2101      	movs	r1, #1
 8004978:	438a      	bics	r2, r1
 800497a:	609a      	str	r2, [r3, #8]
 800497c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800497e:	63fb      	str	r3, [r7, #60]	; 0x3c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004980:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8004982:	f383 8810 	msr	PRIMASK, r3
}
 8004986:	46c0      	nop			; (mov r8, r8)

        huart->gState = HAL_UART_STATE_READY;
 8004988:	68fb      	ldr	r3, [r7, #12]
 800498a:	2220      	movs	r2, #32
 800498c:	679a      	str	r2, [r3, #120]	; 0x78
        huart->RxState = HAL_UART_STATE_READY;
 800498e:	68fb      	ldr	r3, [r7, #12]
 8004990:	2220      	movs	r2, #32
 8004992:	67da      	str	r2, [r3, #124]	; 0x7c

        __HAL_UNLOCK(huart);
 8004994:	68fb      	ldr	r3, [r7, #12]
 8004996:	2274      	movs	r2, #116	; 0x74
 8004998:	2100      	movs	r1, #0
 800499a:	5499      	strb	r1, [r3, r2]

        return HAL_TIMEOUT;
 800499c:	2303      	movs	r3, #3
 800499e:	e067      	b.n	8004a70 <UART_WaitOnFlagUntilTimeout+0x17c>
      }

      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 80049a0:	68fb      	ldr	r3, [r7, #12]
 80049a2:	681b      	ldr	r3, [r3, #0]
 80049a4:	681b      	ldr	r3, [r3, #0]
 80049a6:	2204      	movs	r2, #4
 80049a8:	4013      	ands	r3, r2
 80049aa:	d050      	beq.n	8004a4e <UART_WaitOnFlagUntilTimeout+0x15a>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 80049ac:	68fb      	ldr	r3, [r7, #12]
 80049ae:	681b      	ldr	r3, [r3, #0]
 80049b0:	69da      	ldr	r2, [r3, #28]
 80049b2:	2380      	movs	r3, #128	; 0x80
 80049b4:	011b      	lsls	r3, r3, #4
 80049b6:	401a      	ands	r2, r3
 80049b8:	2380      	movs	r3, #128	; 0x80
 80049ba:	011b      	lsls	r3, r3, #4
 80049bc:	429a      	cmp	r2, r3
 80049be:	d146      	bne.n	8004a4e <UART_WaitOnFlagUntilTimeout+0x15a>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 80049c0:	68fb      	ldr	r3, [r7, #12]
 80049c2:	681b      	ldr	r3, [r3, #0]
 80049c4:	2280      	movs	r2, #128	; 0x80
 80049c6:	0112      	lsls	r2, r2, #4
 80049c8:	621a      	str	r2, [r3, #32]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80049ca:	f3ef 8310 	mrs	r3, PRIMASK
 80049ce:	613b      	str	r3, [r7, #16]
  return(result);
 80049d0:	693b      	ldr	r3, [r7, #16]

          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
             interrupts for the interrupt process */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80049d2:	64fb      	str	r3, [r7, #76]	; 0x4c
 80049d4:	2301      	movs	r3, #1
 80049d6:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80049d8:	697b      	ldr	r3, [r7, #20]
 80049da:	f383 8810 	msr	PRIMASK, r3
}
 80049de:	46c0      	nop			; (mov r8, r8)
 80049e0:	68fb      	ldr	r3, [r7, #12]
 80049e2:	681b      	ldr	r3, [r3, #0]
 80049e4:	681a      	ldr	r2, [r3, #0]
 80049e6:	68fb      	ldr	r3, [r7, #12]
 80049e8:	681b      	ldr	r3, [r3, #0]
 80049ea:	4923      	ldr	r1, [pc, #140]	; (8004a78 <UART_WaitOnFlagUntilTimeout+0x184>)
 80049ec:	400a      	ands	r2, r1
 80049ee:	601a      	str	r2, [r3, #0]
 80049f0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80049f2:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80049f4:	69bb      	ldr	r3, [r7, #24]
 80049f6:	f383 8810 	msr	PRIMASK, r3
}
 80049fa:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80049fc:	f3ef 8310 	mrs	r3, PRIMASK
 8004a00:	61fb      	str	r3, [r7, #28]
  return(result);
 8004a02:	69fb      	ldr	r3, [r7, #28]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004a04:	64bb      	str	r3, [r7, #72]	; 0x48
 8004a06:	2301      	movs	r3, #1
 8004a08:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004a0a:	6a3b      	ldr	r3, [r7, #32]
 8004a0c:	f383 8810 	msr	PRIMASK, r3
}
 8004a10:	46c0      	nop			; (mov r8, r8)
 8004a12:	68fb      	ldr	r3, [r7, #12]
 8004a14:	681b      	ldr	r3, [r3, #0]
 8004a16:	689a      	ldr	r2, [r3, #8]
 8004a18:	68fb      	ldr	r3, [r7, #12]
 8004a1a:	681b      	ldr	r3, [r3, #0]
 8004a1c:	2101      	movs	r1, #1
 8004a1e:	438a      	bics	r2, r1
 8004a20:	609a      	str	r2, [r3, #8]
 8004a22:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8004a24:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004a26:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004a28:	f383 8810 	msr	PRIMASK, r3
}
 8004a2c:	46c0      	nop			; (mov r8, r8)

          huart->gState = HAL_UART_STATE_READY;
 8004a2e:	68fb      	ldr	r3, [r7, #12]
 8004a30:	2220      	movs	r2, #32
 8004a32:	679a      	str	r2, [r3, #120]	; 0x78
          huart->RxState = HAL_UART_STATE_READY;
 8004a34:	68fb      	ldr	r3, [r7, #12]
 8004a36:	2220      	movs	r2, #32
 8004a38:	67da      	str	r2, [r3, #124]	; 0x7c
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 8004a3a:	68fb      	ldr	r3, [r7, #12]
 8004a3c:	2280      	movs	r2, #128	; 0x80
 8004a3e:	2120      	movs	r1, #32
 8004a40:	5099      	str	r1, [r3, r2]

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 8004a42:	68fb      	ldr	r3, [r7, #12]
 8004a44:	2274      	movs	r2, #116	; 0x74
 8004a46:	2100      	movs	r1, #0
 8004a48:	5499      	strb	r1, [r3, r2]

          return HAL_TIMEOUT;
 8004a4a:	2303      	movs	r3, #3
 8004a4c:	e010      	b.n	8004a70 <UART_WaitOnFlagUntilTimeout+0x17c>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8004a4e:	68fb      	ldr	r3, [r7, #12]
 8004a50:	681b      	ldr	r3, [r3, #0]
 8004a52:	69db      	ldr	r3, [r3, #28]
 8004a54:	68ba      	ldr	r2, [r7, #8]
 8004a56:	4013      	ands	r3, r2
 8004a58:	68ba      	ldr	r2, [r7, #8]
 8004a5a:	1ad3      	subs	r3, r2, r3
 8004a5c:	425a      	negs	r2, r3
 8004a5e:	4153      	adcs	r3, r2
 8004a60:	b2db      	uxtb	r3, r3
 8004a62:	001a      	movs	r2, r3
 8004a64:	1dfb      	adds	r3, r7, #7
 8004a66:	781b      	ldrb	r3, [r3, #0]
 8004a68:	429a      	cmp	r2, r3
 8004a6a:	d100      	bne.n	8004a6e <UART_WaitOnFlagUntilTimeout+0x17a>
 8004a6c:	e74b      	b.n	8004906 <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 8004a6e:	2300      	movs	r3, #0
}
 8004a70:	0018      	movs	r0, r3
 8004a72:	46bd      	mov	sp, r7
 8004a74:	b014      	add	sp, #80	; 0x50
 8004a76:	bd80      	pop	{r7, pc}
 8004a78:	fffffe5f 	.word	0xfffffe5f

08004a7c <UART_Start_Receive_IT>:
  * @param  pData Pointer to data buffer (u8 or u16 data elements).
  * @param  Size  Amount of data elements (u8 or u16) to be received.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_Start_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 8004a7c:	b580      	push	{r7, lr}
 8004a7e:	b08c      	sub	sp, #48	; 0x30
 8004a80:	af00      	add	r7, sp, #0
 8004a82:	60f8      	str	r0, [r7, #12]
 8004a84:	60b9      	str	r1, [r7, #8]
 8004a86:	1dbb      	adds	r3, r7, #6
 8004a88:	801a      	strh	r2, [r3, #0]
  huart->pRxBuffPtr  = pData;
 8004a8a:	68fb      	ldr	r3, [r7, #12]
 8004a8c:	68ba      	ldr	r2, [r7, #8]
 8004a8e:	655a      	str	r2, [r3, #84]	; 0x54
  huart->RxXferSize  = Size;
 8004a90:	68fb      	ldr	r3, [r7, #12]
 8004a92:	1dba      	adds	r2, r7, #6
 8004a94:	2158      	movs	r1, #88	; 0x58
 8004a96:	8812      	ldrh	r2, [r2, #0]
 8004a98:	525a      	strh	r2, [r3, r1]
  huart->RxXferCount = Size;
 8004a9a:	68fb      	ldr	r3, [r7, #12]
 8004a9c:	1dba      	adds	r2, r7, #6
 8004a9e:	215a      	movs	r1, #90	; 0x5a
 8004aa0:	8812      	ldrh	r2, [r2, #0]
 8004aa2:	525a      	strh	r2, [r3, r1]
  huart->RxISR       = NULL;
 8004aa4:	68fb      	ldr	r3, [r7, #12]
 8004aa6:	2200      	movs	r2, #0
 8004aa8:	665a      	str	r2, [r3, #100]	; 0x64

  /* Computation of UART mask to apply to RDR register */
  UART_MASK_COMPUTATION(huart);
 8004aaa:	68fb      	ldr	r3, [r7, #12]
 8004aac:	689a      	ldr	r2, [r3, #8]
 8004aae:	2380      	movs	r3, #128	; 0x80
 8004ab0:	015b      	lsls	r3, r3, #5
 8004ab2:	429a      	cmp	r2, r3
 8004ab4:	d10d      	bne.n	8004ad2 <UART_Start_Receive_IT+0x56>
 8004ab6:	68fb      	ldr	r3, [r7, #12]
 8004ab8:	691b      	ldr	r3, [r3, #16]
 8004aba:	2b00      	cmp	r3, #0
 8004abc:	d104      	bne.n	8004ac8 <UART_Start_Receive_IT+0x4c>
 8004abe:	68fb      	ldr	r3, [r7, #12]
 8004ac0:	225c      	movs	r2, #92	; 0x5c
 8004ac2:	4943      	ldr	r1, [pc, #268]	; (8004bd0 <UART_Start_Receive_IT+0x154>)
 8004ac4:	5299      	strh	r1, [r3, r2]
 8004ac6:	e02e      	b.n	8004b26 <UART_Start_Receive_IT+0xaa>
 8004ac8:	68fb      	ldr	r3, [r7, #12]
 8004aca:	225c      	movs	r2, #92	; 0x5c
 8004acc:	21ff      	movs	r1, #255	; 0xff
 8004ace:	5299      	strh	r1, [r3, r2]
 8004ad0:	e029      	b.n	8004b26 <UART_Start_Receive_IT+0xaa>
 8004ad2:	68fb      	ldr	r3, [r7, #12]
 8004ad4:	689b      	ldr	r3, [r3, #8]
 8004ad6:	2b00      	cmp	r3, #0
 8004ad8:	d10d      	bne.n	8004af6 <UART_Start_Receive_IT+0x7a>
 8004ada:	68fb      	ldr	r3, [r7, #12]
 8004adc:	691b      	ldr	r3, [r3, #16]
 8004ade:	2b00      	cmp	r3, #0
 8004ae0:	d104      	bne.n	8004aec <UART_Start_Receive_IT+0x70>
 8004ae2:	68fb      	ldr	r3, [r7, #12]
 8004ae4:	225c      	movs	r2, #92	; 0x5c
 8004ae6:	21ff      	movs	r1, #255	; 0xff
 8004ae8:	5299      	strh	r1, [r3, r2]
 8004aea:	e01c      	b.n	8004b26 <UART_Start_Receive_IT+0xaa>
 8004aec:	68fb      	ldr	r3, [r7, #12]
 8004aee:	225c      	movs	r2, #92	; 0x5c
 8004af0:	217f      	movs	r1, #127	; 0x7f
 8004af2:	5299      	strh	r1, [r3, r2]
 8004af4:	e017      	b.n	8004b26 <UART_Start_Receive_IT+0xaa>
 8004af6:	68fb      	ldr	r3, [r7, #12]
 8004af8:	689a      	ldr	r2, [r3, #8]
 8004afa:	2380      	movs	r3, #128	; 0x80
 8004afc:	055b      	lsls	r3, r3, #21
 8004afe:	429a      	cmp	r2, r3
 8004b00:	d10d      	bne.n	8004b1e <UART_Start_Receive_IT+0xa2>
 8004b02:	68fb      	ldr	r3, [r7, #12]
 8004b04:	691b      	ldr	r3, [r3, #16]
 8004b06:	2b00      	cmp	r3, #0
 8004b08:	d104      	bne.n	8004b14 <UART_Start_Receive_IT+0x98>
 8004b0a:	68fb      	ldr	r3, [r7, #12]
 8004b0c:	225c      	movs	r2, #92	; 0x5c
 8004b0e:	217f      	movs	r1, #127	; 0x7f
 8004b10:	5299      	strh	r1, [r3, r2]
 8004b12:	e008      	b.n	8004b26 <UART_Start_Receive_IT+0xaa>
 8004b14:	68fb      	ldr	r3, [r7, #12]
 8004b16:	225c      	movs	r2, #92	; 0x5c
 8004b18:	213f      	movs	r1, #63	; 0x3f
 8004b1a:	5299      	strh	r1, [r3, r2]
 8004b1c:	e003      	b.n	8004b26 <UART_Start_Receive_IT+0xaa>
 8004b1e:	68fb      	ldr	r3, [r7, #12]
 8004b20:	225c      	movs	r2, #92	; 0x5c
 8004b22:	2100      	movs	r1, #0
 8004b24:	5299      	strh	r1, [r3, r2]

  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8004b26:	68fb      	ldr	r3, [r7, #12]
 8004b28:	2280      	movs	r2, #128	; 0x80
 8004b2a:	2100      	movs	r1, #0
 8004b2c:	5099      	str	r1, [r3, r2]
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 8004b2e:	68fb      	ldr	r3, [r7, #12]
 8004b30:	2222      	movs	r2, #34	; 0x22
 8004b32:	67da      	str	r2, [r3, #124]	; 0x7c
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004b34:	f3ef 8310 	mrs	r3, PRIMASK
 8004b38:	61fb      	str	r3, [r7, #28]
  return(result);
 8004b3a:	69fb      	ldr	r3, [r7, #28]

  /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004b3c:	62fb      	str	r3, [r7, #44]	; 0x2c
 8004b3e:	2301      	movs	r3, #1
 8004b40:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004b42:	6a3b      	ldr	r3, [r7, #32]
 8004b44:	f383 8810 	msr	PRIMASK, r3
}
 8004b48:	46c0      	nop			; (mov r8, r8)
 8004b4a:	68fb      	ldr	r3, [r7, #12]
 8004b4c:	681b      	ldr	r3, [r3, #0]
 8004b4e:	689a      	ldr	r2, [r3, #8]
 8004b50:	68fb      	ldr	r3, [r7, #12]
 8004b52:	681b      	ldr	r3, [r3, #0]
 8004b54:	2101      	movs	r1, #1
 8004b56:	430a      	orrs	r2, r1
 8004b58:	609a      	str	r2, [r3, #8]
 8004b5a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004b5c:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004b5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004b60:	f383 8810 	msr	PRIMASK, r3
}
 8004b64:	46c0      	nop			; (mov r8, r8)

  /* Set the Rx ISR function pointer according to the data word length */
  if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8004b66:	68fb      	ldr	r3, [r7, #12]
 8004b68:	689a      	ldr	r2, [r3, #8]
 8004b6a:	2380      	movs	r3, #128	; 0x80
 8004b6c:	015b      	lsls	r3, r3, #5
 8004b6e:	429a      	cmp	r2, r3
 8004b70:	d107      	bne.n	8004b82 <UART_Start_Receive_IT+0x106>
 8004b72:	68fb      	ldr	r3, [r7, #12]
 8004b74:	691b      	ldr	r3, [r3, #16]
 8004b76:	2b00      	cmp	r3, #0
 8004b78:	d103      	bne.n	8004b82 <UART_Start_Receive_IT+0x106>
  {
    huart->RxISR = UART_RxISR_16BIT;
 8004b7a:	68fb      	ldr	r3, [r7, #12]
 8004b7c:	4a15      	ldr	r2, [pc, #84]	; (8004bd4 <UART_Start_Receive_IT+0x158>)
 8004b7e:	665a      	str	r2, [r3, #100]	; 0x64
 8004b80:	e002      	b.n	8004b88 <UART_Start_Receive_IT+0x10c>
  }
  else
  {
    huart->RxISR = UART_RxISR_8BIT;
 8004b82:	68fb      	ldr	r3, [r7, #12]
 8004b84:	4a14      	ldr	r2, [pc, #80]	; (8004bd8 <UART_Start_Receive_IT+0x15c>)
 8004b86:	665a      	str	r2, [r3, #100]	; 0x64
  }

  __HAL_UNLOCK(huart);
 8004b88:	68fb      	ldr	r3, [r7, #12]
 8004b8a:	2274      	movs	r2, #116	; 0x74
 8004b8c:	2100      	movs	r1, #0
 8004b8e:	5499      	strb	r1, [r3, r2]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004b90:	f3ef 8310 	mrs	r3, PRIMASK
 8004b94:	613b      	str	r3, [r7, #16]
  return(result);
 8004b96:	693b      	ldr	r3, [r7, #16]

  /* Enable the UART Parity Error interrupt and Data Register Not Empty interrupt */
  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 8004b98:	62bb      	str	r3, [r7, #40]	; 0x28
 8004b9a:	2301      	movs	r3, #1
 8004b9c:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004b9e:	697b      	ldr	r3, [r7, #20]
 8004ba0:	f383 8810 	msr	PRIMASK, r3
}
 8004ba4:	46c0      	nop			; (mov r8, r8)
 8004ba6:	68fb      	ldr	r3, [r7, #12]
 8004ba8:	681b      	ldr	r3, [r3, #0]
 8004baa:	681a      	ldr	r2, [r3, #0]
 8004bac:	68fb      	ldr	r3, [r7, #12]
 8004bae:	681b      	ldr	r3, [r3, #0]
 8004bb0:	2190      	movs	r1, #144	; 0x90
 8004bb2:	0049      	lsls	r1, r1, #1
 8004bb4:	430a      	orrs	r2, r1
 8004bb6:	601a      	str	r2, [r3, #0]
 8004bb8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004bba:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004bbc:	69bb      	ldr	r3, [r7, #24]
 8004bbe:	f383 8810 	msr	PRIMASK, r3
}
 8004bc2:	46c0      	nop			; (mov r8, r8)
  return HAL_OK;
 8004bc4:	2300      	movs	r3, #0
}
 8004bc6:	0018      	movs	r0, r3
 8004bc8:	46bd      	mov	sp, r7
 8004bca:	b00c      	add	sp, #48	; 0x30
 8004bcc:	bd80      	pop	{r7, pc}
 8004bce:	46c0      	nop			; (mov r8, r8)
 8004bd0:	000001ff 	.word	0x000001ff
 8004bd4:	08004e8d 	.word	0x08004e8d
 8004bd8:	08004d25 	.word	0x08004d25

08004bdc <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 8004bdc:	b580      	push	{r7, lr}
 8004bde:	b08e      	sub	sp, #56	; 0x38
 8004be0:	af00      	add	r7, sp, #0
 8004be2:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004be4:	f3ef 8310 	mrs	r3, PRIMASK
 8004be8:	617b      	str	r3, [r7, #20]
  return(result);
 8004bea:	697b      	ldr	r3, [r7, #20]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8004bec:	637b      	str	r3, [r7, #52]	; 0x34
 8004bee:	2301      	movs	r3, #1
 8004bf0:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004bf2:	69bb      	ldr	r3, [r7, #24]
 8004bf4:	f383 8810 	msr	PRIMASK, r3
}
 8004bf8:	46c0      	nop			; (mov r8, r8)
 8004bfa:	687b      	ldr	r3, [r7, #4]
 8004bfc:	681b      	ldr	r3, [r3, #0]
 8004bfe:	681a      	ldr	r2, [r3, #0]
 8004c00:	687b      	ldr	r3, [r7, #4]
 8004c02:	681b      	ldr	r3, [r3, #0]
 8004c04:	4925      	ldr	r1, [pc, #148]	; (8004c9c <UART_EndRxTransfer+0xc0>)
 8004c06:	400a      	ands	r2, r1
 8004c08:	601a      	str	r2, [r3, #0]
 8004c0a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004c0c:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004c0e:	69fb      	ldr	r3, [r7, #28]
 8004c10:	f383 8810 	msr	PRIMASK, r3
}
 8004c14:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004c16:	f3ef 8310 	mrs	r3, PRIMASK
 8004c1a:	623b      	str	r3, [r7, #32]
  return(result);
 8004c1c:	6a3b      	ldr	r3, [r7, #32]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004c1e:	633b      	str	r3, [r7, #48]	; 0x30
 8004c20:	2301      	movs	r3, #1
 8004c22:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004c24:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004c26:	f383 8810 	msr	PRIMASK, r3
}
 8004c2a:	46c0      	nop			; (mov r8, r8)
 8004c2c:	687b      	ldr	r3, [r7, #4]
 8004c2e:	681b      	ldr	r3, [r3, #0]
 8004c30:	689a      	ldr	r2, [r3, #8]
 8004c32:	687b      	ldr	r3, [r7, #4]
 8004c34:	681b      	ldr	r3, [r3, #0]
 8004c36:	2101      	movs	r1, #1
 8004c38:	438a      	bics	r2, r1
 8004c3a:	609a      	str	r2, [r3, #8]
 8004c3c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004c3e:	62bb      	str	r3, [r7, #40]	; 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004c40:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004c42:	f383 8810 	msr	PRIMASK, r3
}
 8004c46:	46c0      	nop			; (mov r8, r8)

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8004c48:	687b      	ldr	r3, [r7, #4]
 8004c4a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004c4c:	2b01      	cmp	r3, #1
 8004c4e:	d118      	bne.n	8004c82 <UART_EndRxTransfer+0xa6>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004c50:	f3ef 8310 	mrs	r3, PRIMASK
 8004c54:	60bb      	str	r3, [r7, #8]
  return(result);
 8004c56:	68bb      	ldr	r3, [r7, #8]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8004c58:	62fb      	str	r3, [r7, #44]	; 0x2c
 8004c5a:	2301      	movs	r3, #1
 8004c5c:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004c5e:	68fb      	ldr	r3, [r7, #12]
 8004c60:	f383 8810 	msr	PRIMASK, r3
}
 8004c64:	46c0      	nop			; (mov r8, r8)
 8004c66:	687b      	ldr	r3, [r7, #4]
 8004c68:	681b      	ldr	r3, [r3, #0]
 8004c6a:	681a      	ldr	r2, [r3, #0]
 8004c6c:	687b      	ldr	r3, [r7, #4]
 8004c6e:	681b      	ldr	r3, [r3, #0]
 8004c70:	2110      	movs	r1, #16
 8004c72:	438a      	bics	r2, r1
 8004c74:	601a      	str	r2, [r3, #0]
 8004c76:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004c78:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004c7a:	693b      	ldr	r3, [r7, #16]
 8004c7c:	f383 8810 	msr	PRIMASK, r3
}
 8004c80:	46c0      	nop			; (mov r8, r8)
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8004c82:	687b      	ldr	r3, [r7, #4]
 8004c84:	2220      	movs	r2, #32
 8004c86:	67da      	str	r2, [r3, #124]	; 0x7c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8004c88:	687b      	ldr	r3, [r7, #4]
 8004c8a:	2200      	movs	r2, #0
 8004c8c:	661a      	str	r2, [r3, #96]	; 0x60

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 8004c8e:	687b      	ldr	r3, [r7, #4]
 8004c90:	2200      	movs	r2, #0
 8004c92:	665a      	str	r2, [r3, #100]	; 0x64
}
 8004c94:	46c0      	nop			; (mov r8, r8)
 8004c96:	46bd      	mov	sp, r7
 8004c98:	b00e      	add	sp, #56	; 0x38
 8004c9a:	bd80      	pop	{r7, pc}
 8004c9c:	fffffedf 	.word	0xfffffedf

08004ca0 <UART_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 8004ca0:	b580      	push	{r7, lr}
 8004ca2:	b084      	sub	sp, #16
 8004ca4:	af00      	add	r7, sp, #0
 8004ca6:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 8004ca8:	687b      	ldr	r3, [r7, #4]
 8004caa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004cac:	60fb      	str	r3, [r7, #12]
  huart->RxXferCount = 0U;
 8004cae:	68fb      	ldr	r3, [r7, #12]
 8004cb0:	225a      	movs	r2, #90	; 0x5a
 8004cb2:	2100      	movs	r1, #0
 8004cb4:	5299      	strh	r1, [r3, r2]
  huart->TxXferCount = 0U;
 8004cb6:	68fb      	ldr	r3, [r7, #12]
 8004cb8:	2252      	movs	r2, #82	; 0x52
 8004cba:	2100      	movs	r1, #0
 8004cbc:	5299      	strh	r1, [r3, r2]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 8004cbe:	68fb      	ldr	r3, [r7, #12]
 8004cc0:	0018      	movs	r0, r3
 8004cc2:	f7ff fa49 	bl	8004158 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8004cc6:	46c0      	nop			; (mov r8, r8)
 8004cc8:	46bd      	mov	sp, r7
 8004cca:	b004      	add	sp, #16
 8004ccc:	bd80      	pop	{r7, pc}

08004cce <UART_EndTransmit_IT>:
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
 8004cce:	b580      	push	{r7, lr}
 8004cd0:	b086      	sub	sp, #24
 8004cd2:	af00      	add	r7, sp, #0
 8004cd4:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004cd6:	f3ef 8310 	mrs	r3, PRIMASK
 8004cda:	60bb      	str	r3, [r7, #8]
  return(result);
 8004cdc:	68bb      	ldr	r3, [r7, #8]
  /* Disable the UART Transmit Complete Interrupt */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8004cde:	617b      	str	r3, [r7, #20]
 8004ce0:	2301      	movs	r3, #1
 8004ce2:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004ce4:	68fb      	ldr	r3, [r7, #12]
 8004ce6:	f383 8810 	msr	PRIMASK, r3
}
 8004cea:	46c0      	nop			; (mov r8, r8)
 8004cec:	687b      	ldr	r3, [r7, #4]
 8004cee:	681b      	ldr	r3, [r3, #0]
 8004cf0:	681a      	ldr	r2, [r3, #0]
 8004cf2:	687b      	ldr	r3, [r7, #4]
 8004cf4:	681b      	ldr	r3, [r3, #0]
 8004cf6:	2140      	movs	r1, #64	; 0x40
 8004cf8:	438a      	bics	r2, r1
 8004cfa:	601a      	str	r2, [r3, #0]
 8004cfc:	697b      	ldr	r3, [r7, #20]
 8004cfe:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004d00:	693b      	ldr	r3, [r7, #16]
 8004d02:	f383 8810 	msr	PRIMASK, r3
}
 8004d06:	46c0      	nop			; (mov r8, r8)

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8004d08:	687b      	ldr	r3, [r7, #4]
 8004d0a:	2220      	movs	r2, #32
 8004d0c:	679a      	str	r2, [r3, #120]	; 0x78

  /* Cleat TxISR function pointer */
  huart->TxISR = NULL;
 8004d0e:	687b      	ldr	r3, [r7, #4]
 8004d10:	2200      	movs	r2, #0
 8004d12:	669a      	str	r2, [r3, #104]	; 0x68
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 8004d14:	687b      	ldr	r3, [r7, #4]
 8004d16:	0018      	movs	r0, r3
 8004d18:	f7ff fa16 	bl	8004148 <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8004d1c:	46c0      	nop			; (mov r8, r8)
 8004d1e:	46bd      	mov	sp, r7
 8004d20:	b006      	add	sp, #24
 8004d22:	bd80      	pop	{r7, pc}

08004d24 <UART_RxISR_8BIT>:
  * @brief RX interrupt handler for 7 or 8 bits data word length .
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT(UART_HandleTypeDef *huart)
{
 8004d24:	b580      	push	{r7, lr}
 8004d26:	b090      	sub	sp, #64	; 0x40
 8004d28:	af00      	add	r7, sp, #0
 8004d2a:	6078      	str	r0, [r7, #4]
  uint16_t uhMask = huart->Mask;
 8004d2c:	203e      	movs	r0, #62	; 0x3e
 8004d2e:	183b      	adds	r3, r7, r0
 8004d30:	687a      	ldr	r2, [r7, #4]
 8004d32:	215c      	movs	r1, #92	; 0x5c
 8004d34:	5a52      	ldrh	r2, [r2, r1]
 8004d36:	801a      	strh	r2, [r3, #0]
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8004d38:	687b      	ldr	r3, [r7, #4]
 8004d3a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8004d3c:	2b22      	cmp	r3, #34	; 0x22
 8004d3e:	d000      	beq.n	8004d42 <UART_RxISR_8BIT+0x1e>
 8004d40:	e095      	b.n	8004e6e <UART_RxISR_8BIT+0x14a>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8004d42:	687b      	ldr	r3, [r7, #4]
 8004d44:	681b      	ldr	r3, [r3, #0]
 8004d46:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004d48:	213c      	movs	r1, #60	; 0x3c
 8004d4a:	187b      	adds	r3, r7, r1
 8004d4c:	801a      	strh	r2, [r3, #0]
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 8004d4e:	187b      	adds	r3, r7, r1
 8004d50:	881b      	ldrh	r3, [r3, #0]
 8004d52:	b2da      	uxtb	r2, r3
 8004d54:	183b      	adds	r3, r7, r0
 8004d56:	881b      	ldrh	r3, [r3, #0]
 8004d58:	b2d9      	uxtb	r1, r3
 8004d5a:	687b      	ldr	r3, [r7, #4]
 8004d5c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004d5e:	400a      	ands	r2, r1
 8004d60:	b2d2      	uxtb	r2, r2
 8004d62:	701a      	strb	r2, [r3, #0]
    huart->pRxBuffPtr++;
 8004d64:	687b      	ldr	r3, [r7, #4]
 8004d66:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004d68:	1c5a      	adds	r2, r3, #1
 8004d6a:	687b      	ldr	r3, [r7, #4]
 8004d6c:	655a      	str	r2, [r3, #84]	; 0x54
    huart->RxXferCount--;
 8004d6e:	687b      	ldr	r3, [r7, #4]
 8004d70:	225a      	movs	r2, #90	; 0x5a
 8004d72:	5a9b      	ldrh	r3, [r3, r2]
 8004d74:	b29b      	uxth	r3, r3
 8004d76:	3b01      	subs	r3, #1
 8004d78:	b299      	uxth	r1, r3
 8004d7a:	687b      	ldr	r3, [r7, #4]
 8004d7c:	225a      	movs	r2, #90	; 0x5a
 8004d7e:	5299      	strh	r1, [r3, r2]

    if (huart->RxXferCount == 0U)
 8004d80:	687b      	ldr	r3, [r7, #4]
 8004d82:	225a      	movs	r2, #90	; 0x5a
 8004d84:	5a9b      	ldrh	r3, [r3, r2]
 8004d86:	b29b      	uxth	r3, r3
 8004d88:	2b00      	cmp	r3, #0
 8004d8a:	d178      	bne.n	8004e7e <UART_RxISR_8BIT+0x15a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004d8c:	f3ef 8310 	mrs	r3, PRIMASK
 8004d90:	61bb      	str	r3, [r7, #24]
  return(result);
 8004d92:	69bb      	ldr	r3, [r7, #24]
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupts */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8004d94:	63bb      	str	r3, [r7, #56]	; 0x38
 8004d96:	2301      	movs	r3, #1
 8004d98:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004d9a:	69fb      	ldr	r3, [r7, #28]
 8004d9c:	f383 8810 	msr	PRIMASK, r3
}
 8004da0:	46c0      	nop			; (mov r8, r8)
 8004da2:	687b      	ldr	r3, [r7, #4]
 8004da4:	681b      	ldr	r3, [r3, #0]
 8004da6:	681a      	ldr	r2, [r3, #0]
 8004da8:	687b      	ldr	r3, [r7, #4]
 8004daa:	681b      	ldr	r3, [r3, #0]
 8004dac:	4936      	ldr	r1, [pc, #216]	; (8004e88 <UART_RxISR_8BIT+0x164>)
 8004dae:	400a      	ands	r2, r1
 8004db0:	601a      	str	r2, [r3, #0]
 8004db2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004db4:	623b      	str	r3, [r7, #32]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004db6:	6a3b      	ldr	r3, [r7, #32]
 8004db8:	f383 8810 	msr	PRIMASK, r3
}
 8004dbc:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004dbe:	f3ef 8310 	mrs	r3, PRIMASK
 8004dc2:	627b      	str	r3, [r7, #36]	; 0x24
  return(result);
 8004dc4:	6a7b      	ldr	r3, [r7, #36]	; 0x24

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004dc6:	637b      	str	r3, [r7, #52]	; 0x34
 8004dc8:	2301      	movs	r3, #1
 8004dca:	62bb      	str	r3, [r7, #40]	; 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004dcc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004dce:	f383 8810 	msr	PRIMASK, r3
}
 8004dd2:	46c0      	nop			; (mov r8, r8)
 8004dd4:	687b      	ldr	r3, [r7, #4]
 8004dd6:	681b      	ldr	r3, [r3, #0]
 8004dd8:	689a      	ldr	r2, [r3, #8]
 8004dda:	687b      	ldr	r3, [r7, #4]
 8004ddc:	681b      	ldr	r3, [r3, #0]
 8004dde:	2101      	movs	r1, #1
 8004de0:	438a      	bics	r2, r1
 8004de2:	609a      	str	r2, [r3, #8]
 8004de4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004de6:	62fb      	str	r3, [r7, #44]	; 0x2c
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004de8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004dea:	f383 8810 	msr	PRIMASK, r3
}
 8004dee:	46c0      	nop			; (mov r8, r8)

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8004df0:	687b      	ldr	r3, [r7, #4]
 8004df2:	2220      	movs	r2, #32
 8004df4:	67da      	str	r2, [r3, #124]	; 0x7c

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
 8004df6:	687b      	ldr	r3, [r7, #4]
 8004df8:	2200      	movs	r2, #0
 8004dfa:	665a      	str	r2, [r3, #100]	; 0x64

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8004dfc:	687b      	ldr	r3, [r7, #4]
 8004dfe:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004e00:	2b01      	cmp	r3, #1
 8004e02:	d12f      	bne.n	8004e64 <UART_RxISR_8BIT+0x140>
      {
        /* Set reception type to Standard */
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8004e04:	687b      	ldr	r3, [r7, #4]
 8004e06:	2200      	movs	r2, #0
 8004e08:	661a      	str	r2, [r3, #96]	; 0x60
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004e0a:	f3ef 8310 	mrs	r3, PRIMASK
 8004e0e:	60fb      	str	r3, [r7, #12]
  return(result);
 8004e10:	68fb      	ldr	r3, [r7, #12]

        /* Disable IDLE interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8004e12:	633b      	str	r3, [r7, #48]	; 0x30
 8004e14:	2301      	movs	r3, #1
 8004e16:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004e18:	693b      	ldr	r3, [r7, #16]
 8004e1a:	f383 8810 	msr	PRIMASK, r3
}
 8004e1e:	46c0      	nop			; (mov r8, r8)
 8004e20:	687b      	ldr	r3, [r7, #4]
 8004e22:	681b      	ldr	r3, [r3, #0]
 8004e24:	681a      	ldr	r2, [r3, #0]
 8004e26:	687b      	ldr	r3, [r7, #4]
 8004e28:	681b      	ldr	r3, [r3, #0]
 8004e2a:	2110      	movs	r1, #16
 8004e2c:	438a      	bics	r2, r1
 8004e2e:	601a      	str	r2, [r3, #0]
 8004e30:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004e32:	617b      	str	r3, [r7, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004e34:	697b      	ldr	r3, [r7, #20]
 8004e36:	f383 8810 	msr	PRIMASK, r3
}
 8004e3a:	46c0      	nop			; (mov r8, r8)

        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8004e3c:	687b      	ldr	r3, [r7, #4]
 8004e3e:	681b      	ldr	r3, [r3, #0]
 8004e40:	69db      	ldr	r3, [r3, #28]
 8004e42:	2210      	movs	r2, #16
 8004e44:	4013      	ands	r3, r2
 8004e46:	2b10      	cmp	r3, #16
 8004e48:	d103      	bne.n	8004e52 <UART_RxISR_8BIT+0x12e>
        {
          /* Clear IDLE Flag */
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8004e4a:	687b      	ldr	r3, [r7, #4]
 8004e4c:	681b      	ldr	r3, [r3, #0]
 8004e4e:	2210      	movs	r2, #16
 8004e50:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8004e52:	687b      	ldr	r3, [r7, #4]
 8004e54:	2258      	movs	r2, #88	; 0x58
 8004e56:	5a9a      	ldrh	r2, [r3, r2]
 8004e58:	687b      	ldr	r3, [r7, #4]
 8004e5a:	0011      	movs	r1, r2
 8004e5c:	0018      	movs	r0, r3
 8004e5e:	f7ff f983 	bl	8004168 <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 8004e62:	e00c      	b.n	8004e7e <UART_RxISR_8BIT+0x15a>
        HAL_UART_RxCpltCallback(huart);
 8004e64:	687b      	ldr	r3, [r7, #4]
 8004e66:	0018      	movs	r0, r3
 8004e68:	f7fb fb2a 	bl	80004c0 <HAL_UART_RxCpltCallback>
}
 8004e6c:	e007      	b.n	8004e7e <UART_RxISR_8BIT+0x15a>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8004e6e:	687b      	ldr	r3, [r7, #4]
 8004e70:	681b      	ldr	r3, [r3, #0]
 8004e72:	699a      	ldr	r2, [r3, #24]
 8004e74:	687b      	ldr	r3, [r7, #4]
 8004e76:	681b      	ldr	r3, [r3, #0]
 8004e78:	2108      	movs	r1, #8
 8004e7a:	430a      	orrs	r2, r1
 8004e7c:	619a      	str	r2, [r3, #24]
}
 8004e7e:	46c0      	nop			; (mov r8, r8)
 8004e80:	46bd      	mov	sp, r7
 8004e82:	b010      	add	sp, #64	; 0x40
 8004e84:	bd80      	pop	{r7, pc}
 8004e86:	46c0      	nop			; (mov r8, r8)
 8004e88:	fffffedf 	.word	0xfffffedf

08004e8c <UART_RxISR_16BIT>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT(UART_HandleTypeDef *huart)
{
 8004e8c:	b580      	push	{r7, lr}
 8004e8e:	b090      	sub	sp, #64	; 0x40
 8004e90:	af00      	add	r7, sp, #0
 8004e92:	6078      	str	r0, [r7, #4]
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
 8004e94:	203e      	movs	r0, #62	; 0x3e
 8004e96:	183b      	adds	r3, r7, r0
 8004e98:	687a      	ldr	r2, [r7, #4]
 8004e9a:	215c      	movs	r1, #92	; 0x5c
 8004e9c:	5a52      	ldrh	r2, [r2, r1]
 8004e9e:	801a      	strh	r2, [r3, #0]
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8004ea0:	687b      	ldr	r3, [r7, #4]
 8004ea2:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8004ea4:	2b22      	cmp	r3, #34	; 0x22
 8004ea6:	d000      	beq.n	8004eaa <UART_RxISR_16BIT+0x1e>
 8004ea8:	e095      	b.n	8004fd6 <UART_RxISR_16BIT+0x14a>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8004eaa:	687b      	ldr	r3, [r7, #4]
 8004eac:	681b      	ldr	r3, [r3, #0]
 8004eae:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004eb0:	213c      	movs	r1, #60	; 0x3c
 8004eb2:	187b      	adds	r3, r7, r1
 8004eb4:	801a      	strh	r2, [r3, #0]
    tmp = (uint16_t *) huart->pRxBuffPtr ;
 8004eb6:	687b      	ldr	r3, [r7, #4]
 8004eb8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004eba:	63bb      	str	r3, [r7, #56]	; 0x38
    *tmp = (uint16_t)(uhdata & uhMask);
 8004ebc:	187b      	adds	r3, r7, r1
 8004ebe:	183a      	adds	r2, r7, r0
 8004ec0:	881b      	ldrh	r3, [r3, #0]
 8004ec2:	8812      	ldrh	r2, [r2, #0]
 8004ec4:	4013      	ands	r3, r2
 8004ec6:	b29a      	uxth	r2, r3
 8004ec8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004eca:	801a      	strh	r2, [r3, #0]
    huart->pRxBuffPtr += 2U;
 8004ecc:	687b      	ldr	r3, [r7, #4]
 8004ece:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004ed0:	1c9a      	adds	r2, r3, #2
 8004ed2:	687b      	ldr	r3, [r7, #4]
 8004ed4:	655a      	str	r2, [r3, #84]	; 0x54
    huart->RxXferCount--;
 8004ed6:	687b      	ldr	r3, [r7, #4]
 8004ed8:	225a      	movs	r2, #90	; 0x5a
 8004eda:	5a9b      	ldrh	r3, [r3, r2]
 8004edc:	b29b      	uxth	r3, r3
 8004ede:	3b01      	subs	r3, #1
 8004ee0:	b299      	uxth	r1, r3
 8004ee2:	687b      	ldr	r3, [r7, #4]
 8004ee4:	225a      	movs	r2, #90	; 0x5a
 8004ee6:	5299      	strh	r1, [r3, r2]

    if (huart->RxXferCount == 0U)
 8004ee8:	687b      	ldr	r3, [r7, #4]
 8004eea:	225a      	movs	r2, #90	; 0x5a
 8004eec:	5a9b      	ldrh	r3, [r3, r2]
 8004eee:	b29b      	uxth	r3, r3
 8004ef0:	2b00      	cmp	r3, #0
 8004ef2:	d178      	bne.n	8004fe6 <UART_RxISR_16BIT+0x15a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004ef4:	f3ef 8310 	mrs	r3, PRIMASK
 8004ef8:	617b      	str	r3, [r7, #20]
  return(result);
 8004efa:	697b      	ldr	r3, [r7, #20]
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8004efc:	637b      	str	r3, [r7, #52]	; 0x34
 8004efe:	2301      	movs	r3, #1
 8004f00:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004f02:	69bb      	ldr	r3, [r7, #24]
 8004f04:	f383 8810 	msr	PRIMASK, r3
}
 8004f08:	46c0      	nop			; (mov r8, r8)
 8004f0a:	687b      	ldr	r3, [r7, #4]
 8004f0c:	681b      	ldr	r3, [r3, #0]
 8004f0e:	681a      	ldr	r2, [r3, #0]
 8004f10:	687b      	ldr	r3, [r7, #4]
 8004f12:	681b      	ldr	r3, [r3, #0]
 8004f14:	4936      	ldr	r1, [pc, #216]	; (8004ff0 <UART_RxISR_16BIT+0x164>)
 8004f16:	400a      	ands	r2, r1
 8004f18:	601a      	str	r2, [r3, #0]
 8004f1a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004f1c:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004f1e:	69fb      	ldr	r3, [r7, #28]
 8004f20:	f383 8810 	msr	PRIMASK, r3
}
 8004f24:	46c0      	nop			; (mov r8, r8)
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004f26:	f3ef 8310 	mrs	r3, PRIMASK
 8004f2a:	623b      	str	r3, [r7, #32]
  return(result);
 8004f2c:	6a3b      	ldr	r3, [r7, #32]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004f2e:	633b      	str	r3, [r7, #48]	; 0x30
 8004f30:	2301      	movs	r3, #1
 8004f32:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004f34:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004f36:	f383 8810 	msr	PRIMASK, r3
}
 8004f3a:	46c0      	nop			; (mov r8, r8)
 8004f3c:	687b      	ldr	r3, [r7, #4]
 8004f3e:	681b      	ldr	r3, [r3, #0]
 8004f40:	689a      	ldr	r2, [r3, #8]
 8004f42:	687b      	ldr	r3, [r7, #4]
 8004f44:	681b      	ldr	r3, [r3, #0]
 8004f46:	2101      	movs	r1, #1
 8004f48:	438a      	bics	r2, r1
 8004f4a:	609a      	str	r2, [r3, #8]
 8004f4c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004f4e:	62bb      	str	r3, [r7, #40]	; 0x28
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004f50:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004f52:	f383 8810 	msr	PRIMASK, r3
}
 8004f56:	46c0      	nop			; (mov r8, r8)

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8004f58:	687b      	ldr	r3, [r7, #4]
 8004f5a:	2220      	movs	r2, #32
 8004f5c:	67da      	str	r2, [r3, #124]	; 0x7c

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
 8004f5e:	687b      	ldr	r3, [r7, #4]
 8004f60:	2200      	movs	r2, #0
 8004f62:	665a      	str	r2, [r3, #100]	; 0x64

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8004f64:	687b      	ldr	r3, [r7, #4]
 8004f66:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8004f68:	2b01      	cmp	r3, #1
 8004f6a:	d12f      	bne.n	8004fcc <UART_RxISR_16BIT+0x140>
      {
        /* Set reception type to Standard */
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8004f6c:	687b      	ldr	r3, [r7, #4]
 8004f6e:	2200      	movs	r2, #0
 8004f70:	661a      	str	r2, [r3, #96]	; 0x60
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8004f72:	f3ef 8310 	mrs	r3, PRIMASK
 8004f76:	60bb      	str	r3, [r7, #8]
  return(result);
 8004f78:	68bb      	ldr	r3, [r7, #8]

        /* Disable IDLE interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8004f7a:	62fb      	str	r3, [r7, #44]	; 0x2c
 8004f7c:	2301      	movs	r3, #1
 8004f7e:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004f80:	68fb      	ldr	r3, [r7, #12]
 8004f82:	f383 8810 	msr	PRIMASK, r3
}
 8004f86:	46c0      	nop			; (mov r8, r8)
 8004f88:	687b      	ldr	r3, [r7, #4]
 8004f8a:	681b      	ldr	r3, [r3, #0]
 8004f8c:	681a      	ldr	r2, [r3, #0]
 8004f8e:	687b      	ldr	r3, [r7, #4]
 8004f90:	681b      	ldr	r3, [r3, #0]
 8004f92:	2110      	movs	r1, #16
 8004f94:	438a      	bics	r2, r1
 8004f96:	601a      	str	r2, [r3, #0]
 8004f98:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004f9a:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8004f9c:	693b      	ldr	r3, [r7, #16]
 8004f9e:	f383 8810 	msr	PRIMASK, r3
}
 8004fa2:	46c0      	nop			; (mov r8, r8)

        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8004fa4:	687b      	ldr	r3, [r7, #4]
 8004fa6:	681b      	ldr	r3, [r3, #0]
 8004fa8:	69db      	ldr	r3, [r3, #28]
 8004faa:	2210      	movs	r2, #16
 8004fac:	4013      	ands	r3, r2
 8004fae:	2b10      	cmp	r3, #16
 8004fb0:	d103      	bne.n	8004fba <UART_RxISR_16BIT+0x12e>
        {
          /* Clear IDLE Flag */
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8004fb2:	687b      	ldr	r3, [r7, #4]
 8004fb4:	681b      	ldr	r3, [r3, #0]
 8004fb6:	2210      	movs	r2, #16
 8004fb8:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8004fba:	687b      	ldr	r3, [r7, #4]
 8004fbc:	2258      	movs	r2, #88	; 0x58
 8004fbe:	5a9a      	ldrh	r2, [r3, r2]
 8004fc0:	687b      	ldr	r3, [r7, #4]
 8004fc2:	0011      	movs	r1, r2
 8004fc4:	0018      	movs	r0, r3
 8004fc6:	f7ff f8cf 	bl	8004168 <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 8004fca:	e00c      	b.n	8004fe6 <UART_RxISR_16BIT+0x15a>
        HAL_UART_RxCpltCallback(huart);
 8004fcc:	687b      	ldr	r3, [r7, #4]
 8004fce:	0018      	movs	r0, r3
 8004fd0:	f7fb fa76 	bl	80004c0 <HAL_UART_RxCpltCallback>
}
 8004fd4:	e007      	b.n	8004fe6 <UART_RxISR_16BIT+0x15a>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8004fd6:	687b      	ldr	r3, [r7, #4]
 8004fd8:	681b      	ldr	r3, [r3, #0]
 8004fda:	699a      	ldr	r2, [r3, #24]
 8004fdc:	687b      	ldr	r3, [r7, #4]
 8004fde:	681b      	ldr	r3, [r3, #0]
 8004fe0:	2108      	movs	r1, #8
 8004fe2:	430a      	orrs	r2, r1
 8004fe4:	619a      	str	r2, [r3, #24]
}
 8004fe6:	46c0      	nop			; (mov r8, r8)
 8004fe8:	46bd      	mov	sp, r7
 8004fea:	b010      	add	sp, #64	; 0x40
 8004fec:	bd80      	pop	{r7, pc}
 8004fee:	46c0      	nop			; (mov r8, r8)
 8004ff0:	fffffedf 	.word	0xfffffedf

08004ff4 <HAL_UARTEx_WakeupCallback>:
  * @brief UART wakeup from Stop mode callback.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UARTEx_WakeupCallback(UART_HandleTypeDef *huart)
{
 8004ff4:	b580      	push	{r7, lr}
 8004ff6:	b082      	sub	sp, #8
 8004ff8:	af00      	add	r7, sp, #0
 8004ffa:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_WakeupCallback can be implemented in the user file.
   */
}
 8004ffc:	46c0      	nop			; (mov r8, r8)
 8004ffe:	46bd      	mov	sp, r7
 8005000:	b002      	add	sp, #8
 8005002:	bd80      	pop	{r7, pc}

08005004 <HTTP_Client_Init>:

static httpc_state_t* HTTP_Connection_State;
static HTTP_Manager_TypDef HTTP_Manager;

void HTTP_Client_Init(HTTP_Client_Config_TypDef *cfg)
{
 8005004:	b580      	push	{r7, lr}
 8005006:	b082      	sub	sp, #8
 8005008:	af00      	add	r7, sp, #0
 800500a:	6078      	str	r0, [r7, #4]
    HTTP_Cleanup();
 800500c:	f000 f820 	bl	8005050 <HTTP_Cleanup>
    memcpy(&HTTP_Client_Config, cfg, sizeof(HTTP_Client_Config_TypDef));
 8005010:	4a0a      	ldr	r2, [pc, #40]	; (800503c <HTTP_Client_Init+0x38>)
 8005012:	6879      	ldr	r1, [r7, #4]
 8005014:	4b0a      	ldr	r3, [pc, #40]	; (8005040 <HTTP_Client_Init+0x3c>)
 8005016:	0018      	movs	r0, r3
 8005018:	f017 fbec 	bl	801c7f4 <memcpy>
    HTTP_Manager.Step = HTTP_STEP_DISCONNECT;
 800501c:	4b09      	ldr	r3, [pc, #36]	; (8005044 <HTTP_Client_Init+0x40>)
 800501e:	2200      	movs	r2, #0
 8005020:	701a      	strb	r2, [r3, #0]
    DEBUG_INFO("HTTP_STEP_DISCONNECT.\r\n");
 8005022:	f017 fb8d 	bl	801c740 <sys_get_tick_ms>
 8005026:	0001      	movs	r1, r0
 8005028:	4a07      	ldr	r2, [pc, #28]	; (8005048 <HTTP_Client_Init+0x44>)
 800502a:	4b08      	ldr	r3, [pc, #32]	; (800504c <HTTP_Client_Init+0x48>)
 800502c:	0018      	movs	r0, r3
 800502e:	f7fd f8cd 	bl	80021cc <app_debug_rtt_raw>
}
 8005032:	46c0      	nop			; (mov r8, r8)
 8005034:	46bd      	mov	sp, r7
 8005036:	b002      	add	sp, #8
 8005038:	bd80      	pop	{r7, pc}
 800503a:	46c0      	nop			; (mov r8, r8)
 800503c:	00000202 	.word	0x00000202
 8005040:	20000f04 	.word	0x20000f04
 8005044:	2000111c 	.word	0x2000111c
 8005048:	0801def0 	.word	0x0801def0
 800504c:	0801def4 	.word	0x0801def4

08005050 <HTTP_Cleanup>:
void HTTP_Cleanup(void)
{
 8005050:	b580      	push	{r7, lr}
 8005052:	af00      	add	r7, sp, #0
    //Total_Bytes_Recv = 0;
    //Content_Length = 0;
    memset(&HTTP_Client_Config, 0, sizeof(HTTP_Client_Config));
 8005054:	4a04      	ldr	r2, [pc, #16]	; (8005068 <HTTP_Cleanup+0x18>)
 8005056:	4b05      	ldr	r3, [pc, #20]	; (800506c <HTTP_Cleanup+0x1c>)
 8005058:	2100      	movs	r1, #0
 800505a:	0018      	movs	r0, r3
 800505c:	f017 fbe6 	bl	801c82c <memset>
}
 8005060:	46c0      	nop			; (mov r8, r8)
 8005062:	46bd      	mov	sp, r7
 8005064:	bd80      	pop	{r7, pc}
 8005066:	46c0      	nop			; (mov r8, r8)
 8005068:	00000202 	.word	0x00000202
 800506c:	20000f04 	.word	0x20000f04

08005070 <HTTP_Headers_Done_Callback>:
/**
 * @brief Header received done callback
 */
err_t HTTP_Headers_Done_Callback(httpc_state_t *connection, void *arg, struct pbuf *hdr, u16_t hdr_len, u32_t content_len)
{
 8005070:	b580      	push	{r7, lr}
 8005072:	b084      	sub	sp, #16
 8005074:	af00      	add	r7, sp, #0
 8005076:	60f8      	str	r0, [r7, #12]
 8005078:	60b9      	str	r1, [r7, #8]
 800507a:	607a      	str	r2, [r7, #4]
 800507c:	001a      	movs	r2, r3
 800507e:	1cbb      	adds	r3, r7, #2
 8005080:	801a      	strh	r2, [r3, #0]
    DEBUG_INFO("httpc_headers_callback, content length %d\r\n", content_len);
 8005082:	f017 fb5d 	bl	801c740 <sys_get_tick_ms>
 8005086:	0001      	movs	r1, r0
 8005088:	69bb      	ldr	r3, [r7, #24]
 800508a:	4a0e      	ldr	r2, [pc, #56]	; (80050c4 <HTTP_Headers_Done_Callback+0x54>)
 800508c:	480e      	ldr	r0, [pc, #56]	; (80050c8 <HTTP_Headers_Done_Callback+0x58>)
 800508e:	f7fd f89d 	bl	80021cc <app_debug_rtt_raw>

    if (content_len == 0xFFFFFFFF)
 8005092:	69bb      	ldr	r3, [r7, #24]
 8005094:	3301      	adds	r3, #1
 8005096:	d108      	bne.n	80050aa <HTTP_Headers_Done_Callback+0x3a>
            Content length không hợp lệ, có thể có những lí do sau
            	- Trong header server trả về không có trường "Content-Length"
            	- Server trả về dạng stream data, dữ liệu kết thúc khi server đóng kết nối
            	- Các lí do khác
        */
        DEBUG_INFO("Invalid content length\r\n");
 8005098:	f017 fb52 	bl	801c740 <sys_get_tick_ms>
 800509c:	0001      	movs	r1, r0
 800509e:	4a09      	ldr	r2, [pc, #36]	; (80050c4 <HTTP_Headers_Done_Callback+0x54>)
 80050a0:	4b0a      	ldr	r3, [pc, #40]	; (80050cc <HTTP_Headers_Done_Callback+0x5c>)
 80050a2:	0018      	movs	r0, r3
 80050a4:	f7fd f892 	bl	80021cc <app_debug_rtt_raw>
 80050a8:	e007      	b.n	80050ba <HTTP_Headers_Done_Callback+0x4a>
    }
    else
    {
        DEBUG_INFO("HTTP content length %u bytes\r\n", content_len);
 80050aa:	f017 fb49 	bl	801c740 <sys_get_tick_ms>
 80050ae:	0001      	movs	r1, r0
 80050b0:	69bb      	ldr	r3, [r7, #24]
 80050b2:	4a04      	ldr	r2, [pc, #16]	; (80050c4 <HTTP_Headers_Done_Callback+0x54>)
 80050b4:	4806      	ldr	r0, [pc, #24]	; (80050d0 <HTTP_Headers_Done_Callback+0x60>)
 80050b6:	f7fd f889 	bl	80021cc <app_debug_rtt_raw>
    }

    return ERR_OK;
 80050ba:	2300      	movs	r3, #0
}
 80050bc:	0018      	movs	r0, r3
 80050be:	46bd      	mov	sp, r7
 80050c0:	b004      	add	sp, #16
 80050c2:	bd80      	pop	{r7, pc}
 80050c4:	0801def0 	.word	0x0801def0
 80050c8:	0801df28 	.word	0x0801df28
 80050cc:	0801df70 	.word	0x0801df70
 80050d0:	0801dfa4 	.word	0x0801dfa4

080050d4 <HTTP_Result_Callback>:
/**
 * @brief Result transfer done callback
 */
static void HTTP_Result_Callback(void *arg, httpc_result_t httpc_result, u32_t rx_content_len, u32_t srv_res, err_t err)
{
 80050d4:	b5b0      	push	{r4, r5, r7, lr}
 80050d6:	b086      	sub	sp, #24
 80050d8:	af02      	add	r7, sp, #8
 80050da:	60f8      	str	r0, [r7, #12]
 80050dc:	607a      	str	r2, [r7, #4]
 80050de:	603b      	str	r3, [r7, #0]
 80050e0:	250b      	movs	r5, #11
 80050e2:	197b      	adds	r3, r7, r5
 80050e4:	1c0a      	adds	r2, r1, #0
 80050e6:	701a      	strb	r2, [r3, #0]
    DEBUG_INFO("result: %d, content len: %d, status code: %d\r\n", httpc_result, rx_content_len, srv_res);
 80050e8:	f017 fb2a 	bl	801c740 <sys_get_tick_ms>
 80050ec:	0004      	movs	r4, r0
 80050ee:	197b      	adds	r3, r7, r5
 80050f0:	7819      	ldrb	r1, [r3, #0]
 80050f2:	4a1b      	ldr	r2, [pc, #108]	; (8005160 <HTTP_Result_Callback+0x8c>)
 80050f4:	481b      	ldr	r0, [pc, #108]	; (8005164 <HTTP_Result_Callback+0x90>)
 80050f6:	683b      	ldr	r3, [r7, #0]
 80050f8:	9301      	str	r3, [sp, #4]
 80050fa:	687b      	ldr	r3, [r7, #4]
 80050fc:	9300      	str	r3, [sp, #0]
 80050fe:	000b      	movs	r3, r1
 8005100:	0021      	movs	r1, r4
 8005102:	f7fd f863 	bl	80021cc <app_debug_rtt_raw>
    switch (err)
 8005106:	2320      	movs	r3, #32
 8005108:	18fb      	adds	r3, r7, r3
 800510a:	781b      	ldrb	r3, [r3, #0]
 800510c:	b25b      	sxtb	r3, r3
 800510e:	2b00      	cmp	r3, #0
 8005110:	d004      	beq.n	800511c <HTTP_Result_Callback+0x48>
 8005112:	db15      	blt.n	8005140 <HTTP_Result_Callback+0x6c>
 8005114:	3b01      	subs	r3, #1
 8005116:	2b08      	cmp	r3, #8
 8005118:	d812      	bhi.n	8005140 <HTTP_Result_Callback+0x6c>
 800511a:	e008      	b.n	800512e <HTTP_Result_Callback+0x5a>
    {
        case HTTPC_RESULT_OK: /** File successfully received */
        {
            DEBUG_INFO("HTTPC_RESULT_OK\r\n");
 800511c:	f017 fb10 	bl	801c740 <sys_get_tick_ms>
 8005120:	0001      	movs	r1, r0
 8005122:	4a0f      	ldr	r2, [pc, #60]	; (8005160 <HTTP_Result_Callback+0x8c>)
 8005124:	4b10      	ldr	r3, [pc, #64]	; (8005168 <HTTP_Result_Callback+0x94>)
 8005126:	0018      	movs	r0, r3
 8005128:	f7fd f850 	bl	80021cc <app_debug_rtt_raw>
        }
            break;
 800512c:	e014      	b.n	8005158 <HTTP_Result_Callback+0x84>
        case HTTPC_RESULT_ERR_MEM:         /** Local memory error */
                                           //break;
        case HTTPC_RESULT_LOCAL_ABORT:     /** Local abort */
                                           //break;
        case HTTPC_RESULT_ERR_CONTENT_LEN: /** Content length mismatch */
            DEBUG_ERROR("Error content length\r\n");
 800512e:	f017 fb07 	bl	801c740 <sys_get_tick_ms>
 8005132:	0001      	movs	r1, r0
 8005134:	4a0a      	ldr	r2, [pc, #40]	; (8005160 <HTTP_Result_Callback+0x8c>)
 8005136:	4b0d      	ldr	r3, [pc, #52]	; (800516c <HTTP_Result_Callback+0x98>)
 8005138:	0018      	movs	r0, r3
 800513a:	f7fd f847 	bl	80021cc <app_debug_rtt_raw>
            break;
 800513e:	e00b      	b.n	8005158 <HTTP_Result_Callback+0x84>

        default:
            DEBUG_INFO("httpc_result_callback error %d\r\n", err);
 8005140:	f017 fafe 	bl	801c740 <sys_get_tick_ms>
 8005144:	0001      	movs	r1, r0
 8005146:	2320      	movs	r3, #32
 8005148:	18fb      	adds	r3, r7, r3
 800514a:	781b      	ldrb	r3, [r3, #0]
 800514c:	b25b      	sxtb	r3, r3
 800514e:	4a04      	ldr	r2, [pc, #16]	; (8005160 <HTTP_Result_Callback+0x8c>)
 8005150:	4807      	ldr	r0, [pc, #28]	; (8005170 <HTTP_Result_Callback+0x9c>)
 8005152:	f7fd f83b 	bl	80021cc <app_debug_rtt_raw>
            break;
 8005156:	46c0      	nop			; (mov r8, r8)
    }
}
 8005158:	46c0      	nop			; (mov r8, r8)
 800515a:	46bd      	mov	sp, r7
 800515c:	b004      	add	sp, #16
 800515e:	bdb0      	pop	{r4, r5, r7, pc}
 8005160:	0801def0 	.word	0x0801def0
 8005164:	0801dfdc 	.word	0x0801dfdc
 8005168:	0801e024 	.word	0x0801e024
 800516c:	0801e050 	.word	0x0801e050
 8005170:	0801e080 	.word	0x0801e080

08005174 <HTTP_File_Receive_Callback>:
 * @param pointer to PCB
 * @param pointer to incoming pbuf
 * @param state of incoming process
 */
static err_t HTTP_File_Receive_Callback(void *arg, struct tcp_pcb *tpcb, struct pbuf *data_recv, err_t err)
{
 8005174:	b590      	push	{r4, r7, lr}
 8005176:	b089      	sub	sp, #36	; 0x24
 8005178:	af02      	add	r7, sp, #8
 800517a:	60f8      	str	r0, [r7, #12]
 800517c:	60b9      	str	r1, [r7, #8]
 800517e:	607a      	str	r2, [r7, #4]
 8005180:	001a      	movs	r2, r3
 8005182:	1cfb      	adds	r3, r7, #3
 8005184:	701a      	strb	r2, [r3, #0]
    // Nếu có dữ liệu đến, kiểm tra buffer
    // Nếu buffer không hợp lệ (NULL) thì đóng kết nối TCP
    if (data_recv)
 8005186:	687b      	ldr	r3, [r7, #4]
 8005188:	2b00      	cmp	r3, #0
 800518a:	d02c      	beq.n	80051e6 <HTTP_File_Receive_Callback+0x72>
    {
        struct pbuf *q;
        for (q = data_recv; q; q = q->next)
 800518c:	687b      	ldr	r3, [r7, #4]
 800518e:	617b      	str	r3, [r7, #20]
 8005190:	e019      	b.n	80051c6 <HTTP_File_Receive_Callback+0x52>
        {
            // Đây là dữ liệu nhận về, có độ dài bằng q->len, và data là q->payload
            DEBUG_INFO("HTTP data %.*s\r\n", q->len, q->payload);
 8005192:	f017 fad5 	bl	801c740 <sys_get_tick_ms>
 8005196:	0001      	movs	r1, r0
 8005198:	697b      	ldr	r3, [r7, #20]
 800519a:	895b      	ldrh	r3, [r3, #10]
 800519c:	001c      	movs	r4, r3
 800519e:	697b      	ldr	r3, [r7, #20]
 80051a0:	685b      	ldr	r3, [r3, #4]
 80051a2:	4a1a      	ldr	r2, [pc, #104]	; (800520c <HTTP_File_Receive_Callback+0x98>)
 80051a4:	481a      	ldr	r0, [pc, #104]	; (8005210 <HTTP_File_Receive_Callback+0x9c>)
 80051a6:	9300      	str	r3, [sp, #0]
 80051a8:	0023      	movs	r3, r4
 80051aa:	f7fd f80f 	bl	80021cc <app_debug_rtt_raw>
            DEBUG_INFO("HTTP data %s\r\n", q->payload);
 80051ae:	f017 fac7 	bl	801c740 <sys_get_tick_ms>
 80051b2:	0001      	movs	r1, r0
 80051b4:	697b      	ldr	r3, [r7, #20]
 80051b6:	685b      	ldr	r3, [r3, #4]
 80051b8:	4a14      	ldr	r2, [pc, #80]	; (800520c <HTTP_File_Receive_Callback+0x98>)
 80051ba:	4816      	ldr	r0, [pc, #88]	; (8005214 <HTTP_File_Receive_Callback+0xa0>)
 80051bc:	f7fd f806 	bl	80021cc <app_debug_rtt_raw>
        for (q = data_recv; q; q = q->next)
 80051c0:	697b      	ldr	r3, [r7, #20]
 80051c2:	681b      	ldr	r3, [r3, #0]
 80051c4:	617b      	str	r3, [r7, #20]
 80051c6:	697b      	ldr	r3, [r7, #20]
 80051c8:	2b00      	cmp	r3, #0
 80051ca:	d1e2      	bne.n	8005192 <HTTP_File_Receive_Callback+0x1e>
        }
        tcp_recved(tpcb, data_recv->tot_len);
 80051cc:	687b      	ldr	r3, [r7, #4]
 80051ce:	891a      	ldrh	r2, [r3, #8]
 80051d0:	68bb      	ldr	r3, [r7, #8]
 80051d2:	0011      	movs	r1, r2
 80051d4:	0018      	movs	r0, r3
 80051d6:	f005 fc4d 	bl	800aa74 <tcp_recved>
        pbuf_free(data_recv);
 80051da:	687b      	ldr	r3, [r7, #4]
 80051dc:	0018      	movs	r0, r3
 80051de:	f004 fa59 	bl	8009694 <pbuf_free>
        DEBUG_WARN("tcp_close\r\n");
        tcp_close(tpcb);
        return ERR_ABRT;
    }

    return ERR_OK;
 80051e2:	2300      	movs	r3, #0
 80051e4:	e00d      	b.n	8005202 <HTTP_File_Receive_Callback+0x8e>
        DEBUG_WARN("tcp_close\r\n");
 80051e6:	f017 faab 	bl	801c740 <sys_get_tick_ms>
 80051ea:	0001      	movs	r1, r0
 80051ec:	4a07      	ldr	r2, [pc, #28]	; (800520c <HTTP_File_Receive_Callback+0x98>)
 80051ee:	4b0a      	ldr	r3, [pc, #40]	; (8005218 <HTTP_File_Receive_Callback+0xa4>)
 80051f0:	0018      	movs	r0, r3
 80051f2:	f7fc ffeb 	bl	80021cc <app_debug_rtt_raw>
        tcp_close(tpcb);
 80051f6:	68bb      	ldr	r3, [r7, #8]
 80051f8:	0018      	movs	r0, r3
 80051fa:	f005 fadd 	bl	800a7b8 <tcp_close>
        return ERR_ABRT;
 80051fe:	230d      	movs	r3, #13
 8005200:	425b      	negs	r3, r3
}
 8005202:	0018      	movs	r0, r3
 8005204:	46bd      	mov	sp, r7
 8005206:	b007      	add	sp, #28
 8005208:	bd90      	pop	{r4, r7, pc}
 800520a:	46c0      	nop			; (mov r8, r8)
 800520c:	0801def0 	.word	0x0801def0
 8005210:	0801e0bc 	.word	0x0801e0bc
 8005214:	0801e0e8 	.word	0x0801e0e8
 8005218:	0801e110 	.word	0x0801e110

0800521c <HTTP_Config>:

void HTTP_Config(void)
{
 800521c:	b590      	push	{r4, r7, lr}
 800521e:	b083      	sub	sp, #12
 8005220:	af02      	add	r7, sp, #8
    /* Init Http connection params */
    HTTP_Connect_Settings.use_proxy = 0;
 8005222:	4b0f      	ldr	r3, [pc, #60]	; (8005260 <HTTP_Config+0x44>)
 8005224:	2200      	movs	r2, #0
 8005226:	719a      	strb	r2, [r3, #6]
    HTTP_Connect_Settings.headers_done_fn = HTTP_Headers_Done_Callback;
 8005228:	4b0d      	ldr	r3, [pc, #52]	; (8005260 <HTTP_Config+0x44>)
 800522a:	4a0e      	ldr	r2, [pc, #56]	; (8005264 <HTTP_Config+0x48>)
 800522c:	60da      	str	r2, [r3, #12]
    HTTP_Connect_Settings.result_fn = HTTP_Result_Callback;
 800522e:	4b0c      	ldr	r3, [pc, #48]	; (8005260 <HTTP_Config+0x44>)
 8005230:	4a0d      	ldr	r2, [pc, #52]	; (8005268 <HTTP_Config+0x4c>)
 8005232:	609a      	str	r2, [r3, #8]

    DEBUG_INFO("HTTP url %s%s, port %d\r\n", HTTP_Client_Config.Url,
 8005234:	f017 fa84 	bl	801c740 <sys_get_tick_ms>
 8005238:	0004      	movs	r4, r0
 800523a:	4a0c      	ldr	r2, [pc, #48]	; (800526c <HTTP_Config+0x50>)
 800523c:	2380      	movs	r3, #128	; 0x80
 800523e:	005b      	lsls	r3, r3, #1
 8005240:	5ad3      	ldrh	r3, [r2, r3]
 8005242:	490a      	ldr	r1, [pc, #40]	; (800526c <HTTP_Config+0x50>)
 8005244:	4a0a      	ldr	r2, [pc, #40]	; (8005270 <HTTP_Config+0x54>)
 8005246:	480b      	ldr	r0, [pc, #44]	; (8005274 <HTTP_Config+0x58>)
 8005248:	9301      	str	r3, [sp, #4]
 800524a:	4b0b      	ldr	r3, [pc, #44]	; (8005278 <HTTP_Config+0x5c>)
 800524c:	9300      	str	r3, [sp, #0]
 800524e:	000b      	movs	r3, r1
 8005250:	0021      	movs	r1, r4
 8005252:	f7fc ffbb 	bl	80021cc <app_debug_rtt_raw>
                                             HTTP_Client_Config.File,
                                             HTTP_Client_Config.Port);
}
 8005256:	46c0      	nop			; (mov r8, r8)
 8005258:	46bd      	mov	sp, r7
 800525a:	b001      	add	sp, #4
 800525c:	bd90      	pop	{r4, r7, pc}
 800525e:	46c0      	nop			; (mov r8, r8)
 8005260:	20001108 	.word	0x20001108
 8005264:	08005071 	.word	0x08005071
 8005268:	080050d5 	.word	0x080050d5
 800526c:	20000f04 	.word	0x20000f04
 8005270:	0801def0 	.word	0x0801def0
 8005274:	0801e138 	.word	0x0801e138
 8005278:	20001006 	.word	0x20001006

0800527c <HTTP_Get_Data>:
void HTTP_Get_Data(void)
{
 800527c:	b5b0      	push	{r4, r5, r7, lr}
 800527e:	b086      	sub	sp, #24
 8005280:	af04      	add	r7, sp, #16
    // Kết nối HTTP
    err_t err = httpc_get_file_dns((const char*)HTTP_Client_Config.Url,
 8005282:	4a1a      	ldr	r2, [pc, #104]	; (80052ec <HTTP_Get_Data+0x70>)
 8005284:	2380      	movs	r3, #128	; 0x80
 8005286:	005b      	lsls	r3, r3, #1
 8005288:	5ad1      	ldrh	r1, [r2, r3]
 800528a:	1dfc      	adds	r4, r7, #7
 800528c:	4d18      	ldr	r5, [pc, #96]	; (80052f0 <HTTP_Get_Data+0x74>)
 800528e:	4a19      	ldr	r2, [pc, #100]	; (80052f4 <HTTP_Get_Data+0x78>)
 8005290:	4816      	ldr	r0, [pc, #88]	; (80052ec <HTTP_Get_Data+0x70>)
 8005292:	4b19      	ldr	r3, [pc, #100]	; (80052f8 <HTTP_Get_Data+0x7c>)
 8005294:	9302      	str	r3, [sp, #8]
 8005296:	2300      	movs	r3, #0
 8005298:	9301      	str	r3, [sp, #4]
 800529a:	4b18      	ldr	r3, [pc, #96]	; (80052fc <HTTP_Get_Data+0x80>)
 800529c:	9300      	str	r3, [sp, #0]
 800529e:	002b      	movs	r3, r5
 80052a0:	f000 fe5a 	bl	8005f58 <httpc_get_file_dns>
 80052a4:	0003      	movs	r3, r0
 80052a6:	7023      	strb	r3, [r4, #0]
                                   HTTP_Client_Config.File,
                                   &HTTP_Connect_Settings,
                                   HTTP_File_Receive_Callback,
                                   NULL,
                                   &HTTP_Connection_State);
    HTTP_Connect_Settings.headers_done_fn = HTTP_Headers_Done_Callback;
 80052a8:	4b11      	ldr	r3, [pc, #68]	; (80052f0 <HTTP_Get_Data+0x74>)
 80052aa:	4a15      	ldr	r2, [pc, #84]	; (8005300 <HTTP_Get_Data+0x84>)
 80052ac:	60da      	str	r2, [r3, #12]
    HTTP_Connect_Settings.result_fn = HTTP_Result_Callback;
 80052ae:	4b10      	ldr	r3, [pc, #64]	; (80052f0 <HTTP_Get_Data+0x74>)
 80052b0:	4a14      	ldr	r2, [pc, #80]	; (8005304 <HTTP_Get_Data+0x88>)
 80052b2:	609a      	str	r2, [r3, #8]
    if(err != ERR_OK)
 80052b4:	1dfb      	adds	r3, r7, #7
 80052b6:	781b      	ldrb	r3, [r3, #0]
 80052b8:	b25b      	sxtb	r3, r3
 80052ba:	2b00      	cmp	r3, #0
 80052bc:	d00a      	beq.n	80052d4 <HTTP_Get_Data+0x58>
    {
        DEBUG_INFO("HTTP Get File DNS return %d\r\n", err);
 80052be:	f017 fa3f 	bl	801c740 <sys_get_tick_ms>
 80052c2:	0001      	movs	r1, r0
 80052c4:	1dfb      	adds	r3, r7, #7
 80052c6:	781b      	ldrb	r3, [r3, #0]
 80052c8:	b25b      	sxtb	r3, r3
 80052ca:	4a0f      	ldr	r2, [pc, #60]	; (8005308 <HTTP_Get_Data+0x8c>)
 80052cc:	480f      	ldr	r0, [pc, #60]	; (800530c <HTTP_Get_Data+0x90>)
 80052ce:	f7fc ff7d 	bl	80021cc <app_debug_rtt_raw>
    {
        DEBUG_INFO("HTTP Get File DNS successfully\r\n");
        //HTTP_Manager.Step = HTTP_STEP_CONNECTED;
        //DEBUG_INFO("HTTP_STEP_CONNECTED.\r\n");
    }
}
 80052d2:	e007      	b.n	80052e4 <HTTP_Get_Data+0x68>
        DEBUG_INFO("HTTP Get File DNS successfully\r\n");
 80052d4:	f017 fa34 	bl	801c740 <sys_get_tick_ms>
 80052d8:	0001      	movs	r1, r0
 80052da:	4a0b      	ldr	r2, [pc, #44]	; (8005308 <HTTP_Get_Data+0x8c>)
 80052dc:	4b0c      	ldr	r3, [pc, #48]	; (8005310 <HTTP_Get_Data+0x94>)
 80052de:	0018      	movs	r0, r3
 80052e0:	f7fc ff74 	bl	80021cc <app_debug_rtt_raw>
}
 80052e4:	46c0      	nop			; (mov r8, r8)
 80052e6:	46bd      	mov	sp, r7
 80052e8:	b002      	add	sp, #8
 80052ea:	bdb0      	pop	{r4, r5, r7, pc}
 80052ec:	20000f04 	.word	0x20000f04
 80052f0:	20001108 	.word	0x20001108
 80052f4:	20001006 	.word	0x20001006
 80052f8:	20001118 	.word	0x20001118
 80052fc:	08005175 	.word	0x08005175
 8005300:	08005071 	.word	0x08005071
 8005304:	080050d5 	.word	0x080050d5
 8005308:	0801def0 	.word	0x0801def0
 800530c:	0801e16c 	.word	0x0801e16c
 8005310:	0801e1a4 	.word	0x0801e1a4

08005314 <HTTP_Client_Polling_Task>:
void HTTP_Client_Polling_Task(void *arg)
{
 8005314:	b580      	push	{r7, lr}
 8005316:	b084      	sub	sp, #16
 8005318:	af00      	add	r7, sp, #0
 800531a:	6078      	str	r0, [r7, #4]
    static uint32_t Last_time_get_data = 0, tick = 0;
    static uint32_t Last_Tick = 0;
    uint32_t Current_Tick = sys_get_tick_ms();
 800531c:	f017 fa10 	bl	801c740 <sys_get_tick_ms>
 8005320:	0003      	movs	r3, r0
 8005322:	60fb      	str	r3, [r7, #12]

    if((Current_Tick - Last_Tick) >= (uint32_t)1000)
 8005324:	4b36      	ldr	r3, [pc, #216]	; (8005400 <HTTP_Client_Polling_Task+0xec>)
 8005326:	681b      	ldr	r3, [r3, #0]
 8005328:	68fa      	ldr	r2, [r7, #12]
 800532a:	1ad2      	subs	r2, r2, r3
 800532c:	23fa      	movs	r3, #250	; 0xfa
 800532e:	009b      	lsls	r3, r3, #2
 8005330:	429a      	cmp	r2, r3
 8005332:	d35c      	bcc.n	80053ee <HTTP_Client_Polling_Task+0xda>
    {
        Last_Tick = Current_Tick;
 8005334:	4b32      	ldr	r3, [pc, #200]	; (8005400 <HTTP_Client_Polling_Task+0xec>)
 8005336:	68fa      	ldr	r2, [r7, #12]
 8005338:	601a      	str	r2, [r3, #0]
    else
    {
        return;
    }
    static bool HTTP_Allow = false;
    if(gsm_data_layer_is_ppp_connected())
 800533a:	f7fb ffb7 	bl	80012ac <gsm_data_layer_is_ppp_connected>
 800533e:	1e03      	subs	r3, r0, #0
 8005340:	d012      	beq.n	8005368 <HTTP_Client_Polling_Task+0x54>
    {
        if(HTTP_Allow == false)
 8005342:	4b30      	ldr	r3, [pc, #192]	; (8005404 <HTTP_Client_Polling_Task+0xf0>)
 8005344:	781b      	ldrb	r3, [r3, #0]
 8005346:	2201      	movs	r2, #1
 8005348:	4053      	eors	r3, r2
 800534a:	b2db      	uxtb	r3, r3
 800534c:	2b00      	cmp	r3, #0
 800534e:	d01a      	beq.n	8005386 <HTTP_Client_Polling_Task+0x72>
        {
            HTTP_Allow = true;
 8005350:	4b2c      	ldr	r3, [pc, #176]	; (8005404 <HTTP_Client_Polling_Task+0xf0>)
 8005352:	2201      	movs	r2, #1
 8005354:	701a      	strb	r2, [r3, #0]
            DEBUG_INFO("HTTP Thread started.\r\n");
 8005356:	f017 f9f3 	bl	801c740 <sys_get_tick_ms>
 800535a:	0001      	movs	r1, r0
 800535c:	4a2a      	ldr	r2, [pc, #168]	; (8005408 <HTTP_Client_Polling_Task+0xf4>)
 800535e:	4b2b      	ldr	r3, [pc, #172]	; (800540c <HTTP_Client_Polling_Task+0xf8>)
 8005360:	0018      	movs	r0, r3
 8005362:	f7fc ff33 	bl	80021cc <app_debug_rtt_raw>
 8005366:	e00e      	b.n	8005386 <HTTP_Client_Polling_Task+0x72>
        }
    }
    else
    {
        if(HTTP_Allow == true)
 8005368:	4b26      	ldr	r3, [pc, #152]	; (8005404 <HTTP_Client_Polling_Task+0xf0>)
 800536a:	781b      	ldrb	r3, [r3, #0]
 800536c:	2b00      	cmp	r3, #0
 800536e:	d00a      	beq.n	8005386 <HTTP_Client_Polling_Task+0x72>
        {
            HTTP_Allow = false;
 8005370:	4b24      	ldr	r3, [pc, #144]	; (8005404 <HTTP_Client_Polling_Task+0xf0>)
 8005372:	2200      	movs	r2, #0
 8005374:	701a      	strb	r2, [r3, #0]
            DEBUG_INFO("HTTP Thread stopped.\r\n");
 8005376:	f017 f9e3 	bl	801c740 <sys_get_tick_ms>
 800537a:	0001      	movs	r1, r0
 800537c:	4a22      	ldr	r2, [pc, #136]	; (8005408 <HTTP_Client_Polling_Task+0xf4>)
 800537e:	4b24      	ldr	r3, [pc, #144]	; (8005410 <HTTP_Client_Polling_Task+0xfc>)
 8005380:	0018      	movs	r0, r3
 8005382:	f7fc ff23 	bl	80021cc <app_debug_rtt_raw>
        }
    }
    if(HTTP_Allow)
 8005386:	4b1f      	ldr	r3, [pc, #124]	; (8005404 <HTTP_Client_Polling_Task+0xf0>)
 8005388:	781b      	ldrb	r3, [r3, #0]
 800538a:	2b00      	cmp	r3, #0
 800538c:	d034      	beq.n	80053f8 <HTTP_Client_Polling_Task+0xe4>
    {
        switch (HTTP_Manager.Step)
 800538e:	4b21      	ldr	r3, [pc, #132]	; (8005414 <HTTP_Client_Polling_Task+0x100>)
 8005390:	781b      	ldrb	r3, [r3, #0]
 8005392:	2b03      	cmp	r3, #3
 8005394:	d02d      	beq.n	80053f2 <HTTP_Client_Polling_Task+0xde>
 8005396:	dc2e      	bgt.n	80053f6 <HTTP_Client_Polling_Task+0xe2>
 8005398:	2b02      	cmp	r3, #2
 800539a:	d01f      	beq.n	80053dc <HTTP_Client_Polling_Task+0xc8>
 800539c:	dc2b      	bgt.n	80053f6 <HTTP_Client_Polling_Task+0xe2>
 800539e:	2b00      	cmp	r3, #0
 80053a0:	d002      	beq.n	80053a8 <HTTP_Client_Polling_Task+0x94>
 80053a2:	2b01      	cmp	r3, #1
 80053a4:	d00c      	beq.n	80053c0 <HTTP_Client_Polling_Task+0xac>
        case HTTP_STEP_CONNECTED:

            break;

        default:
            break;
 80053a6:	e026      	b.n	80053f6 <HTTP_Client_Polling_Task+0xe2>
            HTTP_Manager.Step = HTTP_STEP_CONFIG;
 80053a8:	4b1a      	ldr	r3, [pc, #104]	; (8005414 <HTTP_Client_Polling_Task+0x100>)
 80053aa:	2201      	movs	r2, #1
 80053ac:	701a      	strb	r2, [r3, #0]
            DEBUG_INFO("HTTP_STEP_CONFIG.\r\n");
 80053ae:	f017 f9c7 	bl	801c740 <sys_get_tick_ms>
 80053b2:	0001      	movs	r1, r0
 80053b4:	4a14      	ldr	r2, [pc, #80]	; (8005408 <HTTP_Client_Polling_Task+0xf4>)
 80053b6:	4b18      	ldr	r3, [pc, #96]	; (8005418 <HTTP_Client_Polling_Task+0x104>)
 80053b8:	0018      	movs	r0, r3
 80053ba:	f7fc ff07 	bl	80021cc <app_debug_rtt_raw>
            break;
 80053be:	e01b      	b.n	80053f8 <HTTP_Client_Polling_Task+0xe4>
            HTTP_Config();
 80053c0:	f7ff ff2c 	bl	800521c <HTTP_Config>
            HTTP_Manager.Step = HTTP_STEP_CONNECTING;
 80053c4:	4b13      	ldr	r3, [pc, #76]	; (8005414 <HTTP_Client_Polling_Task+0x100>)
 80053c6:	2202      	movs	r2, #2
 80053c8:	701a      	strb	r2, [r3, #0]
            DEBUG_INFO("HTTP_STEP_CONNECTING.\r\n");
 80053ca:	f017 f9b9 	bl	801c740 <sys_get_tick_ms>
 80053ce:	0001      	movs	r1, r0
 80053d0:	4a0d      	ldr	r2, [pc, #52]	; (8005408 <HTTP_Client_Polling_Task+0xf4>)
 80053d2:	4b12      	ldr	r3, [pc, #72]	; (800541c <HTTP_Client_Polling_Task+0x108>)
 80053d4:	0018      	movs	r0, r3
 80053d6:	f7fc fef9 	bl	80021cc <app_debug_rtt_raw>
            break;
 80053da:	e00d      	b.n	80053f8 <HTTP_Client_Polling_Task+0xe4>
            tick = Current_Tick;
 80053dc:	4b10      	ldr	r3, [pc, #64]	; (8005420 <HTTP_Client_Polling_Task+0x10c>)
 80053de:	68fa      	ldr	r2, [r7, #12]
 80053e0:	601a      	str	r2, [r3, #0]
            HTTP_Get_Data();
 80053e2:	f7ff ff4b 	bl	800527c <HTTP_Get_Data>
            HTTP_Manager.Step = HTTP_STEP_CONNECTED;
 80053e6:	4b0b      	ldr	r3, [pc, #44]	; (8005414 <HTTP_Client_Polling_Task+0x100>)
 80053e8:	2203      	movs	r2, #3
 80053ea:	701a      	strb	r2, [r3, #0]
            break;
 80053ec:	e004      	b.n	80053f8 <HTTP_Client_Polling_Task+0xe4>
        return;
 80053ee:	46c0      	nop			; (mov r8, r8)
 80053f0:	e002      	b.n	80053f8 <HTTP_Client_Polling_Task+0xe4>
            break;
 80053f2:	46c0      	nop			; (mov r8, r8)
 80053f4:	e000      	b.n	80053f8 <HTTP_Client_Polling_Task+0xe4>
            break;
 80053f6:	46c0      	nop			; (mov r8, r8)
        }
    }
}
 80053f8:	46bd      	mov	sp, r7
 80053fa:	b004      	add	sp, #16
 80053fc:	bd80      	pop	{r7, pc}
 80053fe:	46c0      	nop			; (mov r8, r8)
 8005400:	20001120 	.word	0x20001120
 8005404:	20001124 	.word	0x20001124
 8005408:	0801def0 	.word	0x0801def0
 800540c:	0801e1e0 	.word	0x0801e1e0
 8005410:	0801e210 	.word	0x0801e210
 8005414:	2000111c 	.word	0x2000111c
 8005418:	0801e240 	.word	0x0801e240
 800541c:	0801e270 	.word	0x0801e270
 8005420:	20001128 	.word	0x20001128

08005424 <httpc_free_state>:
} httpc_state_t;

/** Free http client state and deallocate all resources within */
static err_t
httpc_free_state(httpc_state_t* req)
{
 8005424:	b5b0      	push	{r4, r5, r7, lr}
 8005426:	b084      	sub	sp, #16
 8005428:	af00      	add	r7, sp, #0
 800542a:	6078      	str	r0, [r7, #4]
  struct altcp_pcb* tpcb;

  if (req->request != NULL) {
 800542c:	687b      	ldr	r3, [r7, #4]
 800542e:	691b      	ldr	r3, [r3, #16]
 8005430:	2b00      	cmp	r3, #0
 8005432:	d007      	beq.n	8005444 <httpc_free_state+0x20>
    pbuf_free(req->request);
 8005434:	687b      	ldr	r3, [r7, #4]
 8005436:	691b      	ldr	r3, [r3, #16]
 8005438:	0018      	movs	r0, r3
 800543a:	f004 f92b 	bl	8009694 <pbuf_free>
    req->request = NULL;
 800543e:	687b      	ldr	r3, [r7, #4]
 8005440:	2200      	movs	r2, #0
 8005442:	611a      	str	r2, [r3, #16]
  }
  if (req->rx_hdrs != NULL) {
 8005444:	687b      	ldr	r3, [r7, #4]
 8005446:	695b      	ldr	r3, [r3, #20]
 8005448:	2b00      	cmp	r3, #0
 800544a:	d007      	beq.n	800545c <httpc_free_state+0x38>
    pbuf_free(req->rx_hdrs);
 800544c:	687b      	ldr	r3, [r7, #4]
 800544e:	695b      	ldr	r3, [r3, #20]
 8005450:	0018      	movs	r0, r3
 8005452:	f004 f91f 	bl	8009694 <pbuf_free>
    req->rx_hdrs = NULL;
 8005456:	687b      	ldr	r3, [r7, #4]
 8005458:	2200      	movs	r2, #0
 800545a:	615a      	str	r2, [r3, #20]
  }

  tpcb = req->pcb;
 800545c:	687b      	ldr	r3, [r7, #4]
 800545e:	681b      	ldr	r3, [r3, #0]
 8005460:	60fb      	str	r3, [r7, #12]
  mem_free(req);
 8005462:	687b      	ldr	r3, [r7, #4]
 8005464:	0018      	movs	r0, r3
 8005466:	f002 fe37 	bl	80080d8 <mem_free>
  req = NULL;
 800546a:	2300      	movs	r3, #0
 800546c:	607b      	str	r3, [r7, #4]

  if (tpcb != NULL) {
 800546e:	68fb      	ldr	r3, [r7, #12]
 8005470:	2b00      	cmp	r3, #0
 8005472:	d02d      	beq.n	80054d0 <httpc_free_state+0xac>
    err_t r;
    altcp_arg(tpcb, NULL);
 8005474:	68fb      	ldr	r3, [r7, #12]
 8005476:	2100      	movs	r1, #0
 8005478:	0018      	movs	r0, r3
 800547a:	f006 fbb0 	bl	800bbde <tcp_arg>
    altcp_recv(tpcb, NULL);
 800547e:	68fb      	ldr	r3, [r7, #12]
 8005480:	2100      	movs	r1, #0
 8005482:	0018      	movs	r0, r3
 8005484:	f006 fbba 	bl	800bbfc <tcp_recv>
    altcp_err(tpcb, NULL);
 8005488:	68fb      	ldr	r3, [r7, #12]
 800548a:	2100      	movs	r1, #0
 800548c:	0018      	movs	r0, r3
 800548e:	f006 fbf9 	bl	800bc84 <tcp_err>
    altcp_poll(tpcb, NULL, 0);
 8005492:	68fb      	ldr	r3, [r7, #12]
 8005494:	2200      	movs	r2, #0
 8005496:	2100      	movs	r1, #0
 8005498:	0018      	movs	r0, r3
 800549a:	f006 fc15 	bl	800bcc8 <tcp_poll>
    altcp_sent(tpcb, NULL);
 800549e:	68fb      	ldr	r3, [r7, #12]
 80054a0:	2100      	movs	r1, #0
 80054a2:	0018      	movs	r0, r3
 80054a4:	f006 fbcc 	bl	800bc40 <tcp_sent>
    r = altcp_close(tpcb);
 80054a8:	250b      	movs	r5, #11
 80054aa:	197c      	adds	r4, r7, r5
 80054ac:	68fb      	ldr	r3, [r7, #12]
 80054ae:	0018      	movs	r0, r3
 80054b0:	f005 f982 	bl	800a7b8 <tcp_close>
 80054b4:	0003      	movs	r3, r0
 80054b6:	7023      	strb	r3, [r4, #0]
    if (r != ERR_OK) {
 80054b8:	197b      	adds	r3, r7, r5
 80054ba:	781b      	ldrb	r3, [r3, #0]
 80054bc:	b25b      	sxtb	r3, r3
 80054be:	2b00      	cmp	r3, #0
 80054c0:	d006      	beq.n	80054d0 <httpc_free_state+0xac>
      altcp_abort(tpcb);
 80054c2:	68fb      	ldr	r3, [r7, #12]
 80054c4:	0018      	movs	r0, r3
 80054c6:	f005 fa67 	bl	800a998 <tcp_abort>
      return ERR_ABRT;
 80054ca:	230d      	movs	r3, #13
 80054cc:	425b      	negs	r3, r3
 80054ce:	e000      	b.n	80054d2 <httpc_free_state+0xae>
    }
  }
  return ERR_OK;
 80054d0:	2300      	movs	r3, #0
}
 80054d2:	0018      	movs	r0, r3
 80054d4:	46bd      	mov	sp, r7
 80054d6:	b004      	add	sp, #16
 80054d8:	bdb0      	pop	{r4, r5, r7, pc}

080054da <httpc_close>:

/** Close the connection: call finished callback and free the state */
static err_t
httpc_close(httpc_state_t* req, httpc_result_t result, u32_t server_response, err_t err)
{
 80054da:	b5f0      	push	{r4, r5, r6, r7, lr}
 80054dc:	b087      	sub	sp, #28
 80054de:	af02      	add	r7, sp, #8
 80054e0:	60f8      	str	r0, [r7, #12]
 80054e2:	0008      	movs	r0, r1
 80054e4:	607a      	str	r2, [r7, #4]
 80054e6:	0019      	movs	r1, r3
 80054e8:	260b      	movs	r6, #11
 80054ea:	19bb      	adds	r3, r7, r6
 80054ec:	1c02      	adds	r2, r0, #0
 80054ee:	701a      	strb	r2, [r3, #0]
 80054f0:	230a      	movs	r3, #10
 80054f2:	18fb      	adds	r3, r7, r3
 80054f4:	1c0a      	adds	r2, r1, #0
 80054f6:	701a      	strb	r2, [r3, #0]
  if (req != NULL) {
 80054f8:	68fb      	ldr	r3, [r7, #12]
 80054fa:	2b00      	cmp	r3, #0
 80054fc:	d01f      	beq.n	800553e <httpc_close+0x64>
    if (req->conn_settings != NULL) {
 80054fe:	68fb      	ldr	r3, [r7, #12]
 8005500:	6a1b      	ldr	r3, [r3, #32]
 8005502:	2b00      	cmp	r3, #0
 8005504:	d015      	beq.n	8005532 <httpc_close+0x58>
      if (req->conn_settings->result_fn != NULL) {
 8005506:	68fb      	ldr	r3, [r7, #12]
 8005508:	6a1b      	ldr	r3, [r3, #32]
 800550a:	689b      	ldr	r3, [r3, #8]
 800550c:	2b00      	cmp	r3, #0
 800550e:	d010      	beq.n	8005532 <httpc_close+0x58>
        req->conn_settings->result_fn(req->callback_arg, result, req->rx_content_len, server_response, err);
 8005510:	68fb      	ldr	r3, [r7, #12]
 8005512:	6a1b      	ldr	r3, [r3, #32]
 8005514:	689c      	ldr	r4, [r3, #8]
 8005516:	68fb      	ldr	r3, [r7, #12]
 8005518:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800551a:	68fb      	ldr	r3, [r7, #12]
 800551c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800551e:	687d      	ldr	r5, [r7, #4]
 8005520:	19bb      	adds	r3, r7, r6
 8005522:	7819      	ldrb	r1, [r3, #0]
 8005524:	230a      	movs	r3, #10
 8005526:	18fb      	adds	r3, r7, r3
 8005528:	781b      	ldrb	r3, [r3, #0]
 800552a:	b25b      	sxtb	r3, r3
 800552c:	9300      	str	r3, [sp, #0]
 800552e:	002b      	movs	r3, r5
 8005530:	47a0      	blx	r4
      }
    }
    return httpc_free_state(req);
 8005532:	68fb      	ldr	r3, [r7, #12]
 8005534:	0018      	movs	r0, r3
 8005536:	f7ff ff75 	bl	8005424 <httpc_free_state>
 800553a:	0003      	movs	r3, r0
 800553c:	e000      	b.n	8005540 <httpc_close+0x66>
  }
  return ERR_OK;
 800553e:	2300      	movs	r3, #0
}
 8005540:	0018      	movs	r0, r3
 8005542:	46bd      	mov	sp, r7
 8005544:	b005      	add	sp, #20
 8005546:	bdf0      	pop	{r4, r5, r6, r7, pc}

08005548 <http_parse_response_status>:

/** Parse http header response line 1 */
static err_t
http_parse_response_status(struct pbuf *p, u16_t *http_version, u16_t *http_status, u16_t *http_status_str_offset)
{
 8005548:	b5f0      	push	{r4, r5, r6, r7, lr}
 800554a:	b08d      	sub	sp, #52	; 0x34
 800554c:	af00      	add	r7, sp, #0
 800554e:	60f8      	str	r0, [r7, #12]
 8005550:	60b9      	str	r1, [r7, #8]
 8005552:	607a      	str	r2, [r7, #4]
 8005554:	603b      	str	r3, [r7, #0]
  u16_t end1 = pbuf_memfind(p, "\r\n", 2, 0);
 8005556:	252a      	movs	r5, #42	; 0x2a
 8005558:	197c      	adds	r4, r7, r5
 800555a:	4957      	ldr	r1, [pc, #348]	; (80056b8 <http_parse_response_status+0x170>)
 800555c:	68f8      	ldr	r0, [r7, #12]
 800555e:	2300      	movs	r3, #0
 8005560:	2202      	movs	r2, #2
 8005562:	f004 fe9f 	bl	800a2a4 <pbuf_memfind>
 8005566:	0003      	movs	r3, r0
 8005568:	8023      	strh	r3, [r4, #0]
  if (end1 != 0xFFFF) {
 800556a:	197b      	adds	r3, r7, r5
 800556c:	881b      	ldrh	r3, [r3, #0]
 800556e:	4a53      	ldr	r2, [pc, #332]	; (80056bc <http_parse_response_status+0x174>)
 8005570:	4293      	cmp	r3, r2
 8005572:	d100      	bne.n	8005576 <http_parse_response_status+0x2e>
 8005574:	e099      	b.n	80056aa <http_parse_response_status+0x162>
    /* get parts of first line */
    u16_t space1, space2;
    space1 = pbuf_memfind(p, " ", 1, 0);
 8005576:	2528      	movs	r5, #40	; 0x28
 8005578:	197c      	adds	r4, r7, r5
 800557a:	4951      	ldr	r1, [pc, #324]	; (80056c0 <http_parse_response_status+0x178>)
 800557c:	68f8      	ldr	r0, [r7, #12]
 800557e:	2300      	movs	r3, #0
 8005580:	2201      	movs	r2, #1
 8005582:	f004 fe8f 	bl	800a2a4 <pbuf_memfind>
 8005586:	0003      	movs	r3, r0
 8005588:	8023      	strh	r3, [r4, #0]
    if (space1 != 0xFFFF) {
 800558a:	197b      	adds	r3, r7, r5
 800558c:	881b      	ldrh	r3, [r3, #0]
 800558e:	4a4b      	ldr	r2, [pc, #300]	; (80056bc <http_parse_response_status+0x174>)
 8005590:	4293      	cmp	r3, r2
 8005592:	d100      	bne.n	8005596 <http_parse_response_status+0x4e>
 8005594:	e089      	b.n	80056aa <http_parse_response_status+0x162>
      if ((pbuf_memcmp(p, 0, "HTTP/", 5) == 0)  && (pbuf_get_at(p, 6) == '.')) {
 8005596:	4a4b      	ldr	r2, [pc, #300]	; (80056c4 <http_parse_response_status+0x17c>)
 8005598:	68f8      	ldr	r0, [r7, #12]
 800559a:	2305      	movs	r3, #5
 800559c:	2100      	movs	r1, #0
 800559e:	f004 fe01 	bl	800a1a4 <pbuf_memcmp>
 80055a2:	1e03      	subs	r3, r0, #0
 80055a4:	d000      	beq.n	80055a8 <http_parse_response_status+0x60>
 80055a6:	e080      	b.n	80056aa <http_parse_response_status+0x162>
 80055a8:	68fb      	ldr	r3, [r7, #12]
 80055aa:	2106      	movs	r1, #6
 80055ac:	0018      	movs	r0, r3
 80055ae:	f004 fd8b 	bl	800a0c8 <pbuf_get_at>
 80055b2:	0003      	movs	r3, r0
 80055b4:	2b2e      	cmp	r3, #46	; 0x2e
 80055b6:	d000      	beq.n	80055ba <http_parse_response_status+0x72>
 80055b8:	e077      	b.n	80056aa <http_parse_response_status+0x162>
        char status_num[10];
        size_t status_num_len;
        /* parse http version */
        u16_t version = pbuf_get_at(p, 5) - '0';
 80055ba:	68fb      	ldr	r3, [r7, #12]
 80055bc:	2105      	movs	r1, #5
 80055be:	0018      	movs	r0, r3
 80055c0:	f004 fd82 	bl	800a0c8 <pbuf_get_at>
 80055c4:	0003      	movs	r3, r0
 80055c6:	b29a      	uxth	r2, r3
 80055c8:	2426      	movs	r4, #38	; 0x26
 80055ca:	193b      	adds	r3, r7, r4
 80055cc:	3a30      	subs	r2, #48	; 0x30
 80055ce:	801a      	strh	r2, [r3, #0]
        version <<= 8;
 80055d0:	193b      	adds	r3, r7, r4
 80055d2:	193a      	adds	r2, r7, r4
 80055d4:	8812      	ldrh	r2, [r2, #0]
 80055d6:	0212      	lsls	r2, r2, #8
 80055d8:	801a      	strh	r2, [r3, #0]
        version |= pbuf_get_at(p, 7) - '0';
 80055da:	68fb      	ldr	r3, [r7, #12]
 80055dc:	2107      	movs	r1, #7
 80055de:	0018      	movs	r0, r3
 80055e0:	f004 fd72 	bl	800a0c8 <pbuf_get_at>
 80055e4:	0003      	movs	r3, r0
 80055e6:	3b30      	subs	r3, #48	; 0x30
 80055e8:	b21a      	sxth	r2, r3
 80055ea:	193b      	adds	r3, r7, r4
 80055ec:	2100      	movs	r1, #0
 80055ee:	5e5b      	ldrsh	r3, [r3, r1]
 80055f0:	4313      	orrs	r3, r2
 80055f2:	b21a      	sxth	r2, r3
 80055f4:	193b      	adds	r3, r7, r4
 80055f6:	801a      	strh	r2, [r3, #0]
        *http_version = version;
 80055f8:	68bb      	ldr	r3, [r7, #8]
 80055fa:	193a      	adds	r2, r7, r4
 80055fc:	8812      	ldrh	r2, [r2, #0]
 80055fe:	801a      	strh	r2, [r3, #0]

        /* parse http status number */
        space2 = pbuf_memfind(p, " ", 1, space1 + 1);
 8005600:	197b      	adds	r3, r7, r5
 8005602:	881b      	ldrh	r3, [r3, #0]
 8005604:	3301      	adds	r3, #1
 8005606:	b29b      	uxth	r3, r3
 8005608:	2624      	movs	r6, #36	; 0x24
 800560a:	19bc      	adds	r4, r7, r6
 800560c:	492c      	ldr	r1, [pc, #176]	; (80056c0 <http_parse_response_status+0x178>)
 800560e:	68f8      	ldr	r0, [r7, #12]
 8005610:	2201      	movs	r2, #1
 8005612:	f004 fe47 	bl	800a2a4 <pbuf_memfind>
 8005616:	0003      	movs	r3, r0
 8005618:	8023      	strh	r3, [r4, #0]
        if (space2 != 0xFFFF) {
 800561a:	0031      	movs	r1, r6
 800561c:	187b      	adds	r3, r7, r1
 800561e:	881b      	ldrh	r3, [r3, #0]
 8005620:	4a26      	ldr	r2, [pc, #152]	; (80056bc <http_parse_response_status+0x174>)
 8005622:	4293      	cmp	r3, r2
 8005624:	d00d      	beq.n	8005642 <http_parse_response_status+0xfa>
          *http_status_str_offset = space2 + 1;
 8005626:	187b      	adds	r3, r7, r1
 8005628:	881b      	ldrh	r3, [r3, #0]
 800562a:	3301      	adds	r3, #1
 800562c:	b29a      	uxth	r2, r3
 800562e:	683b      	ldr	r3, [r7, #0]
 8005630:	801a      	strh	r2, [r3, #0]
          status_num_len = space2 - space1 - 1;
 8005632:	187b      	adds	r3, r7, r1
 8005634:	881a      	ldrh	r2, [r3, #0]
 8005636:	197b      	adds	r3, r7, r5
 8005638:	881b      	ldrh	r3, [r3, #0]
 800563a:	1ad3      	subs	r3, r2, r3
 800563c:	3b01      	subs	r3, #1
 800563e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8005640:	e008      	b.n	8005654 <http_parse_response_status+0x10c>
        } else {
          status_num_len = end1 - space1 - 1;
 8005642:	232a      	movs	r3, #42	; 0x2a
 8005644:	18fb      	adds	r3, r7, r3
 8005646:	881a      	ldrh	r2, [r3, #0]
 8005648:	2328      	movs	r3, #40	; 0x28
 800564a:	18fb      	adds	r3, r7, r3
 800564c:	881b      	ldrh	r3, [r3, #0]
 800564e:	1ad3      	subs	r3, r2, r3
 8005650:	3b01      	subs	r3, #1
 8005652:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        memset(status_num, 0, sizeof(status_num));
 8005654:	2414      	movs	r4, #20
 8005656:	193b      	adds	r3, r7, r4
 8005658:	220a      	movs	r2, #10
 800565a:	2100      	movs	r1, #0
 800565c:	0018      	movs	r0, r3
 800565e:	f017 f8e5 	bl	801c82c <memset>
        if (pbuf_copy_partial(p, status_num, (u16_t)status_num_len, space1 + 1) == status_num_len) {
 8005662:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8005664:	b29a      	uxth	r2, r3
 8005666:	2328      	movs	r3, #40	; 0x28
 8005668:	18fb      	adds	r3, r7, r3
 800566a:	881b      	ldrh	r3, [r3, #0]
 800566c:	3301      	adds	r3, #1
 800566e:	b29b      	uxth	r3, r3
 8005670:	1939      	adds	r1, r7, r4
 8005672:	68f8      	ldr	r0, [r7, #12]
 8005674:	f004 fad8 	bl	8009c28 <pbuf_copy_partial>
 8005678:	0003      	movs	r3, r0
 800567a:	001a      	movs	r2, r3
 800567c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800567e:	4293      	cmp	r3, r2
 8005680:	d113      	bne.n	80056aa <http_parse_response_status+0x162>
          int status = atoi(status_num);
 8005682:	193b      	adds	r3, r7, r4
 8005684:	0018      	movs	r0, r3
 8005686:	f017 f873 	bl	801c770 <atoi>
 800568a:	0003      	movs	r3, r0
 800568c:	623b      	str	r3, [r7, #32]
          if ((status > 0) && (status <= 0xFFFF)) {
 800568e:	6a3b      	ldr	r3, [r7, #32]
 8005690:	2b00      	cmp	r3, #0
 8005692:	dd0a      	ble.n	80056aa <http_parse_response_status+0x162>
 8005694:	6a3a      	ldr	r2, [r7, #32]
 8005696:	2380      	movs	r3, #128	; 0x80
 8005698:	025b      	lsls	r3, r3, #9
 800569a:	429a      	cmp	r2, r3
 800569c:	da05      	bge.n	80056aa <http_parse_response_status+0x162>
            *http_status = (u16_t)status;
 800569e:	6a3b      	ldr	r3, [r7, #32]
 80056a0:	b29a      	uxth	r2, r3
 80056a2:	687b      	ldr	r3, [r7, #4]
 80056a4:	801a      	strh	r2, [r3, #0]
            return ERR_OK;
 80056a6:	2300      	movs	r3, #0
 80056a8:	e001      	b.n	80056ae <http_parse_response_status+0x166>
          }
        }
      }
    }
  }
  return ERR_VAL;
 80056aa:	2306      	movs	r3, #6
 80056ac:	425b      	negs	r3, r3
}
 80056ae:	0018      	movs	r0, r3
 80056b0:	46bd      	mov	sp, r7
 80056b2:	b00d      	add	sp, #52	; 0x34
 80056b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80056b6:	46c0      	nop			; (mov r8, r8)
 80056b8:	0801e2a4 	.word	0x0801e2a4
 80056bc:	0000ffff 	.word	0x0000ffff
 80056c0:	0801e2a8 	.word	0x0801e2a8
 80056c4:	0801e2ac 	.word	0x0801e2ac

080056c8 <http_wait_headers>:

/** Wait for all headers to be received, return its length and content-length (if available) */
static err_t
http_wait_headers(struct pbuf *p, u32_t *content_length, u16_t *total_header_len)
{
 80056c8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80056ca:	b08d      	sub	sp, #52	; 0x34
 80056cc:	af00      	add	r7, sp, #0
 80056ce:	60f8      	str	r0, [r7, #12]
 80056d0:	60b9      	str	r1, [r7, #8]
 80056d2:	607a      	str	r2, [r7, #4]
  u16_t end1 = pbuf_memfind(p, "\r\n\r\n", 4, 0);
 80056d4:	252e      	movs	r5, #46	; 0x2e
 80056d6:	197c      	adds	r4, r7, r5
 80056d8:	4938      	ldr	r1, [pc, #224]	; (80057bc <http_wait_headers+0xf4>)
 80056da:	68f8      	ldr	r0, [r7, #12]
 80056dc:	2300      	movs	r3, #0
 80056de:	2204      	movs	r2, #4
 80056e0:	f004 fde0 	bl	800a2a4 <pbuf_memfind>
 80056e4:	0003      	movs	r3, r0
 80056e6:	8023      	strh	r3, [r4, #0]
  if (end1 < (0xFFFF - 2)) {
 80056e8:	0029      	movs	r1, r5
 80056ea:	187b      	adds	r3, r7, r1
 80056ec:	881b      	ldrh	r3, [r3, #0]
 80056ee:	4a34      	ldr	r2, [pc, #208]	; (80057c0 <http_wait_headers+0xf8>)
 80056f0:	4293      	cmp	r3, r2
 80056f2:	d85c      	bhi.n	80057ae <http_wait_headers+0xe6>
    /* all headers received */
    /* check if we have a content length (@todo: case insensitive?) */
    u16_t content_len_hdr;
    *content_length = HTTPC_CONTENT_LEN_INVALID;
 80056f4:	68bb      	ldr	r3, [r7, #8]
 80056f6:	2201      	movs	r2, #1
 80056f8:	4252      	negs	r2, r2
 80056fa:	601a      	str	r2, [r3, #0]
    *total_header_len = end1 + 4;
 80056fc:	187b      	adds	r3, r7, r1
 80056fe:	881b      	ldrh	r3, [r3, #0]
 8005700:	3304      	adds	r3, #4
 8005702:	b29a      	uxth	r2, r3
 8005704:	687b      	ldr	r3, [r7, #4]
 8005706:	801a      	strh	r2, [r3, #0]

    content_len_hdr = pbuf_memfind(p, "Content-Length: ", 16, 0);
 8005708:	252c      	movs	r5, #44	; 0x2c
 800570a:	197c      	adds	r4, r7, r5
 800570c:	492d      	ldr	r1, [pc, #180]	; (80057c4 <http_wait_headers+0xfc>)
 800570e:	68f8      	ldr	r0, [r7, #12]
 8005710:	2300      	movs	r3, #0
 8005712:	2210      	movs	r2, #16
 8005714:	f004 fdc6 	bl	800a2a4 <pbuf_memfind>
 8005718:	0003      	movs	r3, r0
 800571a:	8023      	strh	r3, [r4, #0]
    if (content_len_hdr != 0xFFFF) {
 800571c:	197b      	adds	r3, r7, r5
 800571e:	881b      	ldrh	r3, [r3, #0]
 8005720:	4a29      	ldr	r2, [pc, #164]	; (80057c8 <http_wait_headers+0x100>)
 8005722:	4293      	cmp	r3, r2
 8005724:	d041      	beq.n	80057aa <http_wait_headers+0xe2>
      u16_t content_len_line_end = pbuf_memfind(p, "\r\n", 2, content_len_hdr);
 8005726:	262a      	movs	r6, #42	; 0x2a
 8005728:	19bc      	adds	r4, r7, r6
 800572a:	197b      	adds	r3, r7, r5
 800572c:	881b      	ldrh	r3, [r3, #0]
 800572e:	4927      	ldr	r1, [pc, #156]	; (80057cc <http_wait_headers+0x104>)
 8005730:	68f8      	ldr	r0, [r7, #12]
 8005732:	2202      	movs	r2, #2
 8005734:	f004 fdb6 	bl	800a2a4 <pbuf_memfind>
 8005738:	0003      	movs	r3, r0
 800573a:	8023      	strh	r3, [r4, #0]
      if (content_len_line_end != 0xFFFF) {
 800573c:	19bb      	adds	r3, r7, r6
 800573e:	881b      	ldrh	r3, [r3, #0]
 8005740:	4a21      	ldr	r2, [pc, #132]	; (80057c8 <http_wait_headers+0x100>)
 8005742:	4293      	cmp	r3, r2
 8005744:	d031      	beq.n	80057aa <http_wait_headers+0xe2>
        char content_len_num[16];
        u16_t content_len_num_len = (u16_t)(content_len_line_end - content_len_hdr - 16);
 8005746:	19ba      	adds	r2, r7, r6
 8005748:	002c      	movs	r4, r5
 800574a:	193b      	adds	r3, r7, r4
 800574c:	8812      	ldrh	r2, [r2, #0]
 800574e:	881b      	ldrh	r3, [r3, #0]
 8005750:	1ad3      	subs	r3, r2, r3
 8005752:	b29a      	uxth	r2, r3
 8005754:	2528      	movs	r5, #40	; 0x28
 8005756:	197b      	adds	r3, r7, r5
 8005758:	3a10      	subs	r2, #16
 800575a:	801a      	strh	r2, [r3, #0]
        memset(content_len_num, 0, sizeof(content_len_num));
 800575c:	2614      	movs	r6, #20
 800575e:	19bb      	adds	r3, r7, r6
 8005760:	2210      	movs	r2, #16
 8005762:	2100      	movs	r1, #0
 8005764:	0018      	movs	r0, r3
 8005766:	f017 f861 	bl	801c82c <memset>
        if (pbuf_copy_partial(p, content_len_num, content_len_num_len, content_len_hdr + 16) == content_len_num_len) {
 800576a:	193b      	adds	r3, r7, r4
 800576c:	881b      	ldrh	r3, [r3, #0]
 800576e:	3310      	adds	r3, #16
 8005770:	b29c      	uxth	r4, r3
 8005772:	197b      	adds	r3, r7, r5
 8005774:	881a      	ldrh	r2, [r3, #0]
 8005776:	19b9      	adds	r1, r7, r6
 8005778:	68f8      	ldr	r0, [r7, #12]
 800577a:	0023      	movs	r3, r4
 800577c:	f004 fa54 	bl	8009c28 <pbuf_copy_partial>
 8005780:	0003      	movs	r3, r0
 8005782:	001a      	movs	r2, r3
 8005784:	197b      	adds	r3, r7, r5
 8005786:	881b      	ldrh	r3, [r3, #0]
 8005788:	4293      	cmp	r3, r2
 800578a:	d10e      	bne.n	80057aa <http_wait_headers+0xe2>
          int len = atoi(content_len_num);
 800578c:	19bb      	adds	r3, r7, r6
 800578e:	0018      	movs	r0, r3
 8005790:	f016 ffee 	bl	801c770 <atoi>
 8005794:	0003      	movs	r3, r0
 8005796:	627b      	str	r3, [r7, #36]	; 0x24
          if ((len >= 0) && ((u32_t)len < HTTPC_CONTENT_LEN_INVALID)) {
 8005798:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800579a:	2b00      	cmp	r3, #0
 800579c:	db05      	blt.n	80057aa <http_wait_headers+0xe2>
 800579e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80057a0:	3301      	adds	r3, #1
 80057a2:	d002      	beq.n	80057aa <http_wait_headers+0xe2>
            *content_length = (u32_t)len;
 80057a4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80057a6:	68bb      	ldr	r3, [r7, #8]
 80057a8:	601a      	str	r2, [r3, #0]
          }
        }
      }
    }
    return ERR_OK;
 80057aa:	2300      	movs	r3, #0
 80057ac:	e001      	b.n	80057b2 <http_wait_headers+0xea>
  }
  return ERR_VAL;
 80057ae:	2306      	movs	r3, #6
 80057b0:	425b      	negs	r3, r3
}
 80057b2:	0018      	movs	r0, r3
 80057b4:	46bd      	mov	sp, r7
 80057b6:	b00d      	add	sp, #52	; 0x34
 80057b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80057ba:	46c0      	nop			; (mov r8, r8)
 80057bc:	0801e2b4 	.word	0x0801e2b4
 80057c0:	0000fffc 	.word	0x0000fffc
 80057c4:	0801e2bc 	.word	0x0801e2bc
 80057c8:	0000ffff 	.word	0x0000ffff
 80057cc:	0801e2a4 	.word	0x0801e2a4

080057d0 <httpc_tcp_recv>:

/** http client tcp recv callback */
static err_t
httpc_tcp_recv(void *arg, struct altcp_pcb *pcb, struct pbuf *p, err_t r)
{
 80057d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80057d2:	b08d      	sub	sp, #52	; 0x34
 80057d4:	af02      	add	r7, sp, #8
 80057d6:	60f8      	str	r0, [r7, #12]
 80057d8:	60b9      	str	r1, [r7, #8]
 80057da:	607a      	str	r2, [r7, #4]
 80057dc:	001a      	movs	r2, r3
 80057de:	1cfb      	adds	r3, r7, #3
 80057e0:	701a      	strb	r2, [r3, #0]
  httpc_state_t* req = (httpc_state_t*)arg;
 80057e2:	68fb      	ldr	r3, [r7, #12]
 80057e4:	623b      	str	r3, [r7, #32]
  LWIP_UNUSED_ARG(r);

  if (p == NULL) {
 80057e6:	687b      	ldr	r3, [r7, #4]
 80057e8:	2b00      	cmp	r3, #0
 80057ea:	d128      	bne.n	800583e <httpc_tcp_recv+0x6e>
    httpc_result_t result;
    if (req->parse_state != HTTPC_PARSE_RX_DATA) {
 80057ec:	6a3b      	ldr	r3, [r7, #32]
 80057ee:	2230      	movs	r2, #48	; 0x30
 80057f0:	5c9b      	ldrb	r3, [r3, r2]
 80057f2:	2b02      	cmp	r3, #2
 80057f4:	d004      	beq.n	8005800 <httpc_tcp_recv+0x30>
      /* did not get RX data yet */
      result = HTTPC_RESULT_ERR_CLOSED;
 80057f6:	2327      	movs	r3, #39	; 0x27
 80057f8:	18fb      	adds	r3, r7, r3
 80057fa:	2204      	movs	r2, #4
 80057fc:	701a      	strb	r2, [r3, #0]
 80057fe:	e012      	b.n	8005826 <httpc_tcp_recv+0x56>
    } else if ((req->hdr_content_len != HTTPC_CONTENT_LEN_INVALID) &&
 8005800:	6a3b      	ldr	r3, [r7, #32]
 8005802:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005804:	3301      	adds	r3, #1
 8005806:	d00a      	beq.n	800581e <httpc_tcp_recv+0x4e>
      (req->hdr_content_len != req->rx_content_len)) {
 8005808:	6a3b      	ldr	r3, [r7, #32]
 800580a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800580c:	6a3b      	ldr	r3, [r7, #32]
 800580e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    } else if ((req->hdr_content_len != HTTPC_CONTENT_LEN_INVALID) &&
 8005810:	429a      	cmp	r2, r3
 8005812:	d004      	beq.n	800581e <httpc_tcp_recv+0x4e>
      /* header has been received with content length but not all data received */
      result = HTTPC_RESULT_ERR_CONTENT_LEN;
 8005814:	2327      	movs	r3, #39	; 0x27
 8005816:	18fb      	adds	r3, r7, r3
 8005818:	2209      	movs	r2, #9
 800581a:	701a      	strb	r2, [r3, #0]
 800581c:	e003      	b.n	8005826 <httpc_tcp_recv+0x56>
    } else {
      /* receiving data and either all data received or no content length header */
      result = HTTPC_RESULT_OK;
 800581e:	2327      	movs	r3, #39	; 0x27
 8005820:	18fb      	adds	r3, r7, r3
 8005822:	2200      	movs	r2, #0
 8005824:	701a      	strb	r2, [r3, #0]
    }
    return httpc_close(req, result, req->rx_status, ERR_OK);
 8005826:	6a3b      	ldr	r3, [r7, #32]
 8005828:	8b5b      	ldrh	r3, [r3, #26]
 800582a:	001a      	movs	r2, r3
 800582c:	2327      	movs	r3, #39	; 0x27
 800582e:	18fb      	adds	r3, r7, r3
 8005830:	7819      	ldrb	r1, [r3, #0]
 8005832:	6a38      	ldr	r0, [r7, #32]
 8005834:	2300      	movs	r3, #0
 8005836:	f7ff fe50 	bl	80054da <httpc_close>
 800583a:	0003      	movs	r3, r0
 800583c:	e0bd      	b.n	80059ba <httpc_tcp_recv+0x1ea>
  }
  if (req->parse_state != HTTPC_PARSE_RX_DATA) {
 800583e:	6a3b      	ldr	r3, [r7, #32]
 8005840:	2230      	movs	r2, #48	; 0x30
 8005842:	5c9b      	ldrb	r3, [r3, r2]
 8005844:	2b02      	cmp	r3, #2
 8005846:	d100      	bne.n	800584a <httpc_tcp_recv+0x7a>
 8005848:	e08c      	b.n	8005964 <httpc_tcp_recv+0x194>
    if (req->rx_hdrs == NULL) {
 800584a:	6a3b      	ldr	r3, [r7, #32]
 800584c:	695b      	ldr	r3, [r3, #20]
 800584e:	2b00      	cmp	r3, #0
 8005850:	d103      	bne.n	800585a <httpc_tcp_recv+0x8a>
      req->rx_hdrs = p;
 8005852:	6a3b      	ldr	r3, [r7, #32]
 8005854:	687a      	ldr	r2, [r7, #4]
 8005856:	615a      	str	r2, [r3, #20]
 8005858:	e006      	b.n	8005868 <httpc_tcp_recv+0x98>
    } else {
      pbuf_cat(req->rx_hdrs, p);
 800585a:	6a3b      	ldr	r3, [r7, #32]
 800585c:	695b      	ldr	r3, [r3, #20]
 800585e:	687a      	ldr	r2, [r7, #4]
 8005860:	0011      	movs	r1, r2
 8005862:	0018      	movs	r0, r3
 8005864:	f003 fff6 	bl	8009854 <pbuf_cat>
    }
    if (req->parse_state == HTTPC_PARSE_WAIT_FIRST_LINE) {
 8005868:	6a3b      	ldr	r3, [r7, #32]
 800586a:	2230      	movs	r2, #48	; 0x30
 800586c:	5c9b      	ldrb	r3, [r3, r2]
 800586e:	2b00      	cmp	r3, #0
 8005870:	d118      	bne.n	80058a4 <httpc_tcp_recv+0xd4>
      u16_t status_str_off;
      err_t err = http_parse_response_status(req->rx_hdrs, &req->rx_http_version, &req->rx_status, &status_str_off);
 8005872:	6a3b      	ldr	r3, [r7, #32]
 8005874:	6958      	ldr	r0, [r3, #20]
 8005876:	6a3b      	ldr	r3, [r7, #32]
 8005878:	3318      	adds	r3, #24
 800587a:	0019      	movs	r1, r3
 800587c:	6a3b      	ldr	r3, [r7, #32]
 800587e:	331a      	adds	r3, #26
 8005880:	001a      	movs	r2, r3
 8005882:	251f      	movs	r5, #31
 8005884:	197c      	adds	r4, r7, r5
 8005886:	2316      	movs	r3, #22
 8005888:	18fb      	adds	r3, r7, r3
 800588a:	f7ff fe5d 	bl	8005548 <http_parse_response_status>
 800588e:	0003      	movs	r3, r0
 8005890:	7023      	strb	r3, [r4, #0]
      if (err == ERR_OK) {
 8005892:	197b      	adds	r3, r7, r5
 8005894:	781b      	ldrb	r3, [r3, #0]
 8005896:	b25b      	sxtb	r3, r3
 8005898:	2b00      	cmp	r3, #0
 800589a:	d103      	bne.n	80058a4 <httpc_tcp_recv+0xd4>
        /* don't care status string */
        req->parse_state = HTTPC_PARSE_WAIT_HEADERS;
 800589c:	6a3b      	ldr	r3, [r7, #32]
 800589e:	2230      	movs	r2, #48	; 0x30
 80058a0:	2101      	movs	r1, #1
 80058a2:	5499      	strb	r1, [r3, r2]
      }
    }
    if (req->parse_state == HTTPC_PARSE_WAIT_HEADERS) {
 80058a4:	6a3b      	ldr	r3, [r7, #32]
 80058a6:	2230      	movs	r2, #48	; 0x30
 80058a8:	5c9b      	ldrb	r3, [r3, r2]
 80058aa:	2b01      	cmp	r3, #1
 80058ac:	d15a      	bne.n	8005964 <httpc_tcp_recv+0x194>
      u16_t total_header_len;
      err_t err = http_wait_headers(req->rx_hdrs, &req->hdr_content_len, &total_header_len);
 80058ae:	6a3b      	ldr	r3, [r7, #32]
 80058b0:	6958      	ldr	r0, [r3, #20]
 80058b2:	6a3b      	ldr	r3, [r7, #32]
 80058b4:	332c      	adds	r3, #44	; 0x2c
 80058b6:	251e      	movs	r5, #30
 80058b8:	197c      	adds	r4, r7, r5
 80058ba:	2614      	movs	r6, #20
 80058bc:	19ba      	adds	r2, r7, r6
 80058be:	0019      	movs	r1, r3
 80058c0:	f7ff ff02 	bl	80056c8 <http_wait_headers>
 80058c4:	0003      	movs	r3, r0
 80058c6:	7023      	strb	r3, [r4, #0]
      if (err == ERR_OK) {
 80058c8:	002c      	movs	r4, r5
 80058ca:	193b      	adds	r3, r7, r4
 80058cc:	781b      	ldrb	r3, [r3, #0]
 80058ce:	b25b      	sxtb	r3, r3
 80058d0:	2b00      	cmp	r3, #0
 80058d2:	d147      	bne.n	8005964 <httpc_tcp_recv+0x194>
        struct pbuf *q;
        /* full header received, send window update for header bytes and call into client callback */
        altcp_recved(pcb, total_header_len);
 80058d4:	19bb      	adds	r3, r7, r6
 80058d6:	881a      	ldrh	r2, [r3, #0]
 80058d8:	68bb      	ldr	r3, [r7, #8]
 80058da:	0011      	movs	r1, r2
 80058dc:	0018      	movs	r0, r3
 80058de:	f005 f8c9 	bl	800aa74 <tcp_recved>
        if (req->conn_settings) {
 80058e2:	6a3b      	ldr	r3, [r7, #32]
 80058e4:	6a1b      	ldr	r3, [r3, #32]
 80058e6:	2b00      	cmp	r3, #0
 80058e8:	d028      	beq.n	800593c <httpc_tcp_recv+0x16c>
          if (req->conn_settings->headers_done_fn) {
 80058ea:	6a3b      	ldr	r3, [r7, #32]
 80058ec:	6a1b      	ldr	r3, [r3, #32]
 80058ee:	68db      	ldr	r3, [r3, #12]
 80058f0:	2b00      	cmp	r3, #0
 80058f2:	d023      	beq.n	800593c <httpc_tcp_recv+0x16c>
            err = req->conn_settings->headers_done_fn(req, req->callback_arg, req->rx_hdrs, total_header_len, req->hdr_content_len);
 80058f4:	6a3b      	ldr	r3, [r7, #32]
 80058f6:	6a1b      	ldr	r3, [r3, #32]
 80058f8:	68dd      	ldr	r5, [r3, #12]
 80058fa:	6a3b      	ldr	r3, [r7, #32]
 80058fc:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80058fe:	6a3b      	ldr	r3, [r7, #32]
 8005900:	695a      	ldr	r2, [r3, #20]
 8005902:	19bb      	adds	r3, r7, r6
 8005904:	881e      	ldrh	r6, [r3, #0]
 8005906:	6a3b      	ldr	r3, [r7, #32]
 8005908:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800590a:	193c      	adds	r4, r7, r4
 800590c:	6a38      	ldr	r0, [r7, #32]
 800590e:	9300      	str	r3, [sp, #0]
 8005910:	0033      	movs	r3, r6
 8005912:	47a8      	blx	r5
 8005914:	0003      	movs	r3, r0
 8005916:	7023      	strb	r3, [r4, #0]
            if (err != ERR_OK) {
 8005918:	241e      	movs	r4, #30
 800591a:	193b      	adds	r3, r7, r4
 800591c:	781b      	ldrb	r3, [r3, #0]
 800591e:	b25b      	sxtb	r3, r3
 8005920:	2b00      	cmp	r3, #0
 8005922:	d00b      	beq.n	800593c <httpc_tcp_recv+0x16c>
              return httpc_close(req, HTTPC_RESULT_LOCAL_ABORT, req->rx_status, err);
 8005924:	6a3b      	ldr	r3, [r7, #32]
 8005926:	8b5b      	ldrh	r3, [r3, #26]
 8005928:	001a      	movs	r2, r3
 800592a:	193b      	adds	r3, r7, r4
 800592c:	781b      	ldrb	r3, [r3, #0]
 800592e:	b25b      	sxtb	r3, r3
 8005930:	6a38      	ldr	r0, [r7, #32]
 8005932:	2108      	movs	r1, #8
 8005934:	f7ff fdd1 	bl	80054da <httpc_close>
 8005938:	0003      	movs	r3, r0
 800593a:	e03e      	b.n	80059ba <httpc_tcp_recv+0x1ea>
            }
          }
        }
        /* hide header bytes in pbuf */
        q = pbuf_free_header(req->rx_hdrs, total_header_len);
 800593c:	6a3b      	ldr	r3, [r7, #32]
 800593e:	695a      	ldr	r2, [r3, #20]
 8005940:	2314      	movs	r3, #20
 8005942:	18fb      	adds	r3, r7, r3
 8005944:	881b      	ldrh	r3, [r3, #0]
 8005946:	0019      	movs	r1, r3
 8005948:	0010      	movs	r0, r2
 800594a:	f003 fe60 	bl	800960e <pbuf_free_header>
 800594e:	0003      	movs	r3, r0
 8005950:	61bb      	str	r3, [r7, #24]
        p = q;
 8005952:	69bb      	ldr	r3, [r7, #24]
 8005954:	607b      	str	r3, [r7, #4]
        req->rx_hdrs = NULL;
 8005956:	6a3b      	ldr	r3, [r7, #32]
 8005958:	2200      	movs	r2, #0
 800595a:	615a      	str	r2, [r3, #20]
        /* go on with data */
        req->parse_state = HTTPC_PARSE_RX_DATA;
 800595c:	6a3b      	ldr	r3, [r7, #32]
 800595e:	2230      	movs	r2, #48	; 0x30
 8005960:	2102      	movs	r1, #2
 8005962:	5499      	strb	r1, [r3, r2]
      }
    }
  }
  if ((p != NULL) && (req->parse_state == HTTPC_PARSE_RX_DATA)) {
 8005964:	687b      	ldr	r3, [r7, #4]
 8005966:	2b00      	cmp	r3, #0
 8005968:	d026      	beq.n	80059b8 <httpc_tcp_recv+0x1e8>
 800596a:	6a3b      	ldr	r3, [r7, #32]
 800596c:	2230      	movs	r2, #48	; 0x30
 800596e:	5c9b      	ldrb	r3, [r3, r2]
 8005970:	2b02      	cmp	r3, #2
 8005972:	d121      	bne.n	80059b8 <httpc_tcp_recv+0x1e8>
    req->rx_content_len += p->tot_len;
 8005974:	6a3b      	ldr	r3, [r7, #32]
 8005976:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005978:	687a      	ldr	r2, [r7, #4]
 800597a:	8912      	ldrh	r2, [r2, #8]
 800597c:	189a      	adds	r2, r3, r2
 800597e:	6a3b      	ldr	r3, [r7, #32]
 8005980:	629a      	str	r2, [r3, #40]	; 0x28
    if (req->recv_fn != NULL) {
 8005982:	6a3b      	ldr	r3, [r7, #32]
 8005984:	69db      	ldr	r3, [r3, #28]
 8005986:	2b00      	cmp	r3, #0
 8005988:	d00b      	beq.n	80059a2 <httpc_tcp_recv+0x1d2>
      /* directly return here: the connection migth already be aborted from the callback! */
      return req->recv_fn(req->callback_arg, pcb, p, r);
 800598a:	6a3b      	ldr	r3, [r7, #32]
 800598c:	69dc      	ldr	r4, [r3, #28]
 800598e:	6a3b      	ldr	r3, [r7, #32]
 8005990:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8005992:	1cfb      	adds	r3, r7, #3
 8005994:	781b      	ldrb	r3, [r3, #0]
 8005996:	b25b      	sxtb	r3, r3
 8005998:	687a      	ldr	r2, [r7, #4]
 800599a:	68b9      	ldr	r1, [r7, #8]
 800599c:	47a0      	blx	r4
 800599e:	0003      	movs	r3, r0
 80059a0:	e00b      	b.n	80059ba <httpc_tcp_recv+0x1ea>
    } else {
      altcp_recved(pcb, p->tot_len);
 80059a2:	687b      	ldr	r3, [r7, #4]
 80059a4:	891a      	ldrh	r2, [r3, #8]
 80059a6:	68bb      	ldr	r3, [r7, #8]
 80059a8:	0011      	movs	r1, r2
 80059aa:	0018      	movs	r0, r3
 80059ac:	f005 f862 	bl	800aa74 <tcp_recved>
      pbuf_free(p);
 80059b0:	687b      	ldr	r3, [r7, #4]
 80059b2:	0018      	movs	r0, r3
 80059b4:	f003 fe6e 	bl	8009694 <pbuf_free>
    }
  }
  return ERR_OK;
 80059b8:	2300      	movs	r3, #0
}
 80059ba:	0018      	movs	r0, r3
 80059bc:	46bd      	mov	sp, r7
 80059be:	b00b      	add	sp, #44	; 0x2c
 80059c0:	bdf0      	pop	{r4, r5, r6, r7, pc}

080059c2 <httpc_tcp_err>:

/** http client tcp err callback */
static void
httpc_tcp_err(void *arg, err_t err)
{
 80059c2:	b580      	push	{r7, lr}
 80059c4:	b084      	sub	sp, #16
 80059c6:	af00      	add	r7, sp, #0
 80059c8:	6078      	str	r0, [r7, #4]
 80059ca:	000a      	movs	r2, r1
 80059cc:	1cfb      	adds	r3, r7, #3
 80059ce:	701a      	strb	r2, [r3, #0]
  httpc_state_t* req = (httpc_state_t*)arg;
 80059d0:	687b      	ldr	r3, [r7, #4]
 80059d2:	60fb      	str	r3, [r7, #12]
  if (req != NULL) {
 80059d4:	68fb      	ldr	r3, [r7, #12]
 80059d6:	2b00      	cmp	r3, #0
 80059d8:	d00a      	beq.n	80059f0 <httpc_tcp_err+0x2e>
    /* pcb has already been deallocated */
    req->pcb = NULL;
 80059da:	68fb      	ldr	r3, [r7, #12]
 80059dc:	2200      	movs	r2, #0
 80059de:	601a      	str	r2, [r3, #0]
    httpc_close(req, HTTPC_RESULT_ERR_CLOSED, 0, err);
 80059e0:	1cfb      	adds	r3, r7, #3
 80059e2:	781b      	ldrb	r3, [r3, #0]
 80059e4:	b25b      	sxtb	r3, r3
 80059e6:	68f8      	ldr	r0, [r7, #12]
 80059e8:	2200      	movs	r2, #0
 80059ea:	2104      	movs	r1, #4
 80059ec:	f7ff fd75 	bl	80054da <httpc_close>
  }
}
 80059f0:	46c0      	nop			; (mov r8, r8)
 80059f2:	46bd      	mov	sp, r7
 80059f4:	b004      	add	sp, #16
 80059f6:	bd80      	pop	{r7, pc}

080059f8 <httpc_tcp_poll>:

/** http client tcp poll callback */
static err_t
httpc_tcp_poll(void *arg, struct altcp_pcb *pcb)
{
 80059f8:	b580      	push	{r7, lr}
 80059fa:	b084      	sub	sp, #16
 80059fc:	af00      	add	r7, sp, #0
 80059fe:	6078      	str	r0, [r7, #4]
 8005a00:	6039      	str	r1, [r7, #0]
  /* implement timeout */
  httpc_state_t* req = (httpc_state_t*)arg;
 8005a02:	687b      	ldr	r3, [r7, #4]
 8005a04:	60fb      	str	r3, [r7, #12]
  LWIP_UNUSED_ARG(pcb);
  if (req != NULL) {
 8005a06:	68fb      	ldr	r3, [r7, #12]
 8005a08:	2b00      	cmp	r3, #0
 8005a0a:	d014      	beq.n	8005a36 <httpc_tcp_poll+0x3e>
    if (req->timeout_ticks) {
 8005a0c:	68fb      	ldr	r3, [r7, #12]
 8005a0e:	68db      	ldr	r3, [r3, #12]
 8005a10:	2b00      	cmp	r3, #0
 8005a12:	d004      	beq.n	8005a1e <httpc_tcp_poll+0x26>
      req->timeout_ticks--;
 8005a14:	68fb      	ldr	r3, [r7, #12]
 8005a16:	68db      	ldr	r3, [r3, #12]
 8005a18:	1e5a      	subs	r2, r3, #1
 8005a1a:	68fb      	ldr	r3, [r7, #12]
 8005a1c:	60da      	str	r2, [r3, #12]
    }
    if (!req->timeout_ticks) {
 8005a1e:	68fb      	ldr	r3, [r7, #12]
 8005a20:	68db      	ldr	r3, [r3, #12]
 8005a22:	2b00      	cmp	r3, #0
 8005a24:	d107      	bne.n	8005a36 <httpc_tcp_poll+0x3e>
      return httpc_close(req, HTTPC_RESULT_ERR_TIMEOUT, 0, ERR_OK);
 8005a26:	68f8      	ldr	r0, [r7, #12]
 8005a28:	2300      	movs	r3, #0
 8005a2a:	2200      	movs	r2, #0
 8005a2c:	2105      	movs	r1, #5
 8005a2e:	f7ff fd54 	bl	80054da <httpc_close>
 8005a32:	0003      	movs	r3, r0
 8005a34:	e000      	b.n	8005a38 <httpc_tcp_poll+0x40>
    }
  }
  return ERR_OK;
 8005a36:	2300      	movs	r3, #0
}
 8005a38:	0018      	movs	r0, r3
 8005a3a:	46bd      	mov	sp, r7
 8005a3c:	b004      	add	sp, #16
 8005a3e:	bd80      	pop	{r7, pc}

08005a40 <httpc_tcp_sent>:

/** http client tcp sent callback */
static err_t
httpc_tcp_sent(void *arg, struct altcp_pcb *pcb, u16_t len)
{
 8005a40:	b580      	push	{r7, lr}
 8005a42:	b084      	sub	sp, #16
 8005a44:	af00      	add	r7, sp, #0
 8005a46:	60f8      	str	r0, [r7, #12]
 8005a48:	60b9      	str	r1, [r7, #8]
 8005a4a:	1dbb      	adds	r3, r7, #6
 8005a4c:	801a      	strh	r2, [r3, #0]
  /* nothing to do here for now */
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(len);
  return ERR_OK;
 8005a4e:	2300      	movs	r3, #0
}
 8005a50:	0018      	movs	r0, r3
 8005a52:	46bd      	mov	sp, r7
 8005a54:	b004      	add	sp, #16
 8005a56:	bd80      	pop	{r7, pc}

08005a58 <httpc_tcp_connected>:

/** http client tcp connected callback */
static err_t
httpc_tcp_connected(void *arg, struct altcp_pcb *pcb, err_t err)
{
 8005a58:	b5b0      	push	{r4, r5, r7, lr}
 8005a5a:	b086      	sub	sp, #24
 8005a5c:	af00      	add	r7, sp, #0
 8005a5e:	60f8      	str	r0, [r7, #12]
 8005a60:	60b9      	str	r1, [r7, #8]
 8005a62:	1dfb      	adds	r3, r7, #7
 8005a64:	701a      	strb	r2, [r3, #0]
  err_t r;
  httpc_state_t* req = (httpc_state_t*)arg;
 8005a66:	68fb      	ldr	r3, [r7, #12]
 8005a68:	617b      	str	r3, [r7, #20]
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  /* send request; last char is zero termination */
  r = altcp_write(req->pcb, req->request->payload, req->request->len - 1, TCP_WRITE_FLAG_COPY);
 8005a6a:	697b      	ldr	r3, [r7, #20]
 8005a6c:	6818      	ldr	r0, [r3, #0]
 8005a6e:	697b      	ldr	r3, [r7, #20]
 8005a70:	691b      	ldr	r3, [r3, #16]
 8005a72:	6859      	ldr	r1, [r3, #4]
 8005a74:	697b      	ldr	r3, [r7, #20]
 8005a76:	691b      	ldr	r3, [r3, #16]
 8005a78:	895b      	ldrh	r3, [r3, #10]
 8005a7a:	3b01      	subs	r3, #1
 8005a7c:	b29a      	uxth	r2, r3
 8005a7e:	2513      	movs	r5, #19
 8005a80:	197c      	adds	r4, r7, r5
 8005a82:	2301      	movs	r3, #1
 8005a84:	f009 fc74 	bl	800f370 <tcp_write>
 8005a88:	0003      	movs	r3, r0
 8005a8a:	7023      	strb	r3, [r4, #0]
  if (r != ERR_OK) {
 8005a8c:	197b      	adds	r3, r7, r5
 8005a8e:	781b      	ldrb	r3, [r3, #0]
 8005a90:	b25b      	sxtb	r3, r3
 8005a92:	2b00      	cmp	r3, #0
 8005a94:	d009      	beq.n	8005aaa <httpc_tcp_connected+0x52>
     /* could not write the single small request -> fail, don't retry */
     return httpc_close(req, HTTPC_RESULT_ERR_MEM, 0, r);
 8005a96:	197b      	adds	r3, r7, r5
 8005a98:	781b      	ldrb	r3, [r3, #0]
 8005a9a:	b25b      	sxtb	r3, r3
 8005a9c:	6978      	ldr	r0, [r7, #20]
 8005a9e:	2200      	movs	r2, #0
 8005aa0:	2107      	movs	r1, #7
 8005aa2:	f7ff fd1a 	bl	80054da <httpc_close>
 8005aa6:	0003      	movs	r3, r0
 8005aa8:	e00d      	b.n	8005ac6 <httpc_tcp_connected+0x6e>
  }
  /* everything written, we can free the request */
  pbuf_free(req->request);
 8005aaa:	697b      	ldr	r3, [r7, #20]
 8005aac:	691b      	ldr	r3, [r3, #16]
 8005aae:	0018      	movs	r0, r3
 8005ab0:	f003 fdf0 	bl	8009694 <pbuf_free>
  req->request = NULL;
 8005ab4:	697b      	ldr	r3, [r7, #20]
 8005ab6:	2200      	movs	r2, #0
 8005ab8:	611a      	str	r2, [r3, #16]

  altcp_output(req->pcb);
 8005aba:	697b      	ldr	r3, [r7, #20]
 8005abc:	681b      	ldr	r3, [r3, #0]
 8005abe:	0018      	movs	r0, r3
 8005ac0:	f00a fd5e 	bl	8010580 <tcp_output>
  return ERR_OK;
 8005ac4:	2300      	movs	r3, #0
}
 8005ac6:	0018      	movs	r0, r3
 8005ac8:	46bd      	mov	sp, r7
 8005aca:	b006      	add	sp, #24
 8005acc:	bdb0      	pop	{r4, r5, r7, pc}
	...

08005ad0 <httpc_get_internal_addr>:

/** Start the http request when the server IP addr is known */
static err_t
httpc_get_internal_addr(httpc_state_t* req, const ip_addr_t *ipaddr)
{
 8005ad0:	b5b0      	push	{r4, r5, r7, lr}
 8005ad2:	b084      	sub	sp, #16
 8005ad4:	af00      	add	r7, sp, #0
 8005ad6:	6078      	str	r0, [r7, #4]
 8005ad8:	6039      	str	r1, [r7, #0]
  err_t err;
  LWIP_ASSERT("req != NULL", req != NULL);
 8005ada:	687b      	ldr	r3, [r7, #4]
 8005adc:	2b00      	cmp	r3, #0
 8005ade:	d106      	bne.n	8005aee <httpc_get_internal_addr+0x1e>
 8005ae0:	4b15      	ldr	r3, [pc, #84]	; (8005b38 <httpc_get_internal_addr+0x68>)
 8005ae2:	22d2      	movs	r2, #210	; 0xd2
 8005ae4:	0052      	lsls	r2, r2, #1
 8005ae6:	4915      	ldr	r1, [pc, #84]	; (8005b3c <httpc_get_internal_addr+0x6c>)
 8005ae8:	4815      	ldr	r0, [pc, #84]	; (8005b40 <httpc_get_internal_addr+0x70>)
 8005aea:	f7fc fb6f 	bl	80021cc <app_debug_rtt_raw>

  if (&req->remote_addr != ipaddr) {
 8005aee:	687b      	ldr	r3, [r7, #4]
 8005af0:	3304      	adds	r3, #4
 8005af2:	683a      	ldr	r2, [r7, #0]
 8005af4:	429a      	cmp	r2, r3
 8005af6:	d003      	beq.n	8005b00 <httpc_get_internal_addr+0x30>
    /* fill in remote addr if called externally */
    req->remote_addr = *ipaddr;
 8005af8:	687b      	ldr	r3, [r7, #4]
 8005afa:	683a      	ldr	r2, [r7, #0]
 8005afc:	6812      	ldr	r2, [r2, #0]
 8005afe:	605a      	str	r2, [r3, #4]
  }

  err = altcp_connect(req->pcb, &req->remote_addr, req->remote_port, httpc_tcp_connected);
 8005b00:	687b      	ldr	r3, [r7, #4]
 8005b02:	6818      	ldr	r0, [r3, #0]
 8005b04:	687b      	ldr	r3, [r7, #4]
 8005b06:	1d19      	adds	r1, r3, #4
 8005b08:	687b      	ldr	r3, [r7, #4]
 8005b0a:	891a      	ldrh	r2, [r3, #8]
 8005b0c:	250f      	movs	r5, #15
 8005b0e:	197c      	adds	r4, r7, r5
 8005b10:	4b0c      	ldr	r3, [pc, #48]	; (8005b44 <httpc_get_internal_addr+0x74>)
 8005b12:	f005 f85b 	bl	800abcc <tcp_connect>
 8005b16:	0003      	movs	r3, r0
 8005b18:	7023      	strb	r3, [r4, #0]
  if (err == ERR_OK) {
 8005b1a:	197b      	adds	r3, r7, r5
 8005b1c:	781b      	ldrb	r3, [r3, #0]
 8005b1e:	b25b      	sxtb	r3, r3
 8005b20:	2b00      	cmp	r3, #0
 8005b22:	d101      	bne.n	8005b28 <httpc_get_internal_addr+0x58>
    return ERR_OK;
 8005b24:	2300      	movs	r3, #0
 8005b26:	e003      	b.n	8005b30 <httpc_get_internal_addr+0x60>
  }
  LWIP_DEBUGF(HTTPC_DEBUG_WARN_STATE, ("tcp_connect failed: %d\n", (int)err));
  return err;
 8005b28:	230f      	movs	r3, #15
 8005b2a:	18fb      	adds	r3, r7, r3
 8005b2c:	781b      	ldrb	r3, [r3, #0]
 8005b2e:	b25b      	sxtb	r3, r3
}
 8005b30:	0018      	movs	r0, r3
 8005b32:	46bd      	mov	sp, r7
 8005b34:	b004      	add	sp, #16
 8005b36:	bdb0      	pop	{r4, r5, r7, pc}
 8005b38:	0801e2d0 	.word	0x0801e2d0
 8005b3c:	0801e304 	.word	0x0801e304
 8005b40:	0801e310 	.word	0x0801e310
 8005b44:	08005a59 	.word	0x08005a59

08005b48 <httpc_dns_found>:
/** DNS callback
 * If ipaddr is non-NULL, resolving succeeded and the request can be sent, otherwise it failed.
 */
static void
httpc_dns_found(const char* hostname, const ip_addr_t *ipaddr, void *arg)
{
 8005b48:	b5b0      	push	{r4, r5, r7, lr}
 8005b4a:	b086      	sub	sp, #24
 8005b4c:	af00      	add	r7, sp, #0
 8005b4e:	60f8      	str	r0, [r7, #12]
 8005b50:	60b9      	str	r1, [r7, #8]
 8005b52:	607a      	str	r2, [r7, #4]
  httpc_state_t* req = (httpc_state_t*)arg;
 8005b54:	687b      	ldr	r3, [r7, #4]
 8005b56:	613b      	str	r3, [r7, #16]
  err_t err;
  httpc_result_t result;

  LWIP_UNUSED_ARG(hostname);

  if (ipaddr != NULL) {
 8005b58:	68bb      	ldr	r3, [r7, #8]
 8005b5a:	2b00      	cmp	r3, #0
 8005b5c:	d013      	beq.n	8005b86 <httpc_dns_found+0x3e>
    err = httpc_get_internal_addr(req, ipaddr);
 8005b5e:	2517      	movs	r5, #23
 8005b60:	197c      	adds	r4, r7, r5
 8005b62:	68ba      	ldr	r2, [r7, #8]
 8005b64:	693b      	ldr	r3, [r7, #16]
 8005b66:	0011      	movs	r1, r2
 8005b68:	0018      	movs	r0, r3
 8005b6a:	f7ff ffb1 	bl	8005ad0 <httpc_get_internal_addr>
 8005b6e:	0003      	movs	r3, r0
 8005b70:	7023      	strb	r3, [r4, #0]
    if (err == ERR_OK) {
 8005b72:	197b      	adds	r3, r7, r5
 8005b74:	781b      	ldrb	r3, [r3, #0]
 8005b76:	b25b      	sxtb	r3, r3
 8005b78:	2b00      	cmp	r3, #0
 8005b7a:	d019      	beq.n	8005bb0 <httpc_dns_found+0x68>
      return;
    }
    result = HTTPC_RESULT_ERR_CONNECT;
 8005b7c:	2316      	movs	r3, #22
 8005b7e:	18fb      	adds	r3, r7, r3
 8005b80:	2202      	movs	r2, #2
 8005b82:	701a      	strb	r2, [r3, #0]
 8005b84:	e007      	b.n	8005b96 <httpc_dns_found+0x4e>
  } else {
    LWIP_DEBUGF(HTTPC_DEBUG_WARN_STATE, ("httpc_dns_found: failed to resolve hostname: %s\n",
      hostname));
    result = HTTPC_RESULT_ERR_HOSTNAME;
 8005b86:	2316      	movs	r3, #22
 8005b88:	18fb      	adds	r3, r7, r3
 8005b8a:	2203      	movs	r2, #3
 8005b8c:	701a      	strb	r2, [r3, #0]
    err = ERR_ARG;
 8005b8e:	2317      	movs	r3, #23
 8005b90:	18fb      	adds	r3, r7, r3
 8005b92:	22f0      	movs	r2, #240	; 0xf0
 8005b94:	701a      	strb	r2, [r3, #0]
  }
  httpc_close(req, result, 0, err);
 8005b96:	2317      	movs	r3, #23
 8005b98:	18fb      	adds	r3, r7, r3
 8005b9a:	2200      	movs	r2, #0
 8005b9c:	569a      	ldrsb	r2, [r3, r2]
 8005b9e:	2316      	movs	r3, #22
 8005ba0:	18fb      	adds	r3, r7, r3
 8005ba2:	7819      	ldrb	r1, [r3, #0]
 8005ba4:	6938      	ldr	r0, [r7, #16]
 8005ba6:	0013      	movs	r3, r2
 8005ba8:	2200      	movs	r2, #0
 8005baa:	f7ff fc96 	bl	80054da <httpc_close>
 8005bae:	e000      	b.n	8005bb2 <httpc_dns_found+0x6a>
      return;
 8005bb0:	46c0      	nop			; (mov r8, r8)
}
 8005bb2:	46bd      	mov	sp, r7
 8005bb4:	b006      	add	sp, #24
 8005bb6:	bdb0      	pop	{r4, r5, r7, pc}

08005bb8 <httpc_get_internal_dns>:
#endif /* LWIP_DNS */

/** Start the http request after converting 'server_name' to ip address (DNS or address string) */
static err_t
httpc_get_internal_dns(httpc_state_t* req, const char* server_name)
{
 8005bb8:	b5b0      	push	{r4, r5, r7, lr}
 8005bba:	b084      	sub	sp, #16
 8005bbc:	af00      	add	r7, sp, #0
 8005bbe:	6078      	str	r0, [r7, #4]
 8005bc0:	6039      	str	r1, [r7, #0]
  err_t err;
  LWIP_ASSERT("req != NULL", req != NULL);
 8005bc2:	687b      	ldr	r3, [r7, #4]
 8005bc4:	2b00      	cmp	r3, #0
 8005bc6:	d106      	bne.n	8005bd6 <httpc_get_internal_dns+0x1e>
 8005bc8:	4b19      	ldr	r3, [pc, #100]	; (8005c30 <httpc_get_internal_dns+0x78>)
 8005bca:	22d6      	movs	r2, #214	; 0xd6
 8005bcc:	32ff      	adds	r2, #255	; 0xff
 8005bce:	4919      	ldr	r1, [pc, #100]	; (8005c34 <httpc_get_internal_dns+0x7c>)
 8005bd0:	4819      	ldr	r0, [pc, #100]	; (8005c38 <httpc_get_internal_dns+0x80>)
 8005bd2:	f7fc fafb 	bl	80021cc <app_debug_rtt_raw>

#if LWIP_DNS
  err = dns_gethostbyname(server_name, &req->remote_addr, httpc_dns_found, req);
 8005bd6:	687b      	ldr	r3, [r7, #4]
 8005bd8:	1d19      	adds	r1, r3, #4
 8005bda:	250f      	movs	r5, #15
 8005bdc:	197c      	adds	r4, r7, r5
 8005bde:	687b      	ldr	r3, [r7, #4]
 8005be0:	4a16      	ldr	r2, [pc, #88]	; (8005c3c <httpc_get_internal_dns+0x84>)
 8005be2:	6838      	ldr	r0, [r7, #0]
 8005be4:	f001 fdce 	bl	8007784 <dns_gethostbyname>
 8005be8:	0003      	movs	r3, r0
 8005bea:	7023      	strb	r3, [r4, #0]
#else
  err = ipaddr_aton(server_name, &req->remote_addr) ? ERR_OK : ERR_ARG;
#endif

  if (err == ERR_OK) {
 8005bec:	0029      	movs	r1, r5
 8005bee:	187b      	adds	r3, r7, r1
 8005bf0:	781b      	ldrb	r3, [r3, #0]
 8005bf2:	b25b      	sxtb	r3, r3
 8005bf4:	2b00      	cmp	r3, #0
 8005bf6:	d10a      	bne.n	8005c0e <httpc_get_internal_dns+0x56>
    /* cached or IP-string */
    err = httpc_get_internal_addr(req, &req->remote_addr);
 8005bf8:	687b      	ldr	r3, [r7, #4]
 8005bfa:	1d1a      	adds	r2, r3, #4
 8005bfc:	187c      	adds	r4, r7, r1
 8005bfe:	687b      	ldr	r3, [r7, #4]
 8005c00:	0011      	movs	r1, r2
 8005c02:	0018      	movs	r0, r3
 8005c04:	f7ff ff64 	bl	8005ad0 <httpc_get_internal_addr>
 8005c08:	0003      	movs	r3, r0
 8005c0a:	7023      	strb	r3, [r4, #0]
 8005c0c:	e007      	b.n	8005c1e <httpc_get_internal_dns+0x66>
  } else if (err == ERR_INPROGRESS) {
 8005c0e:	230f      	movs	r3, #15
 8005c10:	18fb      	adds	r3, r7, r3
 8005c12:	781b      	ldrb	r3, [r3, #0]
 8005c14:	b25b      	sxtb	r3, r3
 8005c16:	3305      	adds	r3, #5
 8005c18:	d101      	bne.n	8005c1e <httpc_get_internal_dns+0x66>
    return ERR_OK;
 8005c1a:	2300      	movs	r3, #0
 8005c1c:	e003      	b.n	8005c26 <httpc_get_internal_dns+0x6e>
  }
  return err;
 8005c1e:	230f      	movs	r3, #15
 8005c20:	18fb      	adds	r3, r7, r3
 8005c22:	781b      	ldrb	r3, [r3, #0]
 8005c24:	b25b      	sxtb	r3, r3
}
 8005c26:	0018      	movs	r0, r3
 8005c28:	46bd      	mov	sp, r7
 8005c2a:	b004      	add	sp, #16
 8005c2c:	bdb0      	pop	{r4, r5, r7, pc}
 8005c2e:	46c0      	nop			; (mov r8, r8)
 8005c30:	0801e2d0 	.word	0x0801e2d0
 8005c34:	0801e304 	.word	0x0801e304
 8005c38:	0801e310 	.word	0x0801e310
 8005c3c:	08005b49 	.word	0x08005b49

08005c40 <httpc_create_request_string>:

static int
httpc_create_request_string(const httpc_connection_t *settings, const char* server_name, int server_port, const char* uri,
                            int use_host, char *buffer, size_t buffer_size)
{
 8005c40:	b590      	push	{r4, r7, lr}
 8005c42:	b089      	sub	sp, #36	; 0x24
 8005c44:	af04      	add	r7, sp, #16
 8005c46:	60f8      	str	r0, [r7, #12]
 8005c48:	60b9      	str	r1, [r7, #8]
 8005c4a:	607a      	str	r2, [r7, #4]
 8005c4c:	603b      	str	r3, [r7, #0]
  if (settings->use_proxy) {
 8005c4e:	68fb      	ldr	r3, [r7, #12]
 8005c50:	799b      	ldrb	r3, [r3, #6]
 8005c52:	2b00      	cmp	r3, #0
 8005c54:	d02c      	beq.n	8005cb0 <httpc_create_request_string+0x70>
    LWIP_ASSERT("server_name != NULL", server_name != NULL);
 8005c56:	68bb      	ldr	r3, [r7, #8]
 8005c58:	2b00      	cmp	r3, #0
 8005c5a:	d106      	bne.n	8005c6a <httpc_create_request_string+0x2a>
 8005c5c:	4b28      	ldr	r3, [pc, #160]	; (8005d00 <httpc_create_request_string+0xc0>)
 8005c5e:	22ec      	movs	r2, #236	; 0xec
 8005c60:	32ff      	adds	r2, #255	; 0xff
 8005c62:	4928      	ldr	r1, [pc, #160]	; (8005d04 <httpc_create_request_string+0xc4>)
 8005c64:	4828      	ldr	r0, [pc, #160]	; (8005d08 <httpc_create_request_string+0xc8>)
 8005c66:	f7fc fab1 	bl	80021cc <app_debug_rtt_raw>
    if (server_port != HTTP_DEFAULT_PORT) {
 8005c6a:	687b      	ldr	r3, [r7, #4]
 8005c6c:	2b50      	cmp	r3, #80	; 0x50
 8005c6e:	d010      	beq.n	8005c92 <httpc_create_request_string+0x52>
      return snprintf(buffer, buffer_size, HTTPC_REQ_11_PROXY_PORT_FORMAT(server_name, server_port, uri, server_name));
 8005c70:	68bc      	ldr	r4, [r7, #8]
 8005c72:	4a26      	ldr	r2, [pc, #152]	; (8005d0c <httpc_create_request_string+0xcc>)
 8005c74:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8005c76:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8005c78:	68bb      	ldr	r3, [r7, #8]
 8005c7a:	9303      	str	r3, [sp, #12]
 8005c7c:	4b24      	ldr	r3, [pc, #144]	; (8005d10 <httpc_create_request_string+0xd0>)
 8005c7e:	9302      	str	r3, [sp, #8]
 8005c80:	683b      	ldr	r3, [r7, #0]
 8005c82:	9301      	str	r3, [sp, #4]
 8005c84:	687b      	ldr	r3, [r7, #4]
 8005c86:	9300      	str	r3, [sp, #0]
 8005c88:	0023      	movs	r3, r4
 8005c8a:	f016 fe91 	bl	801c9b0 <sniprintf>
 8005c8e:	0003      	movs	r3, r0
 8005c90:	e032      	b.n	8005cf8 <httpc_create_request_string+0xb8>
    } else {
      return snprintf(buffer, buffer_size, HTTPC_REQ_11_PROXY_FORMAT(server_name, uri, server_name));
 8005c92:	68bc      	ldr	r4, [r7, #8]
 8005c94:	4a1f      	ldr	r2, [pc, #124]	; (8005d14 <httpc_create_request_string+0xd4>)
 8005c96:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8005c98:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8005c9a:	68bb      	ldr	r3, [r7, #8]
 8005c9c:	9302      	str	r3, [sp, #8]
 8005c9e:	4b1c      	ldr	r3, [pc, #112]	; (8005d10 <httpc_create_request_string+0xd0>)
 8005ca0:	9301      	str	r3, [sp, #4]
 8005ca2:	683b      	ldr	r3, [r7, #0]
 8005ca4:	9300      	str	r3, [sp, #0]
 8005ca6:	0023      	movs	r3, r4
 8005ca8:	f016 fe82 	bl	801c9b0 <sniprintf>
 8005cac:	0003      	movs	r3, r0
 8005cae:	e023      	b.n	8005cf8 <httpc_create_request_string+0xb8>
    }
  } else if (use_host) {
 8005cb0:	6a3b      	ldr	r3, [r7, #32]
 8005cb2:	2b00      	cmp	r3, #0
 8005cb4:	d016      	beq.n	8005ce4 <httpc_create_request_string+0xa4>
    LWIP_ASSERT("server_name != NULL", server_name != NULL);
 8005cb6:	68bb      	ldr	r3, [r7, #8]
 8005cb8:	2b00      	cmp	r3, #0
 8005cba:	d106      	bne.n	8005cca <httpc_create_request_string+0x8a>
 8005cbc:	4b10      	ldr	r3, [pc, #64]	; (8005d00 <httpc_create_request_string+0xc0>)
 8005cbe:	22f9      	movs	r2, #249	; 0xf9
 8005cc0:	0052      	lsls	r2, r2, #1
 8005cc2:	4910      	ldr	r1, [pc, #64]	; (8005d04 <httpc_create_request_string+0xc4>)
 8005cc4:	4810      	ldr	r0, [pc, #64]	; (8005d08 <httpc_create_request_string+0xc8>)
 8005cc6:	f7fc fa81 	bl	80021cc <app_debug_rtt_raw>
    return snprintf(buffer, buffer_size, HTTPC_REQ_11_HOST_FORMAT(uri, server_name));
 8005cca:	683c      	ldr	r4, [r7, #0]
 8005ccc:	4a12      	ldr	r2, [pc, #72]	; (8005d18 <httpc_create_request_string+0xd8>)
 8005cce:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8005cd0:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8005cd2:	68bb      	ldr	r3, [r7, #8]
 8005cd4:	9301      	str	r3, [sp, #4]
 8005cd6:	4b0e      	ldr	r3, [pc, #56]	; (8005d10 <httpc_create_request_string+0xd0>)
 8005cd8:	9300      	str	r3, [sp, #0]
 8005cda:	0023      	movs	r3, r4
 8005cdc:	f016 fe68 	bl	801c9b0 <sniprintf>
 8005ce0:	0003      	movs	r3, r0
 8005ce2:	e009      	b.n	8005cf8 <httpc_create_request_string+0xb8>
  } else {
    return snprintf(buffer, buffer_size, HTTPC_REQ_11_FORMAT(uri));
 8005ce4:	683c      	ldr	r4, [r7, #0]
 8005ce6:	4a0d      	ldr	r2, [pc, #52]	; (8005d1c <httpc_create_request_string+0xdc>)
 8005ce8:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8005cea:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8005cec:	4b08      	ldr	r3, [pc, #32]	; (8005d10 <httpc_create_request_string+0xd0>)
 8005cee:	9300      	str	r3, [sp, #0]
 8005cf0:	0023      	movs	r3, r4
 8005cf2:	f016 fe5d 	bl	801c9b0 <sniprintf>
 8005cf6:	0003      	movs	r3, r0
  }
}
 8005cf8:	0018      	movs	r0, r3
 8005cfa:	46bd      	mov	sp, r7
 8005cfc:	b005      	add	sp, #20
 8005cfe:	bd90      	pop	{r4, r7, pc}
 8005d00:	0801e2d0 	.word	0x0801e2d0
 8005d04:	0801e33c 	.word	0x0801e33c
 8005d08:	0801e310 	.word	0x0801e310
 8005d0c:	0801e350 	.word	0x0801e350
 8005d10:	0801e3ac 	.word	0x0801e3ac
 8005d14:	0801e3e4 	.word	0x0801e3e4
 8005d18:	0801e43c 	.word	0x0801e43c
 8005d1c:	0801e48c 	.word	0x0801e48c

08005d20 <httpc_init_connection_common>:

/** Initialize the connection struct */
static err_t
httpc_init_connection_common(httpc_state_t **connection, const httpc_connection_t *settings, const char* server_name,
                      u16_t server_port, const char* uri, altcp_recv_fn recv_fn, void* callback_arg, int use_host)
{
 8005d20:	b5b0      	push	{r4, r5, r7, lr}
 8005d22:	b08e      	sub	sp, #56	; 0x38
 8005d24:	af04      	add	r7, sp, #16
 8005d26:	60f8      	str	r0, [r7, #12]
 8005d28:	60b9      	str	r1, [r7, #8]
 8005d2a:	607a      	str	r2, [r7, #4]
 8005d2c:	001a      	movs	r2, r3
 8005d2e:	1cbb      	adds	r3, r7, #2
 8005d30:	801a      	strh	r2, [r3, #0]
  httpc_state_t *req;
#if HTTPC_DEBUG_REQUEST
  size_t server_name_len, uri_len;
#endif

  LWIP_ASSERT("uri != NULL", uri != NULL);
 8005d32:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8005d34:	2b00      	cmp	r3, #0
 8005d36:	d105      	bne.n	8005d44 <httpc_init_connection_common+0x24>
 8005d38:	4b6f      	ldr	r3, [pc, #444]	; (8005ef8 <httpc_init_connection_common+0x1d8>)
 8005d3a:	4a70      	ldr	r2, [pc, #448]	; (8005efc <httpc_init_connection_common+0x1dc>)
 8005d3c:	4970      	ldr	r1, [pc, #448]	; (8005f00 <httpc_init_connection_common+0x1e0>)
 8005d3e:	4871      	ldr	r0, [pc, #452]	; (8005f04 <httpc_init_connection_common+0x1e4>)
 8005d40:	f7fc fa44 	bl	80021cc <app_debug_rtt_raw>

  /* get request len */
  req_len = httpc_create_request_string(settings, server_name, server_port, uri, use_host, NULL, 0);
 8005d44:	1cbb      	adds	r3, r7, #2
 8005d46:	881a      	ldrh	r2, [r3, #0]
 8005d48:	6bbc      	ldr	r4, [r7, #56]	; 0x38
 8005d4a:	6879      	ldr	r1, [r7, #4]
 8005d4c:	68b8      	ldr	r0, [r7, #8]
 8005d4e:	2300      	movs	r3, #0
 8005d50:	9302      	str	r3, [sp, #8]
 8005d52:	2300      	movs	r3, #0
 8005d54:	9301      	str	r3, [sp, #4]
 8005d56:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8005d58:	9300      	str	r3, [sp, #0]
 8005d5a:	0023      	movs	r3, r4
 8005d5c:	f7ff ff70 	bl	8005c40 <httpc_create_request_string>
 8005d60:	0003      	movs	r3, r0
 8005d62:	627b      	str	r3, [r7, #36]	; 0x24
  if ((req_len < 0) || (req_len > 0xFFFF)) {
 8005d64:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005d66:	2b00      	cmp	r3, #0
 8005d68:	db04      	blt.n	8005d74 <httpc_init_connection_common+0x54>
 8005d6a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005d6c:	2380      	movs	r3, #128	; 0x80
 8005d6e:	025b      	lsls	r3, r3, #9
 8005d70:	429a      	cmp	r2, r3
 8005d72:	db02      	blt.n	8005d7a <httpc_init_connection_common+0x5a>
    return ERR_VAL;
 8005d74:	2306      	movs	r3, #6
 8005d76:	425b      	negs	r3, r3
 8005d78:	e0ba      	b.n	8005ef0 <httpc_init_connection_common+0x1d0>
  }
  /* alloc state and request in one block */
  alloc_len = sizeof(httpc_state_t);
 8005d7a:	2334      	movs	r3, #52	; 0x34
 8005d7c:	623b      	str	r3, [r7, #32]
#if HTTPC_DEBUG_REQUEST
  server_name_len = server_name ? strlen(server_name) : 0;
  uri_len = strlen(uri);
  alloc_len += server_name_len + 1 + uri_len + 1;
#endif
  mem_alloc_len = (mem_size_t)alloc_len;
 8005d7e:	211e      	movs	r1, #30
 8005d80:	187b      	adds	r3, r7, r1
 8005d82:	6a3a      	ldr	r2, [r7, #32]
 8005d84:	801a      	strh	r2, [r3, #0]
  if ((mem_alloc_len < alloc_len) || (req_len + 1 > 0xFFFF)) {
 8005d86:	187b      	adds	r3, r7, r1
 8005d88:	881b      	ldrh	r3, [r3, #0]
 8005d8a:	6a3a      	ldr	r2, [r7, #32]
 8005d8c:	429a      	cmp	r2, r3
 8005d8e:	d803      	bhi.n	8005d98 <httpc_init_connection_common+0x78>
 8005d90:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005d92:	4a5d      	ldr	r2, [pc, #372]	; (8005f08 <httpc_init_connection_common+0x1e8>)
 8005d94:	4293      	cmp	r3, r2
 8005d96:	dd02      	ble.n	8005d9e <httpc_init_connection_common+0x7e>
    return ERR_VAL;
 8005d98:	2306      	movs	r3, #6
 8005d9a:	425b      	negs	r3, r3
 8005d9c:	e0a8      	b.n	8005ef0 <httpc_init_connection_common+0x1d0>
  }

  req = (httpc_state_t*)mem_malloc((mem_size_t)alloc_len);
 8005d9e:	6a3b      	ldr	r3, [r7, #32]
 8005da0:	b29b      	uxth	r3, r3
 8005da2:	0018      	movs	r0, r3
 8005da4:	f002 fb4a 	bl	800843c <mem_malloc>
 8005da8:	0003      	movs	r3, r0
 8005daa:	61bb      	str	r3, [r7, #24]
  if(req == NULL) {
 8005dac:	69bb      	ldr	r3, [r7, #24]
 8005dae:	2b00      	cmp	r3, #0
 8005db0:	d102      	bne.n	8005db8 <httpc_init_connection_common+0x98>
    return ERR_MEM;
 8005db2:	2301      	movs	r3, #1
 8005db4:	425b      	negs	r3, r3
 8005db6:	e09b      	b.n	8005ef0 <httpc_init_connection_common+0x1d0>
  }
  memset(req, 0, sizeof(httpc_state_t));
 8005db8:	69bb      	ldr	r3, [r7, #24]
 8005dba:	2234      	movs	r2, #52	; 0x34
 8005dbc:	2100      	movs	r1, #0
 8005dbe:	0018      	movs	r0, r3
 8005dc0:	f016 fd34 	bl	801c82c <memset>
  req->timeout_ticks = HTTPC_POLL_TIMEOUT;
 8005dc4:	69bb      	ldr	r3, [r7, #24]
 8005dc6:	221e      	movs	r2, #30
 8005dc8:	60da      	str	r2, [r3, #12]
  req->request = pbuf_alloc(PBUF_RAW, (u16_t)(req_len + 1), PBUF_RAM);
 8005dca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005dcc:	b29b      	uxth	r3, r3
 8005dce:	3301      	adds	r3, #1
 8005dd0:	b29b      	uxth	r3, r3
 8005dd2:	22a0      	movs	r2, #160	; 0xa0
 8005dd4:	0092      	lsls	r2, r2, #2
 8005dd6:	0019      	movs	r1, r3
 8005dd8:	2000      	movs	r0, #0
 8005dda:	f003 f8e3 	bl	8008fa4 <pbuf_alloc>
 8005dde:	0002      	movs	r2, r0
 8005de0:	69bb      	ldr	r3, [r7, #24]
 8005de2:	611a      	str	r2, [r3, #16]
  if (req->request == NULL) {
 8005de4:	69bb      	ldr	r3, [r7, #24]
 8005de6:	691b      	ldr	r3, [r3, #16]
 8005de8:	2b00      	cmp	r3, #0
 8005dea:	d106      	bne.n	8005dfa <httpc_init_connection_common+0xda>
    httpc_free_state(req);
 8005dec:	69bb      	ldr	r3, [r7, #24]
 8005dee:	0018      	movs	r0, r3
 8005df0:	f7ff fb18 	bl	8005424 <httpc_free_state>
    return ERR_MEM;
 8005df4:	2301      	movs	r3, #1
 8005df6:	425b      	negs	r3, r3
 8005df8:	e07a      	b.n	8005ef0 <httpc_init_connection_common+0x1d0>
  }
  if (req->request->next != NULL) {
 8005dfa:	69bb      	ldr	r3, [r7, #24]
 8005dfc:	691b      	ldr	r3, [r3, #16]
 8005dfe:	681b      	ldr	r3, [r3, #0]
 8005e00:	2b00      	cmp	r3, #0
 8005e02:	d006      	beq.n	8005e12 <httpc_init_connection_common+0xf2>
    /* need a pbuf in one piece */
    httpc_free_state(req);
 8005e04:	69bb      	ldr	r3, [r7, #24]
 8005e06:	0018      	movs	r0, r3
 8005e08:	f7ff fb0c 	bl	8005424 <httpc_free_state>
    return ERR_MEM;
 8005e0c:	2301      	movs	r3, #1
 8005e0e:	425b      	negs	r3, r3
 8005e10:	e06e      	b.n	8005ef0 <httpc_init_connection_common+0x1d0>
  }
  req->hdr_content_len = HTTPC_CONTENT_LEN_INVALID;
 8005e12:	69bb      	ldr	r3, [r7, #24]
 8005e14:	2201      	movs	r2, #1
 8005e16:	4252      	negs	r2, r2
 8005e18:	62da      	str	r2, [r3, #44]	; 0x2c
    memcpy(req->server_name, server_name, server_name_len + 1);
  }
  req->uri = req->server_name + server_name_len + 1;
  memcpy(req->uri, uri, uri_len + 1);
#endif
  req->pcb = altcp_new(settings->altcp_allocator);
 8005e1a:	f005 fed7 	bl	800bbcc <tcp_new>
 8005e1e:	0002      	movs	r2, r0
 8005e20:	69bb      	ldr	r3, [r7, #24]
 8005e22:	601a      	str	r2, [r3, #0]
  if(req->pcb == NULL) {
 8005e24:	69bb      	ldr	r3, [r7, #24]
 8005e26:	681b      	ldr	r3, [r3, #0]
 8005e28:	2b00      	cmp	r3, #0
 8005e2a:	d106      	bne.n	8005e3a <httpc_init_connection_common+0x11a>
    httpc_free_state(req);
 8005e2c:	69bb      	ldr	r3, [r7, #24]
 8005e2e:	0018      	movs	r0, r3
 8005e30:	f7ff faf8 	bl	8005424 <httpc_free_state>
    return ERR_MEM;
 8005e34:	2301      	movs	r3, #1
 8005e36:	425b      	negs	r3, r3
 8005e38:	e05a      	b.n	8005ef0 <httpc_init_connection_common+0x1d0>
  }
  req->remote_port = settings->use_proxy ? settings->proxy_port : server_port;
 8005e3a:	68bb      	ldr	r3, [r7, #8]
 8005e3c:	799b      	ldrb	r3, [r3, #6]
 8005e3e:	2b00      	cmp	r3, #0
 8005e40:	d002      	beq.n	8005e48 <httpc_init_connection_common+0x128>
 8005e42:	68bb      	ldr	r3, [r7, #8]
 8005e44:	889b      	ldrh	r3, [r3, #4]
 8005e46:	e001      	b.n	8005e4c <httpc_init_connection_common+0x12c>
 8005e48:	1cbb      	adds	r3, r7, #2
 8005e4a:	881b      	ldrh	r3, [r3, #0]
 8005e4c:	69ba      	ldr	r2, [r7, #24]
 8005e4e:	8113      	strh	r3, [r2, #8]
  altcp_arg(req->pcb, req);
 8005e50:	69bb      	ldr	r3, [r7, #24]
 8005e52:	681b      	ldr	r3, [r3, #0]
 8005e54:	69ba      	ldr	r2, [r7, #24]
 8005e56:	0011      	movs	r1, r2
 8005e58:	0018      	movs	r0, r3
 8005e5a:	f005 fec0 	bl	800bbde <tcp_arg>
  altcp_recv(req->pcb, httpc_tcp_recv);
 8005e5e:	69bb      	ldr	r3, [r7, #24]
 8005e60:	681b      	ldr	r3, [r3, #0]
 8005e62:	4a2a      	ldr	r2, [pc, #168]	; (8005f0c <httpc_init_connection_common+0x1ec>)
 8005e64:	0011      	movs	r1, r2
 8005e66:	0018      	movs	r0, r3
 8005e68:	f005 fec8 	bl	800bbfc <tcp_recv>
  altcp_err(req->pcb, httpc_tcp_err);
 8005e6c:	69bb      	ldr	r3, [r7, #24]
 8005e6e:	681b      	ldr	r3, [r3, #0]
 8005e70:	4a27      	ldr	r2, [pc, #156]	; (8005f10 <httpc_init_connection_common+0x1f0>)
 8005e72:	0011      	movs	r1, r2
 8005e74:	0018      	movs	r0, r3
 8005e76:	f005 ff05 	bl	800bc84 <tcp_err>
  altcp_poll(req->pcb, httpc_tcp_poll, HTTPC_POLL_INTERVAL);
 8005e7a:	69bb      	ldr	r3, [r7, #24]
 8005e7c:	681b      	ldr	r3, [r3, #0]
 8005e7e:	4925      	ldr	r1, [pc, #148]	; (8005f14 <httpc_init_connection_common+0x1f4>)
 8005e80:	2201      	movs	r2, #1
 8005e82:	0018      	movs	r0, r3
 8005e84:	f005 ff20 	bl	800bcc8 <tcp_poll>
  altcp_sent(req->pcb, httpc_tcp_sent);
 8005e88:	69bb      	ldr	r3, [r7, #24]
 8005e8a:	681b      	ldr	r3, [r3, #0]
 8005e8c:	4a22      	ldr	r2, [pc, #136]	; (8005f18 <httpc_init_connection_common+0x1f8>)
 8005e8e:	0011      	movs	r1, r2
 8005e90:	0018      	movs	r0, r3
 8005e92:	f005 fed5 	bl	800bc40 <tcp_sent>

  /* set up request buffer */
  req_len2 = httpc_create_request_string(settings, server_name, server_port, uri, use_host,
 8005e96:	1cbb      	adds	r3, r7, #2
 8005e98:	881c      	ldrh	r4, [r3, #0]
    (char *)req->request->payload, req_len + 1);
 8005e9a:	69bb      	ldr	r3, [r7, #24]
 8005e9c:	691b      	ldr	r3, [r3, #16]
 8005e9e:	685b      	ldr	r3, [r3, #4]
 8005ea0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8005ea2:	3201      	adds	r2, #1
  req_len2 = httpc_create_request_string(settings, server_name, server_port, uri, use_host,
 8005ea4:	0015      	movs	r5, r2
 8005ea6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8005ea8:	6879      	ldr	r1, [r7, #4]
 8005eaa:	68b8      	ldr	r0, [r7, #8]
 8005eac:	9502      	str	r5, [sp, #8]
 8005eae:	9301      	str	r3, [sp, #4]
 8005eb0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8005eb2:	9300      	str	r3, [sp, #0]
 8005eb4:	0013      	movs	r3, r2
 8005eb6:	0022      	movs	r2, r4
 8005eb8:	f7ff fec2 	bl	8005c40 <httpc_create_request_string>
 8005ebc:	0003      	movs	r3, r0
 8005ebe:	617b      	str	r3, [r7, #20]
  if (req_len2 != req_len) {
 8005ec0:	697a      	ldr	r2, [r7, #20]
 8005ec2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005ec4:	429a      	cmp	r2, r3
 8005ec6:	d006      	beq.n	8005ed6 <httpc_init_connection_common+0x1b6>
    httpc_free_state(req);
 8005ec8:	69bb      	ldr	r3, [r7, #24]
 8005eca:	0018      	movs	r0, r3
 8005ecc:	f7ff faaa 	bl	8005424 <httpc_free_state>
    return ERR_VAL;
 8005ed0:	2306      	movs	r3, #6
 8005ed2:	425b      	negs	r3, r3
 8005ed4:	e00c      	b.n	8005ef0 <httpc_init_connection_common+0x1d0>
  }

  req->recv_fn = recv_fn;
 8005ed6:	69bb      	ldr	r3, [r7, #24]
 8005ed8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8005eda:	61da      	str	r2, [r3, #28]
  req->conn_settings = settings;
 8005edc:	69bb      	ldr	r3, [r7, #24]
 8005ede:	68ba      	ldr	r2, [r7, #8]
 8005ee0:	621a      	str	r2, [r3, #32]
  req->callback_arg = callback_arg;
 8005ee2:	69bb      	ldr	r3, [r7, #24]
 8005ee4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8005ee6:	625a      	str	r2, [r3, #36]	; 0x24

  *connection = req;
 8005ee8:	68fb      	ldr	r3, [r7, #12]
 8005eea:	69ba      	ldr	r2, [r7, #24]
 8005eec:	601a      	str	r2, [r3, #0]
  return ERR_OK;
 8005eee:	2300      	movs	r3, #0
}
 8005ef0:	0018      	movs	r0, r3
 8005ef2:	46bd      	mov	sp, r7
 8005ef4:	b00a      	add	sp, #40	; 0x28
 8005ef6:	bdb0      	pop	{r4, r5, r7, pc}
 8005ef8:	0801e2d0 	.word	0x0801e2d0
 8005efc:	00000206 	.word	0x00000206
 8005f00:	0801e4d0 	.word	0x0801e4d0
 8005f04:	0801e310 	.word	0x0801e310
 8005f08:	0000fffe 	.word	0x0000fffe
 8005f0c:	080057d1 	.word	0x080057d1
 8005f10:	080059c3 	.word	0x080059c3
 8005f14:	080059f9 	.word	0x080059f9
 8005f18:	08005a41 	.word	0x08005a41

08005f1c <httpc_init_connection>:
 * Initialize the connection struct
 */
static err_t
httpc_init_connection(httpc_state_t **connection, const httpc_connection_t *settings, const char* server_name,
                      u16_t server_port, const char* uri, altcp_recv_fn recv_fn, void* callback_arg)
{
 8005f1c:	b590      	push	{r4, r7, lr}
 8005f1e:	b089      	sub	sp, #36	; 0x24
 8005f20:	af04      	add	r7, sp, #16
 8005f22:	60f8      	str	r0, [r7, #12]
 8005f24:	60b9      	str	r1, [r7, #8]
 8005f26:	607a      	str	r2, [r7, #4]
 8005f28:	001a      	movs	r2, r3
 8005f2a:	1cbb      	adds	r3, r7, #2
 8005f2c:	801a      	strh	r2, [r3, #0]
  return httpc_init_connection_common(connection, settings, server_name, server_port, uri, recv_fn, callback_arg, 1);
 8005f2e:	1cbb      	adds	r3, r7, #2
 8005f30:	881c      	ldrh	r4, [r3, #0]
 8005f32:	687a      	ldr	r2, [r7, #4]
 8005f34:	68b9      	ldr	r1, [r7, #8]
 8005f36:	68f8      	ldr	r0, [r7, #12]
 8005f38:	2301      	movs	r3, #1
 8005f3a:	9303      	str	r3, [sp, #12]
 8005f3c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005f3e:	9302      	str	r3, [sp, #8]
 8005f40:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8005f42:	9301      	str	r3, [sp, #4]
 8005f44:	6a3b      	ldr	r3, [r7, #32]
 8005f46:	9300      	str	r3, [sp, #0]
 8005f48:	0023      	movs	r3, r4
 8005f4a:	f7ff fee9 	bl	8005d20 <httpc_init_connection_common>
 8005f4e:	0003      	movs	r3, r0
}
 8005f50:	0018      	movs	r0, r3
 8005f52:	46bd      	mov	sp, r7
 8005f54:	b005      	add	sp, #20
 8005f56:	bd90      	pop	{r4, r7, pc}

08005f58 <httpc_get_file_dns>:
 *         or an error code
 */
err_t
httpc_get_file_dns(const char* server_name, u16_t port, const char* uri, const httpc_connection_t *settings,
                   altcp_recv_fn recv_fn, void* callback_arg, httpc_state_t **connection)
{
 8005f58:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005f5a:	b08b      	sub	sp, #44	; 0x2c
 8005f5c:	af04      	add	r7, sp, #16
 8005f5e:	60f8      	str	r0, [r7, #12]
 8005f60:	607a      	str	r2, [r7, #4]
 8005f62:	603b      	str	r3, [r7, #0]
 8005f64:	230a      	movs	r3, #10
 8005f66:	18fb      	adds	r3, r7, r3
 8005f68:	1c0a      	adds	r2, r1, #0
 8005f6a:	801a      	strh	r2, [r3, #0]
  err_t err;
  httpc_state_t* req;

  LWIP_ERROR("invalid parameters", (server_name != NULL) && (uri != NULL) && (recv_fn != NULL), return ERR_ARG;);
 8005f6c:	68fb      	ldr	r3, [r7, #12]
 8005f6e:	2b00      	cmp	r3, #0
 8005f70:	d005      	beq.n	8005f7e <httpc_get_file_dns+0x26>
 8005f72:	687b      	ldr	r3, [r7, #4]
 8005f74:	2b00      	cmp	r3, #0
 8005f76:	d002      	beq.n	8005f7e <httpc_get_file_dns+0x26>
 8005f78:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005f7a:	2b00      	cmp	r3, #0
 8005f7c:	d106      	bne.n	8005f8c <httpc_get_file_dns+0x34>
 8005f7e:	4b2b      	ldr	r3, [pc, #172]	; (800602c <httpc_get_file_dns+0xd4>)
 8005f80:	0018      	movs	r0, r3
 8005f82:	f7fc f923 	bl	80021cc <app_debug_rtt_raw>
 8005f86:	2310      	movs	r3, #16
 8005f88:	425b      	negs	r3, r3
 8005f8a:	e04a      	b.n	8006022 <httpc_get_file_dns+0xca>

  err = httpc_init_connection(&req, settings, server_name, port, uri, recv_fn, callback_arg);
 8005f8c:	2617      	movs	r6, #23
 8005f8e:	19bc      	adds	r4, r7, r6
 8005f90:	230a      	movs	r3, #10
 8005f92:	18fb      	adds	r3, r7, r3
 8005f94:	881d      	ldrh	r5, [r3, #0]
 8005f96:	68fa      	ldr	r2, [r7, #12]
 8005f98:	6839      	ldr	r1, [r7, #0]
 8005f9a:	2310      	movs	r3, #16
 8005f9c:	18f8      	adds	r0, r7, r3
 8005f9e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8005fa0:	9302      	str	r3, [sp, #8]
 8005fa2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005fa4:	9301      	str	r3, [sp, #4]
 8005fa6:	687b      	ldr	r3, [r7, #4]
 8005fa8:	9300      	str	r3, [sp, #0]
 8005faa:	002b      	movs	r3, r5
 8005fac:	f7ff ffb6 	bl	8005f1c <httpc_init_connection>
 8005fb0:	0003      	movs	r3, r0
 8005fb2:	7023      	strb	r3, [r4, #0]
  if (err != ERR_OK) {
 8005fb4:	19bb      	adds	r3, r7, r6
 8005fb6:	781b      	ldrb	r3, [r3, #0]
 8005fb8:	b25b      	sxtb	r3, r3
 8005fba:	2b00      	cmp	r3, #0
 8005fbc:	d003      	beq.n	8005fc6 <httpc_get_file_dns+0x6e>
    return err;
 8005fbe:	19bb      	adds	r3, r7, r6
 8005fc0:	781b      	ldrb	r3, [r3, #0]
 8005fc2:	b25b      	sxtb	r3, r3
 8005fc4:	e02d      	b.n	8006022 <httpc_get_file_dns+0xca>
  }

  if (settings->use_proxy) {
 8005fc6:	683b      	ldr	r3, [r7, #0]
 8005fc8:	799b      	ldrb	r3, [r3, #6]
 8005fca:	2b00      	cmp	r3, #0
 8005fcc:	d00a      	beq.n	8005fe4 <httpc_get_file_dns+0x8c>
    err = httpc_get_internal_addr(req, &settings->proxy_addr);
 8005fce:	693b      	ldr	r3, [r7, #16]
 8005fd0:	683a      	ldr	r2, [r7, #0]
 8005fd2:	2117      	movs	r1, #23
 8005fd4:	187c      	adds	r4, r7, r1
 8005fd6:	0011      	movs	r1, r2
 8005fd8:	0018      	movs	r0, r3
 8005fda:	f7ff fd79 	bl	8005ad0 <httpc_get_internal_addr>
 8005fde:	0003      	movs	r3, r0
 8005fe0:	7023      	strb	r3, [r4, #0]
 8005fe2:	e009      	b.n	8005ff8 <httpc_get_file_dns+0xa0>
  } else {
    err = httpc_get_internal_dns(req, server_name);
 8005fe4:	693b      	ldr	r3, [r7, #16]
 8005fe6:	2217      	movs	r2, #23
 8005fe8:	18bc      	adds	r4, r7, r2
 8005fea:	68fa      	ldr	r2, [r7, #12]
 8005fec:	0011      	movs	r1, r2
 8005fee:	0018      	movs	r0, r3
 8005ff0:	f7ff fde2 	bl	8005bb8 <httpc_get_internal_dns>
 8005ff4:	0003      	movs	r3, r0
 8005ff6:	7023      	strb	r3, [r4, #0]
  }
  if(err != ERR_OK) {
 8005ff8:	2417      	movs	r4, #23
 8005ffa:	193b      	adds	r3, r7, r4
 8005ffc:	781b      	ldrb	r3, [r3, #0]
 8005ffe:	b25b      	sxtb	r3, r3
 8006000:	2b00      	cmp	r3, #0
 8006002:	d007      	beq.n	8006014 <httpc_get_file_dns+0xbc>
    httpc_free_state(req);
 8006004:	693b      	ldr	r3, [r7, #16]
 8006006:	0018      	movs	r0, r3
 8006008:	f7ff fa0c 	bl	8005424 <httpc_free_state>
    return err;
 800600c:	193b      	adds	r3, r7, r4
 800600e:	781b      	ldrb	r3, [r3, #0]
 8006010:	b25b      	sxtb	r3, r3
 8006012:	e006      	b.n	8006022 <httpc_get_file_dns+0xca>
  }

  if (connection != NULL) {
 8006014:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006016:	2b00      	cmp	r3, #0
 8006018:	d002      	beq.n	8006020 <httpc_get_file_dns+0xc8>
    *connection = req;
 800601a:	693a      	ldr	r2, [r7, #16]
 800601c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800601e:	601a      	str	r2, [r3, #0]
  }
  return ERR_OK;
 8006020:	2300      	movs	r3, #0
}
 8006022:	0018      	movs	r0, r3
 8006024:	46bd      	mov	sp, r7
 8006026:	b007      	add	sp, #28
 8006028:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800602a:	46c0      	nop			; (mov r8, r8)
 800602c:	0801e4dc 	.word	0x0801e4dc

08006030 <sntp_process>:
/**
 * SNTP processing of received timestamp
 */
static void
sntp_process(const struct sntp_timestamps *timestamps)
{
 8006030:	b580      	push	{r7, lr}
 8006032:	b084      	sub	sp, #16
 8006034:	af00      	add	r7, sp, #0
 8006036:	6078      	str	r0, [r7, #4]
  s32_t sec;
  u32_t frac;

  sec  = (s32_t)lwip_ntohl(timestamps->xmit.sec);
 8006038:	687b      	ldr	r3, [r7, #4]
 800603a:	681b      	ldr	r3, [r3, #0]
 800603c:	0018      	movs	r0, r3
 800603e:	f000 fa8f 	bl	8006560 <lwip_htonl>
 8006042:	0003      	movs	r3, r0
 8006044:	60fb      	str	r3, [r7, #12]
  frac = lwip_ntohl(timestamps->xmit.frac);
 8006046:	687b      	ldr	r3, [r7, #4]
 8006048:	685b      	ldr	r3, [r3, #4]
 800604a:	0018      	movs	r0, r3
 800604c:	f000 fa88 	bl	8006560 <lwip_htonl>
 8006050:	0003      	movs	r3, r0
 8006052:	60bb      	str	r3, [r7, #8]
      frac = (u32_t)((u64_t)t4);
    }
  }
#endif /* SNTP_COMP_ROUNDTRIP */

  SNTP_SET_SYSTEM_TIME_NTP(sec, frac);
 8006054:	68fb      	ldr	r3, [r7, #12]
 8006056:	4a05      	ldr	r2, [pc, #20]	; (800606c <sntp_process+0x3c>)
 8006058:	4694      	mov	ip, r2
 800605a:	4463      	add	r3, ip
 800605c:	0018      	movs	r0, r3
 800605e:	f7fa ff65 	bl	8000f2c <lwip_sntp_recv_callback>
  LWIP_UNUSED_ARG(frac); /* might be unused if only seconds are set */
  LWIP_DEBUGF(SNTP_DEBUG_TRACE, ("sntp_process: %s, %" U32_F " us\n",
                                 sntp_format_time(sec), SNTP_FRAC_TO_US(frac)));
}
 8006062:	46c0      	nop			; (mov r8, r8)
 8006064:	46bd      	mov	sp, r7
 8006066:	b004      	add	sp, #16
 8006068:	bd80      	pop	{r7, pc}
 800606a:	46c0      	nop			; (mov r8, r8)
 800606c:	7c558180 	.word	0x7c558180

08006070 <sntp_initialize_request>:
/**
 * Initialize request struct to be sent to server.
 */
static void
sntp_initialize_request(struct sntp_msg *req)
{
 8006070:	b580      	push	{r7, lr}
 8006072:	b082      	sub	sp, #8
 8006074:	af00      	add	r7, sp, #0
 8006076:	6078      	str	r0, [r7, #4]
  memset(req, 0, SNTP_MSG_LEN);
 8006078:	687b      	ldr	r3, [r7, #4]
 800607a:	2230      	movs	r2, #48	; 0x30
 800607c:	2100      	movs	r1, #0
 800607e:	0018      	movs	r0, r3
 8006080:	f016 fbd4 	bl	801c82c <memset>
  req->li_vn_mode = SNTP_LI_NO_WARNING | SNTP_VERSION | SNTP_MODE_CLIENT;
 8006084:	687b      	ldr	r3, [r7, #4]
 8006086:	2223      	movs	r2, #35	; 0x23
 8006088:	701a      	strb	r2, [r3, #0]
# endif
    req->transmit_timestamp[0] = sec;
    req->transmit_timestamp[1] = frac;
  }
#endif /* SNTP_CHECK_RESPONSE >= 2 || SNTP_COMP_ROUNDTRIP */
}
 800608a:	46c0      	nop			; (mov r8, r8)
 800608c:	46bd      	mov	sp, r7
 800608e:	b002      	add	sp, #8
 8006090:	bd80      	pop	{r7, pc}
	...

08006094 <sntp_retry>:
 *
 * @param arg is unused (only necessary to conform to sys_timeout)
 */
static void
sntp_retry(void *arg)
{
 8006094:	b580      	push	{r7, lr}
 8006096:	b084      	sub	sp, #16
 8006098:	af00      	add	r7, sp, #0
 800609a:	6078      	str	r0, [r7, #4]

  LWIP_DEBUGF(SNTP_DEBUG_STATE, ("sntp_retry: Next request will be sent in %"U32_F" ms\n",
                                 sntp_retry_timeout));

  /* set up a timer to send a retry and increase the retry delay */
  sys_untimeout(sntp_request, NULL);
 800609c:	4b12      	ldr	r3, [pc, #72]	; (80060e8 <sntp_retry+0x54>)
 800609e:	2100      	movs	r1, #0
 80060a0:	0018      	movs	r0, r3
 80060a2:	f00b fe01 	bl	8011ca8 <sys_untimeout>
  sys_timeout(sntp_retry_timeout, sntp_request, NULL);
 80060a6:	4b11      	ldr	r3, [pc, #68]	; (80060ec <sntp_retry+0x58>)
 80060a8:	681b      	ldr	r3, [r3, #0]
 80060aa:	490f      	ldr	r1, [pc, #60]	; (80060e8 <sntp_retry+0x54>)
 80060ac:	2200      	movs	r2, #0
 80060ae:	0018      	movs	r0, r3
 80060b0:	f00b fdd2 	bl	8011c58 <sys_timeout>

#if SNTP_RETRY_TIMEOUT_EXP
  {
    u32_t new_retry_timeout;
    /* increase the timeout for next retry */
    new_retry_timeout = sntp_retry_timeout << 1;
 80060b4:	4b0d      	ldr	r3, [pc, #52]	; (80060ec <sntp_retry+0x58>)
 80060b6:	681b      	ldr	r3, [r3, #0]
 80060b8:	005b      	lsls	r3, r3, #1
 80060ba:	60fb      	str	r3, [r7, #12]
    /* limit to maximum timeout and prevent overflow */
    if ((new_retry_timeout <= SNTP_RETRY_TIMEOUT_MAX) &&
 80060bc:	68fb      	ldr	r3, [r7, #12]
 80060be:	4a0c      	ldr	r2, [pc, #48]	; (80060f0 <sntp_retry+0x5c>)
 80060c0:	4293      	cmp	r3, r2
 80060c2:	d808      	bhi.n	80060d6 <sntp_retry+0x42>
        (new_retry_timeout > sntp_retry_timeout)) {
 80060c4:	4b09      	ldr	r3, [pc, #36]	; (80060ec <sntp_retry+0x58>)
 80060c6:	681b      	ldr	r3, [r3, #0]
    if ((new_retry_timeout <= SNTP_RETRY_TIMEOUT_MAX) &&
 80060c8:	68fa      	ldr	r2, [r7, #12]
 80060ca:	429a      	cmp	r2, r3
 80060cc:	d903      	bls.n	80060d6 <sntp_retry+0x42>
      sntp_retry_timeout = new_retry_timeout;
 80060ce:	4b07      	ldr	r3, [pc, #28]	; (80060ec <sntp_retry+0x58>)
 80060d0:	68fa      	ldr	r2, [r7, #12]
 80060d2:	601a      	str	r2, [r3, #0]
 80060d4:	e003      	b.n	80060de <sntp_retry+0x4a>
    } else {
      sntp_retry_timeout = SNTP_RETRY_TIMEOUT_MAX;
 80060d6:	4b05      	ldr	r3, [pc, #20]	; (80060ec <sntp_retry+0x58>)
 80060d8:	4a05      	ldr	r2, [pc, #20]	; (80060f0 <sntp_retry+0x5c>)
 80060da:	601a      	str	r2, [r3, #0]
    }
  }
#endif /* SNTP_RETRY_TIMEOUT_EXP */
}
 80060dc:	46c0      	nop			; (mov r8, r8)
 80060de:	46c0      	nop			; (mov r8, r8)
 80060e0:	46bd      	mov	sp, r7
 80060e2:	b004      	add	sp, #16
 80060e4:	bd80      	pop	{r7, pc}
 80060e6:	46c0      	nop			; (mov r8, r8)
 80060e8:	08006325 	.word	0x08006325
 80060ec:	20001140 	.word	0x20001140
 80060f0:	000249f0 	.word	0x000249f0

080060f4 <sntp_recv>:
#endif /* SNTP_SUPPORT_MULTIPLE_SERVERS */

/** UDP recv callback for the sntp pcb */
static void
sntp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
{
 80060f4:	b5b0      	push	{r4, r5, r7, lr}
 80060f6:	b088      	sub	sp, #32
 80060f8:	af00      	add	r7, sp, #0
 80060fa:	60f8      	str	r0, [r7, #12]
 80060fc:	60b9      	str	r1, [r7, #8]
 80060fe:	607a      	str	r2, [r7, #4]
 8006100:	603b      	str	r3, [r7, #0]
  err_t err;

  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);

  err = ERR_ARG;
 8006102:	231f      	movs	r3, #31
 8006104:	18fb      	adds	r3, r7, r3
 8006106:	22f0      	movs	r2, #240	; 0xf0
 8006108:	701a      	strb	r2, [r3, #0]
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
#endif /* SNTP_CHECK_RESPONSE >= 1 */
  {
    /* process the response */
    if (p->tot_len == SNTP_MSG_LEN) {
 800610a:	687b      	ldr	r3, [r7, #4]
 800610c:	891b      	ldrh	r3, [r3, #8]
 800610e:	2b30      	cmp	r3, #48	; 0x30
 8006110:	d13e      	bne.n	8006190 <sntp_recv+0x9c>
      mode = pbuf_get_at(p, SNTP_OFFSET_LI_VN_MODE) & SNTP_MODE_MASK;
 8006112:	687b      	ldr	r3, [r7, #4]
 8006114:	2100      	movs	r1, #0
 8006116:	0018      	movs	r0, r3
 8006118:	f003 ffd6 	bl	800a0c8 <pbuf_get_at>
 800611c:	0003      	movs	r3, r0
 800611e:	0019      	movs	r1, r3
 8006120:	201e      	movs	r0, #30
 8006122:	183b      	adds	r3, r7, r0
 8006124:	2207      	movs	r2, #7
 8006126:	400a      	ands	r2, r1
 8006128:	701a      	strb	r2, [r3, #0]
      /* if this is a SNTP response... */
      if (((sntp_opmode == SNTP_OPMODE_POLL)       && (mode == SNTP_MODE_SERVER)) ||
 800612a:	4b3a      	ldr	r3, [pc, #232]	; (8006214 <sntp_recv+0x120>)
 800612c:	781b      	ldrb	r3, [r3, #0]
 800612e:	2b00      	cmp	r3, #0
 8006130:	d103      	bne.n	800613a <sntp_recv+0x46>
 8006132:	183b      	adds	r3, r7, r0
 8006134:	781b      	ldrb	r3, [r3, #0]
 8006136:	2b04      	cmp	r3, #4
 8006138:	d008      	beq.n	800614c <sntp_recv+0x58>
          ((sntp_opmode == SNTP_OPMODE_LISTENONLY) && (mode == SNTP_MODE_BROADCAST))) {
 800613a:	4b36      	ldr	r3, [pc, #216]	; (8006214 <sntp_recv+0x120>)
 800613c:	781b      	ldrb	r3, [r3, #0]
      if (((sntp_opmode == SNTP_OPMODE_POLL)       && (mode == SNTP_MODE_SERVER)) ||
 800613e:	2b01      	cmp	r3, #1
 8006140:	d122      	bne.n	8006188 <sntp_recv+0x94>
          ((sntp_opmode == SNTP_OPMODE_LISTENONLY) && (mode == SNTP_MODE_BROADCAST))) {
 8006142:	231e      	movs	r3, #30
 8006144:	18fb      	adds	r3, r7, r3
 8006146:	781b      	ldrb	r3, [r3, #0]
 8006148:	2b05      	cmp	r3, #5
 800614a:	d11d      	bne.n	8006188 <sntp_recv+0x94>
        stratum = pbuf_get_at(p, SNTP_OFFSET_STRATUM);
 800614c:	251d      	movs	r5, #29
 800614e:	197c      	adds	r4, r7, r5
 8006150:	687b      	ldr	r3, [r7, #4]
 8006152:	2101      	movs	r1, #1
 8006154:	0018      	movs	r0, r3
 8006156:	f003 ffb7 	bl	800a0c8 <pbuf_get_at>
 800615a:	0003      	movs	r3, r0
 800615c:	7023      	strb	r3, [r4, #0]

        if (stratum == SNTP_STRATUM_KOD) {
 800615e:	197b      	adds	r3, r7, r5
 8006160:	781b      	ldrb	r3, [r3, #0]
 8006162:	2b00      	cmp	r3, #0
 8006164:	d104      	bne.n	8006170 <sntp_recv+0x7c>
          /* Kiss-of-death packet. Use another server or increase UPDATE_DELAY. */
          err = SNTP_ERR_KOD;
 8006166:	231f      	movs	r3, #31
 8006168:	18fb      	adds	r3, r7, r3
 800616a:	2201      	movs	r2, #1
 800616c:	701a      	strb	r2, [r3, #0]
        if (stratum == SNTP_STRATUM_KOD) {
 800616e:	e00f      	b.n	8006190 <sntp_recv+0x9c>
          LWIP_DEBUGF(SNTP_DEBUG_STATE, ("sntp_recv: Received Kiss-of-Death\n"));
        } else {
          pbuf_copy_partial(p, &timestamps, sizeof(timestamps), SNTP_OFFSET_TIMESTAMPS);
 8006170:	2310      	movs	r3, #16
 8006172:	18f9      	adds	r1, r7, r3
 8006174:	6878      	ldr	r0, [r7, #4]
 8006176:	2328      	movs	r3, #40	; 0x28
 8006178:	2208      	movs	r2, #8
 800617a:	f003 fd55 	bl	8009c28 <pbuf_copy_partial>
          } else
#endif /* SNTP_CHECK_RESPONSE >= 2 */
            /* @todo: add code for SNTP_CHECK_RESPONSE >= 3 and >= 4 here */
          {
            /* correct answer */
            err = ERR_OK;
 800617e:	231f      	movs	r3, #31
 8006180:	18fb      	adds	r3, r7, r3
 8006182:	2200      	movs	r2, #0
 8006184:	701a      	strb	r2, [r3, #0]
        if (stratum == SNTP_STRATUM_KOD) {
 8006186:	e003      	b.n	8006190 <sntp_recv+0x9c>
          }
        }
      } else {
        LWIP_DEBUGF(SNTP_DEBUG_WARN, ("sntp_recv: Invalid mode in response: %"U16_F"\n", (u16_t)mode));
        /* wait for correct response */
        err = ERR_TIMEOUT;
 8006188:	231f      	movs	r3, #31
 800618a:	18fb      	adds	r3, r7, r3
 800618c:	22fd      	movs	r2, #253	; 0xfd
 800618e:	701a      	strb	r2, [r3, #0]
    /* packet from wrong remote address or port, wait for correct response */
    err = ERR_TIMEOUT;
  }
#endif /* SNTP_CHECK_RESPONSE >= 1 */

  pbuf_free(p);
 8006190:	687b      	ldr	r3, [r7, #4]
 8006192:	0018      	movs	r0, r3
 8006194:	f003 fa7e 	bl	8009694 <pbuf_free>

  if (err == ERR_OK) {
 8006198:	231f      	movs	r3, #31
 800619a:	18fb      	adds	r3, r7, r3
 800619c:	781b      	ldrb	r3, [r3, #0]
 800619e:	b25b      	sxtb	r3, r3
 80061a0:	2b00      	cmp	r3, #0
 80061a2:	d125      	bne.n	80061f0 <sntp_recv+0xfc>
    /* correct packet received: process it it */
    sntp_process(&timestamps);
 80061a4:	2310      	movs	r3, #16
 80061a6:	18fb      	adds	r3, r7, r3
 80061a8:	0018      	movs	r0, r3
 80061aa:	f7ff ff41 	bl	8006030 <sntp_process>

#if SNTP_MONITOR_SERVER_REACHABILITY
    /* indicate that server responded */
    sntp_servers[sntp_current_server].reachability |= 1;
 80061ae:	4b1a      	ldr	r3, [pc, #104]	; (8006218 <sntp_recv+0x124>)
 80061b0:	7a1b      	ldrb	r3, [r3, #8]
 80061b2:	2201      	movs	r2, #1
 80061b4:	4313      	orrs	r3, r2
 80061b6:	b2da      	uxtb	r2, r3
 80061b8:	4b17      	ldr	r3, [pc, #92]	; (8006218 <sntp_recv+0x124>)
 80061ba:	721a      	strb	r2, [r3, #8]
#endif /* SNTP_MONITOR_SERVER_REACHABILITY */
    /* Set up timeout for next request (only if poll response was received)*/
    if (sntp_opmode == SNTP_OPMODE_POLL) {
 80061bc:	4b15      	ldr	r3, [pc, #84]	; (8006214 <sntp_recv+0x120>)
 80061be:	781b      	ldrb	r3, [r3, #0]
 80061c0:	2b00      	cmp	r3, #0
 80061c2:	d122      	bne.n	800620a <sntp_recv+0x116>
      u32_t sntp_update_delay;
      sys_untimeout(sntp_try_next_server, NULL);
 80061c4:	4b15      	ldr	r3, [pc, #84]	; (800621c <sntp_recv+0x128>)
 80061c6:	2100      	movs	r1, #0
 80061c8:	0018      	movs	r0, r3
 80061ca:	f00b fd6d 	bl	8011ca8 <sys_untimeout>
      sys_untimeout(sntp_request, NULL);
 80061ce:	4b14      	ldr	r3, [pc, #80]	; (8006220 <sntp_recv+0x12c>)
 80061d0:	2100      	movs	r1, #0
 80061d2:	0018      	movs	r0, r3
 80061d4:	f00b fd68 	bl	8011ca8 <sys_untimeout>

      /* Correct response, reset retry timeout */
      SNTP_RESET_RETRY_TIMEOUT();
 80061d8:	4b12      	ldr	r3, [pc, #72]	; (8006224 <sntp_recv+0x130>)
 80061da:	4a13      	ldr	r2, [pc, #76]	; (8006228 <sntp_recv+0x134>)
 80061dc:	601a      	str	r2, [r3, #0]

      sntp_update_delay = (u32_t)SNTP_UPDATE_DELAY;
 80061de:	4b13      	ldr	r3, [pc, #76]	; (800622c <sntp_recv+0x138>)
 80061e0:	61bb      	str	r3, [r7, #24]
      sys_timeout(sntp_update_delay, sntp_request, NULL);
 80061e2:	490f      	ldr	r1, [pc, #60]	; (8006220 <sntp_recv+0x12c>)
 80061e4:	69bb      	ldr	r3, [r7, #24]
 80061e6:	2200      	movs	r2, #0
 80061e8:	0018      	movs	r0, r3
 80061ea:	f00b fd35 	bl	8011c58 <sys_timeout>
      sntp_try_next_server(NULL);
    }
  } else {
    /* ignore any broken packet, poll mode: retry after timeout to avoid flooding */
  }
}
 80061ee:	e00c      	b.n	800620a <sntp_recv+0x116>
  } else if (err == SNTP_ERR_KOD) {
 80061f0:	231f      	movs	r3, #31
 80061f2:	18fb      	adds	r3, r7, r3
 80061f4:	781b      	ldrb	r3, [r3, #0]
 80061f6:	b25b      	sxtb	r3, r3
 80061f8:	2b01      	cmp	r3, #1
 80061fa:	d106      	bne.n	800620a <sntp_recv+0x116>
    if (sntp_opmode == SNTP_OPMODE_POLL) {
 80061fc:	4b05      	ldr	r3, [pc, #20]	; (8006214 <sntp_recv+0x120>)
 80061fe:	781b      	ldrb	r3, [r3, #0]
 8006200:	2b00      	cmp	r3, #0
 8006202:	d102      	bne.n	800620a <sntp_recv+0x116>
      sntp_try_next_server(NULL);
 8006204:	2000      	movs	r0, #0
 8006206:	f7ff ff45 	bl	8006094 <sntp_retry>
}
 800620a:	46c0      	nop			; (mov r8, r8)
 800620c:	46bd      	mov	sp, r7
 800620e:	b008      	add	sp, #32
 8006210:	bdb0      	pop	{r4, r5, r7, pc}
 8006212:	46c0      	nop			; (mov r8, r8)
 8006214:	2000112c 	.word	0x2000112c
 8006218:	20001134 	.word	0x20001134
 800621c:	08006095 	.word	0x08006095
 8006220:	08006325 	.word	0x08006325
 8006224:	20001140 	.word	0x20001140
 8006228:	00003a98 	.word	0x00003a98
 800622c:	0036ee80 	.word	0x0036ee80

08006230 <sntp_send_request>:
 *
 * @param server_addr resolved IP address of the SNTP server
 */
static void
sntp_send_request(const ip_addr_t *server_addr)
{
 8006230:	b580      	push	{r7, lr}
 8006232:	b084      	sub	sp, #16
 8006234:	af00      	add	r7, sp, #0
 8006236:	6078      	str	r0, [r7, #4]
  struct pbuf *p;

  LWIP_ASSERT("server_addr != NULL", server_addr != NULL);
 8006238:	687b      	ldr	r3, [r7, #4]
 800623a:	2b00      	cmp	r3, #0
 800623c:	d105      	bne.n	800624a <sntp_send_request+0x1a>
 800623e:	4b22      	ldr	r3, [pc, #136]	; (80062c8 <sntp_send_request+0x98>)
 8006240:	4a22      	ldr	r2, [pc, #136]	; (80062cc <sntp_send_request+0x9c>)
 8006242:	4923      	ldr	r1, [pc, #140]	; (80062d0 <sntp_send_request+0xa0>)
 8006244:	4823      	ldr	r0, [pc, #140]	; (80062d4 <sntp_send_request+0xa4>)
 8006246:	f7fb ffc1 	bl	80021cc <app_debug_rtt_raw>

  p = pbuf_alloc(PBUF_TRANSPORT, SNTP_MSG_LEN, PBUF_RAM);
 800624a:	23a0      	movs	r3, #160	; 0xa0
 800624c:	009b      	lsls	r3, r3, #2
 800624e:	001a      	movs	r2, r3
 8006250:	2130      	movs	r1, #48	; 0x30
 8006252:	2038      	movs	r0, #56	; 0x38
 8006254:	f002 fea6 	bl	8008fa4 <pbuf_alloc>
 8006258:	0003      	movs	r3, r0
 800625a:	60fb      	str	r3, [r7, #12]
  if (p != NULL) {
 800625c:	68fb      	ldr	r3, [r7, #12]
 800625e:	2b00      	cmp	r3, #0
 8006260:	d023      	beq.n	80062aa <sntp_send_request+0x7a>
    struct sntp_msg *sntpmsg = (struct sntp_msg *)p->payload;
 8006262:	68fb      	ldr	r3, [r7, #12]
 8006264:	685b      	ldr	r3, [r3, #4]
 8006266:	60bb      	str	r3, [r7, #8]
    LWIP_DEBUGF(SNTP_DEBUG_STATE, ("sntp_send_request: Sending request to server\n"));
    /* initialize request message */
    sntp_initialize_request(sntpmsg);
 8006268:	68bb      	ldr	r3, [r7, #8]
 800626a:	0018      	movs	r0, r3
 800626c:	f7ff ff00 	bl	8006070 <sntp_initialize_request>
    /* send request */
    udp_sendto(sntp_pcb, p, server_addr, SNTP_PORT);
 8006270:	4b19      	ldr	r3, [pc, #100]	; (80062d8 <sntp_send_request+0xa8>)
 8006272:	6818      	ldr	r0, [r3, #0]
 8006274:	687a      	ldr	r2, [r7, #4]
 8006276:	68f9      	ldr	r1, [r7, #12]
 8006278:	237b      	movs	r3, #123	; 0x7b
 800627a:	f00b ffad 	bl	80121d8 <udp_sendto>
    /* free the pbuf after sending it */
    pbuf_free(p);
 800627e:	68fb      	ldr	r3, [r7, #12]
 8006280:	0018      	movs	r0, r3
 8006282:	f003 fa07 	bl	8009694 <pbuf_free>
#if SNTP_MONITOR_SERVER_REACHABILITY
    /* indicate new packet has been sent */
    sntp_servers[sntp_current_server].reachability <<= 1;
 8006286:	4b15      	ldr	r3, [pc, #84]	; (80062dc <sntp_send_request+0xac>)
 8006288:	7a1b      	ldrb	r3, [r3, #8]
 800628a:	18db      	adds	r3, r3, r3
 800628c:	b2da      	uxtb	r2, r3
 800628e:	4b13      	ldr	r3, [pc, #76]	; (80062dc <sntp_send_request+0xac>)
 8006290:	721a      	strb	r2, [r3, #8]
#endif /* SNTP_MONITOR_SERVER_REACHABILITY */
    /* set up receive timeout: try next server or retry on timeout */
    sys_untimeout(sntp_try_next_server, NULL);
 8006292:	4b13      	ldr	r3, [pc, #76]	; (80062e0 <sntp_send_request+0xb0>)
 8006294:	2100      	movs	r1, #0
 8006296:	0018      	movs	r0, r3
 8006298:	f00b fd06 	bl	8011ca8 <sys_untimeout>
    sys_timeout((u32_t)SNTP_RECV_TIMEOUT, sntp_try_next_server, NULL);
 800629c:	4b10      	ldr	r3, [pc, #64]	; (80062e0 <sntp_send_request+0xb0>)
 800629e:	4811      	ldr	r0, [pc, #68]	; (80062e4 <sntp_send_request+0xb4>)
 80062a0:	2200      	movs	r2, #0
 80062a2:	0019      	movs	r1, r3
 80062a4:	f00b fcd8 	bl	8011c58 <sys_timeout>
                                     (u32_t)SNTP_RETRY_TIMEOUT));
    /* out of memory: set up a timer to send a retry */
    sys_untimeout(sntp_request, NULL);
    sys_timeout((u32_t)SNTP_RETRY_TIMEOUT, sntp_request, NULL);
  }
}
 80062a8:	e00a      	b.n	80062c0 <sntp_send_request+0x90>
    sys_untimeout(sntp_request, NULL);
 80062aa:	4b0f      	ldr	r3, [pc, #60]	; (80062e8 <sntp_send_request+0xb8>)
 80062ac:	2100      	movs	r1, #0
 80062ae:	0018      	movs	r0, r3
 80062b0:	f00b fcfa 	bl	8011ca8 <sys_untimeout>
    sys_timeout((u32_t)SNTP_RETRY_TIMEOUT, sntp_request, NULL);
 80062b4:	4b0c      	ldr	r3, [pc, #48]	; (80062e8 <sntp_send_request+0xb8>)
 80062b6:	480b      	ldr	r0, [pc, #44]	; (80062e4 <sntp_send_request+0xb4>)
 80062b8:	2200      	movs	r2, #0
 80062ba:	0019      	movs	r1, r3
 80062bc:	f00b fccc 	bl	8011c58 <sys_timeout>
}
 80062c0:	46c0      	nop			; (mov r8, r8)
 80062c2:	46bd      	mov	sp, r7
 80062c4:	b004      	add	sp, #16
 80062c6:	bd80      	pop	{r7, pc}
 80062c8:	0801e4f0 	.word	0x0801e4f0
 80062cc:	00000223 	.word	0x00000223
 80062d0:	0801e51c 	.word	0x0801e51c
 80062d4:	0801e530 	.word	0x0801e530
 80062d8:	20001130 	.word	0x20001130
 80062dc:	20001134 	.word	0x20001134
 80062e0:	08006095 	.word	0x08006095
 80062e4:	00003a98 	.word	0x00003a98
 80062e8:	08006325 	.word	0x08006325

080062ec <sntp_dns_found>:
/**
 * DNS found callback when using DNS names as server address.
 */
static void
sntp_dns_found(const char *hostname, const ip_addr_t *ipaddr, void *arg)
{
 80062ec:	b580      	push	{r7, lr}
 80062ee:	b084      	sub	sp, #16
 80062f0:	af00      	add	r7, sp, #0
 80062f2:	60f8      	str	r0, [r7, #12]
 80062f4:	60b9      	str	r1, [r7, #8]
 80062f6:	607a      	str	r2, [r7, #4]
  LWIP_UNUSED_ARG(hostname);
  LWIP_UNUSED_ARG(arg);

  if (ipaddr != NULL) {
 80062f8:	68bb      	ldr	r3, [r7, #8]
 80062fa:	2b00      	cmp	r3, #0
 80062fc:	d008      	beq.n	8006310 <sntp_dns_found+0x24>
    /* Address resolved, send request */
    LWIP_DEBUGF(SNTP_DEBUG_STATE, ("sntp_dns_found: Server address resolved, sending request\n"));
    sntp_servers[sntp_current_server].addr = *ipaddr;
 80062fe:	4b08      	ldr	r3, [pc, #32]	; (8006320 <sntp_dns_found+0x34>)
 8006300:	68ba      	ldr	r2, [r7, #8]
 8006302:	6812      	ldr	r2, [r2, #0]
 8006304:	605a      	str	r2, [r3, #4]
    sntp_send_request(ipaddr);
 8006306:	68bb      	ldr	r3, [r7, #8]
 8006308:	0018      	movs	r0, r3
 800630a:	f7ff ff91 	bl	8006230 <sntp_send_request>
  } else {
    /* DNS resolving failed -> try another server */
    LWIP_DEBUGF(SNTP_DEBUG_WARN_STATE, ("sntp_dns_found: Failed to resolve server address resolved, trying next server\n"));
    sntp_try_next_server(NULL);
  }
}
 800630e:	e002      	b.n	8006316 <sntp_dns_found+0x2a>
    sntp_try_next_server(NULL);
 8006310:	2000      	movs	r0, #0
 8006312:	f7ff febf 	bl	8006094 <sntp_retry>
}
 8006316:	46c0      	nop			; (mov r8, r8)
 8006318:	46bd      	mov	sp, r7
 800631a:	b004      	add	sp, #16
 800631c:	bd80      	pop	{r7, pc}
 800631e:	46c0      	nop			; (mov r8, r8)
 8006320:	20001134 	.word	0x20001134

08006324 <sntp_request>:
 *
 * @param arg is unused (only necessary to conform to sys_timeout)
 */
static void
sntp_request(void *arg)
{
 8006324:	b5b0      	push	{r4, r5, r7, lr}
 8006326:	b084      	sub	sp, #16
 8006328:	af00      	add	r7, sp, #0
 800632a:	6078      	str	r0, [r7, #4]

  LWIP_UNUSED_ARG(arg);

  /* initialize SNTP server address */
#if SNTP_SERVER_DNS
  if (sntp_servers[sntp_current_server].name) {
 800632c:	4b24      	ldr	r3, [pc, #144]	; (80063c0 <sntp_request+0x9c>)
 800632e:	681b      	ldr	r3, [r3, #0]
 8006330:	2b00      	cmp	r3, #0
 8006332:	d01c      	beq.n	800636e <sntp_request+0x4a>
    /* always resolve the name and rely on dns-internal caching & timeout */
    ip_addr_set_zero(&sntp_servers[sntp_current_server].addr);
 8006334:	4b22      	ldr	r3, [pc, #136]	; (80063c0 <sntp_request+0x9c>)
 8006336:	2200      	movs	r2, #0
 8006338:	605a      	str	r2, [r3, #4]
    err = dns_gethostbyname(sntp_servers[sntp_current_server].name, &sntp_server_address,
 800633a:	4b21      	ldr	r3, [pc, #132]	; (80063c0 <sntp_request+0x9c>)
 800633c:	6818      	ldr	r0, [r3, #0]
 800633e:	250f      	movs	r5, #15
 8006340:	197c      	adds	r4, r7, r5
 8006342:	4a20      	ldr	r2, [pc, #128]	; (80063c4 <sntp_request+0xa0>)
 8006344:	2308      	movs	r3, #8
 8006346:	18f9      	adds	r1, r7, r3
 8006348:	2300      	movs	r3, #0
 800634a:	f001 fa1b 	bl	8007784 <dns_gethostbyname>
 800634e:	0003      	movs	r3, r0
 8006350:	7023      	strb	r3, [r4, #0]
                            sntp_dns_found, NULL);
    if (err == ERR_INPROGRESS) {
 8006352:	197b      	adds	r3, r7, r5
 8006354:	781b      	ldrb	r3, [r3, #0]
 8006356:	b25b      	sxtb	r3, r3
 8006358:	3305      	adds	r3, #5
 800635a:	d02d      	beq.n	80063b8 <sntp_request+0x94>
      /* DNS request sent, wait for sntp_dns_found being called */
      LWIP_DEBUGF(SNTP_DEBUG_STATE, ("sntp_request: Waiting for server address to be resolved.\n"));
      return;
    } else if (err == ERR_OK) {
 800635c:	197b      	adds	r3, r7, r5
 800635e:	781b      	ldrb	r3, [r3, #0]
 8006360:	b25b      	sxtb	r3, r3
 8006362:	2b00      	cmp	r3, #0
 8006364:	d110      	bne.n	8006388 <sntp_request+0x64>
      sntp_servers[sntp_current_server].addr = sntp_server_address;
 8006366:	4b16      	ldr	r3, [pc, #88]	; (80063c0 <sntp_request+0x9c>)
 8006368:	68ba      	ldr	r2, [r7, #8]
 800636a:	605a      	str	r2, [r3, #4]
 800636c:	e00c      	b.n	8006388 <sntp_request+0x64>
    }
  } else
#endif /* SNTP_SERVER_DNS */
  {
    sntp_server_address = sntp_servers[sntp_current_server].addr;
 800636e:	4b14      	ldr	r3, [pc, #80]	; (80063c0 <sntp_request+0x9c>)
 8006370:	685b      	ldr	r3, [r3, #4]
 8006372:	60bb      	str	r3, [r7, #8]
    err = (ip_addr_isany_val(sntp_server_address)) ? ERR_ARG : ERR_OK;
 8006374:	68bb      	ldr	r3, [r7, #8]
 8006376:	2b00      	cmp	r3, #0
 8006378:	d102      	bne.n	8006380 <sntp_request+0x5c>
 800637a:	2310      	movs	r3, #16
 800637c:	425a      	negs	r2, r3
 800637e:	e000      	b.n	8006382 <sntp_request+0x5e>
 8006380:	2200      	movs	r2, #0
 8006382:	230f      	movs	r3, #15
 8006384:	18fb      	adds	r3, r7, r3
 8006386:	701a      	strb	r2, [r3, #0]
  }

  if (err == ERR_OK) {
 8006388:	230f      	movs	r3, #15
 800638a:	18fb      	adds	r3, r7, r3
 800638c:	781b      	ldrb	r3, [r3, #0]
 800638e:	b25b      	sxtb	r3, r3
 8006390:	2b00      	cmp	r3, #0
 8006392:	d105      	bne.n	80063a0 <sntp_request+0x7c>
    LWIP_DEBUGF(SNTP_DEBUG_TRACE, ("sntp_request: current server address is %s\n",
                                   ipaddr_ntoa(&sntp_server_address)));
    sntp_send_request(&sntp_server_address);
 8006394:	2308      	movs	r3, #8
 8006396:	18fb      	adds	r3, r7, r3
 8006398:	0018      	movs	r0, r3
 800639a:	f7ff ff49 	bl	8006230 <sntp_send_request>
 800639e:	e00c      	b.n	80063ba <sntp_request+0x96>
  } else {
    /* address conversion failed, try another server */
    LWIP_DEBUGF(SNTP_DEBUG_WARN_STATE, ("sntp_request: Invalid server address, trying next server.\n"));
    sys_untimeout(sntp_try_next_server, NULL);
 80063a0:	4b09      	ldr	r3, [pc, #36]	; (80063c8 <sntp_request+0xa4>)
 80063a2:	2100      	movs	r1, #0
 80063a4:	0018      	movs	r0, r3
 80063a6:	f00b fc7f 	bl	8011ca8 <sys_untimeout>
    sys_timeout((u32_t)SNTP_RETRY_TIMEOUT, sntp_try_next_server, NULL);
 80063aa:	4b07      	ldr	r3, [pc, #28]	; (80063c8 <sntp_request+0xa4>)
 80063ac:	4807      	ldr	r0, [pc, #28]	; (80063cc <sntp_request+0xa8>)
 80063ae:	2200      	movs	r2, #0
 80063b0:	0019      	movs	r1, r3
 80063b2:	f00b fc51 	bl	8011c58 <sys_timeout>
 80063b6:	e000      	b.n	80063ba <sntp_request+0x96>
      return;
 80063b8:	46c0      	nop			; (mov r8, r8)
  }
}
 80063ba:	46bd      	mov	sp, r7
 80063bc:	b004      	add	sp, #16
 80063be:	bdb0      	pop	{r4, r5, r7, pc}
 80063c0:	20001134 	.word	0x20001134
 80063c4:	080062ed 	.word	0x080062ed
 80063c8:	08006095 	.word	0x08006095
 80063cc:	00003a98 	.word	0x00003a98

080063d0 <sntp_init>:
 * Initialize this module.
 * Send out request instantly or after SNTP_STARTUP_DELAY(_FUNC).
 */
void
sntp_init(void)
{
 80063d0:	b580      	push	{r7, lr}
 80063d2:	af00      	add	r7, sp, #0
#else
#error SNTP_SERVER_ADDRESS string not supported SNTP_SERVER_DNS==0
#endif
#endif /* SNTP_SERVER_ADDRESS */

  if (sntp_pcb == NULL) {
 80063d4:	4b25      	ldr	r3, [pc, #148]	; (800646c <sntp_init+0x9c>)
 80063d6:	681b      	ldr	r3, [r3, #0]
 80063d8:	2b00      	cmp	r3, #0
 80063da:	d144      	bne.n	8006466 <sntp_init+0x96>
    sntp_pcb = udp_new_ip_type(IPADDR_TYPE_ANY);
 80063dc:	202e      	movs	r0, #46	; 0x2e
 80063de:	f00c fa72 	bl	80128c6 <udp_new_ip_type>
 80063e2:	0002      	movs	r2, r0
 80063e4:	4b21      	ldr	r3, [pc, #132]	; (800646c <sntp_init+0x9c>)
 80063e6:	601a      	str	r2, [r3, #0]
    LWIP_ASSERT("Failed to allocate udp pcb for sntp client", sntp_pcb != NULL);
 80063e8:	4b20      	ldr	r3, [pc, #128]	; (800646c <sntp_init+0x9c>)
 80063ea:	681b      	ldr	r3, [r3, #0]
 80063ec:	2b00      	cmp	r3, #0
 80063ee:	d105      	bne.n	80063fc <sntp_init+0x2c>
 80063f0:	4b1f      	ldr	r3, [pc, #124]	; (8006470 <sntp_init+0xa0>)
 80063f2:	4a20      	ldr	r2, [pc, #128]	; (8006474 <sntp_init+0xa4>)
 80063f4:	4920      	ldr	r1, [pc, #128]	; (8006478 <sntp_init+0xa8>)
 80063f6:	4821      	ldr	r0, [pc, #132]	; (800647c <sntp_init+0xac>)
 80063f8:	f7fb fee8 	bl	80021cc <app_debug_rtt_raw>
    if (sntp_pcb != NULL) {
 80063fc:	4b1b      	ldr	r3, [pc, #108]	; (800646c <sntp_init+0x9c>)
 80063fe:	681b      	ldr	r3, [r3, #0]
 8006400:	2b00      	cmp	r3, #0
 8006402:	d030      	beq.n	8006466 <sntp_init+0x96>
      udp_recv(sntp_pcb, sntp_recv, NULL);
 8006404:	4b19      	ldr	r3, [pc, #100]	; (800646c <sntp_init+0x9c>)
 8006406:	681b      	ldr	r3, [r3, #0]
 8006408:	491d      	ldr	r1, [pc, #116]	; (8006480 <sntp_init+0xb0>)
 800640a:	2200      	movs	r2, #0
 800640c:	0018      	movs	r0, r3
 800640e:	f00c f9eb 	bl	80127e8 <udp_recv>

      if (sntp_opmode == SNTP_OPMODE_POLL) {
 8006412:	4b1c      	ldr	r3, [pc, #112]	; (8006484 <sntp_init+0xb4>)
 8006414:	781b      	ldrb	r3, [r3, #0]
 8006416:	2b00      	cmp	r3, #0
 8006418:	d111      	bne.n	800643e <sntp_init+0x6e>
        SNTP_RESET_RETRY_TIMEOUT();
 800641a:	4b1b      	ldr	r3, [pc, #108]	; (8006488 <sntp_init+0xb8>)
 800641c:	4a1b      	ldr	r2, [pc, #108]	; (800648c <sntp_init+0xbc>)
 800641e:	601a      	str	r2, [r3, #0]
#if SNTP_STARTUP_DELAY
        sys_timeout((u32_t)SNTP_STARTUP_DELAY_FUNC, sntp_request, NULL);
 8006420:	f016 f984 	bl	801c72c <sys_rand>
 8006424:	0003      	movs	r3, r0
 8006426:	491a      	ldr	r1, [pc, #104]	; (8006490 <sntp_init+0xc0>)
 8006428:	0018      	movs	r0, r3
 800642a:	f7f9 ff05 	bl	8000238 <__aeabi_uidivmod>
 800642e:	000b      	movs	r3, r1
 8006430:	0018      	movs	r0, r3
 8006432:	4b18      	ldr	r3, [pc, #96]	; (8006494 <sntp_init+0xc4>)
 8006434:	2200      	movs	r2, #0
 8006436:	0019      	movs	r1, r3
 8006438:	f00b fc0e 	bl	8011c58 <sys_timeout>
        ip_set_option(sntp_pcb, SOF_BROADCAST);
        udp_bind(sntp_pcb, IP_ANY_TYPE, SNTP_PORT);
      }
    }
  }
}
 800643c:	e013      	b.n	8006466 <sntp_init+0x96>
      } else if (sntp_opmode == SNTP_OPMODE_LISTENONLY) {
 800643e:	4b11      	ldr	r3, [pc, #68]	; (8006484 <sntp_init+0xb4>)
 8006440:	781b      	ldrb	r3, [r3, #0]
 8006442:	2b01      	cmp	r3, #1
 8006444:	d10f      	bne.n	8006466 <sntp_init+0x96>
        ip_set_option(sntp_pcb, SOF_BROADCAST);
 8006446:	4b09      	ldr	r3, [pc, #36]	; (800646c <sntp_init+0x9c>)
 8006448:	681b      	ldr	r3, [r3, #0]
 800644a:	7a5a      	ldrb	r2, [r3, #9]
 800644c:	4b07      	ldr	r3, [pc, #28]	; (800646c <sntp_init+0x9c>)
 800644e:	681b      	ldr	r3, [r3, #0]
 8006450:	2120      	movs	r1, #32
 8006452:	430a      	orrs	r2, r1
 8006454:	b2d2      	uxtb	r2, r2
 8006456:	725a      	strb	r2, [r3, #9]
        udp_bind(sntp_pcb, IP_ANY_TYPE, SNTP_PORT);
 8006458:	4b04      	ldr	r3, [pc, #16]	; (800646c <sntp_init+0x9c>)
 800645a:	681b      	ldr	r3, [r3, #0]
 800645c:	490e      	ldr	r1, [pc, #56]	; (8006498 <sntp_init+0xc8>)
 800645e:	227b      	movs	r2, #123	; 0x7b
 8006460:	0018      	movs	r0, r3
 8006462:	f00c f929 	bl	80126b8 <udp_bind>
}
 8006466:	46c0      	nop			; (mov r8, r8)
 8006468:	46bd      	mov	sp, r7
 800646a:	bd80      	pop	{r7, pc}
 800646c:	20001130 	.word	0x20001130
 8006470:	0801e4f0 	.word	0x0801e4f0
 8006474:	0000029d 	.word	0x0000029d
 8006478:	0801e55c 	.word	0x0801e55c
 800647c:	0801e530 	.word	0x0801e530
 8006480:	080060f5 	.word	0x080060f5
 8006484:	2000112c 	.word	0x2000112c
 8006488:	20001140 	.word	0x20001140
 800648c:	00003a98 	.word	0x00003a98
 8006490:	00001388 	.word	0x00001388
 8006494:	08006325 	.word	0x08006325
 8006498:	08021a50 	.word	0x08021a50

0800649c <sntp_setoperatingmode>:
 * Sets the operating mode.
 * @param operating_mode one of the available operating modes
 */
void
sntp_setoperatingmode(u8_t operating_mode)
{
 800649c:	b580      	push	{r7, lr}
 800649e:	b082      	sub	sp, #8
 80064a0:	af00      	add	r7, sp, #0
 80064a2:	0002      	movs	r2, r0
 80064a4:	1dfb      	adds	r3, r7, #7
 80064a6:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("Invalid operating mode", operating_mode <= SNTP_OPMODE_LISTENONLY);
 80064a8:	1dfb      	adds	r3, r7, #7
 80064aa:	781b      	ldrb	r3, [r3, #0]
 80064ac:	2b01      	cmp	r3, #1
 80064ae:	d906      	bls.n	80064be <sntp_setoperatingmode+0x22>
 80064b0:	4b0c      	ldr	r3, [pc, #48]	; (80064e4 <sntp_setoperatingmode+0x48>)
 80064b2:	22b6      	movs	r2, #182	; 0xb6
 80064b4:	0092      	lsls	r2, r2, #2
 80064b6:	490c      	ldr	r1, [pc, #48]	; (80064e8 <sntp_setoperatingmode+0x4c>)
 80064b8:	480c      	ldr	r0, [pc, #48]	; (80064ec <sntp_setoperatingmode+0x50>)
 80064ba:	f7fb fe87 	bl	80021cc <app_debug_rtt_raw>
  LWIP_ASSERT("Operating mode must not be set while SNTP client is running", sntp_pcb == NULL);
 80064be:	4b0c      	ldr	r3, [pc, #48]	; (80064f0 <sntp_setoperatingmode+0x54>)
 80064c0:	681b      	ldr	r3, [r3, #0]
 80064c2:	2b00      	cmp	r3, #0
 80064c4:	d005      	beq.n	80064d2 <sntp_setoperatingmode+0x36>
 80064c6:	4b07      	ldr	r3, [pc, #28]	; (80064e4 <sntp_setoperatingmode+0x48>)
 80064c8:	4a0a      	ldr	r2, [pc, #40]	; (80064f4 <sntp_setoperatingmode+0x58>)
 80064ca:	490b      	ldr	r1, [pc, #44]	; (80064f8 <sntp_setoperatingmode+0x5c>)
 80064cc:	4807      	ldr	r0, [pc, #28]	; (80064ec <sntp_setoperatingmode+0x50>)
 80064ce:	f7fb fe7d 	bl	80021cc <app_debug_rtt_raw>
  sntp_opmode = operating_mode;
 80064d2:	4b0a      	ldr	r3, [pc, #40]	; (80064fc <sntp_setoperatingmode+0x60>)
 80064d4:	1dfa      	adds	r2, r7, #7
 80064d6:	7812      	ldrb	r2, [r2, #0]
 80064d8:	701a      	strb	r2, [r3, #0]
}
 80064da:	46c0      	nop			; (mov r8, r8)
 80064dc:	46bd      	mov	sp, r7
 80064de:	b002      	add	sp, #8
 80064e0:	bd80      	pop	{r7, pc}
 80064e2:	46c0      	nop			; (mov r8, r8)
 80064e4:	0801e4f0 	.word	0x0801e4f0
 80064e8:	0801e588 	.word	0x0801e588
 80064ec:	0801e530 	.word	0x0801e530
 80064f0:	20001130 	.word	0x20001130
 80064f4:	000002d9 	.word	0x000002d9
 80064f8:	0801e5a0 	.word	0x0801e5a0
 80064fc:	2000112c 	.word	0x2000112c

08006500 <sntp_setservername>:
 * @param idx the index of the NTP server to set must be < SNTP_MAX_SERVERS
 * @param server DNS name of the NTP server to set, to be resolved at contact time
 */
void
sntp_setservername(u8_t idx, const char *server)
{
 8006500:	b580      	push	{r7, lr}
 8006502:	b082      	sub	sp, #8
 8006504:	af00      	add	r7, sp, #0
 8006506:	0002      	movs	r2, r0
 8006508:	6039      	str	r1, [r7, #0]
 800650a:	1dfb      	adds	r3, r7, #7
 800650c:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT_CORE_LOCKED();
  if (idx < SNTP_MAX_SERVERS) {
 800650e:	1dfb      	adds	r3, r7, #7
 8006510:	781b      	ldrb	r3, [r3, #0]
 8006512:	2b00      	cmp	r3, #0
 8006514:	d108      	bne.n	8006528 <sntp_setservername+0x28>
    sntp_servers[idx].name = server;
 8006516:	1dfb      	adds	r3, r7, #7
 8006518:	781a      	ldrb	r2, [r3, #0]
 800651a:	4905      	ldr	r1, [pc, #20]	; (8006530 <sntp_setservername+0x30>)
 800651c:	0013      	movs	r3, r2
 800651e:	005b      	lsls	r3, r3, #1
 8006520:	189b      	adds	r3, r3, r2
 8006522:	009b      	lsls	r3, r3, #2
 8006524:	683a      	ldr	r2, [r7, #0]
 8006526:	505a      	str	r2, [r3, r1]
  }
}
 8006528:	46c0      	nop			; (mov r8, r8)
 800652a:	46bd      	mov	sp, r7
 800652c:	b002      	add	sp, #8
 800652e:	bd80      	pop	{r7, pc}
 8006530:	20001134 	.word	0x20001134

08006534 <lwip_htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
lwip_htons(u16_t n)
{
 8006534:	b580      	push	{r7, lr}
 8006536:	b082      	sub	sp, #8
 8006538:	af00      	add	r7, sp, #0
 800653a:	0002      	movs	r2, r0
 800653c:	1dbb      	adds	r3, r7, #6
 800653e:	801a      	strh	r2, [r3, #0]
  return PP_HTONS(n);
 8006540:	1dbb      	adds	r3, r7, #6
 8006542:	881b      	ldrh	r3, [r3, #0]
 8006544:	021b      	lsls	r3, r3, #8
 8006546:	b21a      	sxth	r2, r3
 8006548:	1dbb      	adds	r3, r7, #6
 800654a:	881b      	ldrh	r3, [r3, #0]
 800654c:	0a1b      	lsrs	r3, r3, #8
 800654e:	b29b      	uxth	r3, r3
 8006550:	b21b      	sxth	r3, r3
 8006552:	4313      	orrs	r3, r2
 8006554:	b21b      	sxth	r3, r3
 8006556:	b29b      	uxth	r3, r3
}
 8006558:	0018      	movs	r0, r3
 800655a:	46bd      	mov	sp, r7
 800655c:	b002      	add	sp, #8
 800655e:	bd80      	pop	{r7, pc}

08006560 <lwip_htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
lwip_htonl(u32_t n)
{
 8006560:	b580      	push	{r7, lr}
 8006562:	b082      	sub	sp, #8
 8006564:	af00      	add	r7, sp, #0
 8006566:	6078      	str	r0, [r7, #4]
  return PP_HTONL(n);
 8006568:	687b      	ldr	r3, [r7, #4]
 800656a:	061a      	lsls	r2, r3, #24
 800656c:	687b      	ldr	r3, [r7, #4]
 800656e:	0219      	lsls	r1, r3, #8
 8006570:	23ff      	movs	r3, #255	; 0xff
 8006572:	041b      	lsls	r3, r3, #16
 8006574:	400b      	ands	r3, r1
 8006576:	431a      	orrs	r2, r3
 8006578:	687b      	ldr	r3, [r7, #4]
 800657a:	0a19      	lsrs	r1, r3, #8
 800657c:	23ff      	movs	r3, #255	; 0xff
 800657e:	021b      	lsls	r3, r3, #8
 8006580:	400b      	ands	r3, r1
 8006582:	431a      	orrs	r2, r3
 8006584:	687b      	ldr	r3, [r7, #4]
 8006586:	0e1b      	lsrs	r3, r3, #24
 8006588:	4313      	orrs	r3, r2
}
 800658a:	0018      	movs	r0, r3
 800658c:	46bd      	mov	sp, r7
 800658e:	b002      	add	sp, #8
 8006590:	bd80      	pop	{r7, pc}

08006592 <lwip_strnicmp>:
 * lwIP default implementation for strnicmp() non-standard function.
 * This can be \#defined to strnicmp() depending on your platform port.
 */
int
lwip_strnicmp(const char *str1, const char *str2, size_t len)
{
 8006592:	b5b0      	push	{r4, r5, r7, lr}
 8006594:	b086      	sub	sp, #24
 8006596:	af00      	add	r7, sp, #0
 8006598:	60f8      	str	r0, [r7, #12]
 800659a:	60b9      	str	r1, [r7, #8]
 800659c:	607a      	str	r2, [r7, #4]
  char c1, c2;

  do {
    c1 = *str1++;
 800659e:	68fb      	ldr	r3, [r7, #12]
 80065a0:	1c5a      	adds	r2, r3, #1
 80065a2:	60fa      	str	r2, [r7, #12]
 80065a4:	2117      	movs	r1, #23
 80065a6:	187a      	adds	r2, r7, r1
 80065a8:	781b      	ldrb	r3, [r3, #0]
 80065aa:	7013      	strb	r3, [r2, #0]
    c2 = *str2++;
 80065ac:	68bb      	ldr	r3, [r7, #8]
 80065ae:	1c5a      	adds	r2, r3, #1
 80065b0:	60ba      	str	r2, [r7, #8]
 80065b2:	2416      	movs	r4, #22
 80065b4:	193a      	adds	r2, r7, r4
 80065b6:	781b      	ldrb	r3, [r3, #0]
 80065b8:	7013      	strb	r3, [r2, #0]
    if (c1 != c2) {
 80065ba:	187a      	adds	r2, r7, r1
 80065bc:	193b      	adds	r3, r7, r4
 80065be:	7812      	ldrb	r2, [r2, #0]
 80065c0:	781b      	ldrb	r3, [r3, #0]
 80065c2:	429a      	cmp	r2, r3
 80065c4:	d020      	beq.n	8006608 <lwip_strnicmp+0x76>
      char c1_upc = c1 | 0x20;
 80065c6:	2015      	movs	r0, #21
 80065c8:	183b      	adds	r3, r7, r0
 80065ca:	187a      	adds	r2, r7, r1
 80065cc:	7812      	ldrb	r2, [r2, #0]
 80065ce:	2120      	movs	r1, #32
 80065d0:	430a      	orrs	r2, r1
 80065d2:	701a      	strb	r2, [r3, #0]
      if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
 80065d4:	183b      	adds	r3, r7, r0
 80065d6:	781b      	ldrb	r3, [r3, #0]
 80065d8:	2b60      	cmp	r3, #96	; 0x60
 80065da:	d912      	bls.n	8006602 <lwip_strnicmp+0x70>
 80065dc:	183b      	adds	r3, r7, r0
 80065de:	781b      	ldrb	r3, [r3, #0]
 80065e0:	2b7a      	cmp	r3, #122	; 0x7a
 80065e2:	d80e      	bhi.n	8006602 <lwip_strnicmp+0x70>
        /* characters are not equal an one is in the alphabet range:
        downcase both chars and check again */
        char c2_upc = c2 | 0x20;
 80065e4:	2514      	movs	r5, #20
 80065e6:	197b      	adds	r3, r7, r5
 80065e8:	193a      	adds	r2, r7, r4
 80065ea:	7812      	ldrb	r2, [r2, #0]
 80065ec:	2120      	movs	r1, #32
 80065ee:	430a      	orrs	r2, r1
 80065f0:	701a      	strb	r2, [r3, #0]
        if (c1_upc != c2_upc) {
 80065f2:	183a      	adds	r2, r7, r0
 80065f4:	197b      	adds	r3, r7, r5
 80065f6:	7812      	ldrb	r2, [r2, #0]
 80065f8:	781b      	ldrb	r3, [r3, #0]
 80065fa:	429a      	cmp	r2, r3
 80065fc:	d003      	beq.n	8006606 <lwip_strnicmp+0x74>
          /* still not equal */
          /* don't care for < or > */
          return 1;
 80065fe:	2301      	movs	r3, #1
 8006600:	e00e      	b.n	8006620 <lwip_strnicmp+0x8e>
        }
      } else {
        /* characters are not equal but none is in the alphabet range */
        return 1;
 8006602:	2301      	movs	r3, #1
 8006604:	e00c      	b.n	8006620 <lwip_strnicmp+0x8e>
      if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
 8006606:	46c0      	nop			; (mov r8, r8)
      }
    }
    len--;
 8006608:	687b      	ldr	r3, [r7, #4]
 800660a:	3b01      	subs	r3, #1
 800660c:	607b      	str	r3, [r7, #4]
  } while ((len != 0) && (c1 != 0));
 800660e:	687b      	ldr	r3, [r7, #4]
 8006610:	2b00      	cmp	r3, #0
 8006612:	d004      	beq.n	800661e <lwip_strnicmp+0x8c>
 8006614:	2317      	movs	r3, #23
 8006616:	18fb      	adds	r3, r7, r3
 8006618:	781b      	ldrb	r3, [r3, #0]
 800661a:	2b00      	cmp	r3, #0
 800661c:	d1bf      	bne.n	800659e <lwip_strnicmp+0xc>
  return 0;
 800661e:	2300      	movs	r3, #0
}
 8006620:	0018      	movs	r0, r3
 8006622:	46bd      	mov	sp, r7
 8006624:	b006      	add	sp, #24
 8006626:	bdb0      	pop	{r4, r5, r7, pc}

08006628 <dns_init>:
 * Initialize the resolver: set up the UDP pcb and configure the default server
 * (if DNS_SERVER_ADDRESS is set).
 */
void
dns_init(void)
{
 8006628:	b580      	push	{r7, lr}
 800662a:	af00      	add	r7, sp, #0
#endif

#if DNS_LOCAL_HOSTLIST
  dns_init_local();
#endif
}
 800662c:	46c0      	nop			; (mov r8, r8)
 800662e:	46bd      	mov	sp, r7
 8006630:	bd80      	pop	{r7, pc}
	...

08006634 <dns_setserver>:
 * @param numdns the index of the DNS server to set must be < DNS_MAX_SERVERS
 * @param dnsserver IP address of the DNS server to set
 */
void
dns_setserver(u8_t numdns, const ip_addr_t *dnsserver)
{
 8006634:	b580      	push	{r7, lr}
 8006636:	b082      	sub	sp, #8
 8006638:	af00      	add	r7, sp, #0
 800663a:	0002      	movs	r2, r0
 800663c:	6039      	str	r1, [r7, #0]
 800663e:	1dfb      	adds	r3, r7, #7
 8006640:	701a      	strb	r2, [r3, #0]
  if (numdns < DNS_MAX_SERVERS) {
 8006642:	1dfb      	adds	r3, r7, #7
 8006644:	781b      	ldrb	r3, [r3, #0]
 8006646:	2b01      	cmp	r3, #1
 8006648:	d811      	bhi.n	800666e <dns_setserver+0x3a>
    if (dnsserver != NULL) {
 800664a:	683b      	ldr	r3, [r7, #0]
 800664c:	2b00      	cmp	r3, #0
 800664e:	d007      	beq.n	8006660 <dns_setserver+0x2c>
      dns_servers[numdns] = (*dnsserver);
 8006650:	1dfb      	adds	r3, r7, #7
 8006652:	781b      	ldrb	r3, [r3, #0]
 8006654:	4a08      	ldr	r2, [pc, #32]	; (8006678 <dns_setserver+0x44>)
 8006656:	0099      	lsls	r1, r3, #2
 8006658:	683b      	ldr	r3, [r7, #0]
 800665a:	681b      	ldr	r3, [r3, #0]
 800665c:	508b      	str	r3, [r1, r2]
    } else {
      dns_servers[numdns] = *IP_ADDR_ANY;
    }
  }
}
 800665e:	e006      	b.n	800666e <dns_setserver+0x3a>
      dns_servers[numdns] = *IP_ADDR_ANY;
 8006660:	1dfb      	adds	r3, r7, #7
 8006662:	781b      	ldrb	r3, [r3, #0]
 8006664:	4a04      	ldr	r2, [pc, #16]	; (8006678 <dns_setserver+0x44>)
 8006666:	0099      	lsls	r1, r3, #2
 8006668:	4b04      	ldr	r3, [pc, #16]	; (800667c <dns_setserver+0x48>)
 800666a:	681b      	ldr	r3, [r3, #0]
 800666c:	508b      	str	r3, [r1, r2]
}
 800666e:	46c0      	nop			; (mov r8, r8)
 8006670:	46bd      	mov	sp, r7
 8006672:	b002      	add	sp, #8
 8006674:	bd80      	pop	{r7, pc}
 8006676:	46c0      	nop			; (mov r8, r8)
 8006678:	20001328 	.word	0x20001328
 800667c:	08021a50 	.word	0x08021a50

08006680 <dns_getserver>:
 * @return IP address of the indexed DNS server or "ip_addr_any" if the DNS
 *         server has not been configured.
 */
const ip_addr_t *
dns_getserver(u8_t numdns)
{
 8006680:	b580      	push	{r7, lr}
 8006682:	b082      	sub	sp, #8
 8006684:	af00      	add	r7, sp, #0
 8006686:	0002      	movs	r2, r0
 8006688:	1dfb      	adds	r3, r7, #7
 800668a:	701a      	strb	r2, [r3, #0]
  if (numdns < DNS_MAX_SERVERS) {
 800668c:	1dfb      	adds	r3, r7, #7
 800668e:	781b      	ldrb	r3, [r3, #0]
 8006690:	2b01      	cmp	r3, #1
 8006692:	d805      	bhi.n	80066a0 <dns_getserver+0x20>
    return &dns_servers[numdns];
 8006694:	1dfb      	adds	r3, r7, #7
 8006696:	781b      	ldrb	r3, [r3, #0]
 8006698:	009a      	lsls	r2, r3, #2
 800669a:	4b04      	ldr	r3, [pc, #16]	; (80066ac <dns_getserver+0x2c>)
 800669c:	18d3      	adds	r3, r2, r3
 800669e:	e000      	b.n	80066a2 <dns_getserver+0x22>
  } else {
    return IP_ADDR_ANY;
 80066a0:	4b03      	ldr	r3, [pc, #12]	; (80066b0 <dns_getserver+0x30>)
  }
}
 80066a2:	0018      	movs	r0, r3
 80066a4:	46bd      	mov	sp, r7
 80066a6:	b002      	add	sp, #8
 80066a8:	bd80      	pop	{r7, pc}
 80066aa:	46c0      	nop			; (mov r8, r8)
 80066ac:	20001328 	.word	0x20001328
 80066b0:	08021a50 	.word	0x08021a50

080066b4 <dns_tmr>:
 * The DNS resolver client timer - handle retries and timeouts and should
 * be called every DNS_TMR_INTERVAL milliseconds (every second by default).
 */
void
dns_tmr(void)
{
 80066b4:	b580      	push	{r7, lr}
 80066b6:	af00      	add	r7, sp, #0
  LWIP_DEBUGF(DNS_DEBUG, ("dns_tmr: dns_check_entries\n"));
  dns_check_entries();
 80066b8:	f000 fd16 	bl	80070e8 <dns_check_entries>
}
 80066bc:	46c0      	nop			; (mov r8, r8)
 80066be:	46bd      	mov	sp, r7
 80066c0:	bd80      	pop	{r7, pc}
	...

080066c4 <dns_lookup>:
 *         was not found in the cached dns_table.
 * @return ERR_OK if found, ERR_ARG if not found
 */
static err_t
dns_lookup(const char *name, ip_addr_t *addr LWIP_DNS_ADDRTYPE_ARG(u8_t dns_addrtype))
{
 80066c4:	b590      	push	{r4, r7, lr}
 80066c6:	b085      	sub	sp, #20
 80066c8:	af00      	add	r7, sp, #0
 80066ca:	6078      	str	r0, [r7, #4]
 80066cc:	6039      	str	r1, [r7, #0]
    return ERR_OK;
  }
#endif /* DNS_LOOKUP_LOCAL_EXTERN */

  /* Walk through name list, return entry if found. If not, return NULL. */
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 80066ce:	230f      	movs	r3, #15
 80066d0:	18fb      	adds	r3, r7, r3
 80066d2:	2200      	movs	r2, #0
 80066d4:	701a      	strb	r2, [r3, #0]
 80066d6:	e034      	b.n	8006742 <dns_lookup+0x7e>
    if ((dns_table[i].state == DNS_STATE_DONE) &&
 80066d8:	240f      	movs	r4, #15
 80066da:	193b      	adds	r3, r7, r4
 80066dc:	781a      	ldrb	r2, [r3, #0]
 80066de:	491e      	ldr	r1, [pc, #120]	; (8006758 <dns_lookup+0x94>)
 80066e0:	0013      	movs	r3, r2
 80066e2:	00db      	lsls	r3, r3, #3
 80066e4:	189b      	adds	r3, r3, r2
 80066e6:	011b      	lsls	r3, r3, #4
 80066e8:	18cb      	adds	r3, r1, r3
 80066ea:	330a      	adds	r3, #10
 80066ec:	781b      	ldrb	r3, [r3, #0]
 80066ee:	2b03      	cmp	r3, #3
 80066f0:	d121      	bne.n	8006736 <dns_lookup+0x72>
        (lwip_strnicmp(name, dns_table[i].name, sizeof(dns_table[i].name)) == 0) &&
 80066f2:	193b      	adds	r3, r7, r4
 80066f4:	781a      	ldrb	r2, [r3, #0]
 80066f6:	0013      	movs	r3, r2
 80066f8:	00db      	lsls	r3, r3, #3
 80066fa:	189b      	adds	r3, r3, r2
 80066fc:	011b      	lsls	r3, r3, #4
 80066fe:	3310      	adds	r3, #16
 8006700:	001a      	movs	r2, r3
 8006702:	4b15      	ldr	r3, [pc, #84]	; (8006758 <dns_lookup+0x94>)
 8006704:	18d1      	adds	r1, r2, r3
 8006706:	687b      	ldr	r3, [r7, #4]
 8006708:	2280      	movs	r2, #128	; 0x80
 800670a:	0018      	movs	r0, r3
 800670c:	f7ff ff41 	bl	8006592 <lwip_strnicmp>
 8006710:	1e03      	subs	r3, r0, #0
    if ((dns_table[i].state == DNS_STATE_DONE) &&
 8006712:	d110      	bne.n	8006736 <dns_lookup+0x72>
        LWIP_DNS_ADDRTYPE_MATCH_IP(dns_addrtype, dns_table[i].ipaddr)) {
      LWIP_DEBUGF(DNS_DEBUG, ("dns_lookup: \"%s\": found = ", name));
      ip_addr_debug_print_val(DNS_DEBUG, dns_table[i].ipaddr);
      LWIP_DEBUGF(DNS_DEBUG, ("\n"));
      if (addr) {
 8006714:	683b      	ldr	r3, [r7, #0]
 8006716:	2b00      	cmp	r3, #0
 8006718:	d00b      	beq.n	8006732 <dns_lookup+0x6e>
        ip_addr_copy(*addr, dns_table[i].ipaddr);
 800671a:	193b      	adds	r3, r7, r4
 800671c:	781a      	ldrb	r2, [r3, #0]
 800671e:	490e      	ldr	r1, [pc, #56]	; (8006758 <dns_lookup+0x94>)
 8006720:	0013      	movs	r3, r2
 8006722:	00db      	lsls	r3, r3, #3
 8006724:	189b      	adds	r3, r3, r2
 8006726:	011b      	lsls	r3, r3, #4
 8006728:	18cb      	adds	r3, r1, r3
 800672a:	3304      	adds	r3, #4
 800672c:	681a      	ldr	r2, [r3, #0]
 800672e:	683b      	ldr	r3, [r7, #0]
 8006730:	601a      	str	r2, [r3, #0]
      }
      return ERR_OK;
 8006732:	2300      	movs	r3, #0
 8006734:	e00c      	b.n	8006750 <dns_lookup+0x8c>
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 8006736:	220f      	movs	r2, #15
 8006738:	18bb      	adds	r3, r7, r2
 800673a:	18ba      	adds	r2, r7, r2
 800673c:	7812      	ldrb	r2, [r2, #0]
 800673e:	3201      	adds	r2, #1
 8006740:	701a      	strb	r2, [r3, #0]
 8006742:	230f      	movs	r3, #15
 8006744:	18fb      	adds	r3, r7, r3
 8006746:	781b      	ldrb	r3, [r3, #0]
 8006748:	2b02      	cmp	r3, #2
 800674a:	d9c5      	bls.n	80066d8 <dns_lookup+0x14>
    }
  }

  return ERR_ARG;
 800674c:	2310      	movs	r3, #16
 800674e:	425b      	negs	r3, r3
}
 8006750:	0018      	movs	r0, r3
 8006752:	46bd      	mov	sp, r7
 8006754:	b005      	add	sp, #20
 8006756:	bd90      	pop	{r4, r7, pc}
 8006758:	20001154 	.word	0x20001154

0800675c <dns_compare_name>:
 * @param start_offset offset into p where the name starts
 * @return 0xFFFF: names differ, other: names equal -> offset behind name
 */
static u16_t
dns_compare_name(const char *query, struct pbuf *p, u16_t start_offset)
{
 800675c:	b590      	push	{r4, r7, lr}
 800675e:	b089      	sub	sp, #36	; 0x24
 8006760:	af00      	add	r7, sp, #0
 8006762:	60f8      	str	r0, [r7, #12]
 8006764:	60b9      	str	r1, [r7, #8]
 8006766:	1dbb      	adds	r3, r7, #6
 8006768:	801a      	strh	r2, [r3, #0]
  int n;
  u16_t response_offset = start_offset;
 800676a:	231a      	movs	r3, #26
 800676c:	18fb      	adds	r3, r7, r3
 800676e:	1dba      	adds	r2, r7, #6
 8006770:	8812      	ldrh	r2, [r2, #0]
 8006772:	801a      	strh	r2, [r3, #0]

  do {
    n = pbuf_try_get_at(p, response_offset);
 8006774:	241a      	movs	r4, #26
 8006776:	193b      	adds	r3, r7, r4
 8006778:	881a      	ldrh	r2, [r3, #0]
 800677a:	68bb      	ldr	r3, [r7, #8]
 800677c:	0011      	movs	r1, r2
 800677e:	0018      	movs	r0, r3
 8006780:	f003 fcbd 	bl	800a0fe <pbuf_try_get_at>
 8006784:	0003      	movs	r3, r0
 8006786:	61fb      	str	r3, [r7, #28]
    if ((n < 0) || (response_offset == 0xFFFF)) {
 8006788:	69fb      	ldr	r3, [r7, #28]
 800678a:	2b00      	cmp	r3, #0
 800678c:	db04      	blt.n	8006798 <dns_compare_name+0x3c>
 800678e:	193b      	adds	r3, r7, r4
 8006790:	881b      	ldrh	r3, [r3, #0]
 8006792:	4a48      	ldr	r2, [pc, #288]	; (80068b4 <dns_compare_name+0x158>)
 8006794:	4293      	cmp	r3, r2
 8006796:	d101      	bne.n	800679c <dns_compare_name+0x40>
      /* error or overflow */
      return 0xFFFF;
 8006798:	4b46      	ldr	r3, [pc, #280]	; (80068b4 <dns_compare_name+0x158>)
 800679a:	e087      	b.n	80068ac <dns_compare_name+0x150>
    }
    response_offset++;
 800679c:	211a      	movs	r1, #26
 800679e:	187b      	adds	r3, r7, r1
 80067a0:	881a      	ldrh	r2, [r3, #0]
 80067a2:	187b      	adds	r3, r7, r1
 80067a4:	3201      	adds	r2, #1
 80067a6:	801a      	strh	r2, [r3, #0]
    /** @see RFC 1035 - 4.1.4. Message compression */
    if ((n & 0xc0) == 0xc0) {
 80067a8:	69fb      	ldr	r3, [r7, #28]
 80067aa:	22c0      	movs	r2, #192	; 0xc0
 80067ac:	4013      	ands	r3, r2
 80067ae:	2bc0      	cmp	r3, #192	; 0xc0
 80067b0:	d156      	bne.n	8006860 <dns_compare_name+0x104>
      /* Compressed name: cannot be equal since we don't send them */
      return 0xFFFF;
 80067b2:	4b40      	ldr	r3, [pc, #256]	; (80068b4 <dns_compare_name+0x158>)
 80067b4:	e07a      	b.n	80068ac <dns_compare_name+0x150>
    } else {
      /* Not compressed name */
      while (n > 0) {
        int c = pbuf_try_get_at(p, response_offset);
 80067b6:	231a      	movs	r3, #26
 80067b8:	18fb      	adds	r3, r7, r3
 80067ba:	881a      	ldrh	r2, [r3, #0]
 80067bc:	68bb      	ldr	r3, [r7, #8]
 80067be:	0011      	movs	r1, r2
 80067c0:	0018      	movs	r0, r3
 80067c2:	f003 fc9c 	bl	800a0fe <pbuf_try_get_at>
 80067c6:	0003      	movs	r3, r0
 80067c8:	617b      	str	r3, [r7, #20]
        if (c < 0) {
 80067ca:	697b      	ldr	r3, [r7, #20]
 80067cc:	2b00      	cmp	r3, #0
 80067ce:	da01      	bge.n	80067d4 <dns_compare_name+0x78>
          return 0xFFFF;
 80067d0:	4b38      	ldr	r3, [pc, #224]	; (80068b4 <dns_compare_name+0x158>)
 80067d2:	e06b      	b.n	80068ac <dns_compare_name+0x150>
        }
        if (lwip_tolower((*query)) != lwip_tolower((u8_t)c)) {
 80067d4:	2113      	movs	r1, #19
 80067d6:	187b      	adds	r3, r7, r1
 80067d8:	68fa      	ldr	r2, [r7, #12]
 80067da:	7812      	ldrb	r2, [r2, #0]
 80067dc:	701a      	strb	r2, [r3, #0]
 80067de:	187b      	adds	r3, r7, r1
 80067e0:	781b      	ldrb	r3, [r3, #0]
 80067e2:	1c5a      	adds	r2, r3, #1
 80067e4:	4b34      	ldr	r3, [pc, #208]	; (80068b8 <dns_compare_name+0x15c>)
 80067e6:	18d3      	adds	r3, r2, r3
 80067e8:	781b      	ldrb	r3, [r3, #0]
 80067ea:	001a      	movs	r2, r3
 80067ec:	2303      	movs	r3, #3
 80067ee:	4013      	ands	r3, r2
 80067f0:	2b01      	cmp	r3, #1
 80067f2:	d104      	bne.n	80067fe <dns_compare_name+0xa2>
 80067f4:	187b      	adds	r3, r7, r1
 80067f6:	781b      	ldrb	r3, [r3, #0]
 80067f8:	3320      	adds	r3, #32
 80067fa:	001a      	movs	r2, r3
 80067fc:	e002      	b.n	8006804 <dns_compare_name+0xa8>
 80067fe:	2313      	movs	r3, #19
 8006800:	18fb      	adds	r3, r7, r3
 8006802:	781a      	ldrb	r2, [r3, #0]
 8006804:	2012      	movs	r0, #18
 8006806:	183b      	adds	r3, r7, r0
 8006808:	6979      	ldr	r1, [r7, #20]
 800680a:	7019      	strb	r1, [r3, #0]
 800680c:	183b      	adds	r3, r7, r0
 800680e:	781b      	ldrb	r3, [r3, #0]
 8006810:	1c59      	adds	r1, r3, #1
 8006812:	4b29      	ldr	r3, [pc, #164]	; (80068b8 <dns_compare_name+0x15c>)
 8006814:	18cb      	adds	r3, r1, r3
 8006816:	781b      	ldrb	r3, [r3, #0]
 8006818:	0019      	movs	r1, r3
 800681a:	2303      	movs	r3, #3
 800681c:	400b      	ands	r3, r1
 800681e:	2b01      	cmp	r3, #1
 8006820:	d103      	bne.n	800682a <dns_compare_name+0xce>
 8006822:	183b      	adds	r3, r7, r0
 8006824:	781b      	ldrb	r3, [r3, #0]
 8006826:	3320      	adds	r3, #32
 8006828:	e002      	b.n	8006830 <dns_compare_name+0xd4>
 800682a:	2312      	movs	r3, #18
 800682c:	18fb      	adds	r3, r7, r3
 800682e:	781b      	ldrb	r3, [r3, #0]
 8006830:	429a      	cmp	r2, r3
 8006832:	d001      	beq.n	8006838 <dns_compare_name+0xdc>
          return 0xFFFF;
 8006834:	4b1f      	ldr	r3, [pc, #124]	; (80068b4 <dns_compare_name+0x158>)
 8006836:	e039      	b.n	80068ac <dns_compare_name+0x150>
        }
        if (response_offset == 0xFFFF) {
 8006838:	231a      	movs	r3, #26
 800683a:	18fb      	adds	r3, r7, r3
 800683c:	881b      	ldrh	r3, [r3, #0]
 800683e:	4a1d      	ldr	r2, [pc, #116]	; (80068b4 <dns_compare_name+0x158>)
 8006840:	4293      	cmp	r3, r2
 8006842:	d101      	bne.n	8006848 <dns_compare_name+0xec>
          /* would overflow */
          return 0xFFFF;
 8006844:	4b1b      	ldr	r3, [pc, #108]	; (80068b4 <dns_compare_name+0x158>)
 8006846:	e031      	b.n	80068ac <dns_compare_name+0x150>
        }
        response_offset++;
 8006848:	211a      	movs	r1, #26
 800684a:	187b      	adds	r3, r7, r1
 800684c:	881a      	ldrh	r2, [r3, #0]
 800684e:	187b      	adds	r3, r7, r1
 8006850:	3201      	adds	r2, #1
 8006852:	801a      	strh	r2, [r3, #0]
        ++query;
 8006854:	68fb      	ldr	r3, [r7, #12]
 8006856:	3301      	adds	r3, #1
 8006858:	60fb      	str	r3, [r7, #12]
        --n;
 800685a:	69fb      	ldr	r3, [r7, #28]
 800685c:	3b01      	subs	r3, #1
 800685e:	61fb      	str	r3, [r7, #28]
      while (n > 0) {
 8006860:	69fb      	ldr	r3, [r7, #28]
 8006862:	2b00      	cmp	r3, #0
 8006864:	dca7      	bgt.n	80067b6 <dns_compare_name+0x5a>
      }
      ++query;
 8006866:	68fb      	ldr	r3, [r7, #12]
 8006868:	3301      	adds	r3, #1
 800686a:	60fb      	str	r3, [r7, #12]
    }
    n = pbuf_try_get_at(p, response_offset);
 800686c:	231a      	movs	r3, #26
 800686e:	18fb      	adds	r3, r7, r3
 8006870:	881a      	ldrh	r2, [r3, #0]
 8006872:	68bb      	ldr	r3, [r7, #8]
 8006874:	0011      	movs	r1, r2
 8006876:	0018      	movs	r0, r3
 8006878:	f003 fc41 	bl	800a0fe <pbuf_try_get_at>
 800687c:	0003      	movs	r3, r0
 800687e:	61fb      	str	r3, [r7, #28]
    if (n < 0) {
 8006880:	69fb      	ldr	r3, [r7, #28]
 8006882:	2b00      	cmp	r3, #0
 8006884:	da01      	bge.n	800688a <dns_compare_name+0x12e>
      return 0xFFFF;
 8006886:	4b0b      	ldr	r3, [pc, #44]	; (80068b4 <dns_compare_name+0x158>)
 8006888:	e010      	b.n	80068ac <dns_compare_name+0x150>
    }
  } while (n != 0);
 800688a:	69fb      	ldr	r3, [r7, #28]
 800688c:	2b00      	cmp	r3, #0
 800688e:	d000      	beq.n	8006892 <dns_compare_name+0x136>
 8006890:	e770      	b.n	8006774 <dns_compare_name+0x18>

  if (response_offset == 0xFFFF) {
 8006892:	231a      	movs	r3, #26
 8006894:	18fb      	adds	r3, r7, r3
 8006896:	881b      	ldrh	r3, [r3, #0]
 8006898:	4a06      	ldr	r2, [pc, #24]	; (80068b4 <dns_compare_name+0x158>)
 800689a:	4293      	cmp	r3, r2
 800689c:	d101      	bne.n	80068a2 <dns_compare_name+0x146>
    /* would overflow */
    return 0xFFFF;
 800689e:	4b05      	ldr	r3, [pc, #20]	; (80068b4 <dns_compare_name+0x158>)
 80068a0:	e004      	b.n	80068ac <dns_compare_name+0x150>
  }
  return (u16_t)(response_offset + 1);
 80068a2:	231a      	movs	r3, #26
 80068a4:	18fb      	adds	r3, r7, r3
 80068a6:	881b      	ldrh	r3, [r3, #0]
 80068a8:	3301      	adds	r3, #1
 80068aa:	b29b      	uxth	r3, r3
}
 80068ac:	0018      	movs	r0, r3
 80068ae:	46bd      	mov	sp, r7
 80068b0:	b009      	add	sp, #36	; 0x24
 80068b2:	bd90      	pop	{r4, r7, pc}
 80068b4:	0000ffff 	.word	0x0000ffff
 80068b8:	0802202c 	.word	0x0802202c

080068bc <dns_skip_name>:
 * @param query_idx start index into p pointing to encoded DNS name in the DNS server response
 * @return index to end of the name
 */
static u16_t
dns_skip_name(struct pbuf *p, u16_t query_idx)
{
 80068bc:	b590      	push	{r4, r7, lr}
 80068be:	b085      	sub	sp, #20
 80068c0:	af00      	add	r7, sp, #0
 80068c2:	6078      	str	r0, [r7, #4]
 80068c4:	000a      	movs	r2, r1
 80068c6:	1cbb      	adds	r3, r7, #2
 80068c8:	801a      	strh	r2, [r3, #0]
  int n;
  u16_t offset = query_idx;
 80068ca:	230e      	movs	r3, #14
 80068cc:	18fb      	adds	r3, r7, r3
 80068ce:	1cba      	adds	r2, r7, #2
 80068d0:	8812      	ldrh	r2, [r2, #0]
 80068d2:	801a      	strh	r2, [r3, #0]

  do {
    n = pbuf_try_get_at(p, offset++);
 80068d4:	240e      	movs	r4, #14
 80068d6:	193b      	adds	r3, r7, r4
 80068d8:	881b      	ldrh	r3, [r3, #0]
 80068da:	193a      	adds	r2, r7, r4
 80068dc:	1c59      	adds	r1, r3, #1
 80068de:	8011      	strh	r1, [r2, #0]
 80068e0:	687a      	ldr	r2, [r7, #4]
 80068e2:	0019      	movs	r1, r3
 80068e4:	0010      	movs	r0, r2
 80068e6:	f003 fc0a 	bl	800a0fe <pbuf_try_get_at>
 80068ea:	0003      	movs	r3, r0
 80068ec:	60bb      	str	r3, [r7, #8]
    if ((n < 0) || (offset == 0)) {
 80068ee:	68bb      	ldr	r3, [r7, #8]
 80068f0:	2b00      	cmp	r3, #0
 80068f2:	db03      	blt.n	80068fc <dns_skip_name+0x40>
 80068f4:	193b      	adds	r3, r7, r4
 80068f6:	881b      	ldrh	r3, [r3, #0]
 80068f8:	2b00      	cmp	r3, #0
 80068fa:	d101      	bne.n	8006900 <dns_skip_name+0x44>
      return 0xFFFF;
 80068fc:	4b1e      	ldr	r3, [pc, #120]	; (8006978 <dns_skip_name+0xbc>)
 80068fe:	e037      	b.n	8006970 <dns_skip_name+0xb4>
    }
    /** @see RFC 1035 - 4.1.4. Message compression */
    if ((n & 0xc0) == 0xc0) {
 8006900:	68bb      	ldr	r3, [r7, #8]
 8006902:	22c0      	movs	r2, #192	; 0xc0
 8006904:	4013      	ands	r3, r2
 8006906:	2bc0      	cmp	r3, #192	; 0xc0
 8006908:	d024      	beq.n	8006954 <dns_skip_name+0x98>
      /* Compressed name: since we only want to skip it (not check it), stop here */
      break;
    } else {
      /* Not compressed name */
      if (offset + n >= p->tot_len) {
 800690a:	230e      	movs	r3, #14
 800690c:	18fb      	adds	r3, r7, r3
 800690e:	881a      	ldrh	r2, [r3, #0]
 8006910:	68bb      	ldr	r3, [r7, #8]
 8006912:	18d3      	adds	r3, r2, r3
 8006914:	687a      	ldr	r2, [r7, #4]
 8006916:	8912      	ldrh	r2, [r2, #8]
 8006918:	4293      	cmp	r3, r2
 800691a:	db01      	blt.n	8006920 <dns_skip_name+0x64>
        return 0xFFFF;
 800691c:	4b16      	ldr	r3, [pc, #88]	; (8006978 <dns_skip_name+0xbc>)
 800691e:	e027      	b.n	8006970 <dns_skip_name+0xb4>
      }
      offset = (u16_t)(offset + n);
 8006920:	68bb      	ldr	r3, [r7, #8]
 8006922:	b299      	uxth	r1, r3
 8006924:	200e      	movs	r0, #14
 8006926:	183b      	adds	r3, r7, r0
 8006928:	183a      	adds	r2, r7, r0
 800692a:	8812      	ldrh	r2, [r2, #0]
 800692c:	188a      	adds	r2, r1, r2
 800692e:	801a      	strh	r2, [r3, #0]
    }
    n = pbuf_try_get_at(p, offset);
 8006930:	183b      	adds	r3, r7, r0
 8006932:	881a      	ldrh	r2, [r3, #0]
 8006934:	687b      	ldr	r3, [r7, #4]
 8006936:	0011      	movs	r1, r2
 8006938:	0018      	movs	r0, r3
 800693a:	f003 fbe0 	bl	800a0fe <pbuf_try_get_at>
 800693e:	0003      	movs	r3, r0
 8006940:	60bb      	str	r3, [r7, #8]
    if (n < 0) {
 8006942:	68bb      	ldr	r3, [r7, #8]
 8006944:	2b00      	cmp	r3, #0
 8006946:	da01      	bge.n	800694c <dns_skip_name+0x90>
      return 0xFFFF;
 8006948:	4b0b      	ldr	r3, [pc, #44]	; (8006978 <dns_skip_name+0xbc>)
 800694a:	e011      	b.n	8006970 <dns_skip_name+0xb4>
    }
  } while (n != 0);
 800694c:	68bb      	ldr	r3, [r7, #8]
 800694e:	2b00      	cmp	r3, #0
 8006950:	d1c0      	bne.n	80068d4 <dns_skip_name+0x18>
 8006952:	e000      	b.n	8006956 <dns_skip_name+0x9a>
      break;
 8006954:	46c0      	nop			; (mov r8, r8)

  if (offset == 0xFFFF) {
 8006956:	230e      	movs	r3, #14
 8006958:	18fb      	adds	r3, r7, r3
 800695a:	881b      	ldrh	r3, [r3, #0]
 800695c:	4a06      	ldr	r2, [pc, #24]	; (8006978 <dns_skip_name+0xbc>)
 800695e:	4293      	cmp	r3, r2
 8006960:	d101      	bne.n	8006966 <dns_skip_name+0xaa>
    return 0xFFFF;
 8006962:	4b05      	ldr	r3, [pc, #20]	; (8006978 <dns_skip_name+0xbc>)
 8006964:	e004      	b.n	8006970 <dns_skip_name+0xb4>
  }
  return (u16_t)(offset + 1);
 8006966:	230e      	movs	r3, #14
 8006968:	18fb      	adds	r3, r7, r3
 800696a:	881b      	ldrh	r3, [r3, #0]
 800696c:	3301      	adds	r3, #1
 800696e:	b29b      	uxth	r3, r3
}
 8006970:	0018      	movs	r0, r3
 8006972:	46bd      	mov	sp, r7
 8006974:	b005      	add	sp, #20
 8006976:	bd90      	pop	{r4, r7, pc}
 8006978:	0000ffff 	.word	0x0000ffff

0800697c <dns_send>:
 * @param idx the DNS table entry index for which to send a request
 * @return ERR_OK if packet is sent; an err_t indicating the problem otherwise
 */
static err_t
dns_send(u8_t idx)
{
 800697c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800697e:	b091      	sub	sp, #68	; 0x44
 8006980:	af00      	add	r7, sp, #0
 8006982:	0002      	movs	r2, r0
 8006984:	1dfb      	adds	r3, r7, #7
 8006986:	701a      	strb	r2, [r3, #0]
  struct pbuf *p;
  u16_t query_idx, copy_len;
  const char *hostname, *hostname_part;
  u8_t n;
  u8_t pcb_idx;
  struct dns_table_entry *entry = &dns_table[idx];
 8006988:	1dfb      	adds	r3, r7, #7
 800698a:	781a      	ldrb	r2, [r3, #0]
 800698c:	0013      	movs	r3, r2
 800698e:	00db      	lsls	r3, r3, #3
 8006990:	189b      	adds	r3, r3, r2
 8006992:	011b      	lsls	r3, r3, #4
 8006994:	4a7e      	ldr	r2, [pc, #504]	; (8006b90 <dns_send+0x214>)
 8006996:	189b      	adds	r3, r3, r2
 8006998:	633b      	str	r3, [r7, #48]	; 0x30

  LWIP_DEBUGF(DNS_DEBUG, ("dns_send: dns_servers[%"U16_F"] \"%s\": request\n",
                          (u16_t)(entry->server_idx), entry->name));
  LWIP_ASSERT("dns server out of array", entry->server_idx < DNS_MAX_SERVERS);
 800699a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800699c:	7adb      	ldrb	r3, [r3, #11]
 800699e:	2b01      	cmp	r3, #1
 80069a0:	d905      	bls.n	80069ae <dns_send+0x32>
 80069a2:	4b7c      	ldr	r3, [pc, #496]	; (8006b94 <dns_send+0x218>)
 80069a4:	4a7c      	ldr	r2, [pc, #496]	; (8006b98 <dns_send+0x21c>)
 80069a6:	497d      	ldr	r1, [pc, #500]	; (8006b9c <dns_send+0x220>)
 80069a8:	487d      	ldr	r0, [pc, #500]	; (8006ba0 <dns_send+0x224>)
 80069aa:	f7fb fc0f 	bl	80021cc <app_debug_rtt_raw>
  if (ip_addr_isany_val(dns_servers[entry->server_idx])
 80069ae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80069b0:	7adb      	ldrb	r3, [r3, #11]
 80069b2:	001a      	movs	r2, r3
 80069b4:	4b7b      	ldr	r3, [pc, #492]	; (8006ba4 <dns_send+0x228>)
 80069b6:	0092      	lsls	r2, r2, #2
 80069b8:	58d3      	ldr	r3, [r2, r3]
 80069ba:	2b00      	cmp	r3, #0
 80069bc:	d10a      	bne.n	80069d4 <dns_send+0x58>
      && !entry->is_mdns
#endif
     ) {
    /* DNS server not valid anymore, e.g. PPP netif has been shut down */
    /* call specified callback function if provided */
    dns_call_found(idx, NULL);
 80069be:	1dfb      	adds	r3, r7, #7
 80069c0:	781b      	ldrb	r3, [r3, #0]
 80069c2:	2100      	movs	r1, #0
 80069c4:	0018      	movs	r0, r3
 80069c6:	f000 f9a3 	bl	8006d10 <dns_call_found>
    /* flush this entry */
    entry->state = DNS_STATE_UNUSED;
 80069ca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80069cc:	2200      	movs	r2, #0
 80069ce:	729a      	strb	r2, [r3, #10]
    return ERR_OK;
 80069d0:	2300      	movs	r3, #0
 80069d2:	e0d8      	b.n	8006b86 <dns_send+0x20a>
  }

  /* if here, we have either a new query or a retry on a previous query to process */
  p = pbuf_alloc(PBUF_TRANSPORT, (u16_t)(SIZEOF_DNS_HDR + strlen(entry->name) + 2 +
 80069d4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80069d6:	3310      	adds	r3, #16
 80069d8:	0018      	movs	r0, r3
 80069da:	f7f9 fb95 	bl	8000108 <strlen>
 80069de:	0003      	movs	r3, r0
 80069e0:	b29b      	uxth	r3, r3
 80069e2:	3312      	adds	r3, #18
 80069e4:	b29b      	uxth	r3, r3
 80069e6:	22a0      	movs	r2, #160	; 0xa0
 80069e8:	0092      	lsls	r2, r2, #2
 80069ea:	0019      	movs	r1, r3
 80069ec:	2038      	movs	r0, #56	; 0x38
 80069ee:	f002 fad9 	bl	8008fa4 <pbuf_alloc>
 80069f2:	0003      	movs	r3, r0
 80069f4:	62fb      	str	r3, [r7, #44]	; 0x2c
                                         SIZEOF_DNS_QUERY), PBUF_RAM);
  if (p != NULL) {
 80069f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80069f8:	2b00      	cmp	r3, #0
 80069fa:	d100      	bne.n	80069fe <dns_send+0x82>
 80069fc:	e0b3      	b.n	8006b66 <dns_send+0x1ea>
    const ip_addr_t *dst;
    u16_t dst_port;
    /* fill dns header */
    memset(&hdr, 0, SIZEOF_DNS_HDR);
 80069fe:	2410      	movs	r4, #16
 8006a00:	193b      	adds	r3, r7, r4
 8006a02:	220c      	movs	r2, #12
 8006a04:	2100      	movs	r1, #0
 8006a06:	0018      	movs	r0, r3
 8006a08:	f015 ff10 	bl	801c82c <memset>
    hdr.id = lwip_htons(entry->txid);
 8006a0c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8006a0e:	891b      	ldrh	r3, [r3, #8]
 8006a10:	0018      	movs	r0, r3
 8006a12:	f7ff fd8f 	bl	8006534 <lwip_htons>
 8006a16:	0003      	movs	r3, r0
 8006a18:	001a      	movs	r2, r3
 8006a1a:	193b      	adds	r3, r7, r4
 8006a1c:	801a      	strh	r2, [r3, #0]
    hdr.flags1 = DNS_FLAG1_RD;
 8006a1e:	193b      	adds	r3, r7, r4
 8006a20:	2201      	movs	r2, #1
 8006a22:	709a      	strb	r2, [r3, #2]
    hdr.numquestions = PP_HTONS(1);
 8006a24:	193b      	adds	r3, r7, r4
 8006a26:	2280      	movs	r2, #128	; 0x80
 8006a28:	0052      	lsls	r2, r2, #1
 8006a2a:	809a      	strh	r2, [r3, #4]
    pbuf_take(p, &hdr, SIZEOF_DNS_HDR);
 8006a2c:	1939      	adds	r1, r7, r4
 8006a2e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006a30:	220c      	movs	r2, #12
 8006a32:	0018      	movs	r0, r3
 8006a34:	f003 f9ce 	bl	8009dd4 <pbuf_take>
    hostname = entry->name;
 8006a38:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8006a3a:	3310      	adds	r3, #16
 8006a3c:	63bb      	str	r3, [r7, #56]	; 0x38
    --hostname;
 8006a3e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006a40:	3b01      	subs	r3, #1
 8006a42:	63bb      	str	r3, [r7, #56]	; 0x38

    /* convert hostname into suitable query format. */
    query_idx = SIZEOF_DNS_HDR;
 8006a44:	233c      	movs	r3, #60	; 0x3c
 8006a46:	18fb      	adds	r3, r7, r3
 8006a48:	220c      	movs	r2, #12
 8006a4a:	801a      	strh	r2, [r3, #0]
    do {
      ++hostname;
 8006a4c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006a4e:	3301      	adds	r3, #1
 8006a50:	63bb      	str	r3, [r7, #56]	; 0x38
      hostname_part = hostname;
 8006a52:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006a54:	62bb      	str	r3, [r7, #40]	; 0x28
      for (n = 0; *hostname != '.' && *hostname != 0; ++hostname) {
 8006a56:	2337      	movs	r3, #55	; 0x37
 8006a58:	18fb      	adds	r3, r7, r3
 8006a5a:	2200      	movs	r2, #0
 8006a5c:	701a      	strb	r2, [r3, #0]
 8006a5e:	e008      	b.n	8006a72 <dns_send+0xf6>
        ++n;
 8006a60:	2237      	movs	r2, #55	; 0x37
 8006a62:	18bb      	adds	r3, r7, r2
 8006a64:	18ba      	adds	r2, r7, r2
 8006a66:	7812      	ldrb	r2, [r2, #0]
 8006a68:	3201      	adds	r2, #1
 8006a6a:	701a      	strb	r2, [r3, #0]
      for (n = 0; *hostname != '.' && *hostname != 0; ++hostname) {
 8006a6c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006a6e:	3301      	adds	r3, #1
 8006a70:	63bb      	str	r3, [r7, #56]	; 0x38
 8006a72:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006a74:	781b      	ldrb	r3, [r3, #0]
 8006a76:	2b2e      	cmp	r3, #46	; 0x2e
 8006a78:	d003      	beq.n	8006a82 <dns_send+0x106>
 8006a7a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006a7c:	781b      	ldrb	r3, [r3, #0]
 8006a7e:	2b00      	cmp	r3, #0
 8006a80:	d1ee      	bne.n	8006a60 <dns_send+0xe4>
      }
      copy_len = (u16_t)(hostname - hostname_part);
 8006a82:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8006a84:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006a86:	1ad2      	subs	r2, r2, r3
 8006a88:	2326      	movs	r3, #38	; 0x26
 8006a8a:	18fb      	adds	r3, r7, r3
 8006a8c:	801a      	strh	r2, [r3, #0]
      if (query_idx + n + 1 > 0xFFFF) {
 8006a8e:	253c      	movs	r5, #60	; 0x3c
 8006a90:	197b      	adds	r3, r7, r5
 8006a92:	881a      	ldrh	r2, [r3, #0]
 8006a94:	2637      	movs	r6, #55	; 0x37
 8006a96:	19bb      	adds	r3, r7, r6
 8006a98:	781b      	ldrb	r3, [r3, #0]
 8006a9a:	18d3      	adds	r3, r2, r3
 8006a9c:	4a42      	ldr	r2, [pc, #264]	; (8006ba8 <dns_send+0x22c>)
 8006a9e:	4293      	cmp	r3, r2
 8006aa0:	dc6a      	bgt.n	8006b78 <dns_send+0x1fc>
        /* u16_t overflow */
        goto overflow_return;
      }
      pbuf_put_at(p, query_idx, n);
 8006aa2:	19bb      	adds	r3, r7, r6
 8006aa4:	781a      	ldrb	r2, [r3, #0]
 8006aa6:	197b      	adds	r3, r7, r5
 8006aa8:	8819      	ldrh	r1, [r3, #0]
 8006aaa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006aac:	0018      	movs	r0, r3
 8006aae:	f003 fb4d 	bl	800a14c <pbuf_put_at>
      pbuf_take_at(p, hostname_part, copy_len, (u16_t)(query_idx + 1));
 8006ab2:	197b      	adds	r3, r7, r5
 8006ab4:	881b      	ldrh	r3, [r3, #0]
 8006ab6:	3301      	adds	r3, #1
 8006ab8:	b29c      	uxth	r4, r3
 8006aba:	2326      	movs	r3, #38	; 0x26
 8006abc:	18fb      	adds	r3, r7, r3
 8006abe:	881a      	ldrh	r2, [r3, #0]
 8006ac0:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8006ac2:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8006ac4:	0023      	movs	r3, r4
 8006ac6:	f003 fa15 	bl	8009ef4 <pbuf_take_at>
      query_idx = (u16_t)(query_idx + n + 1);
 8006aca:	19bb      	adds	r3, r7, r6
 8006acc:	781b      	ldrb	r3, [r3, #0]
 8006ace:	b29a      	uxth	r2, r3
 8006ad0:	197b      	adds	r3, r7, r5
 8006ad2:	881b      	ldrh	r3, [r3, #0]
 8006ad4:	18d3      	adds	r3, r2, r3
 8006ad6:	b29a      	uxth	r2, r3
 8006ad8:	197b      	adds	r3, r7, r5
 8006ada:	3201      	adds	r2, #1
 8006adc:	801a      	strh	r2, [r3, #0]
    } while (*hostname != 0);
 8006ade:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006ae0:	781b      	ldrb	r3, [r3, #0]
 8006ae2:	2b00      	cmp	r3, #0
 8006ae4:	d1b2      	bne.n	8006a4c <dns_send+0xd0>
    pbuf_put_at(p, query_idx, 0);
 8006ae6:	197b      	adds	r3, r7, r5
 8006ae8:	8819      	ldrh	r1, [r3, #0]
 8006aea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006aec:	2200      	movs	r2, #0
 8006aee:	0018      	movs	r0, r3
 8006af0:	f003 fb2c 	bl	800a14c <pbuf_put_at>
    query_idx++;
 8006af4:	0029      	movs	r1, r5
 8006af6:	187b      	adds	r3, r7, r1
 8006af8:	881a      	ldrh	r2, [r3, #0]
 8006afa:	187b      	adds	r3, r7, r1
 8006afc:	3201      	adds	r2, #1
 8006afe:	801a      	strh	r2, [r3, #0]

    /* fill dns query */
    if (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype)) {
      qry.type = PP_HTONS(DNS_RRTYPE_AAAA);
    } else {
      qry.type = PP_HTONS(DNS_RRTYPE_A);
 8006b00:	200c      	movs	r0, #12
 8006b02:	183b      	adds	r3, r7, r0
 8006b04:	2280      	movs	r2, #128	; 0x80
 8006b06:	0052      	lsls	r2, r2, #1
 8006b08:	801a      	strh	r2, [r3, #0]
    }
    qry.cls = PP_HTONS(DNS_RRCLASS_IN);
 8006b0a:	183b      	adds	r3, r7, r0
 8006b0c:	2280      	movs	r2, #128	; 0x80
 8006b0e:	0052      	lsls	r2, r2, #1
 8006b10:	805a      	strh	r2, [r3, #2]
    pbuf_take_at(p, &qry, SIZEOF_DNS_QUERY, query_idx);
 8006b12:	187b      	adds	r3, r7, r1
 8006b14:	881b      	ldrh	r3, [r3, #0]
 8006b16:	1839      	adds	r1, r7, r0
 8006b18:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8006b1a:	2204      	movs	r2, #4
 8006b1c:	f003 f9ea 	bl	8009ef4 <pbuf_take_at>

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
    pcb_idx = entry->pcb_idx;
 8006b20:	2125      	movs	r1, #37	; 0x25
 8006b22:	187b      	adds	r3, r7, r1
 8006b24:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8006b26:	7bd2      	ldrb	r2, [r2, #15]
 8006b28:	701a      	strb	r2, [r3, #0]
      }
#endif
    } else
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
    {
      dst_port = DNS_SERVER_PORT;
 8006b2a:	2522      	movs	r5, #34	; 0x22
 8006b2c:	197b      	adds	r3, r7, r5
 8006b2e:	2235      	movs	r2, #53	; 0x35
 8006b30:	801a      	strh	r2, [r3, #0]
      dst = &dns_servers[entry->server_idx];
 8006b32:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8006b34:	7adb      	ldrb	r3, [r3, #11]
 8006b36:	009a      	lsls	r2, r3, #2
 8006b38:	4b1a      	ldr	r3, [pc, #104]	; (8006ba4 <dns_send+0x228>)
 8006b3a:	18d3      	adds	r3, r2, r3
 8006b3c:	61fb      	str	r3, [r7, #28]
    }
    err = udp_sendto(dns_pcbs[pcb_idx], p, dst, dst_port);
 8006b3e:	187b      	adds	r3, r7, r1
 8006b40:	781a      	ldrb	r2, [r3, #0]
 8006b42:	4b1a      	ldr	r3, [pc, #104]	; (8006bac <dns_send+0x230>)
 8006b44:	0092      	lsls	r2, r2, #2
 8006b46:	58d0      	ldr	r0, [r2, r3]
 8006b48:	233f      	movs	r3, #63	; 0x3f
 8006b4a:	18fc      	adds	r4, r7, r3
 8006b4c:	197b      	adds	r3, r7, r5
 8006b4e:	881b      	ldrh	r3, [r3, #0]
 8006b50:	69fa      	ldr	r2, [r7, #28]
 8006b52:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8006b54:	f00b fb40 	bl	80121d8 <udp_sendto>
 8006b58:	0003      	movs	r3, r0
 8006b5a:	7023      	strb	r3, [r4, #0]

    /* free pbuf */
    pbuf_free(p);
 8006b5c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006b5e:	0018      	movs	r0, r3
 8006b60:	f002 fd98 	bl	8009694 <pbuf_free>
 8006b64:	e003      	b.n	8006b6e <dns_send+0x1f2>
  } else {
    err = ERR_MEM;
 8006b66:	233f      	movs	r3, #63	; 0x3f
 8006b68:	18fb      	adds	r3, r7, r3
 8006b6a:	22ff      	movs	r2, #255	; 0xff
 8006b6c:	701a      	strb	r2, [r3, #0]
  }

  return err;
 8006b6e:	233f      	movs	r3, #63	; 0x3f
 8006b70:	18fb      	adds	r3, r7, r3
 8006b72:	781b      	ldrb	r3, [r3, #0]
 8006b74:	b25b      	sxtb	r3, r3
 8006b76:	e006      	b.n	8006b86 <dns_send+0x20a>
        goto overflow_return;
 8006b78:	46c0      	nop			; (mov r8, r8)
overflow_return:
  pbuf_free(p);
 8006b7a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006b7c:	0018      	movs	r0, r3
 8006b7e:	f002 fd89 	bl	8009694 <pbuf_free>
  return ERR_VAL;
 8006b82:	2306      	movs	r3, #6
 8006b84:	425b      	negs	r3, r3
}
 8006b86:	0018      	movs	r0, r3
 8006b88:	46bd      	mov	sp, r7
 8006b8a:	b011      	add	sp, #68	; 0x44
 8006b8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006b8e:	46c0      	nop			; (mov r8, r8)
 8006b90:	20001154 	.word	0x20001154
 8006b94:	0801e5dc 	.word	0x0801e5dc
 8006b98:	000002fa 	.word	0x000002fa
 8006b9c:	0801e604 	.word	0x0801e604
 8006ba0:	0801e61c 	.word	0x0801e61c
 8006ba4:	20001328 	.word	0x20001328
 8006ba8:	0000fffe 	.word	0x0000fffe
 8006bac:	20001144 	.word	0x20001144

08006bb0 <dns_alloc_random_port>:

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
static struct udp_pcb *
dns_alloc_random_port(void)
{
 8006bb0:	b590      	push	{r4, r7, lr}
 8006bb2:	b085      	sub	sp, #20
 8006bb4:	af00      	add	r7, sp, #0
  err_t err;
  struct udp_pcb *pcb;

  pcb = udp_new_ip_type(IPADDR_TYPE_ANY);
 8006bb6:	202e      	movs	r0, #46	; 0x2e
 8006bb8:	f00b fe85 	bl	80128c6 <udp_new_ip_type>
 8006bbc:	0003      	movs	r3, r0
 8006bbe:	60bb      	str	r3, [r7, #8]
  if (pcb == NULL) {
 8006bc0:	68bb      	ldr	r3, [r7, #8]
 8006bc2:	2b00      	cmp	r3, #0
 8006bc4:	d101      	bne.n	8006bca <dns_alloc_random_port+0x1a>
    /* out of memory, have to reuse an existing pcb */
    return NULL;
 8006bc6:	2300      	movs	r3, #0
 8006bc8:	e032      	b.n	8006c30 <dns_alloc_random_port+0x80>
  }
  do {
    u16_t port = (u16_t)DNS_RAND_TXID();
 8006bca:	f015 fdaf 	bl	801c72c <sys_rand>
 8006bce:	0002      	movs	r2, r0
 8006bd0:	1dbb      	adds	r3, r7, #6
 8006bd2:	801a      	strh	r2, [r3, #0]
    if (DNS_PORT_ALLOWED(port)) {
 8006bd4:	1dbb      	adds	r3, r7, #6
 8006bd6:	881a      	ldrh	r2, [r3, #0]
 8006bd8:	2380      	movs	r3, #128	; 0x80
 8006bda:	00db      	lsls	r3, r3, #3
 8006bdc:	429a      	cmp	r2, r3
 8006bde:	d30b      	bcc.n	8006bf8 <dns_alloc_random_port+0x48>
      err = udp_bind(pcb, IP_ANY_TYPE, port);
 8006be0:	230f      	movs	r3, #15
 8006be2:	18fc      	adds	r4, r7, r3
 8006be4:	1dbb      	adds	r3, r7, #6
 8006be6:	881a      	ldrh	r2, [r3, #0]
 8006be8:	4913      	ldr	r1, [pc, #76]	; (8006c38 <dns_alloc_random_port+0x88>)
 8006bea:	68bb      	ldr	r3, [r7, #8]
 8006bec:	0018      	movs	r0, r3
 8006bee:	f00b fd63 	bl	80126b8 <udp_bind>
 8006bf2:	0003      	movs	r3, r0
 8006bf4:	7023      	strb	r3, [r4, #0]
 8006bf6:	e003      	b.n	8006c00 <dns_alloc_random_port+0x50>
    } else {
      /* this port is not allowed, try again */
      err = ERR_USE;
 8006bf8:	230f      	movs	r3, #15
 8006bfa:	18fb      	adds	r3, r7, r3
 8006bfc:	22f8      	movs	r2, #248	; 0xf8
 8006bfe:	701a      	strb	r2, [r3, #0]
    }
  } while (err == ERR_USE);
 8006c00:	220f      	movs	r2, #15
 8006c02:	18bb      	adds	r3, r7, r2
 8006c04:	781b      	ldrb	r3, [r3, #0]
 8006c06:	b25b      	sxtb	r3, r3
 8006c08:	3308      	adds	r3, #8
 8006c0a:	d0de      	beq.n	8006bca <dns_alloc_random_port+0x1a>
  if (err != ERR_OK) {
 8006c0c:	18bb      	adds	r3, r7, r2
 8006c0e:	781b      	ldrb	r3, [r3, #0]
 8006c10:	b25b      	sxtb	r3, r3
 8006c12:	2b00      	cmp	r3, #0
 8006c14:	d005      	beq.n	8006c22 <dns_alloc_random_port+0x72>
    udp_remove(pcb);
 8006c16:	68bb      	ldr	r3, [r7, #8]
 8006c18:	0018      	movs	r0, r3
 8006c1a:	f00b fdff 	bl	801281c <udp_remove>
    return NULL;
 8006c1e:	2300      	movs	r3, #0
 8006c20:	e006      	b.n	8006c30 <dns_alloc_random_port+0x80>
  }
  udp_recv(pcb, dns_recv, NULL);
 8006c22:	4906      	ldr	r1, [pc, #24]	; (8006c3c <dns_alloc_random_port+0x8c>)
 8006c24:	68bb      	ldr	r3, [r7, #8]
 8006c26:	2200      	movs	r2, #0
 8006c28:	0018      	movs	r0, r3
 8006c2a:	f00b fddd 	bl	80127e8 <udp_recv>
  return pcb;
 8006c2e:	68bb      	ldr	r3, [r7, #8]
}
 8006c30:	0018      	movs	r0, r3
 8006c32:	46bd      	mov	sp, r7
 8006c34:	b005      	add	sp, #20
 8006c36:	bd90      	pop	{r4, r7, pc}
 8006c38:	08021a50 	.word	0x08021a50
 8006c3c:	08007191 	.word	0x08007191

08006c40 <dns_alloc_pcb>:
 *
 * @return an index into dns_pcbs
 */
static u8_t
dns_alloc_pcb(void)
{
 8006c40:	b590      	push	{r4, r7, lr}
 8006c42:	b083      	sub	sp, #12
 8006c44:	af00      	add	r7, sp, #0
  u8_t i;
  u8_t idx;

  for (i = 0; i < DNS_MAX_SOURCE_PORTS; i++) {
 8006c46:	1dfb      	adds	r3, r7, #7
 8006c48:	2200      	movs	r2, #0
 8006c4a:	701a      	strb	r2, [r3, #0]
 8006c4c:	e00b      	b.n	8006c66 <dns_alloc_pcb+0x26>
    if (dns_pcbs[i] == NULL) {
 8006c4e:	1dfb      	adds	r3, r7, #7
 8006c50:	781a      	ldrb	r2, [r3, #0]
 8006c52:	4b2d      	ldr	r3, [pc, #180]	; (8006d08 <dns_alloc_pcb+0xc8>)
 8006c54:	0092      	lsls	r2, r2, #2
 8006c56:	58d3      	ldr	r3, [r2, r3]
 8006c58:	2b00      	cmp	r3, #0
 8006c5a:	d009      	beq.n	8006c70 <dns_alloc_pcb+0x30>
  for (i = 0; i < DNS_MAX_SOURCE_PORTS; i++) {
 8006c5c:	1dfb      	adds	r3, r7, #7
 8006c5e:	781a      	ldrb	r2, [r3, #0]
 8006c60:	1dfb      	adds	r3, r7, #7
 8006c62:	3201      	adds	r2, #1
 8006c64:	701a      	strb	r2, [r3, #0]
 8006c66:	1dfb      	adds	r3, r7, #7
 8006c68:	781b      	ldrb	r3, [r3, #0]
 8006c6a:	2b02      	cmp	r3, #2
 8006c6c:	d9ef      	bls.n	8006c4e <dns_alloc_pcb+0xe>
 8006c6e:	e000      	b.n	8006c72 <dns_alloc_pcb+0x32>
      break;
 8006c70:	46c0      	nop			; (mov r8, r8)
    }
  }
  if (i < DNS_MAX_SOURCE_PORTS) {
 8006c72:	1dfb      	adds	r3, r7, #7
 8006c74:	781b      	ldrb	r3, [r3, #0]
 8006c76:	2b02      	cmp	r3, #2
 8006c78:	d815      	bhi.n	8006ca6 <dns_alloc_pcb+0x66>
    dns_pcbs[i] = dns_alloc_random_port();
 8006c7a:	1dfb      	adds	r3, r7, #7
 8006c7c:	781c      	ldrb	r4, [r3, #0]
 8006c7e:	f7ff ff97 	bl	8006bb0 <dns_alloc_random_port>
 8006c82:	0001      	movs	r1, r0
 8006c84:	4b20      	ldr	r3, [pc, #128]	; (8006d08 <dns_alloc_pcb+0xc8>)
 8006c86:	00a2      	lsls	r2, r4, #2
 8006c88:	50d1      	str	r1, [r2, r3]
    if (dns_pcbs[i] != NULL) {
 8006c8a:	1dfb      	adds	r3, r7, #7
 8006c8c:	781a      	ldrb	r2, [r3, #0]
 8006c8e:	4b1e      	ldr	r3, [pc, #120]	; (8006d08 <dns_alloc_pcb+0xc8>)
 8006c90:	0092      	lsls	r2, r2, #2
 8006c92:	58d3      	ldr	r3, [r2, r3]
 8006c94:	2b00      	cmp	r3, #0
 8006c96:	d006      	beq.n	8006ca6 <dns_alloc_pcb+0x66>
      /* succeeded */
      dns_last_pcb_idx = i;
 8006c98:	4b1c      	ldr	r3, [pc, #112]	; (8006d0c <dns_alloc_pcb+0xcc>)
 8006c9a:	1dfa      	adds	r2, r7, #7
 8006c9c:	7812      	ldrb	r2, [r2, #0]
 8006c9e:	701a      	strb	r2, [r3, #0]
      return i;
 8006ca0:	1dfb      	adds	r3, r7, #7
 8006ca2:	781b      	ldrb	r3, [r3, #0]
 8006ca4:	e02c      	b.n	8006d00 <dns_alloc_pcb+0xc0>
    }
  }
  /* if we come here, creating a new UDP pcb failed, so we have to use
     an already existing one (so overflow is no issue) */
  for (i = 0, idx = (u8_t)(dns_last_pcb_idx + 1); i < DNS_MAX_SOURCE_PORTS; i++, idx++) {
 8006ca6:	1dfb      	adds	r3, r7, #7
 8006ca8:	2200      	movs	r2, #0
 8006caa:	701a      	strb	r2, [r3, #0]
 8006cac:	4b17      	ldr	r3, [pc, #92]	; (8006d0c <dns_alloc_pcb+0xcc>)
 8006cae:	781a      	ldrb	r2, [r3, #0]
 8006cb0:	1dbb      	adds	r3, r7, #6
 8006cb2:	3201      	adds	r2, #1
 8006cb4:	701a      	strb	r2, [r3, #0]
 8006cb6:	e01e      	b.n	8006cf6 <dns_alloc_pcb+0xb6>
    if (idx >= DNS_MAX_SOURCE_PORTS) {
 8006cb8:	1dbb      	adds	r3, r7, #6
 8006cba:	781b      	ldrb	r3, [r3, #0]
 8006cbc:	2b02      	cmp	r3, #2
 8006cbe:	d902      	bls.n	8006cc6 <dns_alloc_pcb+0x86>
      idx = 0;
 8006cc0:	1dbb      	adds	r3, r7, #6
 8006cc2:	2200      	movs	r2, #0
 8006cc4:	701a      	strb	r2, [r3, #0]
    }
    if (dns_pcbs[idx] != NULL) {
 8006cc6:	1dbb      	adds	r3, r7, #6
 8006cc8:	781a      	ldrb	r2, [r3, #0]
 8006cca:	4b0f      	ldr	r3, [pc, #60]	; (8006d08 <dns_alloc_pcb+0xc8>)
 8006ccc:	0092      	lsls	r2, r2, #2
 8006cce:	58d3      	ldr	r3, [r2, r3]
 8006cd0:	2b00      	cmp	r3, #0
 8006cd2:	d006      	beq.n	8006ce2 <dns_alloc_pcb+0xa2>
      dns_last_pcb_idx = idx;
 8006cd4:	4b0d      	ldr	r3, [pc, #52]	; (8006d0c <dns_alloc_pcb+0xcc>)
 8006cd6:	1dba      	adds	r2, r7, #6
 8006cd8:	7812      	ldrb	r2, [r2, #0]
 8006cda:	701a      	strb	r2, [r3, #0]
      return idx;
 8006cdc:	1dbb      	adds	r3, r7, #6
 8006cde:	781b      	ldrb	r3, [r3, #0]
 8006ce0:	e00e      	b.n	8006d00 <dns_alloc_pcb+0xc0>
  for (i = 0, idx = (u8_t)(dns_last_pcb_idx + 1); i < DNS_MAX_SOURCE_PORTS; i++, idx++) {
 8006ce2:	1dfb      	adds	r3, r7, #7
 8006ce4:	781a      	ldrb	r2, [r3, #0]
 8006ce6:	1dfb      	adds	r3, r7, #7
 8006ce8:	3201      	adds	r2, #1
 8006cea:	701a      	strb	r2, [r3, #0]
 8006cec:	1dbb      	adds	r3, r7, #6
 8006cee:	781a      	ldrb	r2, [r3, #0]
 8006cf0:	1dbb      	adds	r3, r7, #6
 8006cf2:	3201      	adds	r2, #1
 8006cf4:	701a      	strb	r2, [r3, #0]
 8006cf6:	1dfb      	adds	r3, r7, #7
 8006cf8:	781b      	ldrb	r3, [r3, #0]
 8006cfa:	2b02      	cmp	r3, #2
 8006cfc:	d9dc      	bls.n	8006cb8 <dns_alloc_pcb+0x78>
    }
  }
  return DNS_MAX_SOURCE_PORTS;
 8006cfe:	2303      	movs	r3, #3
}
 8006d00:	0018      	movs	r0, r3
 8006d02:	46bd      	mov	sp, r7
 8006d04:	b003      	add	sp, #12
 8006d06:	bd90      	pop	{r4, r7, pc}
 8006d08:	20001144 	.word	0x20001144
 8006d0c:	20001150 	.word	0x20001150

08006d10 <dns_call_found>:
 * @param idx dns table index of the entry that is resolved or removed
 * @param addr IP address for the hostname (or NULL on error or memory shortage)
 */
static void
dns_call_found(u8_t idx, ip_addr_t *addr)
{
 8006d10:	b5b0      	push	{r4, r5, r7, lr}
 8006d12:	b084      	sub	sp, #16
 8006d14:	af00      	add	r7, sp, #0
 8006d16:	0002      	movs	r2, r0
 8006d18:	6039      	str	r1, [r7, #0]
 8006d1a:	1dfb      	adds	r3, r7, #7
 8006d1c:	701a      	strb	r2, [r3, #0]
    }
  }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 8006d1e:	230f      	movs	r3, #15
 8006d20:	18fb      	adds	r3, r7, r3
 8006d22:	2200      	movs	r2, #0
 8006d24:	701a      	strb	r2, [r3, #0]
 8006d26:	e046      	b.n	8006db6 <dns_call_found+0xa6>
    if (dns_requests[i].found && (dns_requests[i].dns_table_idx == idx)) {
 8006d28:	250f      	movs	r5, #15
 8006d2a:	197b      	adds	r3, r7, r5
 8006d2c:	781a      	ldrb	r2, [r3, #0]
 8006d2e:	4964      	ldr	r1, [pc, #400]	; (8006ec0 <dns_call_found+0x1b0>)
 8006d30:	0013      	movs	r3, r2
 8006d32:	005b      	lsls	r3, r3, #1
 8006d34:	189b      	adds	r3, r3, r2
 8006d36:	009b      	lsls	r3, r3, #2
 8006d38:	585b      	ldr	r3, [r3, r1]
 8006d3a:	2b00      	cmp	r3, #0
 8006d3c:	d035      	beq.n	8006daa <dns_call_found+0x9a>
 8006d3e:	197b      	adds	r3, r7, r5
 8006d40:	781a      	ldrb	r2, [r3, #0]
 8006d42:	495f      	ldr	r1, [pc, #380]	; (8006ec0 <dns_call_found+0x1b0>)
 8006d44:	0013      	movs	r3, r2
 8006d46:	005b      	lsls	r3, r3, #1
 8006d48:	189b      	adds	r3, r3, r2
 8006d4a:	009b      	lsls	r3, r3, #2
 8006d4c:	18cb      	adds	r3, r1, r3
 8006d4e:	3308      	adds	r3, #8
 8006d50:	781b      	ldrb	r3, [r3, #0]
 8006d52:	1dfa      	adds	r2, r7, #7
 8006d54:	7812      	ldrb	r2, [r2, #0]
 8006d56:	429a      	cmp	r2, r3
 8006d58:	d127      	bne.n	8006daa <dns_call_found+0x9a>
      (*dns_requests[i].found)(dns_table[idx].name, addr, dns_requests[i].arg);
 8006d5a:	197b      	adds	r3, r7, r5
 8006d5c:	781a      	ldrb	r2, [r3, #0]
 8006d5e:	4958      	ldr	r1, [pc, #352]	; (8006ec0 <dns_call_found+0x1b0>)
 8006d60:	0013      	movs	r3, r2
 8006d62:	005b      	lsls	r3, r3, #1
 8006d64:	189b      	adds	r3, r3, r2
 8006d66:	009b      	lsls	r3, r3, #2
 8006d68:	585c      	ldr	r4, [r3, r1]
 8006d6a:	1dfb      	adds	r3, r7, #7
 8006d6c:	781a      	ldrb	r2, [r3, #0]
 8006d6e:	0013      	movs	r3, r2
 8006d70:	00db      	lsls	r3, r3, #3
 8006d72:	189b      	adds	r3, r3, r2
 8006d74:	011b      	lsls	r3, r3, #4
 8006d76:	3310      	adds	r3, #16
 8006d78:	001a      	movs	r2, r3
 8006d7a:	4b52      	ldr	r3, [pc, #328]	; (8006ec4 <dns_call_found+0x1b4>)
 8006d7c:	18d0      	adds	r0, r2, r3
 8006d7e:	197b      	adds	r3, r7, r5
 8006d80:	781a      	ldrb	r2, [r3, #0]
 8006d82:	494f      	ldr	r1, [pc, #316]	; (8006ec0 <dns_call_found+0x1b0>)
 8006d84:	0013      	movs	r3, r2
 8006d86:	005b      	lsls	r3, r3, #1
 8006d88:	189b      	adds	r3, r3, r2
 8006d8a:	009b      	lsls	r3, r3, #2
 8006d8c:	18cb      	adds	r3, r1, r3
 8006d8e:	3304      	adds	r3, #4
 8006d90:	681a      	ldr	r2, [r3, #0]
 8006d92:	683b      	ldr	r3, [r7, #0]
 8006d94:	0019      	movs	r1, r3
 8006d96:	47a0      	blx	r4
      /* flush this entry */
      dns_requests[i].found = NULL;
 8006d98:	197b      	adds	r3, r7, r5
 8006d9a:	781a      	ldrb	r2, [r3, #0]
 8006d9c:	4948      	ldr	r1, [pc, #288]	; (8006ec0 <dns_call_found+0x1b0>)
 8006d9e:	0013      	movs	r3, r2
 8006da0:	005b      	lsls	r3, r3, #1
 8006da2:	189b      	adds	r3, r3, r2
 8006da4:	009b      	lsls	r3, r3, #2
 8006da6:	2200      	movs	r2, #0
 8006da8:	505a      	str	r2, [r3, r1]
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 8006daa:	210f      	movs	r1, #15
 8006dac:	187b      	adds	r3, r7, r1
 8006dae:	781a      	ldrb	r2, [r3, #0]
 8006db0:	187b      	adds	r3, r7, r1
 8006db2:	3201      	adds	r2, #1
 8006db4:	701a      	strb	r2, [r3, #0]
 8006db6:	220f      	movs	r2, #15
 8006db8:	18bb      	adds	r3, r7, r2
 8006dba:	781b      	ldrb	r3, [r3, #0]
 8006dbc:	2b02      	cmp	r3, #2
 8006dbe:	d9b3      	bls.n	8006d28 <dns_call_found+0x18>
  }
  dns_requests[idx].found = NULL;
#endif
#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
  /* close the pcb used unless other request are using it */
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 8006dc0:	18bb      	adds	r3, r7, r2
 8006dc2:	2200      	movs	r2, #0
 8006dc4:	701a      	strb	r2, [r3, #0]
 8006dc6:	e03b      	b.n	8006e40 <dns_call_found+0x130>
    if (i == idx) {
 8006dc8:	200f      	movs	r0, #15
 8006dca:	183a      	adds	r2, r7, r0
 8006dcc:	1dfb      	adds	r3, r7, #7
 8006dce:	7812      	ldrb	r2, [r2, #0]
 8006dd0:	781b      	ldrb	r3, [r3, #0]
 8006dd2:	429a      	cmp	r2, r3
 8006dd4:	d02d      	beq.n	8006e32 <dns_call_found+0x122>
      continue; /* only check other requests */
    }
    if (dns_table[i].state == DNS_STATE_ASKING) {
 8006dd6:	183b      	adds	r3, r7, r0
 8006dd8:	781a      	ldrb	r2, [r3, #0]
 8006dda:	493a      	ldr	r1, [pc, #232]	; (8006ec4 <dns_call_found+0x1b4>)
 8006ddc:	0013      	movs	r3, r2
 8006dde:	00db      	lsls	r3, r3, #3
 8006de0:	189b      	adds	r3, r3, r2
 8006de2:	011b      	lsls	r3, r3, #4
 8006de4:	18cb      	adds	r3, r1, r3
 8006de6:	330a      	adds	r3, #10
 8006de8:	781b      	ldrb	r3, [r3, #0]
 8006dea:	2b02      	cmp	r3, #2
 8006dec:	d122      	bne.n	8006e34 <dns_call_found+0x124>
      if (dns_table[i].pcb_idx == dns_table[idx].pcb_idx) {
 8006dee:	183b      	adds	r3, r7, r0
 8006df0:	781a      	ldrb	r2, [r3, #0]
 8006df2:	4934      	ldr	r1, [pc, #208]	; (8006ec4 <dns_call_found+0x1b4>)
 8006df4:	0013      	movs	r3, r2
 8006df6:	00db      	lsls	r3, r3, #3
 8006df8:	189b      	adds	r3, r3, r2
 8006dfa:	011b      	lsls	r3, r3, #4
 8006dfc:	18cb      	adds	r3, r1, r3
 8006dfe:	330f      	adds	r3, #15
 8006e00:	7819      	ldrb	r1, [r3, #0]
 8006e02:	1dfb      	adds	r3, r7, #7
 8006e04:	781a      	ldrb	r2, [r3, #0]
 8006e06:	482f      	ldr	r0, [pc, #188]	; (8006ec4 <dns_call_found+0x1b4>)
 8006e08:	0013      	movs	r3, r2
 8006e0a:	00db      	lsls	r3, r3, #3
 8006e0c:	189b      	adds	r3, r3, r2
 8006e0e:	011b      	lsls	r3, r3, #4
 8006e10:	18c3      	adds	r3, r0, r3
 8006e12:	330f      	adds	r3, #15
 8006e14:	781b      	ldrb	r3, [r3, #0]
 8006e16:	4299      	cmp	r1, r3
 8006e18:	d10c      	bne.n	8006e34 <dns_call_found+0x124>
        /* another request is still using the same pcb */
        dns_table[idx].pcb_idx = DNS_MAX_SOURCE_PORTS;
 8006e1a:	1dfb      	adds	r3, r7, #7
 8006e1c:	781a      	ldrb	r2, [r3, #0]
 8006e1e:	4929      	ldr	r1, [pc, #164]	; (8006ec4 <dns_call_found+0x1b4>)
 8006e20:	0013      	movs	r3, r2
 8006e22:	00db      	lsls	r3, r3, #3
 8006e24:	189b      	adds	r3, r3, r2
 8006e26:	011b      	lsls	r3, r3, #4
 8006e28:	18cb      	adds	r3, r1, r3
 8006e2a:	330f      	adds	r3, #15
 8006e2c:	2203      	movs	r2, #3
 8006e2e:	701a      	strb	r2, [r3, #0]
        break;
 8006e30:	e00b      	b.n	8006e4a <dns_call_found+0x13a>
      continue; /* only check other requests */
 8006e32:	46c0      	nop			; (mov r8, r8)
  for (i = 0; i < DNS_MAX_REQUESTS; i++) {
 8006e34:	210f      	movs	r1, #15
 8006e36:	187b      	adds	r3, r7, r1
 8006e38:	781a      	ldrb	r2, [r3, #0]
 8006e3a:	187b      	adds	r3, r7, r1
 8006e3c:	3201      	adds	r2, #1
 8006e3e:	701a      	strb	r2, [r3, #0]
 8006e40:	230f      	movs	r3, #15
 8006e42:	18fb      	adds	r3, r7, r3
 8006e44:	781b      	ldrb	r3, [r3, #0]
 8006e46:	2b02      	cmp	r3, #2
 8006e48:	d9be      	bls.n	8006dc8 <dns_call_found+0xb8>
      }
    }
  }
  if (dns_table[idx].pcb_idx < DNS_MAX_SOURCE_PORTS) {
 8006e4a:	1dfb      	adds	r3, r7, #7
 8006e4c:	781a      	ldrb	r2, [r3, #0]
 8006e4e:	491d      	ldr	r1, [pc, #116]	; (8006ec4 <dns_call_found+0x1b4>)
 8006e50:	0013      	movs	r3, r2
 8006e52:	00db      	lsls	r3, r3, #3
 8006e54:	189b      	adds	r3, r3, r2
 8006e56:	011b      	lsls	r3, r3, #4
 8006e58:	18cb      	adds	r3, r1, r3
 8006e5a:	330f      	adds	r3, #15
 8006e5c:	781b      	ldrb	r3, [r3, #0]
 8006e5e:	2b02      	cmp	r3, #2
 8006e60:	d82a      	bhi.n	8006eb8 <dns_call_found+0x1a8>
    /* if we come here, the pcb is not used any more and can be removed */
    udp_remove(dns_pcbs[dns_table[idx].pcb_idx]);
 8006e62:	1dfb      	adds	r3, r7, #7
 8006e64:	781a      	ldrb	r2, [r3, #0]
 8006e66:	4917      	ldr	r1, [pc, #92]	; (8006ec4 <dns_call_found+0x1b4>)
 8006e68:	0013      	movs	r3, r2
 8006e6a:	00db      	lsls	r3, r3, #3
 8006e6c:	189b      	adds	r3, r3, r2
 8006e6e:	011b      	lsls	r3, r3, #4
 8006e70:	18cb      	adds	r3, r1, r3
 8006e72:	330f      	adds	r3, #15
 8006e74:	781b      	ldrb	r3, [r3, #0]
 8006e76:	001a      	movs	r2, r3
 8006e78:	4b13      	ldr	r3, [pc, #76]	; (8006ec8 <dns_call_found+0x1b8>)
 8006e7a:	0092      	lsls	r2, r2, #2
 8006e7c:	58d3      	ldr	r3, [r2, r3]
 8006e7e:	0018      	movs	r0, r3
 8006e80:	f00b fccc 	bl	801281c <udp_remove>
    dns_pcbs[dns_table[idx].pcb_idx] = NULL;
 8006e84:	1dfb      	adds	r3, r7, #7
 8006e86:	781a      	ldrb	r2, [r3, #0]
 8006e88:	490e      	ldr	r1, [pc, #56]	; (8006ec4 <dns_call_found+0x1b4>)
 8006e8a:	0013      	movs	r3, r2
 8006e8c:	00db      	lsls	r3, r3, #3
 8006e8e:	189b      	adds	r3, r3, r2
 8006e90:	011b      	lsls	r3, r3, #4
 8006e92:	18cb      	adds	r3, r1, r3
 8006e94:	330f      	adds	r3, #15
 8006e96:	781b      	ldrb	r3, [r3, #0]
 8006e98:	001a      	movs	r2, r3
 8006e9a:	4b0b      	ldr	r3, [pc, #44]	; (8006ec8 <dns_call_found+0x1b8>)
 8006e9c:	0092      	lsls	r2, r2, #2
 8006e9e:	2100      	movs	r1, #0
 8006ea0:	50d1      	str	r1, [r2, r3]
    dns_table[idx].pcb_idx = DNS_MAX_SOURCE_PORTS;
 8006ea2:	1dfb      	adds	r3, r7, #7
 8006ea4:	781a      	ldrb	r2, [r3, #0]
 8006ea6:	4907      	ldr	r1, [pc, #28]	; (8006ec4 <dns_call_found+0x1b4>)
 8006ea8:	0013      	movs	r3, r2
 8006eaa:	00db      	lsls	r3, r3, #3
 8006eac:	189b      	adds	r3, r3, r2
 8006eae:	011b      	lsls	r3, r3, #4
 8006eb0:	18cb      	adds	r3, r1, r3
 8006eb2:	330f      	adds	r3, #15
 8006eb4:	2203      	movs	r2, #3
 8006eb6:	701a      	strb	r2, [r3, #0]
  }
#endif
}
 8006eb8:	46c0      	nop			; (mov r8, r8)
 8006eba:	46bd      	mov	sp, r7
 8006ebc:	b004      	add	sp, #16
 8006ebe:	bdb0      	pop	{r4, r5, r7, pc}
 8006ec0:	20001304 	.word	0x20001304
 8006ec4:	20001154 	.word	0x20001154
 8006ec8:	20001144 	.word	0x20001144

08006ecc <dns_create_txid>:

/* Create a query transmission ID that is unique for all outstanding queries */
static u16_t
dns_create_txid(void)
{
 8006ecc:	b580      	push	{r7, lr}
 8006ece:	b082      	sub	sp, #8
 8006ed0:	af00      	add	r7, sp, #0
  u16_t txid;
  u8_t i;

again:
  txid = (u16_t)DNS_RAND_TXID();
 8006ed2:	f015 fc2b 	bl	801c72c <sys_rand>
 8006ed6:	0002      	movs	r2, r0
 8006ed8:	1d3b      	adds	r3, r7, #4
 8006eda:	801a      	strh	r2, [r3, #0]

  /* check whether the ID is unique */
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
 8006edc:	1dfb      	adds	r3, r7, #7
 8006ede:	2200      	movs	r2, #0
 8006ee0:	701a      	strb	r2, [r3, #0]
 8006ee2:	e01f      	b.n	8006f24 <dns_create_txid+0x58>
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
 8006ee4:	1dfb      	adds	r3, r7, #7
 8006ee6:	781a      	ldrb	r2, [r3, #0]
 8006ee8:	4913      	ldr	r1, [pc, #76]	; (8006f38 <dns_create_txid+0x6c>)
 8006eea:	0013      	movs	r3, r2
 8006eec:	00db      	lsls	r3, r3, #3
 8006eee:	189b      	adds	r3, r3, r2
 8006ef0:	011b      	lsls	r3, r3, #4
 8006ef2:	18cb      	adds	r3, r1, r3
 8006ef4:	330a      	adds	r3, #10
 8006ef6:	781b      	ldrb	r3, [r3, #0]
 8006ef8:	2b02      	cmp	r3, #2
 8006efa:	d10e      	bne.n	8006f1a <dns_create_txid+0x4e>
        (dns_table[i].txid == txid)) {
 8006efc:	1dfb      	adds	r3, r7, #7
 8006efe:	781a      	ldrb	r2, [r3, #0]
 8006f00:	490d      	ldr	r1, [pc, #52]	; (8006f38 <dns_create_txid+0x6c>)
 8006f02:	0013      	movs	r3, r2
 8006f04:	00db      	lsls	r3, r3, #3
 8006f06:	189b      	adds	r3, r3, r2
 8006f08:	011b      	lsls	r3, r3, #4
 8006f0a:	18cb      	adds	r3, r1, r3
 8006f0c:	3308      	adds	r3, #8
 8006f0e:	881b      	ldrh	r3, [r3, #0]
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
 8006f10:	1d3a      	adds	r2, r7, #4
 8006f12:	8812      	ldrh	r2, [r2, #0]
 8006f14:	429a      	cmp	r2, r3
 8006f16:	d100      	bne.n	8006f1a <dns_create_txid+0x4e>
      /* ID already used by another pending query */
      goto again;
 8006f18:	e7db      	b.n	8006ed2 <dns_create_txid+0x6>
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
 8006f1a:	1dfb      	adds	r3, r7, #7
 8006f1c:	781a      	ldrb	r2, [r3, #0]
 8006f1e:	1dfb      	adds	r3, r7, #7
 8006f20:	3201      	adds	r2, #1
 8006f22:	701a      	strb	r2, [r3, #0]
 8006f24:	1dfb      	adds	r3, r7, #7
 8006f26:	781b      	ldrb	r3, [r3, #0]
 8006f28:	2b02      	cmp	r3, #2
 8006f2a:	d9db      	bls.n	8006ee4 <dns_create_txid+0x18>
    }
  }

  return txid;
 8006f2c:	1d3b      	adds	r3, r7, #4
 8006f2e:	881b      	ldrh	r3, [r3, #0]
}
 8006f30:	0018      	movs	r0, r3
 8006f32:	46bd      	mov	sp, r7
 8006f34:	b002      	add	sp, #8
 8006f36:	bd80      	pop	{r7, pc}
 8006f38:	20001154 	.word	0x20001154

08006f3c <dns_backupserver_available>:
/**
 * Check whether there are other backup DNS servers available to try
 */
static u8_t
dns_backupserver_available(struct dns_table_entry *pentry)
{
 8006f3c:	b580      	push	{r7, lr}
 8006f3e:	b084      	sub	sp, #16
 8006f40:	af00      	add	r7, sp, #0
 8006f42:	6078      	str	r0, [r7, #4]
  u8_t ret = 0;
 8006f44:	210f      	movs	r1, #15
 8006f46:	187b      	adds	r3, r7, r1
 8006f48:	2200      	movs	r2, #0
 8006f4a:	701a      	strb	r2, [r3, #0]

  if (pentry) {
 8006f4c:	687b      	ldr	r3, [r7, #4]
 8006f4e:	2b00      	cmp	r3, #0
 8006f50:	d00e      	beq.n	8006f70 <dns_backupserver_available+0x34>
    if ((pentry->server_idx + 1 < DNS_MAX_SERVERS) && !ip_addr_isany_val(dns_servers[pentry->server_idx + 1])) {
 8006f52:	687b      	ldr	r3, [r7, #4]
 8006f54:	7adb      	ldrb	r3, [r3, #11]
 8006f56:	2b00      	cmp	r3, #0
 8006f58:	d10a      	bne.n	8006f70 <dns_backupserver_available+0x34>
 8006f5a:	687b      	ldr	r3, [r7, #4]
 8006f5c:	7adb      	ldrb	r3, [r3, #11]
 8006f5e:	1c5a      	adds	r2, r3, #1
 8006f60:	4b07      	ldr	r3, [pc, #28]	; (8006f80 <dns_backupserver_available+0x44>)
 8006f62:	0092      	lsls	r2, r2, #2
 8006f64:	58d3      	ldr	r3, [r2, r3]
 8006f66:	2b00      	cmp	r3, #0
 8006f68:	d002      	beq.n	8006f70 <dns_backupserver_available+0x34>
      ret = 1;
 8006f6a:	187b      	adds	r3, r7, r1
 8006f6c:	2201      	movs	r2, #1
 8006f6e:	701a      	strb	r2, [r3, #0]
    }
  }

  return ret;
 8006f70:	230f      	movs	r3, #15
 8006f72:	18fb      	adds	r3, r7, r3
 8006f74:	781b      	ldrb	r3, [r3, #0]
}
 8006f76:	0018      	movs	r0, r3
 8006f78:	46bd      	mov	sp, r7
 8006f7a:	b004      	add	sp, #16
 8006f7c:	bd80      	pop	{r7, pc}
 8006f7e:	46c0      	nop			; (mov r8, r8)
 8006f80:	20001328 	.word	0x20001328

08006f84 <dns_check_entry>:
 *
 * @param i index of the dns_table entry to check
 */
static void
dns_check_entry(u8_t i)
{
 8006f84:	b590      	push	{r4, r7, lr}
 8006f86:	b085      	sub	sp, #20
 8006f88:	af00      	add	r7, sp, #0
 8006f8a:	0002      	movs	r2, r0
 8006f8c:	1dfb      	adds	r3, r7, #7
 8006f8e:	701a      	strb	r2, [r3, #0]
  err_t err;
  struct dns_table_entry *entry = &dns_table[i];
 8006f90:	1dfb      	adds	r3, r7, #7
 8006f92:	781a      	ldrb	r2, [r3, #0]
 8006f94:	0013      	movs	r3, r2
 8006f96:	00db      	lsls	r3, r3, #3
 8006f98:	189b      	adds	r3, r3, r2
 8006f9a:	011b      	lsls	r3, r3, #4
 8006f9c:	4a4b      	ldr	r2, [pc, #300]	; (80070cc <dns_check_entry+0x148>)
 8006f9e:	189b      	adds	r3, r3, r2
 8006fa0:	60fb      	str	r3, [r7, #12]

  LWIP_ASSERT("array index out of bounds", i < DNS_TABLE_SIZE);
 8006fa2:	1dfb      	adds	r3, r7, #7
 8006fa4:	781b      	ldrb	r3, [r3, #0]
 8006fa6:	2b02      	cmp	r3, #2
 8006fa8:	d905      	bls.n	8006fb6 <dns_check_entry+0x32>
 8006faa:	4b49      	ldr	r3, [pc, #292]	; (80070d0 <dns_check_entry+0x14c>)
 8006fac:	4a49      	ldr	r2, [pc, #292]	; (80070d4 <dns_check_entry+0x150>)
 8006fae:	494a      	ldr	r1, [pc, #296]	; (80070d8 <dns_check_entry+0x154>)
 8006fb0:	484a      	ldr	r0, [pc, #296]	; (80070dc <dns_check_entry+0x158>)
 8006fb2:	f7fb f90b 	bl	80021cc <app_debug_rtt_raw>

  switch (entry->state) {
 8006fb6:	68fb      	ldr	r3, [r7, #12]
 8006fb8:	7a9b      	ldrb	r3, [r3, #10]
 8006fba:	2b03      	cmp	r3, #3
 8006fbc:	d065      	beq.n	800708a <dns_check_entry+0x106>
 8006fbe:	dd00      	ble.n	8006fc2 <dns_check_entry+0x3e>
 8006fc0:	e074      	b.n	80070ac <dns_check_entry+0x128>
 8006fc2:	2b02      	cmp	r3, #2
 8006fc4:	d022      	beq.n	800700c <dns_check_entry+0x88>
 8006fc6:	dd00      	ble.n	8006fca <dns_check_entry+0x46>
 8006fc8:	e070      	b.n	80070ac <dns_check_entry+0x128>
 8006fca:	2b00      	cmp	r3, #0
 8006fcc:	d100      	bne.n	8006fd0 <dns_check_entry+0x4c>
 8006fce:	e074      	b.n	80070ba <dns_check_entry+0x136>
 8006fd0:	2b01      	cmp	r3, #1
 8006fd2:	d16b      	bne.n	80070ac <dns_check_entry+0x128>
    case DNS_STATE_NEW:
      /* initialize new entry */
      entry->txid = dns_create_txid();
 8006fd4:	f7ff ff7a 	bl	8006ecc <dns_create_txid>
 8006fd8:	0003      	movs	r3, r0
 8006fda:	001a      	movs	r2, r3
 8006fdc:	68fb      	ldr	r3, [r7, #12]
 8006fde:	811a      	strh	r2, [r3, #8]
      entry->state = DNS_STATE_ASKING;
 8006fe0:	68fb      	ldr	r3, [r7, #12]
 8006fe2:	2202      	movs	r2, #2
 8006fe4:	729a      	strb	r2, [r3, #10]
      entry->server_idx = 0;
 8006fe6:	68fb      	ldr	r3, [r7, #12]
 8006fe8:	2200      	movs	r2, #0
 8006fea:	72da      	strb	r2, [r3, #11]
      entry->tmr = 1;
 8006fec:	68fb      	ldr	r3, [r7, #12]
 8006fee:	2201      	movs	r2, #1
 8006ff0:	731a      	strb	r2, [r3, #12]
      entry->retries = 0;
 8006ff2:	68fb      	ldr	r3, [r7, #12]
 8006ff4:	2200      	movs	r2, #0
 8006ff6:	735a      	strb	r2, [r3, #13]

      /* send DNS packet for this entry */
      err = dns_send(i);
 8006ff8:	230b      	movs	r3, #11
 8006ffa:	18fc      	adds	r4, r7, r3
 8006ffc:	1dfb      	adds	r3, r7, #7
 8006ffe:	781b      	ldrb	r3, [r3, #0]
 8007000:	0018      	movs	r0, r3
 8007002:	f7ff fcbb 	bl	800697c <dns_send>
 8007006:	0003      	movs	r3, r0
 8007008:	7023      	strb	r3, [r4, #0]
      if (err != ERR_OK) {
        LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
                    ("dns_send returned error: %s\n", lwip_strerr(err)));
      }
      break;
 800700a:	e05b      	b.n	80070c4 <dns_check_entry+0x140>
    case DNS_STATE_ASKING:
      if (--entry->tmr == 0) {
 800700c:	68fb      	ldr	r3, [r7, #12]
 800700e:	7b1b      	ldrb	r3, [r3, #12]
 8007010:	3b01      	subs	r3, #1
 8007012:	b2da      	uxtb	r2, r3
 8007014:	68fb      	ldr	r3, [r7, #12]
 8007016:	731a      	strb	r2, [r3, #12]
 8007018:	68fb      	ldr	r3, [r7, #12]
 800701a:	7b1b      	ldrb	r3, [r3, #12]
 800701c:	2b00      	cmp	r3, #0
 800701e:	d14e      	bne.n	80070be <dns_check_entry+0x13a>
        if (++entry->retries == DNS_MAX_RETRIES) {
 8007020:	68fb      	ldr	r3, [r7, #12]
 8007022:	7b5b      	ldrb	r3, [r3, #13]
 8007024:	3301      	adds	r3, #1
 8007026:	b2da      	uxtb	r2, r3
 8007028:	68fb      	ldr	r3, [r7, #12]
 800702a:	735a      	strb	r2, [r3, #13]
 800702c:	68fb      	ldr	r3, [r7, #12]
 800702e:	7b5b      	ldrb	r3, [r3, #13]
 8007030:	2b04      	cmp	r3, #4
 8007032:	d11c      	bne.n	800706e <dns_check_entry+0xea>
          if (dns_backupserver_available(entry)
 8007034:	68fb      	ldr	r3, [r7, #12]
 8007036:	0018      	movs	r0, r3
 8007038:	f7ff ff80 	bl	8006f3c <dns_backupserver_available>
 800703c:	1e03      	subs	r3, r0, #0
 800703e:	d00c      	beq.n	800705a <dns_check_entry+0xd6>
#if LWIP_DNS_SUPPORT_MDNS_QUERIES
              && !entry->is_mdns
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
             ) {
            /* change of server */
            entry->server_idx++;
 8007040:	68fb      	ldr	r3, [r7, #12]
 8007042:	7adb      	ldrb	r3, [r3, #11]
 8007044:	3301      	adds	r3, #1
 8007046:	b2da      	uxtb	r2, r3
 8007048:	68fb      	ldr	r3, [r7, #12]
 800704a:	72da      	strb	r2, [r3, #11]
            entry->tmr = 1;
 800704c:	68fb      	ldr	r3, [r7, #12]
 800704e:	2201      	movs	r2, #1
 8007050:	731a      	strb	r2, [r3, #12]
            entry->retries = 0;
 8007052:	68fb      	ldr	r3, [r7, #12]
 8007054:	2200      	movs	r2, #0
 8007056:	735a      	strb	r2, [r3, #13]
 8007058:	e00d      	b.n	8007076 <dns_check_entry+0xf2>
          } else {
            LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": timeout\n", entry->name));
            /* call specified callback function if provided */
            dns_call_found(i, NULL);
 800705a:	1dfb      	adds	r3, r7, #7
 800705c:	781b      	ldrb	r3, [r3, #0]
 800705e:	2100      	movs	r1, #0
 8007060:	0018      	movs	r0, r3
 8007062:	f7ff fe55 	bl	8006d10 <dns_call_found>
            /* flush this entry */
            entry->state = DNS_STATE_UNUSED;
 8007066:	68fb      	ldr	r3, [r7, #12]
 8007068:	2200      	movs	r2, #0
 800706a:	729a      	strb	r2, [r3, #10]
            break;
 800706c:	e02a      	b.n	80070c4 <dns_check_entry+0x140>
          }
        } else {
          /* wait longer for the next retry */
          entry->tmr = entry->retries;
 800706e:	68fb      	ldr	r3, [r7, #12]
 8007070:	7b5a      	ldrb	r2, [r3, #13]
 8007072:	68fb      	ldr	r3, [r7, #12]
 8007074:	731a      	strb	r2, [r3, #12]
        }

        /* send DNS packet for this entry */
        err = dns_send(i);
 8007076:	230b      	movs	r3, #11
 8007078:	18fc      	adds	r4, r7, r3
 800707a:	1dfb      	adds	r3, r7, #7
 800707c:	781b      	ldrb	r3, [r3, #0]
 800707e:	0018      	movs	r0, r3
 8007080:	f7ff fc7c 	bl	800697c <dns_send>
 8007084:	0003      	movs	r3, r0
 8007086:	7023      	strb	r3, [r4, #0]
        if (err != ERR_OK) {
          LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
                      ("dns_send returned error: %s\n", lwip_strerr(err)));
        }
      }
      break;
 8007088:	e019      	b.n	80070be <dns_check_entry+0x13a>
    case DNS_STATE_DONE:
      /* if the time to live is nul */
      if ((entry->ttl == 0) || (--entry->ttl == 0)) {
 800708a:	68fb      	ldr	r3, [r7, #12]
 800708c:	681b      	ldr	r3, [r3, #0]
 800708e:	2b00      	cmp	r3, #0
 8007090:	d008      	beq.n	80070a4 <dns_check_entry+0x120>
 8007092:	68fb      	ldr	r3, [r7, #12]
 8007094:	681b      	ldr	r3, [r3, #0]
 8007096:	1e5a      	subs	r2, r3, #1
 8007098:	68fb      	ldr	r3, [r7, #12]
 800709a:	601a      	str	r2, [r3, #0]
 800709c:	68fb      	ldr	r3, [r7, #12]
 800709e:	681b      	ldr	r3, [r3, #0]
 80070a0:	2b00      	cmp	r3, #0
 80070a2:	d10e      	bne.n	80070c2 <dns_check_entry+0x13e>
        LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": flush\n", entry->name));
        /* flush this entry, there cannot be any related pending entries in this state */
        entry->state = DNS_STATE_UNUSED;
 80070a4:	68fb      	ldr	r3, [r7, #12]
 80070a6:	2200      	movs	r2, #0
 80070a8:	729a      	strb	r2, [r3, #10]
      }
      break;
 80070aa:	e00a      	b.n	80070c2 <dns_check_entry+0x13e>
    case DNS_STATE_UNUSED:
      /* nothing to do */
      break;
    default:
      LWIP_ASSERT("unknown dns_table entry state:", 0);
 80070ac:	4b08      	ldr	r3, [pc, #32]	; (80070d0 <dns_check_entry+0x14c>)
 80070ae:	4a0c      	ldr	r2, [pc, #48]	; (80070e0 <dns_check_entry+0x15c>)
 80070b0:	490c      	ldr	r1, [pc, #48]	; (80070e4 <dns_check_entry+0x160>)
 80070b2:	480a      	ldr	r0, [pc, #40]	; (80070dc <dns_check_entry+0x158>)
 80070b4:	f7fb f88a 	bl	80021cc <app_debug_rtt_raw>
      break;
 80070b8:	e004      	b.n	80070c4 <dns_check_entry+0x140>
      break;
 80070ba:	46c0      	nop			; (mov r8, r8)
 80070bc:	e002      	b.n	80070c4 <dns_check_entry+0x140>
      break;
 80070be:	46c0      	nop			; (mov r8, r8)
 80070c0:	e000      	b.n	80070c4 <dns_check_entry+0x140>
      break;
 80070c2:	46c0      	nop			; (mov r8, r8)
  }
}
 80070c4:	46c0      	nop			; (mov r8, r8)
 80070c6:	46bd      	mov	sp, r7
 80070c8:	b005      	add	sp, #20
 80070ca:	bd90      	pop	{r4, r7, pc}
 80070cc:	20001154 	.word	0x20001154
 80070d0:	0801e5dc 	.word	0x0801e5dc
 80070d4:	0000041c 	.word	0x0000041c
 80070d8:	0801e648 	.word	0x0801e648
 80070dc:	0801e61c 	.word	0x0801e61c
 80070e0:	0000045b 	.word	0x0000045b
 80070e4:	0801e664 	.word	0x0801e664

080070e8 <dns_check_entries>:
/**
 * Call dns_check_entry for each entry in dns_table - check all entries.
 */
static void
dns_check_entries(void)
{
 80070e8:	b580      	push	{r7, lr}
 80070ea:	b082      	sub	sp, #8
 80070ec:	af00      	add	r7, sp, #0
  u8_t i;

  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 80070ee:	1dfb      	adds	r3, r7, #7
 80070f0:	2200      	movs	r2, #0
 80070f2:	701a      	strb	r2, [r3, #0]
 80070f4:	e009      	b.n	800710a <dns_check_entries+0x22>
    dns_check_entry(i);
 80070f6:	1dfb      	adds	r3, r7, #7
 80070f8:	781b      	ldrb	r3, [r3, #0]
 80070fa:	0018      	movs	r0, r3
 80070fc:	f7ff ff42 	bl	8006f84 <dns_check_entry>
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 8007100:	1dfb      	adds	r3, r7, #7
 8007102:	1dfa      	adds	r2, r7, #7
 8007104:	7812      	ldrb	r2, [r2, #0]
 8007106:	3201      	adds	r2, #1
 8007108:	701a      	strb	r2, [r3, #0]
 800710a:	1dfb      	adds	r3, r7, #7
 800710c:	781b      	ldrb	r3, [r3, #0]
 800710e:	2b02      	cmp	r3, #2
 8007110:	d9f1      	bls.n	80070f6 <dns_check_entries+0xe>
  }
}
 8007112:	46c0      	nop			; (mov r8, r8)
 8007114:	46c0      	nop			; (mov r8, r8)
 8007116:	46bd      	mov	sp, r7
 8007118:	b002      	add	sp, #8
 800711a:	bd80      	pop	{r7, pc}

0800711c <dns_correct_response>:
/**
 * Save TTL and call dns_call_found for correct response.
 */
static void
dns_correct_response(u8_t idx, u32_t ttl)
{
 800711c:	b580      	push	{r7, lr}
 800711e:	b084      	sub	sp, #16
 8007120:	af00      	add	r7, sp, #0
 8007122:	0002      	movs	r2, r0
 8007124:	6039      	str	r1, [r7, #0]
 8007126:	1dfb      	adds	r3, r7, #7
 8007128:	701a      	strb	r2, [r3, #0]
  struct dns_table_entry *entry = &dns_table[idx];
 800712a:	1dfb      	adds	r3, r7, #7
 800712c:	781a      	ldrb	r2, [r3, #0]
 800712e:	0013      	movs	r3, r2
 8007130:	00db      	lsls	r3, r3, #3
 8007132:	189b      	adds	r3, r3, r2
 8007134:	011b      	lsls	r3, r3, #4
 8007136:	4a14      	ldr	r2, [pc, #80]	; (8007188 <dns_correct_response+0x6c>)
 8007138:	189b      	adds	r3, r3, r2
 800713a:	60fb      	str	r3, [r7, #12]

  entry->state = DNS_STATE_DONE;
 800713c:	68fb      	ldr	r3, [r7, #12]
 800713e:	2203      	movs	r2, #3
 8007140:	729a      	strb	r2, [r3, #10]
  LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response = ", entry->name));
  ip_addr_debug_print_val(DNS_DEBUG, entry->ipaddr);
  LWIP_DEBUGF(DNS_DEBUG, ("\n"));

  /* read the answer resource record's TTL, and maximize it if needed */
  entry->ttl = ttl;
 8007142:	68fb      	ldr	r3, [r7, #12]
 8007144:	683a      	ldr	r2, [r7, #0]
 8007146:	601a      	str	r2, [r3, #0]
  if (entry->ttl > DNS_MAX_TTL) {
 8007148:	68fb      	ldr	r3, [r7, #12]
 800714a:	681b      	ldr	r3, [r3, #0]
 800714c:	4a0f      	ldr	r2, [pc, #60]	; (800718c <dns_correct_response+0x70>)
 800714e:	4293      	cmp	r3, r2
 8007150:	d902      	bls.n	8007158 <dns_correct_response+0x3c>
    entry->ttl = DNS_MAX_TTL;
 8007152:	68fb      	ldr	r3, [r7, #12]
 8007154:	4a0d      	ldr	r2, [pc, #52]	; (800718c <dns_correct_response+0x70>)
 8007156:	601a      	str	r2, [r3, #0]
  }
  dns_call_found(idx, &entry->ipaddr);
 8007158:	68fb      	ldr	r3, [r7, #12]
 800715a:	1d1a      	adds	r2, r3, #4
 800715c:	1dfb      	adds	r3, r7, #7
 800715e:	781b      	ldrb	r3, [r3, #0]
 8007160:	0011      	movs	r1, r2
 8007162:	0018      	movs	r0, r3
 8007164:	f7ff fdd4 	bl	8006d10 <dns_call_found>

  if (entry->ttl == 0) {
 8007168:	68fb      	ldr	r3, [r7, #12]
 800716a:	681b      	ldr	r3, [r3, #0]
 800716c:	2b00      	cmp	r3, #0
 800716e:	d106      	bne.n	800717e <dns_correct_response+0x62>
    /* RFC 883, page 29: "Zero values are
       interpreted to mean that the RR can only be used for the
       transaction in progress, and should not be cached."
       -> flush this entry now */
    /* entry reused during callback? */
    if (entry->state == DNS_STATE_DONE) {
 8007170:	68fb      	ldr	r3, [r7, #12]
 8007172:	7a9b      	ldrb	r3, [r3, #10]
 8007174:	2b03      	cmp	r3, #3
 8007176:	d102      	bne.n	800717e <dns_correct_response+0x62>
      entry->state = DNS_STATE_UNUSED;
 8007178:	68fb      	ldr	r3, [r7, #12]
 800717a:	2200      	movs	r2, #0
 800717c:	729a      	strb	r2, [r3, #10]
    }
  }
}
 800717e:	46c0      	nop			; (mov r8, r8)
 8007180:	46bd      	mov	sp, r7
 8007182:	b004      	add	sp, #16
 8007184:	bd80      	pop	{r7, pc}
 8007186:	46c0      	nop			; (mov r8, r8)
 8007188:	20001154 	.word	0x20001154
 800718c:	00093a80 	.word	0x00093a80

08007190 <dns_recv>:
/**
 * Receive input function for DNS response packets arriving for the dns UDP pcb.
 */
static void
dns_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
{
 8007190:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007192:	b091      	sub	sp, #68	; 0x44
 8007194:	af00      	add	r7, sp, #0
 8007196:	60f8      	str	r0, [r7, #12]
 8007198:	60b9      	str	r1, [r7, #8]
 800719a:	607a      	str	r2, [r7, #4]
 800719c:	603b      	str	r3, [r7, #0]
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(port);

  /* is the dns message big enough ? */
  if (p->tot_len < (SIZEOF_DNS_HDR + SIZEOF_DNS_QUERY)) {
 800719e:	687b      	ldr	r3, [r7, #4]
 80071a0:	891b      	ldrh	r3, [r3, #8]
 80071a2:	2b0f      	cmp	r3, #15
 80071a4:	d800      	bhi.n	80071a8 <dns_recv+0x18>
 80071a6:	e162      	b.n	800746e <dns_recv+0x2de>
    /* free pbuf and return */
    goto ignore_packet;
  }

  /* copy dns payload inside static buffer for processing */
  if (pbuf_copy_partial(p, &hdr, SIZEOF_DNS_HDR, 0) == SIZEOF_DNS_HDR) {
 80071a8:	2424      	movs	r4, #36	; 0x24
 80071aa:	1939      	adds	r1, r7, r4
 80071ac:	6878      	ldr	r0, [r7, #4]
 80071ae:	2300      	movs	r3, #0
 80071b0:	220c      	movs	r2, #12
 80071b2:	f002 fd39 	bl	8009c28 <pbuf_copy_partial>
 80071b6:	0003      	movs	r3, r0
 80071b8:	2b0c      	cmp	r3, #12
 80071ba:	d000      	beq.n	80071be <dns_recv+0x2e>
 80071bc:	e159      	b.n	8007472 <dns_recv+0x2e2>
    /* Match the ID in the DNS header with the name table. */
    txid = lwip_htons(hdr.id);
 80071be:	193b      	adds	r3, r7, r4
 80071c0:	881b      	ldrh	r3, [r3, #0]
 80071c2:	2238      	movs	r2, #56	; 0x38
 80071c4:	18bc      	adds	r4, r7, r2
 80071c6:	0018      	movs	r0, r3
 80071c8:	f7ff f9b4 	bl	8006534 <lwip_htons>
 80071cc:	0003      	movs	r3, r0
 80071ce:	8023      	strh	r3, [r4, #0]
    for (i = 0; i < DNS_TABLE_SIZE; i++) {
 80071d0:	233b      	movs	r3, #59	; 0x3b
 80071d2:	18fb      	adds	r3, r7, r3
 80071d4:	2200      	movs	r2, #0
 80071d6:	701a      	strb	r2, [r3, #0]
 80071d8:	e142      	b.n	8007460 <dns_recv+0x2d0>
      struct dns_table_entry *entry = &dns_table[i];
 80071da:	233b      	movs	r3, #59	; 0x3b
 80071dc:	18fb      	adds	r3, r7, r3
 80071de:	781a      	ldrb	r2, [r3, #0]
 80071e0:	0013      	movs	r3, r2
 80071e2:	00db      	lsls	r3, r3, #3
 80071e4:	189b      	adds	r3, r3, r2
 80071e6:	011b      	lsls	r3, r3, #4
 80071e8:	4ab2      	ldr	r2, [pc, #712]	; (80074b4 <dns_recv+0x324>)
 80071ea:	189b      	adds	r3, r3, r2
 80071ec:	637b      	str	r3, [r7, #52]	; 0x34
      if ((entry->state == DNS_STATE_ASKING) &&
 80071ee:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80071f0:	7a9b      	ldrb	r3, [r3, #10]
 80071f2:	2b02      	cmp	r3, #2
 80071f4:	d000      	beq.n	80071f8 <dns_recv+0x68>
 80071f6:	e12d      	b.n	8007454 <dns_recv+0x2c4>
          (entry->txid == txid)) {
 80071f8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80071fa:	891b      	ldrh	r3, [r3, #8]
      if ((entry->state == DNS_STATE_ASKING) &&
 80071fc:	2238      	movs	r2, #56	; 0x38
 80071fe:	18ba      	adds	r2, r7, r2
 8007200:	8812      	ldrh	r2, [r2, #0]
 8007202:	429a      	cmp	r2, r3
 8007204:	d000      	beq.n	8007208 <dns_recv+0x78>
 8007206:	e125      	b.n	8007454 <dns_recv+0x2c4>

        /* We only care about the question(s) and the answers. The authrr
           and the extrarr are simply discarded. */
        nquestions = lwip_htons(hdr.numquestions);
 8007208:	2624      	movs	r6, #36	; 0x24
 800720a:	19bb      	adds	r3, r7, r6
 800720c:	889b      	ldrh	r3, [r3, #4]
 800720e:	2532      	movs	r5, #50	; 0x32
 8007210:	197c      	adds	r4, r7, r5
 8007212:	0018      	movs	r0, r3
 8007214:	f7ff f98e 	bl	8006534 <lwip_htons>
 8007218:	0003      	movs	r3, r0
 800721a:	8023      	strh	r3, [r4, #0]
        nanswers   = lwip_htons(hdr.numanswers);
 800721c:	19bb      	adds	r3, r7, r6
 800721e:	88db      	ldrh	r3, [r3, #6]
 8007220:	223e      	movs	r2, #62	; 0x3e
 8007222:	18bc      	adds	r4, r7, r2
 8007224:	0018      	movs	r0, r3
 8007226:	f7ff f985 	bl	8006534 <lwip_htons>
 800722a:	0003      	movs	r3, r0
 800722c:	8023      	strh	r3, [r4, #0]

        /* Check for correct response. */
        if ((hdr.flags1 & DNS_FLAG1_RESPONSE) == 0) {
 800722e:	19bb      	adds	r3, r7, r6
 8007230:	789b      	ldrb	r3, [r3, #2]
 8007232:	b25b      	sxtb	r3, r3
 8007234:	2b00      	cmp	r3, #0
 8007236:	db00      	blt.n	800723a <dns_recv+0xaa>
 8007238:	e11d      	b.n	8007476 <dns_recv+0x2e6>
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": not a response\n", entry->name));
          goto ignore_packet; /* ignore this packet */
        }
        if (nquestions != 1) {
 800723a:	197b      	adds	r3, r7, r5
 800723c:	881b      	ldrh	r3, [r3, #0]
 800723e:	2b01      	cmp	r3, #1
 8007240:	d000      	beq.n	8007244 <dns_recv+0xb4>
 8007242:	e11a      	b.n	800747a <dns_recv+0x2ea>
        if (!entry->is_mdns)
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
        {
          /* Check whether response comes from the same network address to which the
             question was sent. (RFC 5452) */
          if (!ip_addr_cmp(addr, &dns_servers[entry->server_idx])) {
 8007244:	683b      	ldr	r3, [r7, #0]
 8007246:	681a      	ldr	r2, [r3, #0]
 8007248:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800724a:	7adb      	ldrb	r3, [r3, #11]
 800724c:	0019      	movs	r1, r3
 800724e:	4b9a      	ldr	r3, [pc, #616]	; (80074b8 <dns_recv+0x328>)
 8007250:	0089      	lsls	r1, r1, #2
 8007252:	58cb      	ldr	r3, [r1, r3]
 8007254:	429a      	cmp	r2, r3
 8007256:	d000      	beq.n	800725a <dns_recv+0xca>
 8007258:	e111      	b.n	800747e <dns_recv+0x2ee>
          }
        }

        /* Check if the name in the "question" part match with the name in the entry and
           skip it if equal. */
        res_idx = dns_compare_name(entry->name, p, SIZEOF_DNS_HDR);
 800725a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800725c:	3310      	adds	r3, #16
 800725e:	253c      	movs	r5, #60	; 0x3c
 8007260:	197c      	adds	r4, r7, r5
 8007262:	6879      	ldr	r1, [r7, #4]
 8007264:	220c      	movs	r2, #12
 8007266:	0018      	movs	r0, r3
 8007268:	f7ff fa78 	bl	800675c <dns_compare_name>
 800726c:	0003      	movs	r3, r0
 800726e:	8023      	strh	r3, [r4, #0]
        if (res_idx == 0xFFFF) {
 8007270:	002c      	movs	r4, r5
 8007272:	193b      	adds	r3, r7, r4
 8007274:	881b      	ldrh	r3, [r3, #0]
 8007276:	4a91      	ldr	r2, [pc, #580]	; (80074bc <dns_recv+0x32c>)
 8007278:	4293      	cmp	r3, r2
 800727a:	d100      	bne.n	800727e <dns_recv+0xee>
 800727c:	e101      	b.n	8007482 <dns_recv+0x2f2>
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response not match to query\n", entry->name));
          goto ignore_packet; /* ignore this packet */
        }

        /* check if "question" part matches the request */
        if (pbuf_copy_partial(p, &qry, SIZEOF_DNS_QUERY, res_idx) != SIZEOF_DNS_QUERY) {
 800727e:	193b      	adds	r3, r7, r4
 8007280:	881b      	ldrh	r3, [r3, #0]
 8007282:	2514      	movs	r5, #20
 8007284:	1979      	adds	r1, r7, r5
 8007286:	6878      	ldr	r0, [r7, #4]
 8007288:	2204      	movs	r2, #4
 800728a:	f002 fccd 	bl	8009c28 <pbuf_copy_partial>
 800728e:	0003      	movs	r3, r0
 8007290:	2b04      	cmp	r3, #4
 8007292:	d000      	beq.n	8007296 <dns_recv+0x106>
 8007294:	e0f7      	b.n	8007486 <dns_recv+0x2f6>
          goto ignore_packet; /* ignore this packet */
        }
        if ((qry.cls != PP_HTONS(DNS_RRCLASS_IN)) ||
 8007296:	197b      	adds	r3, r7, r5
 8007298:	885a      	ldrh	r2, [r3, #2]
 800729a:	2380      	movs	r3, #128	; 0x80
 800729c:	005b      	lsls	r3, r3, #1
 800729e:	429a      	cmp	r2, r3
 80072a0:	d000      	beq.n	80072a4 <dns_recv+0x114>
 80072a2:	e0f2      	b.n	800748a <dns_recv+0x2fa>
            (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype) && (qry.type != PP_HTONS(DNS_RRTYPE_AAAA))) ||
            (!LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype) && (qry.type != PP_HTONS(DNS_RRTYPE_A)))) {
 80072a4:	197b      	adds	r3, r7, r5
 80072a6:	881a      	ldrh	r2, [r3, #0]
            (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype) && (qry.type != PP_HTONS(DNS_RRTYPE_AAAA))) ||
 80072a8:	2380      	movs	r3, #128	; 0x80
 80072aa:	005b      	lsls	r3, r3, #1
 80072ac:	429a      	cmp	r2, r3
 80072ae:	d000      	beq.n	80072b2 <dns_recv+0x122>
 80072b0:	e0eb      	b.n	800748a <dns_recv+0x2fa>
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response not match to query\n", entry->name));
          goto ignore_packet; /* ignore this packet */
        }
        /* skip the rest of the "question" part */
        if (res_idx + SIZEOF_DNS_QUERY > 0xFFFF) {
 80072b2:	193b      	adds	r3, r7, r4
 80072b4:	881b      	ldrh	r3, [r3, #0]
 80072b6:	4a82      	ldr	r2, [pc, #520]	; (80074c0 <dns_recv+0x330>)
 80072b8:	4293      	cmp	r3, r2
 80072ba:	d900      	bls.n	80072be <dns_recv+0x12e>
 80072bc:	e0e7      	b.n	800748e <dns_recv+0x2fe>
          goto ignore_packet;
        }
        res_idx = (u16_t)(res_idx + SIZEOF_DNS_QUERY);
 80072be:	193b      	adds	r3, r7, r4
 80072c0:	193a      	adds	r2, r7, r4
 80072c2:	8812      	ldrh	r2, [r2, #0]
 80072c4:	3204      	adds	r2, #4
 80072c6:	801a      	strh	r2, [r3, #0]

        /* Check for error. If so, call callback to inform. */
        if (hdr.flags2 & DNS_FLAG2_ERR_MASK) {
 80072c8:	19bb      	adds	r3, r7, r6
 80072ca:	78db      	ldrb	r3, [r3, #3]
 80072cc:	001a      	movs	r2, r3
 80072ce:	230f      	movs	r3, #15
 80072d0:	4013      	ands	r3, r2
 80072d2:	d100      	bne.n	80072d6 <dns_recv+0x146>
 80072d4:	e09a      	b.n	800740c <dns_recv+0x27c>
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in flags\n", entry->name));

          /* if there is another backup DNS server to try
           * then don't stop the DNS request
           */
          if (dns_backupserver_available(entry)) {
 80072d6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80072d8:	0018      	movs	r0, r3
 80072da:	f7ff fe2f 	bl	8006f3c <dns_backupserver_available>
 80072de:	1e03      	subs	r3, r0, #0
 80072e0:	d100      	bne.n	80072e4 <dns_recv+0x154>
 80072e2:	e0a0      	b.n	8007426 <dns_recv+0x296>
            /* avoid retrying the same server */
            entry->retries = DNS_MAX_RETRIES-1;
 80072e4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80072e6:	2203      	movs	r2, #3
 80072e8:	735a      	strb	r2, [r3, #13]
            entry->tmr     = 1;
 80072ea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80072ec:	2201      	movs	r2, #1
 80072ee:	731a      	strb	r2, [r3, #12]

            /* contact next available server for this entry */
            dns_check_entry(i);
 80072f0:	233b      	movs	r3, #59	; 0x3b
 80072f2:	18fb      	adds	r3, r7, r3
 80072f4:	781b      	ldrb	r3, [r3, #0]
 80072f6:	0018      	movs	r0, r3
 80072f8:	f7ff fe44 	bl	8006f84 <dns_check_entry>

            goto ignore_packet;
 80072fc:	e0d2      	b.n	80074a4 <dns_recv+0x314>
          }
        } else {
          while ((nanswers > 0) && (res_idx < p->tot_len)) {
            /* skip answer resource record's host name */
            res_idx = dns_skip_name(p, res_idx);
 80072fe:	253c      	movs	r5, #60	; 0x3c
 8007300:	197c      	adds	r4, r7, r5
 8007302:	197b      	adds	r3, r7, r5
 8007304:	881a      	ldrh	r2, [r3, #0]
 8007306:	687b      	ldr	r3, [r7, #4]
 8007308:	0011      	movs	r1, r2
 800730a:	0018      	movs	r0, r3
 800730c:	f7ff fad6 	bl	80068bc <dns_skip_name>
 8007310:	0003      	movs	r3, r0
 8007312:	8023      	strh	r3, [r4, #0]
            if (res_idx == 0xFFFF) {
 8007314:	002c      	movs	r4, r5
 8007316:	193b      	adds	r3, r7, r4
 8007318:	881b      	ldrh	r3, [r3, #0]
 800731a:	4a68      	ldr	r2, [pc, #416]	; (80074bc <dns_recv+0x32c>)
 800731c:	4293      	cmp	r3, r2
 800731e:	d100      	bne.n	8007322 <dns_recv+0x192>
 8007320:	e0b7      	b.n	8007492 <dns_recv+0x302>
              goto ignore_packet; /* ignore this packet */
            }

            /* Check for IP address type and Internet class. Others are discarded. */
            if (pbuf_copy_partial(p, &ans, SIZEOF_DNS_ANSWER, res_idx) != SIZEOF_DNS_ANSWER) {
 8007322:	193b      	adds	r3, r7, r4
 8007324:	881b      	ldrh	r3, [r3, #0]
 8007326:	2518      	movs	r5, #24
 8007328:	1979      	adds	r1, r7, r5
 800732a:	6878      	ldr	r0, [r7, #4]
 800732c:	220a      	movs	r2, #10
 800732e:	f002 fc7b 	bl	8009c28 <pbuf_copy_partial>
 8007332:	0003      	movs	r3, r0
 8007334:	2b0a      	cmp	r3, #10
 8007336:	d000      	beq.n	800733a <dns_recv+0x1aa>
 8007338:	e0ad      	b.n	8007496 <dns_recv+0x306>
              goto ignore_packet; /* ignore this packet */
            }
            if (res_idx + SIZEOF_DNS_ANSWER > 0xFFFF) {
 800733a:	193b      	adds	r3, r7, r4
 800733c:	881b      	ldrh	r3, [r3, #0]
 800733e:	4a61      	ldr	r2, [pc, #388]	; (80074c4 <dns_recv+0x334>)
 8007340:	4293      	cmp	r3, r2
 8007342:	d900      	bls.n	8007346 <dns_recv+0x1b6>
 8007344:	e0a9      	b.n	800749a <dns_recv+0x30a>
              goto ignore_packet;
            }
            res_idx = (u16_t)(res_idx + SIZEOF_DNS_ANSWER);
 8007346:	193b      	adds	r3, r7, r4
 8007348:	0021      	movs	r1, r4
 800734a:	193a      	adds	r2, r7, r4
 800734c:	8812      	ldrh	r2, [r2, #0]
 800734e:	320a      	adds	r2, #10
 8007350:	801a      	strh	r2, [r3, #0]

            if (ans.cls == PP_HTONS(DNS_RRCLASS_IN)) {
 8007352:	002c      	movs	r4, r5
 8007354:	193b      	adds	r3, r7, r4
 8007356:	885a      	ldrh	r2, [r3, #2]
 8007358:	2380      	movs	r3, #128	; 0x80
 800735a:	005b      	lsls	r3, r3, #1
 800735c:	429a      	cmp	r2, r3
 800735e:	d134      	bne.n	80073ca <dns_recv+0x23a>
#if LWIP_IPV4
              if ((ans.type == PP_HTONS(DNS_RRTYPE_A)) && (ans.len == PP_HTONS(sizeof(ip4_addr_t)))) {
 8007360:	193b      	adds	r3, r7, r4
 8007362:	881a      	ldrh	r2, [r3, #0]
 8007364:	2380      	movs	r3, #128	; 0x80
 8007366:	005b      	lsls	r3, r3, #1
 8007368:	429a      	cmp	r2, r3
 800736a:	d12e      	bne.n	80073ca <dns_recv+0x23a>
 800736c:	193b      	adds	r3, r7, r4
 800736e:	891a      	ldrh	r2, [r3, #8]
 8007370:	2380      	movs	r3, #128	; 0x80
 8007372:	00db      	lsls	r3, r3, #3
 8007374:	429a      	cmp	r2, r3
 8007376:	d128      	bne.n	80073ca <dns_recv+0x23a>
                if (!LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype))
#endif /* LWIP_IPV4 && LWIP_IPV6 */
                {
                  ip4_addr_t ip4addr;
                  /* read the IP address after answer resource record's header */
                  if (pbuf_copy_partial(p, &ip4addr, sizeof(ip4_addr_t), res_idx) != sizeof(ip4_addr_t)) {
 8007378:	187b      	adds	r3, r7, r1
 800737a:	881b      	ldrh	r3, [r3, #0]
 800737c:	2210      	movs	r2, #16
 800737e:	18b9      	adds	r1, r7, r2
 8007380:	6878      	ldr	r0, [r7, #4]
 8007382:	2204      	movs	r2, #4
 8007384:	f002 fc50 	bl	8009c28 <pbuf_copy_partial>
 8007388:	0003      	movs	r3, r0
 800738a:	2b04      	cmp	r3, #4
 800738c:	d000      	beq.n	8007390 <dns_recv+0x200>
 800738e:	e086      	b.n	800749e <dns_recv+0x30e>
                    goto ignore_packet; /* ignore this packet */
                  }
                  ip_addr_copy_from_ip4(dns_table[i].ipaddr, ip4addr);
 8007390:	253b      	movs	r5, #59	; 0x3b
 8007392:	197b      	adds	r3, r7, r5
 8007394:	781a      	ldrb	r2, [r3, #0]
 8007396:	6939      	ldr	r1, [r7, #16]
 8007398:	4846      	ldr	r0, [pc, #280]	; (80074b4 <dns_recv+0x324>)
 800739a:	0013      	movs	r3, r2
 800739c:	00db      	lsls	r3, r3, #3
 800739e:	189b      	adds	r3, r3, r2
 80073a0:	011b      	lsls	r3, r3, #4
 80073a2:	18c3      	adds	r3, r0, r3
 80073a4:	3304      	adds	r3, #4
 80073a6:	6019      	str	r1, [r3, #0]
                  pbuf_free(p);
 80073a8:	687b      	ldr	r3, [r7, #4]
 80073aa:	0018      	movs	r0, r3
 80073ac:	f002 f972 	bl	8009694 <pbuf_free>
                  /* handle correct response */
                  dns_correct_response(i, lwip_ntohl(ans.ttl));
 80073b0:	193b      	adds	r3, r7, r4
 80073b2:	685b      	ldr	r3, [r3, #4]
 80073b4:	0018      	movs	r0, r3
 80073b6:	f7ff f8d3 	bl	8006560 <lwip_htonl>
 80073ba:	0002      	movs	r2, r0
 80073bc:	197b      	adds	r3, r7, r5
 80073be:	781b      	ldrb	r3, [r3, #0]
 80073c0:	0011      	movs	r1, r2
 80073c2:	0018      	movs	r0, r3
 80073c4:	f7ff feaa 	bl	800711c <dns_correct_response>
 80073c8:	e071      	b.n	80074ae <dns_recv+0x31e>
                }
              }
#endif /* LWIP_IPV6 */
            }
            /* skip this answer */
            if ((int)(res_idx + lwip_htons(ans.len)) > 0xFFFF) {
 80073ca:	253c      	movs	r5, #60	; 0x3c
 80073cc:	197b      	adds	r3, r7, r5
 80073ce:	881c      	ldrh	r4, [r3, #0]
 80073d0:	2618      	movs	r6, #24
 80073d2:	19bb      	adds	r3, r7, r6
 80073d4:	891b      	ldrh	r3, [r3, #8]
 80073d6:	0018      	movs	r0, r3
 80073d8:	f7ff f8ac 	bl	8006534 <lwip_htons>
 80073dc:	0003      	movs	r3, r0
 80073de:	18e2      	adds	r2, r4, r3
 80073e0:	2380      	movs	r3, #128	; 0x80
 80073e2:	025b      	lsls	r3, r3, #9
 80073e4:	429a      	cmp	r2, r3
 80073e6:	da5c      	bge.n	80074a2 <dns_recv+0x312>
              goto ignore_packet; /* ignore this packet */
            }
            res_idx = (u16_t)(res_idx + lwip_htons(ans.len));
 80073e8:	19bb      	adds	r3, r7, r6
 80073ea:	891b      	ldrh	r3, [r3, #8]
 80073ec:	0018      	movs	r0, r3
 80073ee:	f7ff f8a1 	bl	8006534 <lwip_htons>
 80073f2:	0003      	movs	r3, r0
 80073f4:	0019      	movs	r1, r3
 80073f6:	197b      	adds	r3, r7, r5
 80073f8:	197a      	adds	r2, r7, r5
 80073fa:	8812      	ldrh	r2, [r2, #0]
 80073fc:	188a      	adds	r2, r1, r2
 80073fe:	801a      	strh	r2, [r3, #0]
            --nanswers;
 8007400:	223e      	movs	r2, #62	; 0x3e
 8007402:	18bb      	adds	r3, r7, r2
 8007404:	18ba      	adds	r2, r7, r2
 8007406:	8812      	ldrh	r2, [r2, #0]
 8007408:	3a01      	subs	r2, #1
 800740a:	801a      	strh	r2, [r3, #0]
          while ((nanswers > 0) && (res_idx < p->tot_len)) {
 800740c:	233e      	movs	r3, #62	; 0x3e
 800740e:	18fb      	adds	r3, r7, r3
 8007410:	881b      	ldrh	r3, [r3, #0]
 8007412:	2b00      	cmp	r3, #0
 8007414:	d007      	beq.n	8007426 <dns_recv+0x296>
 8007416:	687b      	ldr	r3, [r7, #4]
 8007418:	891b      	ldrh	r3, [r3, #8]
 800741a:	223c      	movs	r2, #60	; 0x3c
 800741c:	18ba      	adds	r2, r7, r2
 800741e:	8812      	ldrh	r2, [r2, #0]
 8007420:	429a      	cmp	r2, r3
 8007422:	d200      	bcs.n	8007426 <dns_recv+0x296>
 8007424:	e76b      	b.n	80072fe <dns_recv+0x16e>
          }
#endif /* LWIP_IPV4 && LWIP_IPV6 */
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in response\n", entry->name));
        }
        /* call callback to indicate error, clean up memory and return */
        pbuf_free(p);
 8007426:	687b      	ldr	r3, [r7, #4]
 8007428:	0018      	movs	r0, r3
 800742a:	f002 f933 	bl	8009694 <pbuf_free>
        dns_call_found(i, NULL);
 800742e:	243b      	movs	r4, #59	; 0x3b
 8007430:	193b      	adds	r3, r7, r4
 8007432:	781b      	ldrb	r3, [r3, #0]
 8007434:	2100      	movs	r1, #0
 8007436:	0018      	movs	r0, r3
 8007438:	f7ff fc6a 	bl	8006d10 <dns_call_found>
        dns_table[i].state = DNS_STATE_UNUSED;
 800743c:	193b      	adds	r3, r7, r4
 800743e:	781a      	ldrb	r2, [r3, #0]
 8007440:	491c      	ldr	r1, [pc, #112]	; (80074b4 <dns_recv+0x324>)
 8007442:	0013      	movs	r3, r2
 8007444:	00db      	lsls	r3, r3, #3
 8007446:	189b      	adds	r3, r3, r2
 8007448:	011b      	lsls	r3, r3, #4
 800744a:	18cb      	adds	r3, r1, r3
 800744c:	330a      	adds	r3, #10
 800744e:	2200      	movs	r2, #0
 8007450:	701a      	strb	r2, [r3, #0]
        return;
 8007452:	e02c      	b.n	80074ae <dns_recv+0x31e>
    for (i = 0; i < DNS_TABLE_SIZE; i++) {
 8007454:	213b      	movs	r1, #59	; 0x3b
 8007456:	187b      	adds	r3, r7, r1
 8007458:	781a      	ldrb	r2, [r3, #0]
 800745a:	187b      	adds	r3, r7, r1
 800745c:	3201      	adds	r2, #1
 800745e:	701a      	strb	r2, [r3, #0]
 8007460:	233b      	movs	r3, #59	; 0x3b
 8007462:	18fb      	adds	r3, r7, r3
 8007464:	781b      	ldrb	r3, [r3, #0]
 8007466:	2b02      	cmp	r3, #2
 8007468:	d800      	bhi.n	800746c <dns_recv+0x2dc>
 800746a:	e6b6      	b.n	80071da <dns_recv+0x4a>
      }
    }
  }

ignore_packet:
 800746c:	e001      	b.n	8007472 <dns_recv+0x2e2>
    goto ignore_packet;
 800746e:	46c0      	nop			; (mov r8, r8)
 8007470:	e018      	b.n	80074a4 <dns_recv+0x314>
ignore_packet:
 8007472:	46c0      	nop			; (mov r8, r8)
 8007474:	e016      	b.n	80074a4 <dns_recv+0x314>
          goto ignore_packet; /* ignore this packet */
 8007476:	46c0      	nop			; (mov r8, r8)
 8007478:	e014      	b.n	80074a4 <dns_recv+0x314>
          goto ignore_packet; /* ignore this packet */
 800747a:	46c0      	nop			; (mov r8, r8)
 800747c:	e012      	b.n	80074a4 <dns_recv+0x314>
            goto ignore_packet; /* ignore this packet */
 800747e:	46c0      	nop			; (mov r8, r8)
 8007480:	e010      	b.n	80074a4 <dns_recv+0x314>
          goto ignore_packet; /* ignore this packet */
 8007482:	46c0      	nop			; (mov r8, r8)
 8007484:	e00e      	b.n	80074a4 <dns_recv+0x314>
          goto ignore_packet; /* ignore this packet */
 8007486:	46c0      	nop			; (mov r8, r8)
 8007488:	e00c      	b.n	80074a4 <dns_recv+0x314>
          goto ignore_packet; /* ignore this packet */
 800748a:	46c0      	nop			; (mov r8, r8)
 800748c:	e00a      	b.n	80074a4 <dns_recv+0x314>
          goto ignore_packet;
 800748e:	46c0      	nop			; (mov r8, r8)
 8007490:	e008      	b.n	80074a4 <dns_recv+0x314>
              goto ignore_packet; /* ignore this packet */
 8007492:	46c0      	nop			; (mov r8, r8)
 8007494:	e006      	b.n	80074a4 <dns_recv+0x314>
              goto ignore_packet; /* ignore this packet */
 8007496:	46c0      	nop			; (mov r8, r8)
 8007498:	e004      	b.n	80074a4 <dns_recv+0x314>
              goto ignore_packet;
 800749a:	46c0      	nop			; (mov r8, r8)
 800749c:	e002      	b.n	80074a4 <dns_recv+0x314>
                    goto ignore_packet; /* ignore this packet */
 800749e:	46c0      	nop			; (mov r8, r8)
 80074a0:	e000      	b.n	80074a4 <dns_recv+0x314>
              goto ignore_packet; /* ignore this packet */
 80074a2:	46c0      	nop			; (mov r8, r8)
  /* deallocate memory and return */
  pbuf_free(p);
 80074a4:	687b      	ldr	r3, [r7, #4]
 80074a6:	0018      	movs	r0, r3
 80074a8:	f002 f8f4 	bl	8009694 <pbuf_free>
  return;
 80074ac:	46c0      	nop			; (mov r8, r8)
}
 80074ae:	46bd      	mov	sp, r7
 80074b0:	b011      	add	sp, #68	; 0x44
 80074b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80074b4:	20001154 	.word	0x20001154
 80074b8:	20001328 	.word	0x20001328
 80074bc:	0000ffff 	.word	0x0000ffff
 80074c0:	0000fffb 	.word	0x0000fffb
 80074c4:	0000fff5 	.word	0x0000fff5

080074c8 <dns_enqueue>:
 * @return err_t return code.
 */
static err_t
dns_enqueue(const char *name, size_t hostnamelen, dns_found_callback found,
            void *callback_arg LWIP_DNS_ADDRTYPE_ARG(u8_t dns_addrtype) LWIP_DNS_ISMDNS_ARG(u8_t is_mdns))
{
 80074c8:	b590      	push	{r4, r7, lr}
 80074ca:	b08b      	sub	sp, #44	; 0x2c
 80074cc:	af00      	add	r7, sp, #0
 80074ce:	60f8      	str	r0, [r7, #12]
 80074d0:	60b9      	str	r1, [r7, #8]
 80074d2:	607a      	str	r2, [r7, #4]
 80074d4:	603b      	str	r3, [r7, #0]
  u8_t i;
  u8_t lseq, lseqi;
  struct dns_table_entry *entry = NULL;
 80074d6:	2300      	movs	r3, #0
 80074d8:	623b      	str	r3, [r7, #32]
  struct dns_req_entry *req;

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
  u8_t r;
  /* check for duplicate entries */
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
 80074da:	2327      	movs	r3, #39	; 0x27
 80074dc:	18fb      	adds	r3, r7, r3
 80074de:	2200      	movs	r2, #0
 80074e0:	701a      	strb	r2, [r3, #0]
 80074e2:	e062      	b.n	80075aa <dns_enqueue+0xe2>
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
 80074e4:	2027      	movs	r0, #39	; 0x27
 80074e6:	183b      	adds	r3, r7, r0
 80074e8:	781a      	ldrb	r2, [r3, #0]
 80074ea:	49a3      	ldr	r1, [pc, #652]	; (8007778 <dns_enqueue+0x2b0>)
 80074ec:	0013      	movs	r3, r2
 80074ee:	00db      	lsls	r3, r3, #3
 80074f0:	189b      	adds	r3, r3, r2
 80074f2:	011b      	lsls	r3, r3, #4
 80074f4:	18cb      	adds	r3, r1, r3
 80074f6:	330a      	adds	r3, #10
 80074f8:	781b      	ldrb	r3, [r3, #0]
 80074fa:	2b02      	cmp	r3, #2
 80074fc:	d14f      	bne.n	800759e <dns_enqueue+0xd6>
        (lwip_strnicmp(name, dns_table[i].name, sizeof(dns_table[i].name)) == 0)) {
 80074fe:	183b      	adds	r3, r7, r0
 8007500:	781a      	ldrb	r2, [r3, #0]
 8007502:	0013      	movs	r3, r2
 8007504:	00db      	lsls	r3, r3, #3
 8007506:	189b      	adds	r3, r3, r2
 8007508:	011b      	lsls	r3, r3, #4
 800750a:	3310      	adds	r3, #16
 800750c:	001a      	movs	r2, r3
 800750e:	4b9a      	ldr	r3, [pc, #616]	; (8007778 <dns_enqueue+0x2b0>)
 8007510:	18d1      	adds	r1, r2, r3
 8007512:	68fb      	ldr	r3, [r7, #12]
 8007514:	2280      	movs	r2, #128	; 0x80
 8007516:	0018      	movs	r0, r3
 8007518:	f7ff f83b 	bl	8006592 <lwip_strnicmp>
 800751c:	1e03      	subs	r3, r0, #0
    if ((dns_table[i].state == DNS_STATE_ASKING) &&
 800751e:	d13e      	bne.n	800759e <dns_enqueue+0xd6>
           for the same host should not be that common */
        continue;
      }
#endif /* LWIP_IPV4 && LWIP_IPV6 */
      /* this is a duplicate entry, find a free request entry */
      for (r = 0; r < DNS_MAX_REQUESTS; r++) {
 8007520:	231b      	movs	r3, #27
 8007522:	18fb      	adds	r3, r7, r3
 8007524:	2200      	movs	r2, #0
 8007526:	701a      	strb	r2, [r3, #0]
 8007528:	e034      	b.n	8007594 <dns_enqueue+0xcc>
        if (dns_requests[r].found == 0) {
 800752a:	201b      	movs	r0, #27
 800752c:	183b      	adds	r3, r7, r0
 800752e:	781a      	ldrb	r2, [r3, #0]
 8007530:	4992      	ldr	r1, [pc, #584]	; (800777c <dns_enqueue+0x2b4>)
 8007532:	0013      	movs	r3, r2
 8007534:	005b      	lsls	r3, r3, #1
 8007536:	189b      	adds	r3, r3, r2
 8007538:	009b      	lsls	r3, r3, #2
 800753a:	585b      	ldr	r3, [r3, r1]
 800753c:	2b00      	cmp	r3, #0
 800753e:	d123      	bne.n	8007588 <dns_enqueue+0xc0>
          dns_requests[r].found = found;
 8007540:	183b      	adds	r3, r7, r0
 8007542:	781a      	ldrb	r2, [r3, #0]
 8007544:	498d      	ldr	r1, [pc, #564]	; (800777c <dns_enqueue+0x2b4>)
 8007546:	0013      	movs	r3, r2
 8007548:	005b      	lsls	r3, r3, #1
 800754a:	189b      	adds	r3, r3, r2
 800754c:	009b      	lsls	r3, r3, #2
 800754e:	687a      	ldr	r2, [r7, #4]
 8007550:	505a      	str	r2, [r3, r1]
          dns_requests[r].arg = callback_arg;
 8007552:	183b      	adds	r3, r7, r0
 8007554:	781a      	ldrb	r2, [r3, #0]
 8007556:	4989      	ldr	r1, [pc, #548]	; (800777c <dns_enqueue+0x2b4>)
 8007558:	0013      	movs	r3, r2
 800755a:	005b      	lsls	r3, r3, #1
 800755c:	189b      	adds	r3, r3, r2
 800755e:	009b      	lsls	r3, r3, #2
 8007560:	18cb      	adds	r3, r1, r3
 8007562:	3304      	adds	r3, #4
 8007564:	683a      	ldr	r2, [r7, #0]
 8007566:	601a      	str	r2, [r3, #0]
          dns_requests[r].dns_table_idx = i;
 8007568:	183b      	adds	r3, r7, r0
 800756a:	781a      	ldrb	r2, [r3, #0]
 800756c:	4983      	ldr	r1, [pc, #524]	; (800777c <dns_enqueue+0x2b4>)
 800756e:	0013      	movs	r3, r2
 8007570:	005b      	lsls	r3, r3, #1
 8007572:	189b      	adds	r3, r3, r2
 8007574:	009b      	lsls	r3, r3, #2
 8007576:	18cb      	adds	r3, r1, r3
 8007578:	3308      	adds	r3, #8
 800757a:	2227      	movs	r2, #39	; 0x27
 800757c:	18ba      	adds	r2, r7, r2
 800757e:	7812      	ldrb	r2, [r2, #0]
 8007580:	701a      	strb	r2, [r3, #0]
          LWIP_DNS_SET_ADDRTYPE(dns_requests[r].reqaddrtype, dns_addrtype);
          LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": duplicate request\n", name));
          return ERR_INPROGRESS;
 8007582:	2305      	movs	r3, #5
 8007584:	425b      	negs	r3, r3
 8007586:	e0f3      	b.n	8007770 <dns_enqueue+0x2a8>
      for (r = 0; r < DNS_MAX_REQUESTS; r++) {
 8007588:	211b      	movs	r1, #27
 800758a:	187b      	adds	r3, r7, r1
 800758c:	781a      	ldrb	r2, [r3, #0]
 800758e:	187b      	adds	r3, r7, r1
 8007590:	3201      	adds	r2, #1
 8007592:	701a      	strb	r2, [r3, #0]
 8007594:	231b      	movs	r3, #27
 8007596:	18fb      	adds	r3, r7, r3
 8007598:	781b      	ldrb	r3, [r3, #0]
 800759a:	2b02      	cmp	r3, #2
 800759c:	d9c5      	bls.n	800752a <dns_enqueue+0x62>
  for (i = 0; i < DNS_TABLE_SIZE; i++) {
 800759e:	2127      	movs	r1, #39	; 0x27
 80075a0:	187b      	adds	r3, r7, r1
 80075a2:	781a      	ldrb	r2, [r3, #0]
 80075a4:	187b      	adds	r3, r7, r1
 80075a6:	3201      	adds	r2, #1
 80075a8:	701a      	strb	r2, [r3, #0]
 80075aa:	2127      	movs	r1, #39	; 0x27
 80075ac:	187b      	adds	r3, r7, r1
 80075ae:	781b      	ldrb	r3, [r3, #0]
 80075b0:	2b02      	cmp	r3, #2
 80075b2:	d997      	bls.n	80074e4 <dns_enqueue+0x1c>
  }
  /* no duplicate entries found */
#endif

  /* search an unused entry, or the oldest one */
  lseq = 0;
 80075b4:	2326      	movs	r3, #38	; 0x26
 80075b6:	18fb      	adds	r3, r7, r3
 80075b8:	2200      	movs	r2, #0
 80075ba:	701a      	strb	r2, [r3, #0]
  lseqi = DNS_TABLE_SIZE;
 80075bc:	2325      	movs	r3, #37	; 0x25
 80075be:	18fb      	adds	r3, r7, r3
 80075c0:	2203      	movs	r2, #3
 80075c2:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 80075c4:	187b      	adds	r3, r7, r1
 80075c6:	2200      	movs	r2, #0
 80075c8:	701a      	strb	r2, [r3, #0]
 80075ca:	e030      	b.n	800762e <dns_enqueue+0x166>
    entry = &dns_table[i];
 80075cc:	2427      	movs	r4, #39	; 0x27
 80075ce:	193b      	adds	r3, r7, r4
 80075d0:	781a      	ldrb	r2, [r3, #0]
 80075d2:	0013      	movs	r3, r2
 80075d4:	00db      	lsls	r3, r3, #3
 80075d6:	189b      	adds	r3, r3, r2
 80075d8:	011b      	lsls	r3, r3, #4
 80075da:	4a67      	ldr	r2, [pc, #412]	; (8007778 <dns_enqueue+0x2b0>)
 80075dc:	189b      	adds	r3, r3, r2
 80075de:	623b      	str	r3, [r7, #32]
    /* is it an unused entry ? */
    if (entry->state == DNS_STATE_UNUSED) {
 80075e0:	6a3b      	ldr	r3, [r7, #32]
 80075e2:	7a9b      	ldrb	r3, [r3, #10]
 80075e4:	2b00      	cmp	r3, #0
 80075e6:	d028      	beq.n	800763a <dns_enqueue+0x172>
      break;
    }
    /* check if this is the oldest completed entry */
    if (entry->state == DNS_STATE_DONE) {
 80075e8:	6a3b      	ldr	r3, [r7, #32]
 80075ea:	7a9b      	ldrb	r3, [r3, #10]
 80075ec:	2b03      	cmp	r3, #3
 80075ee:	d118      	bne.n	8007622 <dns_enqueue+0x15a>
      u8_t age = (u8_t)(dns_seqno - entry->seqno);
 80075f0:	4b63      	ldr	r3, [pc, #396]	; (8007780 <dns_enqueue+0x2b8>)
 80075f2:	7819      	ldrb	r1, [r3, #0]
 80075f4:	6a3b      	ldr	r3, [r7, #32]
 80075f6:	7b9a      	ldrb	r2, [r3, #14]
 80075f8:	201a      	movs	r0, #26
 80075fa:	183b      	adds	r3, r7, r0
 80075fc:	1a8a      	subs	r2, r1, r2
 80075fe:	701a      	strb	r2, [r3, #0]
      if (age > lseq) {
 8007600:	0001      	movs	r1, r0
 8007602:	187a      	adds	r2, r7, r1
 8007604:	2026      	movs	r0, #38	; 0x26
 8007606:	183b      	adds	r3, r7, r0
 8007608:	7812      	ldrb	r2, [r2, #0]
 800760a:	781b      	ldrb	r3, [r3, #0]
 800760c:	429a      	cmp	r2, r3
 800760e:	d908      	bls.n	8007622 <dns_enqueue+0x15a>
        lseq = age;
 8007610:	183b      	adds	r3, r7, r0
 8007612:	187a      	adds	r2, r7, r1
 8007614:	7812      	ldrb	r2, [r2, #0]
 8007616:	701a      	strb	r2, [r3, #0]
        lseqi = i;
 8007618:	2325      	movs	r3, #37	; 0x25
 800761a:	18fb      	adds	r3, r7, r3
 800761c:	193a      	adds	r2, r7, r4
 800761e:	7812      	ldrb	r2, [r2, #0]
 8007620:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 8007622:	2227      	movs	r2, #39	; 0x27
 8007624:	18bb      	adds	r3, r7, r2
 8007626:	18ba      	adds	r2, r7, r2
 8007628:	7812      	ldrb	r2, [r2, #0]
 800762a:	3201      	adds	r2, #1
 800762c:	701a      	strb	r2, [r3, #0]
 800762e:	2327      	movs	r3, #39	; 0x27
 8007630:	18fb      	adds	r3, r7, r3
 8007632:	781b      	ldrb	r3, [r3, #0]
 8007634:	2b02      	cmp	r3, #2
 8007636:	d9c9      	bls.n	80075cc <dns_enqueue+0x104>
 8007638:	e000      	b.n	800763c <dns_enqueue+0x174>
      break;
 800763a:	46c0      	nop			; (mov r8, r8)
      }
    }
  }

  /* if we don't have found an unused entry, use the oldest completed one */
  if (i == DNS_TABLE_SIZE) {
 800763c:	2327      	movs	r3, #39	; 0x27
 800763e:	18fb      	adds	r3, r7, r3
 8007640:	781b      	ldrb	r3, [r3, #0]
 8007642:	2b03      	cmp	r3, #3
 8007644:	d122      	bne.n	800768c <dns_enqueue+0x1c4>
    if ((lseqi >= DNS_TABLE_SIZE) || (dns_table[lseqi].state != DNS_STATE_DONE)) {
 8007646:	2225      	movs	r2, #37	; 0x25
 8007648:	18bb      	adds	r3, r7, r2
 800764a:	781b      	ldrb	r3, [r3, #0]
 800764c:	2b02      	cmp	r3, #2
 800764e:	d80b      	bhi.n	8007668 <dns_enqueue+0x1a0>
 8007650:	18bb      	adds	r3, r7, r2
 8007652:	781a      	ldrb	r2, [r3, #0]
 8007654:	4948      	ldr	r1, [pc, #288]	; (8007778 <dns_enqueue+0x2b0>)
 8007656:	0013      	movs	r3, r2
 8007658:	00db      	lsls	r3, r3, #3
 800765a:	189b      	adds	r3, r3, r2
 800765c:	011b      	lsls	r3, r3, #4
 800765e:	18cb      	adds	r3, r1, r3
 8007660:	330a      	adds	r3, #10
 8007662:	781b      	ldrb	r3, [r3, #0]
 8007664:	2b03      	cmp	r3, #3
 8007666:	d002      	beq.n	800766e <dns_enqueue+0x1a6>
      /* no entry can be used now, table is full */
      LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": DNS entries table is full\n", name));
      return ERR_MEM;
 8007668:	2301      	movs	r3, #1
 800766a:	425b      	negs	r3, r3
 800766c:	e080      	b.n	8007770 <dns_enqueue+0x2a8>
    } else {
      /* use the oldest completed one */
      i = lseqi;
 800766e:	2127      	movs	r1, #39	; 0x27
 8007670:	187b      	adds	r3, r7, r1
 8007672:	2225      	movs	r2, #37	; 0x25
 8007674:	18ba      	adds	r2, r7, r2
 8007676:	7812      	ldrb	r2, [r2, #0]
 8007678:	701a      	strb	r2, [r3, #0]
      entry = &dns_table[i];
 800767a:	187b      	adds	r3, r7, r1
 800767c:	781a      	ldrb	r2, [r3, #0]
 800767e:	0013      	movs	r3, r2
 8007680:	00db      	lsls	r3, r3, #3
 8007682:	189b      	adds	r3, r3, r2
 8007684:	011b      	lsls	r3, r3, #4
 8007686:	4a3c      	ldr	r2, [pc, #240]	; (8007778 <dns_enqueue+0x2b0>)
 8007688:	189b      	adds	r3, r3, r2
 800768a:	623b      	str	r3, [r7, #32]
    }
  }

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
  /* find a free request entry */
  req = NULL;
 800768c:	2300      	movs	r3, #0
 800768e:	61fb      	str	r3, [r7, #28]
  for (r = 0; r < DNS_MAX_REQUESTS; r++) {
 8007690:	231b      	movs	r3, #27
 8007692:	18fb      	adds	r3, r7, r3
 8007694:	2200      	movs	r2, #0
 8007696:	701a      	strb	r2, [r3, #0]
 8007698:	e01a      	b.n	80076d0 <dns_enqueue+0x208>
    if (dns_requests[r].found == NULL) {
 800769a:	201b      	movs	r0, #27
 800769c:	183b      	adds	r3, r7, r0
 800769e:	781a      	ldrb	r2, [r3, #0]
 80076a0:	4936      	ldr	r1, [pc, #216]	; (800777c <dns_enqueue+0x2b4>)
 80076a2:	0013      	movs	r3, r2
 80076a4:	005b      	lsls	r3, r3, #1
 80076a6:	189b      	adds	r3, r3, r2
 80076a8:	009b      	lsls	r3, r3, #2
 80076aa:	585b      	ldr	r3, [r3, r1]
 80076ac:	2b00      	cmp	r3, #0
 80076ae:	d109      	bne.n	80076c4 <dns_enqueue+0x1fc>
      req = &dns_requests[r];
 80076b0:	183b      	adds	r3, r7, r0
 80076b2:	781a      	ldrb	r2, [r3, #0]
 80076b4:	0013      	movs	r3, r2
 80076b6:	005b      	lsls	r3, r3, #1
 80076b8:	189b      	adds	r3, r3, r2
 80076ba:	009b      	lsls	r3, r3, #2
 80076bc:	4a2f      	ldr	r2, [pc, #188]	; (800777c <dns_enqueue+0x2b4>)
 80076be:	189b      	adds	r3, r3, r2
 80076c0:	61fb      	str	r3, [r7, #28]
      break;
 80076c2:	e00a      	b.n	80076da <dns_enqueue+0x212>
  for (r = 0; r < DNS_MAX_REQUESTS; r++) {
 80076c4:	211b      	movs	r1, #27
 80076c6:	187b      	adds	r3, r7, r1
 80076c8:	781a      	ldrb	r2, [r3, #0]
 80076ca:	187b      	adds	r3, r7, r1
 80076cc:	3201      	adds	r2, #1
 80076ce:	701a      	strb	r2, [r3, #0]
 80076d0:	231b      	movs	r3, #27
 80076d2:	18fb      	adds	r3, r7, r3
 80076d4:	781b      	ldrb	r3, [r3, #0]
 80076d6:	2b02      	cmp	r3, #2
 80076d8:	d9df      	bls.n	800769a <dns_enqueue+0x1d2>
    }
  }
  if (req == NULL) {
 80076da:	69fb      	ldr	r3, [r7, #28]
 80076dc:	2b00      	cmp	r3, #0
 80076de:	d102      	bne.n	80076e6 <dns_enqueue+0x21e>
    /* no request entry can be used now, table is full */
    LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": DNS request entries table is full\n", name));
    return ERR_MEM;
 80076e0:	2301      	movs	r3, #1
 80076e2:	425b      	negs	r3, r3
 80076e4:	e044      	b.n	8007770 <dns_enqueue+0x2a8>
  }
  req->dns_table_idx = i;
 80076e6:	69fb      	ldr	r3, [r7, #28]
 80076e8:	2227      	movs	r2, #39	; 0x27
 80076ea:	18ba      	adds	r2, r7, r2
 80076ec:	7812      	ldrb	r2, [r2, #0]
 80076ee:	721a      	strb	r2, [r3, #8]

  /* use this entry */
  LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": use DNS entry %"U16_F"\n", name, (u16_t)(i)));

  /* fill the entry */
  entry->state = DNS_STATE_NEW;
 80076f0:	6a3b      	ldr	r3, [r7, #32]
 80076f2:	2201      	movs	r2, #1
 80076f4:	729a      	strb	r2, [r3, #10]
  entry->seqno = dns_seqno;
 80076f6:	4b22      	ldr	r3, [pc, #136]	; (8007780 <dns_enqueue+0x2b8>)
 80076f8:	781a      	ldrb	r2, [r3, #0]
 80076fa:	6a3b      	ldr	r3, [r7, #32]
 80076fc:	739a      	strb	r2, [r3, #14]
  LWIP_DNS_SET_ADDRTYPE(entry->reqaddrtype, dns_addrtype);
  LWIP_DNS_SET_ADDRTYPE(req->reqaddrtype, dns_addrtype);
  req->found = found;
 80076fe:	69fb      	ldr	r3, [r7, #28]
 8007700:	687a      	ldr	r2, [r7, #4]
 8007702:	601a      	str	r2, [r3, #0]
  req->arg   = callback_arg;
 8007704:	69fb      	ldr	r3, [r7, #28]
 8007706:	683a      	ldr	r2, [r7, #0]
 8007708:	605a      	str	r2, [r3, #4]
  namelen = LWIP_MIN(hostnamelen, DNS_MAX_NAME_LENGTH - 1);
 800770a:	68bb      	ldr	r3, [r7, #8]
 800770c:	2b7f      	cmp	r3, #127	; 0x7f
 800770e:	d900      	bls.n	8007712 <dns_enqueue+0x24a>
 8007710:	237f      	movs	r3, #127	; 0x7f
 8007712:	617b      	str	r3, [r7, #20]
  MEMCPY(entry->name, name, namelen);
 8007714:	6a3b      	ldr	r3, [r7, #32]
 8007716:	3310      	adds	r3, #16
 8007718:	697a      	ldr	r2, [r7, #20]
 800771a:	68f9      	ldr	r1, [r7, #12]
 800771c:	0018      	movs	r0, r3
 800771e:	f015 f869 	bl	801c7f4 <memcpy>
  entry->name[namelen] = 0;
 8007722:	6a3a      	ldr	r2, [r7, #32]
 8007724:	697b      	ldr	r3, [r7, #20]
 8007726:	18d3      	adds	r3, r2, r3
 8007728:	3310      	adds	r3, #16
 800772a:	2200      	movs	r2, #0
 800772c:	701a      	strb	r2, [r3, #0]

#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
  entry->pcb_idx = dns_alloc_pcb();
 800772e:	f7ff fa87 	bl	8006c40 <dns_alloc_pcb>
 8007732:	0003      	movs	r3, r0
 8007734:	001a      	movs	r2, r3
 8007736:	6a3b      	ldr	r3, [r7, #32]
 8007738:	73da      	strb	r2, [r3, #15]
  if (entry->pcb_idx >= DNS_MAX_SOURCE_PORTS) {
 800773a:	6a3b      	ldr	r3, [r7, #32]
 800773c:	7bdb      	ldrb	r3, [r3, #15]
 800773e:	2b02      	cmp	r3, #2
 8007740:	d908      	bls.n	8007754 <dns_enqueue+0x28c>
    /* failed to get a UDP pcb */
    LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": failed to allocate a pcb\n", name));
    entry->state = DNS_STATE_UNUSED;
 8007742:	6a3b      	ldr	r3, [r7, #32]
 8007744:	2200      	movs	r2, #0
 8007746:	729a      	strb	r2, [r3, #10]
    req->found = NULL;
 8007748:	69fb      	ldr	r3, [r7, #28]
 800774a:	2200      	movs	r2, #0
 800774c:	601a      	str	r2, [r3, #0]
    return ERR_MEM;
 800774e:	2301      	movs	r3, #1
 8007750:	425b      	negs	r3, r3
 8007752:	e00d      	b.n	8007770 <dns_enqueue+0x2a8>

#if LWIP_DNS_SUPPORT_MDNS_QUERIES
  entry->is_mdns = is_mdns;
#endif

  dns_seqno++;
 8007754:	4b0a      	ldr	r3, [pc, #40]	; (8007780 <dns_enqueue+0x2b8>)
 8007756:	781b      	ldrb	r3, [r3, #0]
 8007758:	3301      	adds	r3, #1
 800775a:	b2da      	uxtb	r2, r3
 800775c:	4b08      	ldr	r3, [pc, #32]	; (8007780 <dns_enqueue+0x2b8>)
 800775e:	701a      	strb	r2, [r3, #0]

  /* force to send query without waiting timer */
  dns_check_entry(i);
 8007760:	2327      	movs	r3, #39	; 0x27
 8007762:	18fb      	adds	r3, r7, r3
 8007764:	781b      	ldrb	r3, [r3, #0]
 8007766:	0018      	movs	r0, r3
 8007768:	f7ff fc0c 	bl	8006f84 <dns_check_entry>

  /* dns query is enqueued */
  return ERR_INPROGRESS;
 800776c:	2305      	movs	r3, #5
 800776e:	425b      	negs	r3, r3
}
 8007770:	0018      	movs	r0, r3
 8007772:	46bd      	mov	sp, r7
 8007774:	b00b      	add	sp, #44	; 0x2c
 8007776:	bd90      	pop	{r4, r7, pc}
 8007778:	20001154 	.word	0x20001154
 800777c:	20001304 	.word	0x20001304
 8007780:	20001151 	.word	0x20001151

08007784 <dns_gethostbyname>:
 * @return a err_t return code.
 */
err_t
dns_gethostbyname(const char *hostname, ip_addr_t *addr, dns_found_callback found,
                  void *callback_arg)
{
 8007784:	b590      	push	{r4, r7, lr}
 8007786:	b087      	sub	sp, #28
 8007788:	af02      	add	r7, sp, #8
 800778a:	60f8      	str	r0, [r7, #12]
 800778c:	60b9      	str	r1, [r7, #8]
 800778e:	607a      	str	r2, [r7, #4]
 8007790:	603b      	str	r3, [r7, #0]
  return dns_gethostbyname_addrtype(hostname, addr, found, callback_arg, LWIP_DNS_ADDRTYPE_DEFAULT);
 8007792:	683b      	ldr	r3, [r7, #0]
 8007794:	687a      	ldr	r2, [r7, #4]
 8007796:	68b9      	ldr	r1, [r7, #8]
 8007798:	68f8      	ldr	r0, [r7, #12]
 800779a:	2400      	movs	r4, #0
 800779c:	9400      	str	r4, [sp, #0]
 800779e:	f000 f805 	bl	80077ac <dns_gethostbyname_addrtype>
 80077a2:	0003      	movs	r3, r0
}
 80077a4:	0018      	movs	r0, r3
 80077a6:	46bd      	mov	sp, r7
 80077a8:	b005      	add	sp, #20
 80077aa:	bd90      	pop	{r4, r7, pc}

080077ac <dns_gethostbyname_addrtype>:
 *                     - LWIP_DNS_ADDRTYPE_IPV6: try to resolve IPv6 only
 */
err_t
dns_gethostbyname_addrtype(const char *hostname, ip_addr_t *addr, dns_found_callback found,
                           void *callback_arg, u8_t dns_addrtype)
{
 80077ac:	b580      	push	{r7, lr}
 80077ae:	b086      	sub	sp, #24
 80077b0:	af00      	add	r7, sp, #0
 80077b2:	60f8      	str	r0, [r7, #12]
 80077b4:	60b9      	str	r1, [r7, #8]
 80077b6:	607a      	str	r2, [r7, #4]
 80077b8:	603b      	str	r3, [r7, #0]
#if LWIP_DNS_SUPPORT_MDNS_QUERIES
  u8_t is_mdns;
#endif
  /* not initialized or no valid server yet, or invalid addr pointer
   * or invalid hostname or invalid hostname length */
  if ((addr == NULL) ||
 80077ba:	68bb      	ldr	r3, [r7, #8]
 80077bc:	2b00      	cmp	r3, #0
 80077be:	d006      	beq.n	80077ce <dns_gethostbyname_addrtype+0x22>
 80077c0:	68fb      	ldr	r3, [r7, #12]
 80077c2:	2b00      	cmp	r3, #0
 80077c4:	d003      	beq.n	80077ce <dns_gethostbyname_addrtype+0x22>
      (!hostname) || (!hostname[0])) {
 80077c6:	68fb      	ldr	r3, [r7, #12]
 80077c8:	781b      	ldrb	r3, [r3, #0]
 80077ca:	2b00      	cmp	r3, #0
 80077cc:	d102      	bne.n	80077d4 <dns_gethostbyname_addrtype+0x28>
    return ERR_ARG;
 80077ce:	2310      	movs	r3, #16
 80077d0:	425b      	negs	r3, r3
 80077d2:	e02d      	b.n	8007830 <dns_gethostbyname_addrtype+0x84>
#if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) == 0)
  if (dns_pcbs[0] == NULL) {
    return ERR_ARG;
  }
#endif
  hostnamelen = strlen(hostname);
 80077d4:	68fb      	ldr	r3, [r7, #12]
 80077d6:	0018      	movs	r0, r3
 80077d8:	f7f8 fc96 	bl	8000108 <strlen>
 80077dc:	0003      	movs	r3, r0
 80077de:	617b      	str	r3, [r7, #20]
  if (hostnamelen >= DNS_MAX_NAME_LENGTH) {
 80077e0:	697b      	ldr	r3, [r7, #20]
 80077e2:	2b7f      	cmp	r3, #127	; 0x7f
 80077e4:	d902      	bls.n	80077ec <dns_gethostbyname_addrtype+0x40>
    LWIP_DEBUGF(DNS_DEBUG, ("dns_gethostbyname: name too long to resolve"));
    return ERR_ARG;
 80077e6:	2310      	movs	r3, #16
 80077e8:	425b      	negs	r3, r3
 80077ea:	e021      	b.n	8007830 <dns_gethostbyname_addrtype+0x84>
    return ERR_OK;
  }
#endif /* LWIP_HAVE_LOOPIF */

  /* host name already in octet notation? set ip addr and return ERR_OK */
  if (ipaddr_aton(hostname, addr)) {
 80077ec:	68ba      	ldr	r2, [r7, #8]
 80077ee:	68fb      	ldr	r3, [r7, #12]
 80077f0:	0011      	movs	r1, r2
 80077f2:	0018      	movs	r0, r3
 80077f4:	f00b ffc0 	bl	8013778 <ip4addr_aton>
 80077f8:	1e03      	subs	r3, r0, #0
 80077fa:	d001      	beq.n	8007800 <dns_gethostbyname_addrtype+0x54>
#if LWIP_IPV4 && LWIP_IPV6
    if ((IP_IS_V6(addr) && (dns_addrtype != LWIP_DNS_ADDRTYPE_IPV4)) ||
        (IP_IS_V4(addr) && (dns_addrtype != LWIP_DNS_ADDRTYPE_IPV6)))
#endif /* LWIP_IPV4 && LWIP_IPV6 */
    {
      return ERR_OK;
 80077fc:	2300      	movs	r3, #0
 80077fe:	e017      	b.n	8007830 <dns_gethostbyname_addrtype+0x84>
    }
  }
  /* already have this address cached? */
  if (dns_lookup(hostname, addr LWIP_DNS_ADDRTYPE_ARG(dns_addrtype)) == ERR_OK) {
 8007800:	68ba      	ldr	r2, [r7, #8]
 8007802:	68fb      	ldr	r3, [r7, #12]
 8007804:	0011      	movs	r1, r2
 8007806:	0018      	movs	r0, r3
 8007808:	f7fe ff5c 	bl	80066c4 <dns_lookup>
 800780c:	1e03      	subs	r3, r0, #0
 800780e:	d101      	bne.n	8007814 <dns_gethostbyname_addrtype+0x68>
    return ERR_OK;
 8007810:	2300      	movs	r3, #0
 8007812:	e00d      	b.n	8007830 <dns_gethostbyname_addrtype+0x84>

  if (!is_mdns)
#endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
  {
    /* prevent calling found callback if no server is set, return error instead */
    if (ip_addr_isany_val(dns_servers[0])) {
 8007814:	4b08      	ldr	r3, [pc, #32]	; (8007838 <dns_gethostbyname_addrtype+0x8c>)
 8007816:	681b      	ldr	r3, [r3, #0]
 8007818:	2b00      	cmp	r3, #0
 800781a:	d102      	bne.n	8007822 <dns_gethostbyname_addrtype+0x76>
      return ERR_VAL;
 800781c:	2306      	movs	r3, #6
 800781e:	425b      	negs	r3, r3
 8007820:	e006      	b.n	8007830 <dns_gethostbyname_addrtype+0x84>
    }
  }

  /* queue query with specified callback */
  return dns_enqueue(hostname, hostnamelen, found, callback_arg LWIP_DNS_ADDRTYPE_ARG(dns_addrtype)
 8007822:	683b      	ldr	r3, [r7, #0]
 8007824:	687a      	ldr	r2, [r7, #4]
 8007826:	6979      	ldr	r1, [r7, #20]
 8007828:	68f8      	ldr	r0, [r7, #12]
 800782a:	f7ff fe4d 	bl	80074c8 <dns_enqueue>
 800782e:	0003      	movs	r3, r0
                     LWIP_DNS_ISMDNS_ARG(is_mdns));
}
 8007830:	0018      	movs	r0, r3
 8007832:	46bd      	mov	sp, r7
 8007834:	b006      	add	sp, #24
 8007836:	bd80      	pop	{r7, pc}
 8007838:	20001328 	.word	0x20001328

0800783c <lwip_standard_chksum>:
 * @param len length of data to be summed
 * @return host order (!) lwip checksum (non-inverted Internet sum)
 */
u16_t
lwip_standard_chksum(const void *dataptr, int len)
{
 800783c:	b580      	push	{r7, lr}
 800783e:	b088      	sub	sp, #32
 8007840:	af00      	add	r7, sp, #0
 8007842:	6078      	str	r0, [r7, #4]
 8007844:	6039      	str	r1, [r7, #0]
  const u8_t *pb = (const u8_t *)dataptr;
 8007846:	687b      	ldr	r3, [r7, #4]
 8007848:	61fb      	str	r3, [r7, #28]
  const u16_t *ps;
  u16_t t = 0;
 800784a:	210e      	movs	r1, #14
 800784c:	187b      	adds	r3, r7, r1
 800784e:	2200      	movs	r2, #0
 8007850:	801a      	strh	r2, [r3, #0]
  u32_t sum = 0;
 8007852:	2300      	movs	r3, #0
 8007854:	617b      	str	r3, [r7, #20]
  int odd = ((mem_ptr_t)pb & 1);
 8007856:	69fb      	ldr	r3, [r7, #28]
 8007858:	2201      	movs	r2, #1
 800785a:	4013      	ands	r3, r2
 800785c:	613b      	str	r3, [r7, #16]

  /* Get aligned to u16_t */
  if (odd && len > 0) {
 800785e:	693b      	ldr	r3, [r7, #16]
 8007860:	2b00      	cmp	r3, #0
 8007862:	d00c      	beq.n	800787e <lwip_standard_chksum+0x42>
 8007864:	683b      	ldr	r3, [r7, #0]
 8007866:	2b00      	cmp	r3, #0
 8007868:	dd09      	ble.n	800787e <lwip_standard_chksum+0x42>
    ((u8_t *)&t)[1] = *pb++;
 800786a:	69fa      	ldr	r2, [r7, #28]
 800786c:	1c53      	adds	r3, r2, #1
 800786e:	61fb      	str	r3, [r7, #28]
 8007870:	187b      	adds	r3, r7, r1
 8007872:	3301      	adds	r3, #1
 8007874:	7812      	ldrb	r2, [r2, #0]
 8007876:	701a      	strb	r2, [r3, #0]
    len--;
 8007878:	683b      	ldr	r3, [r7, #0]
 800787a:	3b01      	subs	r3, #1
 800787c:	603b      	str	r3, [r7, #0]
  }

  /* Add the bulk of the data */
  ps = (const u16_t *)(const void *)pb;
 800787e:	69fb      	ldr	r3, [r7, #28]
 8007880:	61bb      	str	r3, [r7, #24]
  while (len > 1) {
 8007882:	e00a      	b.n	800789a <lwip_standard_chksum+0x5e>
    sum += *ps++;
 8007884:	69bb      	ldr	r3, [r7, #24]
 8007886:	1c9a      	adds	r2, r3, #2
 8007888:	61ba      	str	r2, [r7, #24]
 800788a:	881b      	ldrh	r3, [r3, #0]
 800788c:	001a      	movs	r2, r3
 800788e:	697b      	ldr	r3, [r7, #20]
 8007890:	189b      	adds	r3, r3, r2
 8007892:	617b      	str	r3, [r7, #20]
    len -= 2;
 8007894:	683b      	ldr	r3, [r7, #0]
 8007896:	3b02      	subs	r3, #2
 8007898:	603b      	str	r3, [r7, #0]
  while (len > 1) {
 800789a:	683b      	ldr	r3, [r7, #0]
 800789c:	2b01      	cmp	r3, #1
 800789e:	dcf1      	bgt.n	8007884 <lwip_standard_chksum+0x48>
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
 80078a0:	683b      	ldr	r3, [r7, #0]
 80078a2:	2b00      	cmp	r3, #0
 80078a4:	dd04      	ble.n	80078b0 <lwip_standard_chksum+0x74>
    ((u8_t *)&t)[0] = *(const u8_t *)ps;
 80078a6:	230e      	movs	r3, #14
 80078a8:	18fb      	adds	r3, r7, r3
 80078aa:	69ba      	ldr	r2, [r7, #24]
 80078ac:	7812      	ldrb	r2, [r2, #0]
 80078ae:	701a      	strb	r2, [r3, #0]
  }

  /* Add end bytes */
  sum += t;
 80078b0:	230e      	movs	r3, #14
 80078b2:	18fb      	adds	r3, r7, r3
 80078b4:	881b      	ldrh	r3, [r3, #0]
 80078b6:	001a      	movs	r2, r3
 80078b8:	697b      	ldr	r3, [r7, #20]
 80078ba:	189b      	adds	r3, r3, r2
 80078bc:	617b      	str	r3, [r7, #20]

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  sum = FOLD_U32T(sum);
 80078be:	697b      	ldr	r3, [r7, #20]
 80078c0:	0c1a      	lsrs	r2, r3, #16
 80078c2:	697b      	ldr	r3, [r7, #20]
 80078c4:	041b      	lsls	r3, r3, #16
 80078c6:	0c1b      	lsrs	r3, r3, #16
 80078c8:	18d3      	adds	r3, r2, r3
 80078ca:	617b      	str	r3, [r7, #20]
  sum = FOLD_U32T(sum);
 80078cc:	697b      	ldr	r3, [r7, #20]
 80078ce:	0c1a      	lsrs	r2, r3, #16
 80078d0:	697b      	ldr	r3, [r7, #20]
 80078d2:	041b      	lsls	r3, r3, #16
 80078d4:	0c1b      	lsrs	r3, r3, #16
 80078d6:	18d3      	adds	r3, r2, r3
 80078d8:	617b      	str	r3, [r7, #20]

  /* Swap if alignment was odd */
  if (odd) {
 80078da:	693b      	ldr	r3, [r7, #16]
 80078dc:	2b00      	cmp	r3, #0
 80078de:	d009      	beq.n	80078f4 <lwip_standard_chksum+0xb8>
    sum = SWAP_BYTES_IN_WORD(sum);
 80078e0:	697b      	ldr	r3, [r7, #20]
 80078e2:	021b      	lsls	r3, r3, #8
 80078e4:	041b      	lsls	r3, r3, #16
 80078e6:	0c1a      	lsrs	r2, r3, #16
 80078e8:	697b      	ldr	r3, [r7, #20]
 80078ea:	0a1b      	lsrs	r3, r3, #8
 80078ec:	21ff      	movs	r1, #255	; 0xff
 80078ee:	400b      	ands	r3, r1
 80078f0:	4313      	orrs	r3, r2
 80078f2:	617b      	str	r3, [r7, #20]
  }

  return (u16_t)sum;
 80078f4:	697b      	ldr	r3, [r7, #20]
 80078f6:	b29b      	uxth	r3, r3
}
 80078f8:	0018      	movs	r0, r3
 80078fa:	46bd      	mov	sp, r7
 80078fc:	b008      	add	sp, #32
 80078fe:	bd80      	pop	{r7, pc}

08007900 <inet_cksum_pseudo_base>:
#endif

/** Parts of the pseudo checksum which are common to IPv4 and IPv6 */
static u16_t
inet_cksum_pseudo_base(struct pbuf *p, u8_t proto, u16_t proto_len, u32_t acc)
{
 8007900:	b580      	push	{r7, lr}
 8007902:	b086      	sub	sp, #24
 8007904:	af00      	add	r7, sp, #0
 8007906:	60f8      	str	r0, [r7, #12]
 8007908:	0008      	movs	r0, r1
 800790a:	0011      	movs	r1, r2
 800790c:	607b      	str	r3, [r7, #4]
 800790e:	230b      	movs	r3, #11
 8007910:	18fb      	adds	r3, r7, r3
 8007912:	1c02      	adds	r2, r0, #0
 8007914:	701a      	strb	r2, [r3, #0]
 8007916:	2308      	movs	r3, #8
 8007918:	18fb      	adds	r3, r7, r3
 800791a:	1c0a      	adds	r2, r1, #0
 800791c:	801a      	strh	r2, [r3, #0]
  struct pbuf *q;
  int swapped = 0;
 800791e:	2300      	movs	r3, #0
 8007920:	613b      	str	r3, [r7, #16]

  /* iterate through all pbuf in chain */
  for (q = p; q != NULL; q = q->next) {
 8007922:	68fb      	ldr	r3, [r7, #12]
 8007924:	617b      	str	r3, [r7, #20]
 8007926:	e02c      	b.n	8007982 <inet_cksum_pseudo_base+0x82>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
                             (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
 8007928:	697b      	ldr	r3, [r7, #20]
 800792a:	685a      	ldr	r2, [r3, #4]
 800792c:	697b      	ldr	r3, [r7, #20]
 800792e:	895b      	ldrh	r3, [r3, #10]
 8007930:	0019      	movs	r1, r3
 8007932:	0010      	movs	r0, r2
 8007934:	f7ff ff82 	bl	800783c <lwip_standard_chksum>
 8007938:	0003      	movs	r3, r0
 800793a:	001a      	movs	r2, r3
 800793c:	687b      	ldr	r3, [r7, #4]
 800793e:	189b      	adds	r3, r3, r2
 8007940:	607b      	str	r3, [r7, #4]
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
 8007942:	687b      	ldr	r3, [r7, #4]
 8007944:	0c1a      	lsrs	r2, r3, #16
 8007946:	687b      	ldr	r3, [r7, #4]
 8007948:	041b      	lsls	r3, r3, #16
 800794a:	0c1b      	lsrs	r3, r3, #16
 800794c:	18d3      	adds	r3, r2, r3
 800794e:	607b      	str	r3, [r7, #4]
    if (q->len % 2 != 0) {
 8007950:	697b      	ldr	r3, [r7, #20]
 8007952:	895b      	ldrh	r3, [r3, #10]
 8007954:	2201      	movs	r2, #1
 8007956:	4013      	ands	r3, r2
 8007958:	b29b      	uxth	r3, r3
 800795a:	2b00      	cmp	r3, #0
 800795c:	d00e      	beq.n	800797c <inet_cksum_pseudo_base+0x7c>
      swapped = !swapped;
 800795e:	693b      	ldr	r3, [r7, #16]
 8007960:	425a      	negs	r2, r3
 8007962:	4153      	adcs	r3, r2
 8007964:	b2db      	uxtb	r3, r3
 8007966:	613b      	str	r3, [r7, #16]
      acc = SWAP_BYTES_IN_WORD(acc);
 8007968:	687b      	ldr	r3, [r7, #4]
 800796a:	021b      	lsls	r3, r3, #8
 800796c:	041b      	lsls	r3, r3, #16
 800796e:	0c1a      	lsrs	r2, r3, #16
 8007970:	687b      	ldr	r3, [r7, #4]
 8007972:	0a1b      	lsrs	r3, r3, #8
 8007974:	21ff      	movs	r1, #255	; 0xff
 8007976:	400b      	ands	r3, r1
 8007978:	4313      	orrs	r3, r2
 800797a:	607b      	str	r3, [r7, #4]
  for (q = p; q != NULL; q = q->next) {
 800797c:	697b      	ldr	r3, [r7, #20]
 800797e:	681b      	ldr	r3, [r3, #0]
 8007980:	617b      	str	r3, [r7, #20]
 8007982:	697b      	ldr	r3, [r7, #20]
 8007984:	2b00      	cmp	r3, #0
 8007986:	d1cf      	bne.n	8007928 <inet_cksum_pseudo_base+0x28>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 8007988:	693b      	ldr	r3, [r7, #16]
 800798a:	2b00      	cmp	r3, #0
 800798c:	d009      	beq.n	80079a2 <inet_cksum_pseudo_base+0xa2>
    acc = SWAP_BYTES_IN_WORD(acc);
 800798e:	687b      	ldr	r3, [r7, #4]
 8007990:	021b      	lsls	r3, r3, #8
 8007992:	041b      	lsls	r3, r3, #16
 8007994:	0c1a      	lsrs	r2, r3, #16
 8007996:	687b      	ldr	r3, [r7, #4]
 8007998:	0a1b      	lsrs	r3, r3, #8
 800799a:	21ff      	movs	r1, #255	; 0xff
 800799c:	400b      	ands	r3, r1
 800799e:	4313      	orrs	r3, r2
 80079a0:	607b      	str	r3, [r7, #4]
  }

  acc += (u32_t)lwip_htons((u16_t)proto);
 80079a2:	230b      	movs	r3, #11
 80079a4:	18fb      	adds	r3, r7, r3
 80079a6:	781b      	ldrb	r3, [r3, #0]
 80079a8:	b29b      	uxth	r3, r3
 80079aa:	0018      	movs	r0, r3
 80079ac:	f7fe fdc2 	bl	8006534 <lwip_htons>
 80079b0:	0003      	movs	r3, r0
 80079b2:	001a      	movs	r2, r3
 80079b4:	687b      	ldr	r3, [r7, #4]
 80079b6:	189b      	adds	r3, r3, r2
 80079b8:	607b      	str	r3, [r7, #4]
  acc += (u32_t)lwip_htons(proto_len);
 80079ba:	2308      	movs	r3, #8
 80079bc:	18fb      	adds	r3, r7, r3
 80079be:	881b      	ldrh	r3, [r3, #0]
 80079c0:	0018      	movs	r0, r3
 80079c2:	f7fe fdb7 	bl	8006534 <lwip_htons>
 80079c6:	0003      	movs	r3, r0
 80079c8:	001a      	movs	r2, r3
 80079ca:	687b      	ldr	r3, [r7, #4]
 80079cc:	189b      	adds	r3, r3, r2
 80079ce:	607b      	str	r3, [r7, #4]

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  acc = FOLD_U32T(acc);
 80079d0:	687b      	ldr	r3, [r7, #4]
 80079d2:	0c1a      	lsrs	r2, r3, #16
 80079d4:	687b      	ldr	r3, [r7, #4]
 80079d6:	041b      	lsls	r3, r3, #16
 80079d8:	0c1b      	lsrs	r3, r3, #16
 80079da:	18d3      	adds	r3, r2, r3
 80079dc:	607b      	str	r3, [r7, #4]
  acc = FOLD_U32T(acc);
 80079de:	687b      	ldr	r3, [r7, #4]
 80079e0:	0c1a      	lsrs	r2, r3, #16
 80079e2:	687b      	ldr	r3, [r7, #4]
 80079e4:	041b      	lsls	r3, r3, #16
 80079e6:	0c1b      	lsrs	r3, r3, #16
 80079e8:	18d3      	adds	r3, r2, r3
 80079ea:	607b      	str	r3, [r7, #4]
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 80079ec:	687b      	ldr	r3, [r7, #4]
 80079ee:	b29b      	uxth	r3, r3
 80079f0:	43db      	mvns	r3, r3
 80079f2:	b29b      	uxth	r3, r3
}
 80079f4:	0018      	movs	r0, r3
 80079f6:	46bd      	mov	sp, r7
 80079f8:	b006      	add	sp, #24
 80079fa:	bd80      	pop	{r7, pc}

080079fc <inet_chksum_pseudo>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pseudo(struct pbuf *p, u8_t proto, u16_t proto_len,
                   const ip4_addr_t *src, const ip4_addr_t *dest)
{
 80079fc:	b5b0      	push	{r4, r5, r7, lr}
 80079fe:	b086      	sub	sp, #24
 8007a00:	af00      	add	r7, sp, #0
 8007a02:	60f8      	str	r0, [r7, #12]
 8007a04:	0008      	movs	r0, r1
 8007a06:	0011      	movs	r1, r2
 8007a08:	607b      	str	r3, [r7, #4]
 8007a0a:	250b      	movs	r5, #11
 8007a0c:	197b      	adds	r3, r7, r5
 8007a0e:	1c02      	adds	r2, r0, #0
 8007a10:	701a      	strb	r2, [r3, #0]
 8007a12:	2008      	movs	r0, #8
 8007a14:	183b      	adds	r3, r7, r0
 8007a16:	1c0a      	adds	r2, r1, #0
 8007a18:	801a      	strh	r2, [r3, #0]
  u32_t acc;
  u32_t addr;

  addr = ip4_addr_get_u32(src);
 8007a1a:	687b      	ldr	r3, [r7, #4]
 8007a1c:	681b      	ldr	r3, [r3, #0]
 8007a1e:	617b      	str	r3, [r7, #20]
  acc = (addr & 0xffffUL);
 8007a20:	697b      	ldr	r3, [r7, #20]
 8007a22:	041b      	lsls	r3, r3, #16
 8007a24:	0c1b      	lsrs	r3, r3, #16
 8007a26:	613b      	str	r3, [r7, #16]
  acc = (u32_t)(acc + ((addr >> 16) & 0xffffUL));
 8007a28:	697b      	ldr	r3, [r7, #20]
 8007a2a:	0c1b      	lsrs	r3, r3, #16
 8007a2c:	693a      	ldr	r2, [r7, #16]
 8007a2e:	18d3      	adds	r3, r2, r3
 8007a30:	613b      	str	r3, [r7, #16]
  addr = ip4_addr_get_u32(dest);
 8007a32:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007a34:	681b      	ldr	r3, [r3, #0]
 8007a36:	617b      	str	r3, [r7, #20]
  acc = (u32_t)(acc + (addr & 0xffffUL));
 8007a38:	697b      	ldr	r3, [r7, #20]
 8007a3a:	041b      	lsls	r3, r3, #16
 8007a3c:	0c1b      	lsrs	r3, r3, #16
 8007a3e:	693a      	ldr	r2, [r7, #16]
 8007a40:	18d3      	adds	r3, r2, r3
 8007a42:	613b      	str	r3, [r7, #16]
  acc = (u32_t)(acc + ((addr >> 16) & 0xffffUL));
 8007a44:	697b      	ldr	r3, [r7, #20]
 8007a46:	0c1b      	lsrs	r3, r3, #16
 8007a48:	693a      	ldr	r2, [r7, #16]
 8007a4a:	18d3      	adds	r3, r2, r3
 8007a4c:	613b      	str	r3, [r7, #16]
  /* fold down to 16 bits */
  acc = FOLD_U32T(acc);
 8007a4e:	693b      	ldr	r3, [r7, #16]
 8007a50:	0c1a      	lsrs	r2, r3, #16
 8007a52:	693b      	ldr	r3, [r7, #16]
 8007a54:	041b      	lsls	r3, r3, #16
 8007a56:	0c1b      	lsrs	r3, r3, #16
 8007a58:	18d3      	adds	r3, r2, r3
 8007a5a:	613b      	str	r3, [r7, #16]
  acc = FOLD_U32T(acc);
 8007a5c:	693b      	ldr	r3, [r7, #16]
 8007a5e:	0c1a      	lsrs	r2, r3, #16
 8007a60:	693b      	ldr	r3, [r7, #16]
 8007a62:	041b      	lsls	r3, r3, #16
 8007a64:	0c1b      	lsrs	r3, r3, #16
 8007a66:	18d3      	adds	r3, r2, r3
 8007a68:	613b      	str	r3, [r7, #16]

  return inet_cksum_pseudo_base(p, proto, proto_len, acc);
 8007a6a:	693c      	ldr	r4, [r7, #16]
 8007a6c:	183b      	adds	r3, r7, r0
 8007a6e:	881a      	ldrh	r2, [r3, #0]
 8007a70:	197b      	adds	r3, r7, r5
 8007a72:	7819      	ldrb	r1, [r3, #0]
 8007a74:	68f8      	ldr	r0, [r7, #12]
 8007a76:	0023      	movs	r3, r4
 8007a78:	f7ff ff42 	bl	8007900 <inet_cksum_pseudo_base>
 8007a7c:	0003      	movs	r3, r0
}
 8007a7e:	0018      	movs	r0, r3
 8007a80:	46bd      	mov	sp, r7
 8007a82:	b006      	add	sp, #24
 8007a84:	bdb0      	pop	{r4, r5, r7, pc}

08007a86 <ip_chksum_pseudo>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
ip_chksum_pseudo(struct pbuf *p, u8_t proto, u16_t proto_len,
                 const ip_addr_t *src, const ip_addr_t *dest)
{
 8007a86:	b5b0      	push	{r4, r5, r7, lr}
 8007a88:	b086      	sub	sp, #24
 8007a8a:	af02      	add	r7, sp, #8
 8007a8c:	60f8      	str	r0, [r7, #12]
 8007a8e:	0008      	movs	r0, r1
 8007a90:	0011      	movs	r1, r2
 8007a92:	607b      	str	r3, [r7, #4]
 8007a94:	250b      	movs	r5, #11
 8007a96:	197b      	adds	r3, r7, r5
 8007a98:	1c02      	adds	r2, r0, #0
 8007a9a:	701a      	strb	r2, [r3, #0]
 8007a9c:	2008      	movs	r0, #8
 8007a9e:	183b      	adds	r3, r7, r0
 8007aa0:	1c0a      	adds	r2, r1, #0
 8007aa2:	801a      	strh	r2, [r3, #0]
#if LWIP_IPV4 && LWIP_IPV6
  else
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_IPV4
  {
    return inet_chksum_pseudo(p, proto, proto_len, ip_2_ip4(src), ip_2_ip4(dest));
 8007aa4:	687c      	ldr	r4, [r7, #4]
 8007aa6:	183b      	adds	r3, r7, r0
 8007aa8:	881a      	ldrh	r2, [r3, #0]
 8007aaa:	197b      	adds	r3, r7, r5
 8007aac:	7819      	ldrb	r1, [r3, #0]
 8007aae:	68f8      	ldr	r0, [r7, #12]
 8007ab0:	6a3b      	ldr	r3, [r7, #32]
 8007ab2:	9300      	str	r3, [sp, #0]
 8007ab4:	0023      	movs	r3, r4
 8007ab6:	f7ff ffa1 	bl	80079fc <inet_chksum_pseudo>
 8007aba:	0003      	movs	r3, r0
  }
#endif /* LWIP_IPV4 */
}
 8007abc:	0018      	movs	r0, r3
 8007abe:	46bd      	mov	sp, r7
 8007ac0:	b004      	add	sp, #16
 8007ac2:	bdb0      	pop	{r4, r5, r7, pc}

08007ac4 <inet_cksum_pseudo_partial_base>:

/** Parts of the pseudo checksum which are common to IPv4 and IPv6 */
static u16_t
inet_cksum_pseudo_partial_base(struct pbuf *p, u8_t proto, u16_t proto_len,
                               u16_t chksum_len, u32_t acc)
{
 8007ac4:	b590      	push	{r4, r7, lr}
 8007ac6:	b089      	sub	sp, #36	; 0x24
 8007ac8:	af00      	add	r7, sp, #0
 8007aca:	60f8      	str	r0, [r7, #12]
 8007acc:	000c      	movs	r4, r1
 8007ace:	0010      	movs	r0, r2
 8007ad0:	0019      	movs	r1, r3
 8007ad2:	230b      	movs	r3, #11
 8007ad4:	18fb      	adds	r3, r7, r3
 8007ad6:	1c22      	adds	r2, r4, #0
 8007ad8:	701a      	strb	r2, [r3, #0]
 8007ada:	2308      	movs	r3, #8
 8007adc:	18fb      	adds	r3, r7, r3
 8007ade:	1c02      	adds	r2, r0, #0
 8007ae0:	801a      	strh	r2, [r3, #0]
 8007ae2:	1dbb      	adds	r3, r7, #6
 8007ae4:	1c0a      	adds	r2, r1, #0
 8007ae6:	801a      	strh	r2, [r3, #0]
  struct pbuf *q;
  int swapped = 0;
 8007ae8:	2300      	movs	r3, #0
 8007aea:	61bb      	str	r3, [r7, #24]
  u16_t chklen;

  /* iterate through all pbuf in chain */
  for (q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
 8007aec:	68fb      	ldr	r3, [r7, #12]
 8007aee:	61fb      	str	r3, [r7, #28]
 8007af0:	e04f      	b.n	8007b92 <inet_cksum_pseudo_partial_base+0xce>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
                             (void *)q, (void *)q->next));
    chklen = q->len;
 8007af2:	2116      	movs	r1, #22
 8007af4:	187b      	adds	r3, r7, r1
 8007af6:	69fa      	ldr	r2, [r7, #28]
 8007af8:	8952      	ldrh	r2, [r2, #10]
 8007afa:	801a      	strh	r2, [r3, #0]
    if (chklen > chksum_len) {
 8007afc:	187a      	adds	r2, r7, r1
 8007afe:	1dbb      	adds	r3, r7, #6
 8007b00:	8812      	ldrh	r2, [r2, #0]
 8007b02:	881b      	ldrh	r3, [r3, #0]
 8007b04:	429a      	cmp	r2, r3
 8007b06:	d903      	bls.n	8007b10 <inet_cksum_pseudo_partial_base+0x4c>
      chklen = chksum_len;
 8007b08:	187b      	adds	r3, r7, r1
 8007b0a:	1dba      	adds	r2, r7, #6
 8007b0c:	8812      	ldrh	r2, [r2, #0]
 8007b0e:	801a      	strh	r2, [r3, #0]
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
 8007b10:	69fb      	ldr	r3, [r7, #28]
 8007b12:	685a      	ldr	r2, [r3, #4]
 8007b14:	2416      	movs	r4, #22
 8007b16:	193b      	adds	r3, r7, r4
 8007b18:	881b      	ldrh	r3, [r3, #0]
 8007b1a:	0019      	movs	r1, r3
 8007b1c:	0010      	movs	r0, r2
 8007b1e:	f7ff fe8d 	bl	800783c <lwip_standard_chksum>
 8007b22:	0003      	movs	r3, r0
 8007b24:	001a      	movs	r2, r3
 8007b26:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007b28:	189b      	adds	r3, r3, r2
 8007b2a:	633b      	str	r3, [r7, #48]	; 0x30
    chksum_len = (u16_t)(chksum_len - chklen);
 8007b2c:	1dbb      	adds	r3, r7, #6
 8007b2e:	1db9      	adds	r1, r7, #6
 8007b30:	193a      	adds	r2, r7, r4
 8007b32:	8809      	ldrh	r1, [r1, #0]
 8007b34:	8812      	ldrh	r2, [r2, #0]
 8007b36:	1a8a      	subs	r2, r1, r2
 8007b38:	801a      	strh	r2, [r3, #0]
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
 8007b3a:	1dbb      	adds	r3, r7, #6
 8007b3c:	881b      	ldrh	r3, [r3, #0]
 8007b3e:	4a35      	ldr	r2, [pc, #212]	; (8007c14 <inet_cksum_pseudo_partial_base+0x150>)
 8007b40:	4293      	cmp	r3, r2
 8007b42:	d906      	bls.n	8007b52 <inet_cksum_pseudo_partial_base+0x8e>
 8007b44:	4b34      	ldr	r3, [pc, #208]	; (8007c18 <inet_cksum_pseudo_partial_base+0x154>)
 8007b46:	22d0      	movs	r2, #208	; 0xd0
 8007b48:	0052      	lsls	r2, r2, #1
 8007b4a:	4934      	ldr	r1, [pc, #208]	; (8007c1c <inet_cksum_pseudo_partial_base+0x158>)
 8007b4c:	4834      	ldr	r0, [pc, #208]	; (8007c20 <inet_cksum_pseudo_partial_base+0x15c>)
 8007b4e:	f7fa fb3d 	bl	80021cc <app_debug_rtt_raw>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
 8007b52:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007b54:	0c1a      	lsrs	r2, r3, #16
 8007b56:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007b58:	041b      	lsls	r3, r3, #16
 8007b5a:	0c1b      	lsrs	r3, r3, #16
 8007b5c:	18d3      	adds	r3, r2, r3
 8007b5e:	633b      	str	r3, [r7, #48]	; 0x30
    if (q->len % 2 != 0) {
 8007b60:	69fb      	ldr	r3, [r7, #28]
 8007b62:	895b      	ldrh	r3, [r3, #10]
 8007b64:	2201      	movs	r2, #1
 8007b66:	4013      	ands	r3, r2
 8007b68:	b29b      	uxth	r3, r3
 8007b6a:	2b00      	cmp	r3, #0
 8007b6c:	d00e      	beq.n	8007b8c <inet_cksum_pseudo_partial_base+0xc8>
      swapped = !swapped;
 8007b6e:	69bb      	ldr	r3, [r7, #24]
 8007b70:	425a      	negs	r2, r3
 8007b72:	4153      	adcs	r3, r2
 8007b74:	b2db      	uxtb	r3, r3
 8007b76:	61bb      	str	r3, [r7, #24]
      acc = SWAP_BYTES_IN_WORD(acc);
 8007b78:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007b7a:	021b      	lsls	r3, r3, #8
 8007b7c:	041b      	lsls	r3, r3, #16
 8007b7e:	0c1a      	lsrs	r2, r3, #16
 8007b80:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007b82:	0a1b      	lsrs	r3, r3, #8
 8007b84:	21ff      	movs	r1, #255	; 0xff
 8007b86:	400b      	ands	r3, r1
 8007b88:	4313      	orrs	r3, r2
 8007b8a:	633b      	str	r3, [r7, #48]	; 0x30
  for (q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
 8007b8c:	69fb      	ldr	r3, [r7, #28]
 8007b8e:	681b      	ldr	r3, [r3, #0]
 8007b90:	61fb      	str	r3, [r7, #28]
 8007b92:	69fb      	ldr	r3, [r7, #28]
 8007b94:	2b00      	cmp	r3, #0
 8007b96:	d003      	beq.n	8007ba0 <inet_cksum_pseudo_partial_base+0xdc>
 8007b98:	1dbb      	adds	r3, r7, #6
 8007b9a:	881b      	ldrh	r3, [r3, #0]
 8007b9c:	2b00      	cmp	r3, #0
 8007b9e:	d1a8      	bne.n	8007af2 <inet_cksum_pseudo_partial_base+0x2e>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 8007ba0:	69bb      	ldr	r3, [r7, #24]
 8007ba2:	2b00      	cmp	r3, #0
 8007ba4:	d009      	beq.n	8007bba <inet_cksum_pseudo_partial_base+0xf6>
    acc = SWAP_BYTES_IN_WORD(acc);
 8007ba6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007ba8:	021b      	lsls	r3, r3, #8
 8007baa:	041b      	lsls	r3, r3, #16
 8007bac:	0c1a      	lsrs	r2, r3, #16
 8007bae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007bb0:	0a1b      	lsrs	r3, r3, #8
 8007bb2:	21ff      	movs	r1, #255	; 0xff
 8007bb4:	400b      	ands	r3, r1
 8007bb6:	4313      	orrs	r3, r2
 8007bb8:	633b      	str	r3, [r7, #48]	; 0x30
  }

  acc += (u32_t)lwip_htons((u16_t)proto);
 8007bba:	230b      	movs	r3, #11
 8007bbc:	18fb      	adds	r3, r7, r3
 8007bbe:	781b      	ldrb	r3, [r3, #0]
 8007bc0:	b29b      	uxth	r3, r3
 8007bc2:	0018      	movs	r0, r3
 8007bc4:	f7fe fcb6 	bl	8006534 <lwip_htons>
 8007bc8:	0003      	movs	r3, r0
 8007bca:	001a      	movs	r2, r3
 8007bcc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007bce:	189b      	adds	r3, r3, r2
 8007bd0:	633b      	str	r3, [r7, #48]	; 0x30
  acc += (u32_t)lwip_htons(proto_len);
 8007bd2:	2308      	movs	r3, #8
 8007bd4:	18fb      	adds	r3, r7, r3
 8007bd6:	881b      	ldrh	r3, [r3, #0]
 8007bd8:	0018      	movs	r0, r3
 8007bda:	f7fe fcab 	bl	8006534 <lwip_htons>
 8007bde:	0003      	movs	r3, r0
 8007be0:	001a      	movs	r2, r3
 8007be2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007be4:	189b      	adds	r3, r3, r2
 8007be6:	633b      	str	r3, [r7, #48]	; 0x30

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  acc = FOLD_U32T(acc);
 8007be8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007bea:	0c1a      	lsrs	r2, r3, #16
 8007bec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007bee:	041b      	lsls	r3, r3, #16
 8007bf0:	0c1b      	lsrs	r3, r3, #16
 8007bf2:	18d3      	adds	r3, r2, r3
 8007bf4:	633b      	str	r3, [r7, #48]	; 0x30
  acc = FOLD_U32T(acc);
 8007bf6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007bf8:	0c1a      	lsrs	r2, r3, #16
 8007bfa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007bfc:	041b      	lsls	r3, r3, #16
 8007bfe:	0c1b      	lsrs	r3, r3, #16
 8007c00:	18d3      	adds	r3, r2, r3
 8007c02:	633b      	str	r3, [r7, #48]	; 0x30
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 8007c04:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007c06:	b29b      	uxth	r3, r3
 8007c08:	43db      	mvns	r3, r3
 8007c0a:	b29b      	uxth	r3, r3
}
 8007c0c:	0018      	movs	r0, r3
 8007c0e:	46bd      	mov	sp, r7
 8007c10:	b009      	add	sp, #36	; 0x24
 8007c12:	bd90      	pop	{r4, r7, pc}
 8007c14:	00007ffe 	.word	0x00007ffe
 8007c18:	0801e684 	.word	0x0801e684
 8007c1c:	0801e6b4 	.word	0x0801e6b4
 8007c20:	0801e6c0 	.word	0x0801e6c0

08007c24 <inet_chksum_pseudo_partial>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p, u8_t proto, u16_t proto_len,
                           u16_t chksum_len, const ip4_addr_t *src, const ip4_addr_t *dest)
{
 8007c24:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007c26:	b089      	sub	sp, #36	; 0x24
 8007c28:	af02      	add	r7, sp, #8
 8007c2a:	60f8      	str	r0, [r7, #12]
 8007c2c:	000c      	movs	r4, r1
 8007c2e:	0010      	movs	r0, r2
 8007c30:	0019      	movs	r1, r3
 8007c32:	250b      	movs	r5, #11
 8007c34:	197b      	adds	r3, r7, r5
 8007c36:	1c22      	adds	r2, r4, #0
 8007c38:	701a      	strb	r2, [r3, #0]
 8007c3a:	2608      	movs	r6, #8
 8007c3c:	19bb      	adds	r3, r7, r6
 8007c3e:	1c02      	adds	r2, r0, #0
 8007c40:	801a      	strh	r2, [r3, #0]
 8007c42:	1dbb      	adds	r3, r7, #6
 8007c44:	1c0a      	adds	r2, r1, #0
 8007c46:	801a      	strh	r2, [r3, #0]
  u32_t acc;
  u32_t addr;

  addr = ip4_addr_get_u32(src);
 8007c48:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007c4a:	681b      	ldr	r3, [r3, #0]
 8007c4c:	617b      	str	r3, [r7, #20]
  acc = (addr & 0xffffUL);
 8007c4e:	697b      	ldr	r3, [r7, #20]
 8007c50:	041b      	lsls	r3, r3, #16
 8007c52:	0c1b      	lsrs	r3, r3, #16
 8007c54:	613b      	str	r3, [r7, #16]
  acc = (u32_t)(acc + ((addr >> 16) & 0xffffUL));
 8007c56:	697b      	ldr	r3, [r7, #20]
 8007c58:	0c1b      	lsrs	r3, r3, #16
 8007c5a:	693a      	ldr	r2, [r7, #16]
 8007c5c:	18d3      	adds	r3, r2, r3
 8007c5e:	613b      	str	r3, [r7, #16]
  addr = ip4_addr_get_u32(dest);
 8007c60:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007c62:	681b      	ldr	r3, [r3, #0]
 8007c64:	617b      	str	r3, [r7, #20]
  acc = (u32_t)(acc + (addr & 0xffffUL));
 8007c66:	697b      	ldr	r3, [r7, #20]
 8007c68:	041b      	lsls	r3, r3, #16
 8007c6a:	0c1b      	lsrs	r3, r3, #16
 8007c6c:	693a      	ldr	r2, [r7, #16]
 8007c6e:	18d3      	adds	r3, r2, r3
 8007c70:	613b      	str	r3, [r7, #16]
  acc = (u32_t)(acc + ((addr >> 16) & 0xffffUL));
 8007c72:	697b      	ldr	r3, [r7, #20]
 8007c74:	0c1b      	lsrs	r3, r3, #16
 8007c76:	693a      	ldr	r2, [r7, #16]
 8007c78:	18d3      	adds	r3, r2, r3
 8007c7a:	613b      	str	r3, [r7, #16]
  /* fold down to 16 bits */
  acc = FOLD_U32T(acc);
 8007c7c:	693b      	ldr	r3, [r7, #16]
 8007c7e:	0c1a      	lsrs	r2, r3, #16
 8007c80:	693b      	ldr	r3, [r7, #16]
 8007c82:	041b      	lsls	r3, r3, #16
 8007c84:	0c1b      	lsrs	r3, r3, #16
 8007c86:	18d3      	adds	r3, r2, r3
 8007c88:	613b      	str	r3, [r7, #16]
  acc = FOLD_U32T(acc);
 8007c8a:	693b      	ldr	r3, [r7, #16]
 8007c8c:	0c1a      	lsrs	r2, r3, #16
 8007c8e:	693b      	ldr	r3, [r7, #16]
 8007c90:	041b      	lsls	r3, r3, #16
 8007c92:	0c1b      	lsrs	r3, r3, #16
 8007c94:	18d3      	adds	r3, r2, r3
 8007c96:	613b      	str	r3, [r7, #16]

  return inet_cksum_pseudo_partial_base(p, proto, proto_len, chksum_len, acc);
 8007c98:	1dbb      	adds	r3, r7, #6
 8007c9a:	881c      	ldrh	r4, [r3, #0]
 8007c9c:	19bb      	adds	r3, r7, r6
 8007c9e:	881a      	ldrh	r2, [r3, #0]
 8007ca0:	197b      	adds	r3, r7, r5
 8007ca2:	7819      	ldrb	r1, [r3, #0]
 8007ca4:	68f8      	ldr	r0, [r7, #12]
 8007ca6:	693b      	ldr	r3, [r7, #16]
 8007ca8:	9300      	str	r3, [sp, #0]
 8007caa:	0023      	movs	r3, r4
 8007cac:	f7ff ff0a 	bl	8007ac4 <inet_cksum_pseudo_partial_base>
 8007cb0:	0003      	movs	r3, r0
}
 8007cb2:	0018      	movs	r0, r3
 8007cb4:	46bd      	mov	sp, r7
 8007cb6:	b007      	add	sp, #28
 8007cb8:	bdf0      	pop	{r4, r5, r6, r7, pc}

08007cba <ip_chksum_pseudo_partial>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
ip_chksum_pseudo_partial(struct pbuf *p, u8_t proto, u16_t proto_len,
                         u16_t chksum_len, const ip_addr_t *src, const ip_addr_t *dest)
{
 8007cba:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007cbc:	b087      	sub	sp, #28
 8007cbe:	af02      	add	r7, sp, #8
 8007cc0:	60f8      	str	r0, [r7, #12]
 8007cc2:	000c      	movs	r4, r1
 8007cc4:	0010      	movs	r0, r2
 8007cc6:	0019      	movs	r1, r3
 8007cc8:	250b      	movs	r5, #11
 8007cca:	197b      	adds	r3, r7, r5
 8007ccc:	1c22      	adds	r2, r4, #0
 8007cce:	701a      	strb	r2, [r3, #0]
 8007cd0:	2608      	movs	r6, #8
 8007cd2:	19bb      	adds	r3, r7, r6
 8007cd4:	1c02      	adds	r2, r0, #0
 8007cd6:	801a      	strh	r2, [r3, #0]
 8007cd8:	1dbb      	adds	r3, r7, #6
 8007cda:	1c0a      	adds	r2, r1, #0
 8007cdc:	801a      	strh	r2, [r3, #0]
#if LWIP_IPV4 && LWIP_IPV6
  else
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_IPV4
  {
    return inet_chksum_pseudo_partial(p, proto, proto_len, chksum_len, ip_2_ip4(src), ip_2_ip4(dest));
 8007cde:	1dbb      	adds	r3, r7, #6
 8007ce0:	881c      	ldrh	r4, [r3, #0]
 8007ce2:	19bb      	adds	r3, r7, r6
 8007ce4:	881a      	ldrh	r2, [r3, #0]
 8007ce6:	197b      	adds	r3, r7, r5
 8007ce8:	7819      	ldrb	r1, [r3, #0]
 8007cea:	68f8      	ldr	r0, [r7, #12]
 8007cec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8007cee:	9301      	str	r3, [sp, #4]
 8007cf0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007cf2:	9300      	str	r3, [sp, #0]
 8007cf4:	0023      	movs	r3, r4
 8007cf6:	f7ff ff95 	bl	8007c24 <inet_chksum_pseudo_partial>
 8007cfa:	0003      	movs	r3, r0
  }
#endif /* LWIP_IPV4 */
}
 8007cfc:	0018      	movs	r0, r3
 8007cfe:	46bd      	mov	sp, r7
 8007d00:	b005      	add	sp, #20
 8007d02:	bdf0      	pop	{r4, r5, r6, r7, pc}

08007d04 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(const void *dataptr, u16_t len)
{
 8007d04:	b580      	push	{r7, lr}
 8007d06:	b082      	sub	sp, #8
 8007d08:	af00      	add	r7, sp, #0
 8007d0a:	6078      	str	r0, [r7, #4]
 8007d0c:	000a      	movs	r2, r1
 8007d0e:	1cbb      	adds	r3, r7, #2
 8007d10:	801a      	strh	r2, [r3, #0]
  return (u16_t)~(unsigned int)LWIP_CHKSUM(dataptr, len);
 8007d12:	1cbb      	adds	r3, r7, #2
 8007d14:	881a      	ldrh	r2, [r3, #0]
 8007d16:	687b      	ldr	r3, [r7, #4]
 8007d18:	0011      	movs	r1, r2
 8007d1a:	0018      	movs	r0, r3
 8007d1c:	f7ff fd8e 	bl	800783c <lwip_standard_chksum>
 8007d20:	0003      	movs	r3, r0
 8007d22:	43db      	mvns	r3, r3
 8007d24:	b29b      	uxth	r3, r3
}
 8007d26:	0018      	movs	r0, r3
 8007d28:	46bd      	mov	sp, r7
 8007d2a:	b002      	add	sp, #8
 8007d2c:	bd80      	pop	{r7, pc}

08007d2e <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
 8007d2e:	b580      	push	{r7, lr}
 8007d30:	b086      	sub	sp, #24
 8007d32:	af00      	add	r7, sp, #0
 8007d34:	6078      	str	r0, [r7, #4]
  u32_t acc;
  struct pbuf *q;
  int swapped = 0;
 8007d36:	2300      	movs	r3, #0
 8007d38:	60fb      	str	r3, [r7, #12]

  acc = 0;
 8007d3a:	2300      	movs	r3, #0
 8007d3c:	617b      	str	r3, [r7, #20]
  for (q = p; q != NULL; q = q->next) {
 8007d3e:	687b      	ldr	r3, [r7, #4]
 8007d40:	613b      	str	r3, [r7, #16]
 8007d42:	e02c      	b.n	8007d9e <inet_chksum_pbuf+0x70>
    acc += LWIP_CHKSUM(q->payload, q->len);
 8007d44:	693b      	ldr	r3, [r7, #16]
 8007d46:	685a      	ldr	r2, [r3, #4]
 8007d48:	693b      	ldr	r3, [r7, #16]
 8007d4a:	895b      	ldrh	r3, [r3, #10]
 8007d4c:	0019      	movs	r1, r3
 8007d4e:	0010      	movs	r0, r2
 8007d50:	f7ff fd74 	bl	800783c <lwip_standard_chksum>
 8007d54:	0003      	movs	r3, r0
 8007d56:	001a      	movs	r2, r3
 8007d58:	697b      	ldr	r3, [r7, #20]
 8007d5a:	189b      	adds	r3, r3, r2
 8007d5c:	617b      	str	r3, [r7, #20]
    acc = FOLD_U32T(acc);
 8007d5e:	697b      	ldr	r3, [r7, #20]
 8007d60:	0c1a      	lsrs	r2, r3, #16
 8007d62:	697b      	ldr	r3, [r7, #20]
 8007d64:	041b      	lsls	r3, r3, #16
 8007d66:	0c1b      	lsrs	r3, r3, #16
 8007d68:	18d3      	adds	r3, r2, r3
 8007d6a:	617b      	str	r3, [r7, #20]
    if (q->len % 2 != 0) {
 8007d6c:	693b      	ldr	r3, [r7, #16]
 8007d6e:	895b      	ldrh	r3, [r3, #10]
 8007d70:	2201      	movs	r2, #1
 8007d72:	4013      	ands	r3, r2
 8007d74:	b29b      	uxth	r3, r3
 8007d76:	2b00      	cmp	r3, #0
 8007d78:	d00e      	beq.n	8007d98 <inet_chksum_pbuf+0x6a>
      swapped = !swapped;
 8007d7a:	68fb      	ldr	r3, [r7, #12]
 8007d7c:	425a      	negs	r2, r3
 8007d7e:	4153      	adcs	r3, r2
 8007d80:	b2db      	uxtb	r3, r3
 8007d82:	60fb      	str	r3, [r7, #12]
      acc = SWAP_BYTES_IN_WORD(acc);
 8007d84:	697b      	ldr	r3, [r7, #20]
 8007d86:	021b      	lsls	r3, r3, #8
 8007d88:	041b      	lsls	r3, r3, #16
 8007d8a:	0c1a      	lsrs	r2, r3, #16
 8007d8c:	697b      	ldr	r3, [r7, #20]
 8007d8e:	0a1b      	lsrs	r3, r3, #8
 8007d90:	21ff      	movs	r1, #255	; 0xff
 8007d92:	400b      	ands	r3, r1
 8007d94:	4313      	orrs	r3, r2
 8007d96:	617b      	str	r3, [r7, #20]
  for (q = p; q != NULL; q = q->next) {
 8007d98:	693b      	ldr	r3, [r7, #16]
 8007d9a:	681b      	ldr	r3, [r3, #0]
 8007d9c:	613b      	str	r3, [r7, #16]
 8007d9e:	693b      	ldr	r3, [r7, #16]
 8007da0:	2b00      	cmp	r3, #0
 8007da2:	d1cf      	bne.n	8007d44 <inet_chksum_pbuf+0x16>
    }
  }

  if (swapped) {
 8007da4:	68fb      	ldr	r3, [r7, #12]
 8007da6:	2b00      	cmp	r3, #0
 8007da8:	d009      	beq.n	8007dbe <inet_chksum_pbuf+0x90>
    acc = SWAP_BYTES_IN_WORD(acc);
 8007daa:	697b      	ldr	r3, [r7, #20]
 8007dac:	021b      	lsls	r3, r3, #8
 8007dae:	041b      	lsls	r3, r3, #16
 8007db0:	0c1a      	lsrs	r2, r3, #16
 8007db2:	697b      	ldr	r3, [r7, #20]
 8007db4:	0a1b      	lsrs	r3, r3, #8
 8007db6:	21ff      	movs	r1, #255	; 0xff
 8007db8:	400b      	ands	r3, r1
 8007dba:	4313      	orrs	r3, r2
 8007dbc:	617b      	str	r3, [r7, #20]
  }
  return (u16_t)~(acc & 0xffffUL);
 8007dbe:	697b      	ldr	r3, [r7, #20]
 8007dc0:	b29b      	uxth	r3, r3
 8007dc2:	43db      	mvns	r3, r3
 8007dc4:	b29b      	uxth	r3, r3
}
 8007dc6:	0018      	movs	r0, r3
 8007dc8:	46bd      	mov	sp, r7
 8007dca:	b006      	add	sp, #24
 8007dcc:	bd80      	pop	{r7, pc}

08007dce <lwip_chksum_copy>:
 * For architectures with big caches, data might still be in cache when
 * generating the checksum after copying.
 */
u16_t
lwip_chksum_copy(void *dst, const void *src, u16_t len)
{
 8007dce:	b580      	push	{r7, lr}
 8007dd0:	b084      	sub	sp, #16
 8007dd2:	af00      	add	r7, sp, #0
 8007dd4:	60f8      	str	r0, [r7, #12]
 8007dd6:	60b9      	str	r1, [r7, #8]
 8007dd8:	1dbb      	adds	r3, r7, #6
 8007dda:	801a      	strh	r2, [r3, #0]
  MEMCPY(dst, src, len);
 8007ddc:	1dbb      	adds	r3, r7, #6
 8007dde:	881a      	ldrh	r2, [r3, #0]
 8007de0:	68b9      	ldr	r1, [r7, #8]
 8007de2:	68fb      	ldr	r3, [r7, #12]
 8007de4:	0018      	movs	r0, r3
 8007de6:	f014 fd05 	bl	801c7f4 <memcpy>
  return LWIP_CHKSUM(dst, len);
 8007dea:	1dbb      	adds	r3, r7, #6
 8007dec:	881a      	ldrh	r2, [r3, #0]
 8007dee:	68fb      	ldr	r3, [r7, #12]
 8007df0:	0011      	movs	r1, r2
 8007df2:	0018      	movs	r0, r3
 8007df4:	f7ff fd22 	bl	800783c <lwip_standard_chksum>
 8007df8:	0003      	movs	r3, r0
}
 8007dfa:	0018      	movs	r0, r3
 8007dfc:	46bd      	mov	sp, r7
 8007dfe:	b004      	add	sp, #16
 8007e00:	bd80      	pop	{r7, pc}

08007e02 <lwip_init>:
 * Initialize all modules.
 * Use this in NO_SYS mode. Use tcpip_init() otherwise.
 */
void
lwip_init(void)
{
 8007e02:	b580      	push	{r7, lr}
 8007e04:	b082      	sub	sp, #8
 8007e06:	af00      	add	r7, sp, #0
#ifndef LWIP_SKIP_CONST_CHECK
  int a = 0;
 8007e08:	2300      	movs	r3, #0
 8007e0a:	607b      	str	r3, [r7, #4]
  /* Modules initialization */
  stats_init();
#if !NO_SYS
  sys_init();
#endif /* !NO_SYS */
  mem_init();
 8007e0c:	f000 f8de 	bl	8007fcc <mem_init>
  memp_init();
 8007e10:	f000 fc70 	bl	80086f4 <memp_init>
  pbuf_init();
  netif_init();
 8007e14:	f000 fd6e 	bl	80088f4 <netif_init>
#endif /* LWIP_IPV4 */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
 8007e18:	f009 ffc6 	bl	8011da8 <udp_init>
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
 8007e1c:	f002 fa90 	bl	800a340 <tcp_init>
#endif /* LWIP_TCP */
#if LWIP_IGMP
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
 8007e20:	f7fe fc02 	bl	8006628 <dns_init>
#endif /* LWIP_DNS */
#if PPP_SUPPORT
  ppp_init();
 8007e24:	f011 fd0e 	bl	8019844 <ppp_init>
#endif

#if LWIP_TIMERS
  sys_timeouts_init();
 8007e28:	f009 fef4 	bl	8011c14 <sys_timeouts_init>
#endif /* LWIP_TIMERS */
}
 8007e2c:	46c0      	nop			; (mov r8, r8)
 8007e2e:	46bd      	mov	sp, r7
 8007e30:	b002      	add	sp, #8
 8007e32:	bd80      	pop	{r7, pc}

08007e34 <ptr_to_mem>:
#define mem_overflow_check_element(mem)
#endif /* MEM_OVERFLOW_CHECK */

static struct mem *
ptr_to_mem(mem_size_t ptr)
{
 8007e34:	b580      	push	{r7, lr}
 8007e36:	b082      	sub	sp, #8
 8007e38:	af00      	add	r7, sp, #0
 8007e3a:	0002      	movs	r2, r0
 8007e3c:	1dbb      	adds	r3, r7, #6
 8007e3e:	801a      	strh	r2, [r3, #0]
  return (struct mem *)(void *)&ram[ptr];
 8007e40:	4b04      	ldr	r3, [pc, #16]	; (8007e54 <ptr_to_mem+0x20>)
 8007e42:	681a      	ldr	r2, [r3, #0]
 8007e44:	1dbb      	adds	r3, r7, #6
 8007e46:	881b      	ldrh	r3, [r3, #0]
 8007e48:	18d3      	adds	r3, r2, r3
}
 8007e4a:	0018      	movs	r0, r3
 8007e4c:	46bd      	mov	sp, r7
 8007e4e:	b002      	add	sp, #8
 8007e50:	bd80      	pop	{r7, pc}
 8007e52:	46c0      	nop			; (mov r8, r8)
 8007e54:	20001330 	.word	0x20001330

08007e58 <mem_to_ptr>:

static mem_size_t
mem_to_ptr(void *mem)
{
 8007e58:	b580      	push	{r7, lr}
 8007e5a:	b082      	sub	sp, #8
 8007e5c:	af00      	add	r7, sp, #0
 8007e5e:	6078      	str	r0, [r7, #4]
  return (mem_size_t)((u8_t *)mem - ram);
 8007e60:	4b04      	ldr	r3, [pc, #16]	; (8007e74 <mem_to_ptr+0x1c>)
 8007e62:	681b      	ldr	r3, [r3, #0]
 8007e64:	687a      	ldr	r2, [r7, #4]
 8007e66:	1ad3      	subs	r3, r2, r3
 8007e68:	b29b      	uxth	r3, r3
}
 8007e6a:	0018      	movs	r0, r3
 8007e6c:	46bd      	mov	sp, r7
 8007e6e:	b002      	add	sp, #8
 8007e70:	bd80      	pop	{r7, pc}
 8007e72:	46c0      	nop			; (mov r8, r8)
 8007e74:	20001330 	.word	0x20001330

08007e78 <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
 8007e78:	b590      	push	{r4, r7, lr}
 8007e7a:	b085      	sub	sp, #20
 8007e7c:	af00      	add	r7, sp, #0
 8007e7e:	6078      	str	r0, [r7, #4]
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 8007e80:	4b49      	ldr	r3, [pc, #292]	; (8007fa8 <plug_holes+0x130>)
 8007e82:	681b      	ldr	r3, [r3, #0]
 8007e84:	687a      	ldr	r2, [r7, #4]
 8007e86:	429a      	cmp	r2, r3
 8007e88:	d206      	bcs.n	8007e98 <plug_holes+0x20>
 8007e8a:	4b48      	ldr	r3, [pc, #288]	; (8007fac <plug_holes+0x134>)
 8007e8c:	22e0      	movs	r2, #224	; 0xe0
 8007e8e:	32ff      	adds	r2, #255	; 0xff
 8007e90:	4947      	ldr	r1, [pc, #284]	; (8007fb0 <plug_holes+0x138>)
 8007e92:	4848      	ldr	r0, [pc, #288]	; (8007fb4 <plug_holes+0x13c>)
 8007e94:	f7fa f99a 	bl	80021cc <app_debug_rtt_raw>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
 8007e98:	4b47      	ldr	r3, [pc, #284]	; (8007fb8 <plug_holes+0x140>)
 8007e9a:	681b      	ldr	r3, [r3, #0]
 8007e9c:	687a      	ldr	r2, [r7, #4]
 8007e9e:	429a      	cmp	r2, r3
 8007ea0:	d306      	bcc.n	8007eb0 <plug_holes+0x38>
 8007ea2:	4b42      	ldr	r3, [pc, #264]	; (8007fac <plug_holes+0x134>)
 8007ea4:	22f0      	movs	r2, #240	; 0xf0
 8007ea6:	0052      	lsls	r2, r2, #1
 8007ea8:	4944      	ldr	r1, [pc, #272]	; (8007fbc <plug_holes+0x144>)
 8007eaa:	4842      	ldr	r0, [pc, #264]	; (8007fb4 <plug_holes+0x13c>)
 8007eac:	f7fa f98e 	bl	80021cc <app_debug_rtt_raw>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
 8007eb0:	687b      	ldr	r3, [r7, #4]
 8007eb2:	791b      	ldrb	r3, [r3, #4]
 8007eb4:	2b00      	cmp	r3, #0
 8007eb6:	d006      	beq.n	8007ec6 <plug_holes+0x4e>
 8007eb8:	4b3c      	ldr	r3, [pc, #240]	; (8007fac <plug_holes+0x134>)
 8007eba:	22e2      	movs	r2, #226	; 0xe2
 8007ebc:	32ff      	adds	r2, #255	; 0xff
 8007ebe:	4940      	ldr	r1, [pc, #256]	; (8007fc0 <plug_holes+0x148>)
 8007ec0:	483c      	ldr	r0, [pc, #240]	; (8007fb4 <plug_holes+0x13c>)
 8007ec2:	f7fa f983 	bl	80021cc <app_debug_rtt_raw>

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
 8007ec6:	687b      	ldr	r3, [r7, #4]
 8007ec8:	881a      	ldrh	r2, [r3, #0]
 8007eca:	2380      	movs	r3, #128	; 0x80
 8007ecc:	00db      	lsls	r3, r3, #3
 8007ece:	429a      	cmp	r2, r3
 8007ed0:	d906      	bls.n	8007ee0 <plug_holes+0x68>
 8007ed2:	4b36      	ldr	r3, [pc, #216]	; (8007fac <plug_holes+0x134>)
 8007ed4:	22f2      	movs	r2, #242	; 0xf2
 8007ed6:	0052      	lsls	r2, r2, #1
 8007ed8:	493a      	ldr	r1, [pc, #232]	; (8007fc4 <plug_holes+0x14c>)
 8007eda:	4836      	ldr	r0, [pc, #216]	; (8007fb4 <plug_holes+0x13c>)
 8007edc:	f7fa f976 	bl	80021cc <app_debug_rtt_raw>

  nmem = ptr_to_mem(mem->next);
 8007ee0:	687b      	ldr	r3, [r7, #4]
 8007ee2:	881b      	ldrh	r3, [r3, #0]
 8007ee4:	0018      	movs	r0, r3
 8007ee6:	f7ff ffa5 	bl	8007e34 <ptr_to_mem>
 8007eea:	0003      	movs	r3, r0
 8007eec:	60fb      	str	r3, [r7, #12]
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
 8007eee:	687a      	ldr	r2, [r7, #4]
 8007ef0:	68fb      	ldr	r3, [r7, #12]
 8007ef2:	429a      	cmp	r2, r3
 8007ef4:	d026      	beq.n	8007f44 <plug_holes+0xcc>
 8007ef6:	68fb      	ldr	r3, [r7, #12]
 8007ef8:	791b      	ldrb	r3, [r3, #4]
 8007efa:	2b00      	cmp	r3, #0
 8007efc:	d122      	bne.n	8007f44 <plug_holes+0xcc>
 8007efe:	4b2e      	ldr	r3, [pc, #184]	; (8007fb8 <plug_holes+0x140>)
 8007f00:	681b      	ldr	r3, [r3, #0]
 8007f02:	68fa      	ldr	r2, [r7, #12]
 8007f04:	429a      	cmp	r2, r3
 8007f06:	d01d      	beq.n	8007f44 <plug_holes+0xcc>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
 8007f08:	4b2f      	ldr	r3, [pc, #188]	; (8007fc8 <plug_holes+0x150>)
 8007f0a:	681b      	ldr	r3, [r3, #0]
 8007f0c:	68fa      	ldr	r2, [r7, #12]
 8007f0e:	429a      	cmp	r2, r3
 8007f10:	d102      	bne.n	8007f18 <plug_holes+0xa0>
      lfree = mem;
 8007f12:	4b2d      	ldr	r3, [pc, #180]	; (8007fc8 <plug_holes+0x150>)
 8007f14:	687a      	ldr	r2, [r7, #4]
 8007f16:	601a      	str	r2, [r3, #0]
    }
    mem->next = nmem->next;
 8007f18:	68fb      	ldr	r3, [r7, #12]
 8007f1a:	881a      	ldrh	r2, [r3, #0]
 8007f1c:	687b      	ldr	r3, [r7, #4]
 8007f1e:	801a      	strh	r2, [r3, #0]
    if (nmem->next != MEM_SIZE_ALIGNED) {
 8007f20:	68fb      	ldr	r3, [r7, #12]
 8007f22:	881a      	ldrh	r2, [r3, #0]
 8007f24:	2380      	movs	r3, #128	; 0x80
 8007f26:	00db      	lsls	r3, r3, #3
 8007f28:	429a      	cmp	r2, r3
 8007f2a:	d00b      	beq.n	8007f44 <plug_holes+0xcc>
      ptr_to_mem(nmem->next)->prev = mem_to_ptr(mem);
 8007f2c:	68fb      	ldr	r3, [r7, #12]
 8007f2e:	881b      	ldrh	r3, [r3, #0]
 8007f30:	0018      	movs	r0, r3
 8007f32:	f7ff ff7f 	bl	8007e34 <ptr_to_mem>
 8007f36:	0004      	movs	r4, r0
 8007f38:	687b      	ldr	r3, [r7, #4]
 8007f3a:	0018      	movs	r0, r3
 8007f3c:	f7ff ff8c 	bl	8007e58 <mem_to_ptr>
 8007f40:	0003      	movs	r3, r0
 8007f42:	8063      	strh	r3, [r4, #2]
    }
  }

  /* plug hole backward */
  pmem = ptr_to_mem(mem->prev);
 8007f44:	687b      	ldr	r3, [r7, #4]
 8007f46:	885b      	ldrh	r3, [r3, #2]
 8007f48:	0018      	movs	r0, r3
 8007f4a:	f7ff ff73 	bl	8007e34 <ptr_to_mem>
 8007f4e:	0003      	movs	r3, r0
 8007f50:	60bb      	str	r3, [r7, #8]
  if (pmem != mem && pmem->used == 0) {
 8007f52:	68ba      	ldr	r2, [r7, #8]
 8007f54:	687b      	ldr	r3, [r7, #4]
 8007f56:	429a      	cmp	r2, r3
 8007f58:	d021      	beq.n	8007f9e <plug_holes+0x126>
 8007f5a:	68bb      	ldr	r3, [r7, #8]
 8007f5c:	791b      	ldrb	r3, [r3, #4]
 8007f5e:	2b00      	cmp	r3, #0
 8007f60:	d11d      	bne.n	8007f9e <plug_holes+0x126>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
 8007f62:	4b19      	ldr	r3, [pc, #100]	; (8007fc8 <plug_holes+0x150>)
 8007f64:	681b      	ldr	r3, [r3, #0]
 8007f66:	687a      	ldr	r2, [r7, #4]
 8007f68:	429a      	cmp	r2, r3
 8007f6a:	d102      	bne.n	8007f72 <plug_holes+0xfa>
      lfree = pmem;
 8007f6c:	4b16      	ldr	r3, [pc, #88]	; (8007fc8 <plug_holes+0x150>)
 8007f6e:	68ba      	ldr	r2, [r7, #8]
 8007f70:	601a      	str	r2, [r3, #0]
    }
    pmem->next = mem->next;
 8007f72:	687b      	ldr	r3, [r7, #4]
 8007f74:	881a      	ldrh	r2, [r3, #0]
 8007f76:	68bb      	ldr	r3, [r7, #8]
 8007f78:	801a      	strh	r2, [r3, #0]
    if (mem->next != MEM_SIZE_ALIGNED) {
 8007f7a:	687b      	ldr	r3, [r7, #4]
 8007f7c:	881a      	ldrh	r2, [r3, #0]
 8007f7e:	2380      	movs	r3, #128	; 0x80
 8007f80:	00db      	lsls	r3, r3, #3
 8007f82:	429a      	cmp	r2, r3
 8007f84:	d00b      	beq.n	8007f9e <plug_holes+0x126>
      ptr_to_mem(mem->next)->prev = mem_to_ptr(pmem);
 8007f86:	687b      	ldr	r3, [r7, #4]
 8007f88:	881b      	ldrh	r3, [r3, #0]
 8007f8a:	0018      	movs	r0, r3
 8007f8c:	f7ff ff52 	bl	8007e34 <ptr_to_mem>
 8007f90:	0004      	movs	r4, r0
 8007f92:	68bb      	ldr	r3, [r7, #8]
 8007f94:	0018      	movs	r0, r3
 8007f96:	f7ff ff5f 	bl	8007e58 <mem_to_ptr>
 8007f9a:	0003      	movs	r3, r0
 8007f9c:	8063      	strh	r3, [r4, #2]
    }
  }
}
 8007f9e:	46c0      	nop			; (mov r8, r8)
 8007fa0:	46bd      	mov	sp, r7
 8007fa2:	b005      	add	sp, #20
 8007fa4:	bd90      	pop	{r4, r7, pc}
 8007fa6:	46c0      	nop			; (mov r8, r8)
 8007fa8:	20001330 	.word	0x20001330
 8007fac:	0801e6ec 	.word	0x0801e6ec
 8007fb0:	0801e714 	.word	0x0801e714
 8007fb4:	0801e72c 	.word	0x0801e72c
 8007fb8:	20001334 	.word	0x20001334
 8007fbc:	0801e758 	.word	0x0801e758
 8007fc0:	0801e774 	.word	0x0801e774
 8007fc4:	0801e790 	.word	0x0801e790
 8007fc8:	20001338 	.word	0x20001338

08007fcc <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
 8007fcc:	b580      	push	{r7, lr}
 8007fce:	b082      	sub	sp, #8
 8007fd0:	af00      	add	r7, sp, #0

  LWIP_ASSERT("Sanity check alignment",
              (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT - 1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 8007fd2:	4b19      	ldr	r3, [pc, #100]	; (8008038 <mem_init+0x6c>)
 8007fd4:	3303      	adds	r3, #3
 8007fd6:	2203      	movs	r2, #3
 8007fd8:	4393      	bics	r3, r2
 8007fda:	001a      	movs	r2, r3
 8007fdc:	4b17      	ldr	r3, [pc, #92]	; (800803c <mem_init+0x70>)
 8007fde:	601a      	str	r2, [r3, #0]
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
 8007fe0:	4b16      	ldr	r3, [pc, #88]	; (800803c <mem_init+0x70>)
 8007fe2:	681b      	ldr	r3, [r3, #0]
 8007fe4:	607b      	str	r3, [r7, #4]
  mem->next = MEM_SIZE_ALIGNED;
 8007fe6:	687b      	ldr	r3, [r7, #4]
 8007fe8:	2280      	movs	r2, #128	; 0x80
 8007fea:	00d2      	lsls	r2, r2, #3
 8007fec:	801a      	strh	r2, [r3, #0]
  mem->prev = 0;
 8007fee:	687b      	ldr	r3, [r7, #4]
 8007ff0:	2200      	movs	r2, #0
 8007ff2:	805a      	strh	r2, [r3, #2]
  mem->used = 0;
 8007ff4:	687b      	ldr	r3, [r7, #4]
 8007ff6:	2200      	movs	r2, #0
 8007ff8:	711a      	strb	r2, [r3, #4]
  /* initialize the end of the heap */
  ram_end = ptr_to_mem(MEM_SIZE_ALIGNED);
 8007ffa:	2380      	movs	r3, #128	; 0x80
 8007ffc:	00db      	lsls	r3, r3, #3
 8007ffe:	0018      	movs	r0, r3
 8008000:	f7ff ff18 	bl	8007e34 <ptr_to_mem>
 8008004:	0002      	movs	r2, r0
 8008006:	4b0e      	ldr	r3, [pc, #56]	; (8008040 <mem_init+0x74>)
 8008008:	601a      	str	r2, [r3, #0]
  ram_end->used = 1;
 800800a:	4b0d      	ldr	r3, [pc, #52]	; (8008040 <mem_init+0x74>)
 800800c:	681b      	ldr	r3, [r3, #0]
 800800e:	2201      	movs	r2, #1
 8008010:	711a      	strb	r2, [r3, #4]
  ram_end->next = MEM_SIZE_ALIGNED;
 8008012:	4b0b      	ldr	r3, [pc, #44]	; (8008040 <mem_init+0x74>)
 8008014:	681b      	ldr	r3, [r3, #0]
 8008016:	2280      	movs	r2, #128	; 0x80
 8008018:	00d2      	lsls	r2, r2, #3
 800801a:	801a      	strh	r2, [r3, #0]
  ram_end->prev = MEM_SIZE_ALIGNED;
 800801c:	4b08      	ldr	r3, [pc, #32]	; (8008040 <mem_init+0x74>)
 800801e:	681b      	ldr	r3, [r3, #0]
 8008020:	2280      	movs	r2, #128	; 0x80
 8008022:	00d2      	lsls	r2, r2, #3
 8008024:	805a      	strh	r2, [r3, #2]
  MEM_SANITY();

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
 8008026:	4b05      	ldr	r3, [pc, #20]	; (800803c <mem_init+0x70>)
 8008028:	681a      	ldr	r2, [r3, #0]
 800802a:	4b06      	ldr	r3, [pc, #24]	; (8008044 <mem_init+0x78>)
 800802c:	601a      	str	r2, [r3, #0]
  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

  if (sys_mutex_new(&mem_mutex) != ERR_OK) {
    LWIP_ASSERT("failed to create mem_mutex", 0);
  }
}
 800802e:	46c0      	nop			; (mov r8, r8)
 8008030:	46bd      	mov	sp, r7
 8008032:	b002      	add	sp, #8
 8008034:	bd80      	pop	{r7, pc}
 8008036:	46c0      	nop			; (mov r8, r8)
 8008038:	200014dc 	.word	0x200014dc
 800803c:	20001330 	.word	0x20001330
 8008040:	20001334 	.word	0x20001334
 8008044:	20001338 	.word	0x20001338

08008048 <mem_link_valid>:
/* Check if a struct mem is correctly linked.
 * If not, double-free is a possible reason.
 */
static int
mem_link_valid(struct mem *mem)
{
 8008048:	b5b0      	push	{r4, r5, r7, lr}
 800804a:	b086      	sub	sp, #24
 800804c:	af00      	add	r7, sp, #0
 800804e:	6078      	str	r0, [r7, #4]
  struct mem *nmem, *pmem;
  mem_size_t rmem_idx;
  rmem_idx = mem_to_ptr(mem);
 8008050:	2516      	movs	r5, #22
 8008052:	197c      	adds	r4, r7, r5
 8008054:	687b      	ldr	r3, [r7, #4]
 8008056:	0018      	movs	r0, r3
 8008058:	f7ff fefe 	bl	8007e58 <mem_to_ptr>
 800805c:	0003      	movs	r3, r0
 800805e:	8023      	strh	r3, [r4, #0]
  nmem = ptr_to_mem(mem->next);
 8008060:	687b      	ldr	r3, [r7, #4]
 8008062:	881b      	ldrh	r3, [r3, #0]
 8008064:	0018      	movs	r0, r3
 8008066:	f7ff fee5 	bl	8007e34 <ptr_to_mem>
 800806a:	0003      	movs	r3, r0
 800806c:	613b      	str	r3, [r7, #16]
  pmem = ptr_to_mem(mem->prev);
 800806e:	687b      	ldr	r3, [r7, #4]
 8008070:	885b      	ldrh	r3, [r3, #2]
 8008072:	0018      	movs	r0, r3
 8008074:	f7ff fede 	bl	8007e34 <ptr_to_mem>
 8008078:	0003      	movs	r3, r0
 800807a:	60fb      	str	r3, [r7, #12]
  if ((mem->next > MEM_SIZE_ALIGNED) || (mem->prev > MEM_SIZE_ALIGNED) ||
 800807c:	687b      	ldr	r3, [r7, #4]
 800807e:	881a      	ldrh	r2, [r3, #0]
 8008080:	2380      	movs	r3, #128	; 0x80
 8008082:	00db      	lsls	r3, r3, #3
 8008084:	429a      	cmp	r2, r3
 8008086:	d81d      	bhi.n	80080c4 <mem_link_valid+0x7c>
 8008088:	687b      	ldr	r3, [r7, #4]
 800808a:	885a      	ldrh	r2, [r3, #2]
 800808c:	2380      	movs	r3, #128	; 0x80
 800808e:	00db      	lsls	r3, r3, #3
 8008090:	429a      	cmp	r2, r3
 8008092:	d817      	bhi.n	80080c4 <mem_link_valid+0x7c>
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
 8008094:	687b      	ldr	r3, [r7, #4]
 8008096:	885b      	ldrh	r3, [r3, #2]
  if ((mem->next > MEM_SIZE_ALIGNED) || (mem->prev > MEM_SIZE_ALIGNED) ||
 8008098:	197a      	adds	r2, r7, r5
 800809a:	8812      	ldrh	r2, [r2, #0]
 800809c:	429a      	cmp	r2, r3
 800809e:	d005      	beq.n	80080ac <mem_link_valid+0x64>
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
 80080a0:	68fb      	ldr	r3, [r7, #12]
 80080a2:	881b      	ldrh	r3, [r3, #0]
 80080a4:	197a      	adds	r2, r7, r5
 80080a6:	8812      	ldrh	r2, [r2, #0]
 80080a8:	429a      	cmp	r2, r3
 80080aa:	d10b      	bne.n	80080c4 <mem_link_valid+0x7c>
      ((nmem != ram_end) && (nmem->prev != rmem_idx))) {
 80080ac:	4b09      	ldr	r3, [pc, #36]	; (80080d4 <mem_link_valid+0x8c>)
 80080ae:	681b      	ldr	r3, [r3, #0]
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
 80080b0:	693a      	ldr	r2, [r7, #16]
 80080b2:	429a      	cmp	r2, r3
 80080b4:	d008      	beq.n	80080c8 <mem_link_valid+0x80>
      ((nmem != ram_end) && (nmem->prev != rmem_idx))) {
 80080b6:	693b      	ldr	r3, [r7, #16]
 80080b8:	885b      	ldrh	r3, [r3, #2]
 80080ba:	2216      	movs	r2, #22
 80080bc:	18ba      	adds	r2, r7, r2
 80080be:	8812      	ldrh	r2, [r2, #0]
 80080c0:	429a      	cmp	r2, r3
 80080c2:	d001      	beq.n	80080c8 <mem_link_valid+0x80>
    return 0;
 80080c4:	2300      	movs	r3, #0
 80080c6:	e000      	b.n	80080ca <mem_link_valid+0x82>
  }
  return 1;
 80080c8:	2301      	movs	r3, #1
}
 80080ca:	0018      	movs	r0, r3
 80080cc:	46bd      	mov	sp, r7
 80080ce:	b006      	add	sp, #24
 80080d0:	bdb0      	pop	{r4, r5, r7, pc}
 80080d2:	46c0      	nop			; (mov r8, r8)
 80080d4:	20001334 	.word	0x20001334

080080d8 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
 80080d8:	b580      	push	{r7, lr}
 80080da:	b084      	sub	sp, #16
 80080dc:	af00      	add	r7, sp, #0
 80080de:	6078      	str	r0, [r7, #4]
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 80080e0:	687b      	ldr	r3, [r7, #4]
 80080e2:	2b00      	cmp	r3, #0
 80080e4:	d049      	beq.n	800817a <mem_free+0xa2>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  if ((((mem_ptr_t)rmem) & (MEM_ALIGNMENT - 1)) != 0) {
 80080e6:	687b      	ldr	r3, [r7, #4]
 80080e8:	2203      	movs	r2, #3
 80080ea:	4013      	ands	r3, r2
 80080ec:	d006      	beq.n	80080fc <mem_free+0x24>
    LWIP_MEM_ILLEGAL_FREE("mem_free: sanity check alignment");
 80080ee:	4b25      	ldr	r3, [pc, #148]	; (8008184 <mem_free+0xac>)
 80080f0:	4a25      	ldr	r2, [pc, #148]	; (8008188 <mem_free+0xb0>)
 80080f2:	4926      	ldr	r1, [pc, #152]	; (800818c <mem_free+0xb4>)
 80080f4:	4826      	ldr	r0, [pc, #152]	; (8008190 <mem_free+0xb8>)
 80080f6:	f7fa f869 	bl	80021cc <app_debug_rtt_raw>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: sanity check alignment\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return;
 80080fa:	e03f      	b.n	800817c <mem_free+0xa4>
  }

  /* Get the corresponding struct mem: */
  /* cast through void* to get rid of alignment warnings */
  mem = (struct mem *)(void *)((u8_t *)rmem - (SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET));
 80080fc:	687b      	ldr	r3, [r7, #4]
 80080fe:	3b08      	subs	r3, #8
 8008100:	60fb      	str	r3, [r7, #12]

  if ((u8_t *)mem < ram || (u8_t *)rmem + MIN_SIZE_ALIGNED > (u8_t *)ram_end) {
 8008102:	4b24      	ldr	r3, [pc, #144]	; (8008194 <mem_free+0xbc>)
 8008104:	681b      	ldr	r3, [r3, #0]
 8008106:	68fa      	ldr	r2, [r7, #12]
 8008108:	429a      	cmp	r2, r3
 800810a:	d306      	bcc.n	800811a <mem_free+0x42>
 800810c:	687b      	ldr	r3, [r7, #4]
 800810e:	330c      	adds	r3, #12
 8008110:	001a      	movs	r2, r3
 8008112:	4b21      	ldr	r3, [pc, #132]	; (8008198 <mem_free+0xc0>)
 8008114:	681b      	ldr	r3, [r3, #0]
 8008116:	429a      	cmp	r2, r3
 8008118:	d906      	bls.n	8008128 <mem_free+0x50>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory");
 800811a:	4b1a      	ldr	r3, [pc, #104]	; (8008184 <mem_free+0xac>)
 800811c:	4a1f      	ldr	r2, [pc, #124]	; (800819c <mem_free+0xc4>)
 800811e:	4920      	ldr	r1, [pc, #128]	; (80081a0 <mem_free+0xc8>)
 8008120:	481b      	ldr	r0, [pc, #108]	; (8008190 <mem_free+0xb8>)
 8008122:	f7fa f853 	bl	80021cc <app_debug_rtt_raw>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return;
 8008126:	e029      	b.n	800817c <mem_free+0xa4>
  mem_overflow_check_element(mem);
#endif
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* mem has to be in a used state */
  if (!mem->used) {
 8008128:	68fb      	ldr	r3, [r7, #12]
 800812a:	791b      	ldrb	r3, [r3, #4]
 800812c:	2b00      	cmp	r3, #0
 800812e:	d107      	bne.n	8008140 <mem_free+0x68>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory: double free");
 8008130:	4b14      	ldr	r3, [pc, #80]	; (8008184 <mem_free+0xac>)
 8008132:	22a3      	movs	r2, #163	; 0xa3
 8008134:	0092      	lsls	r2, r2, #2
 8008136:	491b      	ldr	r1, [pc, #108]	; (80081a4 <mem_free+0xcc>)
 8008138:	4815      	ldr	r0, [pc, #84]	; (8008190 <mem_free+0xb8>)
 800813a:	f7fa f847 	bl	80021cc <app_debug_rtt_raw>
    LWIP_MEM_FREE_UNPROTECT();
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory: double free?\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return;
 800813e:	e01d      	b.n	800817c <mem_free+0xa4>
  }

  if (!mem_link_valid(mem)) {
 8008140:	68fb      	ldr	r3, [r7, #12]
 8008142:	0018      	movs	r0, r3
 8008144:	f7ff ff80 	bl	8008048 <mem_link_valid>
 8008148:	1e03      	subs	r3, r0, #0
 800814a:	d106      	bne.n	800815a <mem_free+0x82>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory: non-linked: double free");
 800814c:	4b0d      	ldr	r3, [pc, #52]	; (8008184 <mem_free+0xac>)
 800814e:	4a16      	ldr	r2, [pc, #88]	; (80081a8 <mem_free+0xd0>)
 8008150:	4916      	ldr	r1, [pc, #88]	; (80081ac <mem_free+0xd4>)
 8008152:	480f      	ldr	r0, [pc, #60]	; (8008190 <mem_free+0xb8>)
 8008154:	f7fa f83a 	bl	80021cc <app_debug_rtt_raw>
    LWIP_MEM_FREE_UNPROTECT();
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory: non-linked: double free?\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return;
 8008158:	e010      	b.n	800817c <mem_free+0xa4>
  }

  /* mem is now unused. */
  mem->used = 0;
 800815a:	68fb      	ldr	r3, [r7, #12]
 800815c:	2200      	movs	r2, #0
 800815e:	711a      	strb	r2, [r3, #4]

  if (mem < lfree) {
 8008160:	4b13      	ldr	r3, [pc, #76]	; (80081b0 <mem_free+0xd8>)
 8008162:	681b      	ldr	r3, [r3, #0]
 8008164:	68fa      	ldr	r2, [r7, #12]
 8008166:	429a      	cmp	r2, r3
 8008168:	d202      	bcs.n	8008170 <mem_free+0x98>
    /* the newly freed struct is now the lowest */
    lfree = mem;
 800816a:	4b11      	ldr	r3, [pc, #68]	; (80081b0 <mem_free+0xd8>)
 800816c:	68fa      	ldr	r2, [r7, #12]
 800816e:	601a      	str	r2, [r3, #0]
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));

  /* finally, see if prev or next are free also */
  plug_holes(mem);
 8008170:	68fb      	ldr	r3, [r7, #12]
 8008172:	0018      	movs	r0, r3
 8008174:	f7ff fe80 	bl	8007e78 <plug_holes>
 8008178:	e000      	b.n	800817c <mem_free+0xa4>
    return;
 800817a:	46c0      	nop			; (mov r8, r8)
  MEM_SANITY();
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
 800817c:	46bd      	mov	sp, r7
 800817e:	b004      	add	sp, #16
 8008180:	bd80      	pop	{r7, pc}
 8008182:	46c0      	nop			; (mov r8, r8)
 8008184:	0801e6ec 	.word	0x0801e6ec
 8008188:	00000273 	.word	0x00000273
 800818c:	0801e7bc 	.word	0x0801e7bc
 8008190:	0801e72c 	.word	0x0801e72c
 8008194:	20001330 	.word	0x20001330
 8008198:	20001334 	.word	0x20001334
 800819c:	0000027f 	.word	0x0000027f
 80081a0:	0801e7e0 	.word	0x0801e7e0
 80081a4:	0801e7fc 	.word	0x0801e7fc
 80081a8:	00000295 	.word	0x00000295
 80081ac:	0801e824 	.word	0x0801e824
 80081b0:	20001338 	.word	0x20001338

080081b4 <mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t new_size)
{
 80081b4:	b5b0      	push	{r4, r5, r7, lr}
 80081b6:	b088      	sub	sp, #32
 80081b8:	af00      	add	r7, sp, #0
 80081ba:	6078      	str	r0, [r7, #4]
 80081bc:	000a      	movs	r2, r1
 80081be:	1cbb      	adds	r3, r7, #2
 80081c0:	801a      	strh	r2, [r3, #0]
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = (mem_size_t)LWIP_MEM_ALIGN_SIZE(new_size);
 80081c2:	1cbb      	adds	r3, r7, #2
 80081c4:	881b      	ldrh	r3, [r3, #0]
 80081c6:	3303      	adds	r3, #3
 80081c8:	b29a      	uxth	r2, r3
 80081ca:	201e      	movs	r0, #30
 80081cc:	183b      	adds	r3, r7, r0
 80081ce:	2103      	movs	r1, #3
 80081d0:	438a      	bics	r2, r1
 80081d2:	801a      	strh	r2, [r3, #0]
  if (newsize < MIN_SIZE_ALIGNED) {
 80081d4:	183b      	adds	r3, r7, r0
 80081d6:	881b      	ldrh	r3, [r3, #0]
 80081d8:	2b0b      	cmp	r3, #11
 80081da:	d802      	bhi.n	80081e2 <mem_trim+0x2e>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
 80081dc:	183b      	adds	r3, r7, r0
 80081de:	220c      	movs	r2, #12
 80081e0:	801a      	strh	r2, [r3, #0]
  }
#if MEM_OVERFLOW_CHECK
  newsize += MEM_SANITY_REGION_BEFORE_ALIGNED + MEM_SANITY_REGION_AFTER_ALIGNED;
#endif
  if ((newsize > MEM_SIZE_ALIGNED) || (newsize < new_size)) {
 80081e2:	211e      	movs	r1, #30
 80081e4:	187b      	adds	r3, r7, r1
 80081e6:	881a      	ldrh	r2, [r3, #0]
 80081e8:	2380      	movs	r3, #128	; 0x80
 80081ea:	00db      	lsls	r3, r3, #3
 80081ec:	429a      	cmp	r2, r3
 80081ee:	d805      	bhi.n	80081fc <mem_trim+0x48>
 80081f0:	187a      	adds	r2, r7, r1
 80081f2:	1cbb      	adds	r3, r7, #2
 80081f4:	8812      	ldrh	r2, [r2, #0]
 80081f6:	881b      	ldrh	r3, [r3, #0]
 80081f8:	429a      	cmp	r2, r3
 80081fa:	d201      	bcs.n	8008200 <mem_trim+0x4c>
    return NULL;
 80081fc:	2300      	movs	r3, #0
 80081fe:	e102      	b.n	8008406 <mem_trim+0x252>
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 8008200:	4b83      	ldr	r3, [pc, #524]	; (8008410 <mem_trim+0x25c>)
 8008202:	681b      	ldr	r3, [r3, #0]
 8008204:	687a      	ldr	r2, [r7, #4]
 8008206:	429a      	cmp	r2, r3
 8008208:	d304      	bcc.n	8008214 <mem_trim+0x60>
 800820a:	4b82      	ldr	r3, [pc, #520]	; (8008414 <mem_trim+0x260>)
 800820c:	681b      	ldr	r3, [r3, #0]
 800820e:	687a      	ldr	r2, [r7, #4]
 8008210:	429a      	cmp	r2, r3
 8008212:	d305      	bcc.n	8008220 <mem_trim+0x6c>
 8008214:	4b80      	ldr	r3, [pc, #512]	; (8008418 <mem_trim+0x264>)
 8008216:	4a81      	ldr	r2, [pc, #516]	; (800841c <mem_trim+0x268>)
 8008218:	4981      	ldr	r1, [pc, #516]	; (8008420 <mem_trim+0x26c>)
 800821a:	4882      	ldr	r0, [pc, #520]	; (8008424 <mem_trim+0x270>)
 800821c:	f7f9 ffd6 	bl	80021cc <app_debug_rtt_raw>
              (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 8008220:	4b7b      	ldr	r3, [pc, #492]	; (8008410 <mem_trim+0x25c>)
 8008222:	681b      	ldr	r3, [r3, #0]
 8008224:	687a      	ldr	r2, [r7, #4]
 8008226:	429a      	cmp	r2, r3
 8008228:	d304      	bcc.n	8008234 <mem_trim+0x80>
 800822a:	4b7a      	ldr	r3, [pc, #488]	; (8008414 <mem_trim+0x260>)
 800822c:	681b      	ldr	r3, [r3, #0]
 800822e:	687a      	ldr	r2, [r7, #4]
 8008230:	429a      	cmp	r2, r3
 8008232:	d301      	bcc.n	8008238 <mem_trim+0x84>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
    return rmem;
 8008234:	687b      	ldr	r3, [r7, #4]
 8008236:	e0e6      	b.n	8008406 <mem_trim+0x252>
  }
  /* Get the corresponding struct mem ... */
  /* cast through void* to get rid of alignment warnings */
  mem = (struct mem *)(void *)((u8_t *)rmem - (SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET));
 8008238:	687b      	ldr	r3, [r7, #4]
 800823a:	3b08      	subs	r3, #8
 800823c:	61bb      	str	r3, [r7, #24]
#if MEM_OVERFLOW_CHECK
  mem_overflow_check_element(mem);
#endif
  /* ... and its offset pointer */
  ptr = mem_to_ptr(mem);
 800823e:	2516      	movs	r5, #22
 8008240:	197c      	adds	r4, r7, r5
 8008242:	69bb      	ldr	r3, [r7, #24]
 8008244:	0018      	movs	r0, r3
 8008246:	f7ff fe07 	bl	8007e58 <mem_to_ptr>
 800824a:	0003      	movs	r3, r0
 800824c:	8023      	strh	r3, [r4, #0]

  size = (mem_size_t)((mem_size_t)(mem->next - ptr) - (SIZEOF_STRUCT_MEM + MEM_SANITY_OVERHEAD));
 800824e:	69bb      	ldr	r3, [r7, #24]
 8008250:	881a      	ldrh	r2, [r3, #0]
 8008252:	197b      	adds	r3, r7, r5
 8008254:	881b      	ldrh	r3, [r3, #0]
 8008256:	1ad3      	subs	r3, r2, r3
 8008258:	b29a      	uxth	r2, r3
 800825a:	2114      	movs	r1, #20
 800825c:	187b      	adds	r3, r7, r1
 800825e:	3a08      	subs	r2, #8
 8008260:	801a      	strh	r2, [r3, #0]
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
 8008262:	231e      	movs	r3, #30
 8008264:	18fa      	adds	r2, r7, r3
 8008266:	187b      	adds	r3, r7, r1
 8008268:	8812      	ldrh	r2, [r2, #0]
 800826a:	881b      	ldrh	r3, [r3, #0]
 800826c:	429a      	cmp	r2, r3
 800826e:	d906      	bls.n	800827e <mem_trim+0xca>
 8008270:	4b69      	ldr	r3, [pc, #420]	; (8008418 <mem_trim+0x264>)
 8008272:	22b9      	movs	r2, #185	; 0xb9
 8008274:	0092      	lsls	r2, r2, #2
 8008276:	496c      	ldr	r1, [pc, #432]	; (8008428 <mem_trim+0x274>)
 8008278:	486a      	ldr	r0, [pc, #424]	; (8008424 <mem_trim+0x270>)
 800827a:	f7f9 ffa7 	bl	80021cc <app_debug_rtt_raw>
  if (newsize > size) {
 800827e:	231e      	movs	r3, #30
 8008280:	18fa      	adds	r2, r7, r3
 8008282:	2314      	movs	r3, #20
 8008284:	18fb      	adds	r3, r7, r3
 8008286:	8812      	ldrh	r2, [r2, #0]
 8008288:	881b      	ldrh	r3, [r3, #0]
 800828a:	429a      	cmp	r2, r3
 800828c:	d901      	bls.n	8008292 <mem_trim+0xde>
    /* not supported */
    return NULL;
 800828e:	2300      	movs	r3, #0
 8008290:	e0b9      	b.n	8008406 <mem_trim+0x252>
  }
  if (newsize == size) {
 8008292:	231e      	movs	r3, #30
 8008294:	18fa      	adds	r2, r7, r3
 8008296:	2314      	movs	r3, #20
 8008298:	18fb      	adds	r3, r7, r3
 800829a:	8812      	ldrh	r2, [r2, #0]
 800829c:	881b      	ldrh	r3, [r3, #0]
 800829e:	429a      	cmp	r2, r3
 80082a0:	d101      	bne.n	80082a6 <mem_trim+0xf2>
    /* No change in size, simply return */
    return rmem;
 80082a2:	687b      	ldr	r3, [r7, #4]
 80082a4:	e0af      	b.n	8008406 <mem_trim+0x252>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();

  mem2 = ptr_to_mem(mem->next);
 80082a6:	69bb      	ldr	r3, [r7, #24]
 80082a8:	881b      	ldrh	r3, [r3, #0]
 80082aa:	0018      	movs	r0, r3
 80082ac:	f7ff fdc2 	bl	8007e34 <ptr_to_mem>
 80082b0:	0003      	movs	r3, r0
 80082b2:	613b      	str	r3, [r7, #16]
  if (mem2->used == 0) {
 80082b4:	693b      	ldr	r3, [r7, #16]
 80082b6:	791b      	ldrb	r3, [r3, #4]
 80082b8:	2b00      	cmp	r3, #0
 80082ba:	d152      	bne.n	8008362 <mem_trim+0x1ae>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    LWIP_ASSERT("invalid next ptr", mem->next != MEM_SIZE_ALIGNED);
 80082bc:	69bb      	ldr	r3, [r7, #24]
 80082be:	881a      	ldrh	r2, [r3, #0]
 80082c0:	2380      	movs	r3, #128	; 0x80
 80082c2:	00db      	lsls	r3, r3, #3
 80082c4:	429a      	cmp	r2, r3
 80082c6:	d105      	bne.n	80082d4 <mem_trim+0x120>
 80082c8:	4b53      	ldr	r3, [pc, #332]	; (8008418 <mem_trim+0x264>)
 80082ca:	4a58      	ldr	r2, [pc, #352]	; (800842c <mem_trim+0x278>)
 80082cc:	4958      	ldr	r1, [pc, #352]	; (8008430 <mem_trim+0x27c>)
 80082ce:	4855      	ldr	r0, [pc, #340]	; (8008424 <mem_trim+0x270>)
 80082d0:	f7f9 ff7c 	bl	80021cc <app_debug_rtt_raw>
    /* remember the old next pointer */
    next = mem2->next;
 80082d4:	230c      	movs	r3, #12
 80082d6:	18fb      	adds	r3, r7, r3
 80082d8:	693a      	ldr	r2, [r7, #16]
 80082da:	8812      	ldrh	r2, [r2, #0]
 80082dc:	801a      	strh	r2, [r3, #0]
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + newsize);
 80082de:	2316      	movs	r3, #22
 80082e0:	18fa      	adds	r2, r7, r3
 80082e2:	231e      	movs	r3, #30
 80082e4:	18fb      	adds	r3, r7, r3
 80082e6:	8812      	ldrh	r2, [r2, #0]
 80082e8:	881b      	ldrh	r3, [r3, #0]
 80082ea:	18d3      	adds	r3, r2, r3
 80082ec:	b29a      	uxth	r2, r3
 80082ee:	210e      	movs	r1, #14
 80082f0:	187b      	adds	r3, r7, r1
 80082f2:	3208      	adds	r2, #8
 80082f4:	801a      	strh	r2, [r3, #0]
    if (lfree == mem2) {
 80082f6:	4b4f      	ldr	r3, [pc, #316]	; (8008434 <mem_trim+0x280>)
 80082f8:	681b      	ldr	r3, [r3, #0]
 80082fa:	693a      	ldr	r2, [r7, #16]
 80082fc:	429a      	cmp	r2, r3
 80082fe:	d107      	bne.n	8008310 <mem_trim+0x15c>
      lfree = ptr_to_mem(ptr2);
 8008300:	187b      	adds	r3, r7, r1
 8008302:	881b      	ldrh	r3, [r3, #0]
 8008304:	0018      	movs	r0, r3
 8008306:	f7ff fd95 	bl	8007e34 <ptr_to_mem>
 800830a:	0002      	movs	r2, r0
 800830c:	4b49      	ldr	r3, [pc, #292]	; (8008434 <mem_trim+0x280>)
 800830e:	601a      	str	r2, [r3, #0]
    }
    mem2 = ptr_to_mem(ptr2);
 8008310:	240e      	movs	r4, #14
 8008312:	193b      	adds	r3, r7, r4
 8008314:	881b      	ldrh	r3, [r3, #0]
 8008316:	0018      	movs	r0, r3
 8008318:	f7ff fd8c 	bl	8007e34 <ptr_to_mem>
 800831c:	0003      	movs	r3, r0
 800831e:	613b      	str	r3, [r7, #16]
    mem2->used = 0;
 8008320:	693b      	ldr	r3, [r7, #16]
 8008322:	2200      	movs	r2, #0
 8008324:	711a      	strb	r2, [r3, #4]
    /* restore the next pointer */
    mem2->next = next;
 8008326:	693b      	ldr	r3, [r7, #16]
 8008328:	220c      	movs	r2, #12
 800832a:	18ba      	adds	r2, r7, r2
 800832c:	8812      	ldrh	r2, [r2, #0]
 800832e:	801a      	strh	r2, [r3, #0]
    /* link it back to mem */
    mem2->prev = ptr;
 8008330:	693b      	ldr	r3, [r7, #16]
 8008332:	2216      	movs	r2, #22
 8008334:	18ba      	adds	r2, r7, r2
 8008336:	8812      	ldrh	r2, [r2, #0]
 8008338:	805a      	strh	r2, [r3, #2]
    /* link mem to it */
    mem->next = ptr2;
 800833a:	69bb      	ldr	r3, [r7, #24]
 800833c:	193a      	adds	r2, r7, r4
 800833e:	8812      	ldrh	r2, [r2, #0]
 8008340:	801a      	strh	r2, [r3, #0]
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
 8008342:	693b      	ldr	r3, [r7, #16]
 8008344:	881a      	ldrh	r2, [r3, #0]
 8008346:	2380      	movs	r3, #128	; 0x80
 8008348:	00db      	lsls	r3, r3, #3
 800834a:	429a      	cmp	r2, r3
 800834c:	d05a      	beq.n	8008404 <mem_trim+0x250>
      ptr_to_mem(mem2->next)->prev = ptr2;
 800834e:	693b      	ldr	r3, [r7, #16]
 8008350:	881b      	ldrh	r3, [r3, #0]
 8008352:	0018      	movs	r0, r3
 8008354:	f7ff fd6e 	bl	8007e34 <ptr_to_mem>
 8008358:	0002      	movs	r2, r0
 800835a:	193b      	adds	r3, r7, r4
 800835c:	881b      	ldrh	r3, [r3, #0]
 800835e:	8053      	strh	r3, [r2, #2]
 8008360:	e050      	b.n	8008404 <mem_trim+0x250>
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 8008362:	211e      	movs	r1, #30
 8008364:	187b      	adds	r3, r7, r1
 8008366:	881b      	ldrh	r3, [r3, #0]
 8008368:	3314      	adds	r3, #20
 800836a:	001a      	movs	r2, r3
 800836c:	2314      	movs	r3, #20
 800836e:	18fb      	adds	r3, r7, r3
 8008370:	881b      	ldrh	r3, [r3, #0]
 8008372:	429a      	cmp	r2, r3
 8008374:	d846      	bhi.n	8008404 <mem_trim+0x250>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + newsize);
 8008376:	2316      	movs	r3, #22
 8008378:	18fa      	adds	r2, r7, r3
 800837a:	187b      	adds	r3, r7, r1
 800837c:	8812      	ldrh	r2, [r2, #0]
 800837e:	881b      	ldrh	r3, [r3, #0]
 8008380:	18d3      	adds	r3, r2, r3
 8008382:	b29a      	uxth	r2, r3
 8008384:	230e      	movs	r3, #14
 8008386:	18fb      	adds	r3, r7, r3
 8008388:	3208      	adds	r2, #8
 800838a:	801a      	strh	r2, [r3, #0]
    LWIP_ASSERT("invalid next ptr", mem->next != MEM_SIZE_ALIGNED);
 800838c:	69bb      	ldr	r3, [r7, #24]
 800838e:	881a      	ldrh	r2, [r3, #0]
 8008390:	2380      	movs	r3, #128	; 0x80
 8008392:	00db      	lsls	r3, r3, #3
 8008394:	429a      	cmp	r2, r3
 8008396:	d105      	bne.n	80083a4 <mem_trim+0x1f0>
 8008398:	4b1f      	ldr	r3, [pc, #124]	; (8008418 <mem_trim+0x264>)
 800839a:	4a27      	ldr	r2, [pc, #156]	; (8008438 <mem_trim+0x284>)
 800839c:	4924      	ldr	r1, [pc, #144]	; (8008430 <mem_trim+0x27c>)
 800839e:	4821      	ldr	r0, [pc, #132]	; (8008424 <mem_trim+0x270>)
 80083a0:	f7f9 ff14 	bl	80021cc <app_debug_rtt_raw>
    mem2 = ptr_to_mem(ptr2);
 80083a4:	230e      	movs	r3, #14
 80083a6:	18fb      	adds	r3, r7, r3
 80083a8:	881b      	ldrh	r3, [r3, #0]
 80083aa:	0018      	movs	r0, r3
 80083ac:	f7ff fd42 	bl	8007e34 <ptr_to_mem>
 80083b0:	0003      	movs	r3, r0
 80083b2:	613b      	str	r3, [r7, #16]
    if (mem2 < lfree) {
 80083b4:	4b1f      	ldr	r3, [pc, #124]	; (8008434 <mem_trim+0x280>)
 80083b6:	681b      	ldr	r3, [r3, #0]
 80083b8:	693a      	ldr	r2, [r7, #16]
 80083ba:	429a      	cmp	r2, r3
 80083bc:	d202      	bcs.n	80083c4 <mem_trim+0x210>
      lfree = mem2;
 80083be:	4b1d      	ldr	r3, [pc, #116]	; (8008434 <mem_trim+0x280>)
 80083c0:	693a      	ldr	r2, [r7, #16]
 80083c2:	601a      	str	r2, [r3, #0]
    }
    mem2->used = 0;
 80083c4:	693b      	ldr	r3, [r7, #16]
 80083c6:	2200      	movs	r2, #0
 80083c8:	711a      	strb	r2, [r3, #4]
    mem2->next = mem->next;
 80083ca:	69bb      	ldr	r3, [r7, #24]
 80083cc:	881a      	ldrh	r2, [r3, #0]
 80083ce:	693b      	ldr	r3, [r7, #16]
 80083d0:	801a      	strh	r2, [r3, #0]
    mem2->prev = ptr;
 80083d2:	693b      	ldr	r3, [r7, #16]
 80083d4:	2216      	movs	r2, #22
 80083d6:	18ba      	adds	r2, r7, r2
 80083d8:	8812      	ldrh	r2, [r2, #0]
 80083da:	805a      	strh	r2, [r3, #2]
    mem->next = ptr2;
 80083dc:	69bb      	ldr	r3, [r7, #24]
 80083de:	240e      	movs	r4, #14
 80083e0:	193a      	adds	r2, r7, r4
 80083e2:	8812      	ldrh	r2, [r2, #0]
 80083e4:	801a      	strh	r2, [r3, #0]
    if (mem2->next != MEM_SIZE_ALIGNED) {
 80083e6:	693b      	ldr	r3, [r7, #16]
 80083e8:	881a      	ldrh	r2, [r3, #0]
 80083ea:	2380      	movs	r3, #128	; 0x80
 80083ec:	00db      	lsls	r3, r3, #3
 80083ee:	429a      	cmp	r2, r3
 80083f0:	d008      	beq.n	8008404 <mem_trim+0x250>
      ptr_to_mem(mem2->next)->prev = ptr2;
 80083f2:	693b      	ldr	r3, [r7, #16]
 80083f4:	881b      	ldrh	r3, [r3, #0]
 80083f6:	0018      	movs	r0, r3
 80083f8:	f7ff fd1c 	bl	8007e34 <ptr_to_mem>
 80083fc:	0002      	movs	r2, r0
 80083fe:	193b      	adds	r3, r7, r4
 8008400:	881b      	ldrh	r3, [r3, #0]
 8008402:	8053      	strh	r3, [r2, #2]
  MEM_SANITY();
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
 8008404:	687b      	ldr	r3, [r7, #4]
}
 8008406:	0018      	movs	r0, r3
 8008408:	46bd      	mov	sp, r7
 800840a:	b008      	add	sp, #32
 800840c:	bdb0      	pop	{r4, r5, r7, pc}
 800840e:	46c0      	nop			; (mov r8, r8)
 8008410:	20001330 	.word	0x20001330
 8008414:	20001334 	.word	0x20001334
 8008418:	0801e6ec 	.word	0x0801e6ec
 800841c:	000002d1 	.word	0x000002d1
 8008420:	0801e858 	.word	0x0801e858
 8008424:	0801e72c 	.word	0x0801e72c
 8008428:	0801e870 	.word	0x0801e870
 800842c:	000002f5 	.word	0x000002f5
 8008430:	0801e890 	.word	0x0801e890
 8008434:	20001338 	.word	0x20001338
 8008438:	00000316 	.word	0x00000316

0800843c <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size_in)
{
 800843c:	b590      	push	{r4, r7, lr}
 800843e:	b089      	sub	sp, #36	; 0x24
 8008440:	af00      	add	r7, sp, #0
 8008442:	0002      	movs	r2, r0
 8008444:	1dbb      	adds	r3, r7, #6
 8008446:	801a      	strh	r2, [r3, #0]
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size_in == 0) {
 8008448:	1dbb      	adds	r3, r7, #6
 800844a:	881b      	ldrh	r3, [r3, #0]
 800844c:	2b00      	cmp	r3, #0
 800844e:	d101      	bne.n	8008454 <mem_malloc+0x18>
    return NULL;
 8008450:	2300      	movs	r3, #0
 8008452:	e101      	b.n	8008658 <mem_malloc+0x21c>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = (mem_size_t)LWIP_MEM_ALIGN_SIZE(size_in);
 8008454:	1dbb      	adds	r3, r7, #6
 8008456:	881b      	ldrh	r3, [r3, #0]
 8008458:	3303      	adds	r3, #3
 800845a:	b29a      	uxth	r2, r3
 800845c:	201c      	movs	r0, #28
 800845e:	183b      	adds	r3, r7, r0
 8008460:	2103      	movs	r1, #3
 8008462:	438a      	bics	r2, r1
 8008464:	801a      	strh	r2, [r3, #0]
  if (size < MIN_SIZE_ALIGNED) {
 8008466:	183b      	adds	r3, r7, r0
 8008468:	881b      	ldrh	r3, [r3, #0]
 800846a:	2b0b      	cmp	r3, #11
 800846c:	d802      	bhi.n	8008474 <mem_malloc+0x38>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
 800846e:	183b      	adds	r3, r7, r0
 8008470:	220c      	movs	r2, #12
 8008472:	801a      	strh	r2, [r3, #0]
  }
#if MEM_OVERFLOW_CHECK
  size += MEM_SANITY_REGION_BEFORE_ALIGNED + MEM_SANITY_REGION_AFTER_ALIGNED;
#endif
  if ((size > MEM_SIZE_ALIGNED) || (size < size_in)) {
 8008474:	211c      	movs	r1, #28
 8008476:	187b      	adds	r3, r7, r1
 8008478:	881a      	ldrh	r2, [r3, #0]
 800847a:	2380      	movs	r3, #128	; 0x80
 800847c:	00db      	lsls	r3, r3, #3
 800847e:	429a      	cmp	r2, r3
 8008480:	d805      	bhi.n	800848e <mem_malloc+0x52>
 8008482:	187a      	adds	r2, r7, r1
 8008484:	1dbb      	adds	r3, r7, #6
 8008486:	8812      	ldrh	r2, [r2, #0]
 8008488:	881b      	ldrh	r3, [r3, #0]
 800848a:	429a      	cmp	r2, r3
 800848c:	d201      	bcs.n	8008492 <mem_malloc+0x56>
    return NULL;
 800848e:	2300      	movs	r3, #0
 8008490:	e0e2      	b.n	8008658 <mem_malloc+0x21c>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = mem_to_ptr(lfree); ptr < MEM_SIZE_ALIGNED - size;
 8008492:	4b73      	ldr	r3, [pc, #460]	; (8008660 <mem_malloc+0x224>)
 8008494:	681b      	ldr	r3, [r3, #0]
 8008496:	221e      	movs	r2, #30
 8008498:	18bc      	adds	r4, r7, r2
 800849a:	0018      	movs	r0, r3
 800849c:	f7ff fcdc 	bl	8007e58 <mem_to_ptr>
 80084a0:	0003      	movs	r3, r0
 80084a2:	8023      	strh	r3, [r4, #0]
 80084a4:	e0cb      	b.n	800863e <mem_malloc+0x202>
         ptr = ptr_to_mem(ptr)->next) {
      mem = ptr_to_mem(ptr);
 80084a6:	241e      	movs	r4, #30
 80084a8:	193b      	adds	r3, r7, r4
 80084aa:	881b      	ldrh	r3, [r3, #0]
 80084ac:	0018      	movs	r0, r3
 80084ae:	f7ff fcc1 	bl	8007e34 <ptr_to_mem>
 80084b2:	0003      	movs	r3, r0
 80084b4:	617b      	str	r3, [r7, #20]
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
 80084b6:	697b      	ldr	r3, [r7, #20]
 80084b8:	791b      	ldrb	r3, [r3, #4]
 80084ba:	2b00      	cmp	r3, #0
 80084bc:	d000      	beq.n	80084c0 <mem_malloc+0x84>
 80084be:	e0b4      	b.n	800862a <mem_malloc+0x1ee>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 80084c0:	697b      	ldr	r3, [r7, #20]
 80084c2:	881b      	ldrh	r3, [r3, #0]
 80084c4:	001a      	movs	r2, r3
 80084c6:	0021      	movs	r1, r4
 80084c8:	187b      	adds	r3, r7, r1
 80084ca:	881b      	ldrh	r3, [r3, #0]
 80084cc:	1ad3      	subs	r3, r2, r3
 80084ce:	3b08      	subs	r3, #8
 80084d0:	001a      	movs	r2, r3
 80084d2:	201c      	movs	r0, #28
 80084d4:	183b      	adds	r3, r7, r0
 80084d6:	881b      	ldrh	r3, [r3, #0]
      if ((!mem->used) &&
 80084d8:	429a      	cmp	r2, r3
 80084da:	d200      	bcs.n	80084de <mem_malloc+0xa2>
 80084dc:	e0a5      	b.n	800862a <mem_malloc+0x1ee>
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 80084de:	697b      	ldr	r3, [r7, #20]
 80084e0:	881b      	ldrh	r3, [r3, #0]
 80084e2:	001a      	movs	r2, r3
 80084e4:	187b      	adds	r3, r7, r1
 80084e6:	881b      	ldrh	r3, [r3, #0]
 80084e8:	1ad3      	subs	r3, r2, r3
 80084ea:	3b08      	subs	r3, #8
 80084ec:	001a      	movs	r2, r3
 80084ee:	183b      	adds	r3, r7, r0
 80084f0:	881b      	ldrh	r3, [r3, #0]
 80084f2:	3314      	adds	r3, #20
 80084f4:	429a      	cmp	r2, r3
 80084f6:	d340      	bcc.n	800857a <mem_malloc+0x13e>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + size);
 80084f8:	187a      	adds	r2, r7, r1
 80084fa:	183b      	adds	r3, r7, r0
 80084fc:	8812      	ldrh	r2, [r2, #0]
 80084fe:	881b      	ldrh	r3, [r3, #0]
 8008500:	18d3      	adds	r3, r2, r3
 8008502:	b29a      	uxth	r2, r3
 8008504:	2112      	movs	r1, #18
 8008506:	187b      	adds	r3, r7, r1
 8008508:	3208      	adds	r2, #8
 800850a:	801a      	strh	r2, [r3, #0]
          LWIP_ASSERT("invalid next ptr",ptr2 != MEM_SIZE_ALIGNED);
 800850c:	187b      	adds	r3, r7, r1
 800850e:	881a      	ldrh	r2, [r3, #0]
 8008510:	2380      	movs	r3, #128	; 0x80
 8008512:	00db      	lsls	r3, r3, #3
 8008514:	429a      	cmp	r2, r3
 8008516:	d105      	bne.n	8008524 <mem_malloc+0xe8>
 8008518:	4b52      	ldr	r3, [pc, #328]	; (8008664 <mem_malloc+0x228>)
 800851a:	4a53      	ldr	r2, [pc, #332]	; (8008668 <mem_malloc+0x22c>)
 800851c:	4953      	ldr	r1, [pc, #332]	; (800866c <mem_malloc+0x230>)
 800851e:	4854      	ldr	r0, [pc, #336]	; (8008670 <mem_malloc+0x234>)
 8008520:	f7f9 fe54 	bl	80021cc <app_debug_rtt_raw>
          /* create mem2 struct */
          mem2 = ptr_to_mem(ptr2);
 8008524:	2412      	movs	r4, #18
 8008526:	193b      	adds	r3, r7, r4
 8008528:	881b      	ldrh	r3, [r3, #0]
 800852a:	0018      	movs	r0, r3
 800852c:	f7ff fc82 	bl	8007e34 <ptr_to_mem>
 8008530:	0003      	movs	r3, r0
 8008532:	60fb      	str	r3, [r7, #12]
          mem2->used = 0;
 8008534:	68fb      	ldr	r3, [r7, #12]
 8008536:	2200      	movs	r2, #0
 8008538:	711a      	strb	r2, [r3, #4]
          mem2->next = mem->next;
 800853a:	697b      	ldr	r3, [r7, #20]
 800853c:	881a      	ldrh	r2, [r3, #0]
 800853e:	68fb      	ldr	r3, [r7, #12]
 8008540:	801a      	strh	r2, [r3, #0]
          mem2->prev = ptr;
 8008542:	68fb      	ldr	r3, [r7, #12]
 8008544:	221e      	movs	r2, #30
 8008546:	18ba      	adds	r2, r7, r2
 8008548:	8812      	ldrh	r2, [r2, #0]
 800854a:	805a      	strh	r2, [r3, #2]
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
 800854c:	697b      	ldr	r3, [r7, #20]
 800854e:	193a      	adds	r2, r7, r4
 8008550:	8812      	ldrh	r2, [r2, #0]
 8008552:	801a      	strh	r2, [r3, #0]
          mem->used = 1;
 8008554:	697b      	ldr	r3, [r7, #20]
 8008556:	2201      	movs	r2, #1
 8008558:	711a      	strb	r2, [r3, #4]

          if (mem2->next != MEM_SIZE_ALIGNED) {
 800855a:	68fb      	ldr	r3, [r7, #12]
 800855c:	881a      	ldrh	r2, [r3, #0]
 800855e:	2380      	movs	r3, #128	; 0x80
 8008560:	00db      	lsls	r3, r3, #3
 8008562:	429a      	cmp	r2, r3
 8008564:	d00c      	beq.n	8008580 <mem_malloc+0x144>
            ptr_to_mem(mem2->next)->prev = ptr2;
 8008566:	68fb      	ldr	r3, [r7, #12]
 8008568:	881b      	ldrh	r3, [r3, #0]
 800856a:	0018      	movs	r0, r3
 800856c:	f7ff fc62 	bl	8007e34 <ptr_to_mem>
 8008570:	0002      	movs	r2, r0
 8008572:	193b      	adds	r3, r7, r4
 8008574:	881b      	ldrh	r3, [r3, #0]
 8008576:	8053      	strh	r3, [r2, #2]
 8008578:	e002      	b.n	8008580 <mem_malloc+0x144>
           * take care of this).
           * -> near fit or exact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
 800857a:	697b      	ldr	r3, [r7, #20]
 800857c:	2201      	movs	r2, #1
 800857e:	711a      	strb	r2, [r3, #4]
          MEM_STATS_INC_USED(used, mem->next - mem_to_ptr(mem));
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
 8008580:	4b37      	ldr	r3, [pc, #220]	; (8008660 <mem_malloc+0x224>)
 8008582:	681b      	ldr	r3, [r3, #0]
 8008584:	697a      	ldr	r2, [r7, #20]
 8008586:	429a      	cmp	r2, r3
 8008588:	d127      	bne.n	80085da <mem_malloc+0x19e>
          struct mem *cur = lfree;
 800858a:	4b35      	ldr	r3, [pc, #212]	; (8008660 <mem_malloc+0x224>)
 800858c:	681b      	ldr	r3, [r3, #0]
 800858e:	61bb      	str	r3, [r7, #24]
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
 8008590:	e006      	b.n	80085a0 <mem_malloc+0x164>
              /* If mem_free or mem_trim have run, we have to restart since they
                 could have altered our current struct mem or lfree. */
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = ptr_to_mem(cur->next);
 8008592:	69bb      	ldr	r3, [r7, #24]
 8008594:	881b      	ldrh	r3, [r3, #0]
 8008596:	0018      	movs	r0, r3
 8008598:	f7ff fc4c 	bl	8007e34 <ptr_to_mem>
 800859c:	0003      	movs	r3, r0
 800859e:	61bb      	str	r3, [r7, #24]
          while (cur->used && cur != ram_end) {
 80085a0:	69bb      	ldr	r3, [r7, #24]
 80085a2:	791b      	ldrb	r3, [r3, #4]
 80085a4:	2b00      	cmp	r3, #0
 80085a6:	d004      	beq.n	80085b2 <mem_malloc+0x176>
 80085a8:	4b32      	ldr	r3, [pc, #200]	; (8008674 <mem_malloc+0x238>)
 80085aa:	681b      	ldr	r3, [r3, #0]
 80085ac:	69ba      	ldr	r2, [r7, #24]
 80085ae:	429a      	cmp	r2, r3
 80085b0:	d1ef      	bne.n	8008592 <mem_malloc+0x156>
          }
          lfree = cur;
 80085b2:	4b2b      	ldr	r3, [pc, #172]	; (8008660 <mem_malloc+0x224>)
 80085b4:	69ba      	ldr	r2, [r7, #24]
 80085b6:	601a      	str	r2, [r3, #0]
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
 80085b8:	4b29      	ldr	r3, [pc, #164]	; (8008660 <mem_malloc+0x224>)
 80085ba:	681a      	ldr	r2, [r3, #0]
 80085bc:	4b2d      	ldr	r3, [pc, #180]	; (8008674 <mem_malloc+0x238>)
 80085be:	681b      	ldr	r3, [r3, #0]
 80085c0:	429a      	cmp	r2, r3
 80085c2:	d00a      	beq.n	80085da <mem_malloc+0x19e>
 80085c4:	4b26      	ldr	r3, [pc, #152]	; (8008660 <mem_malloc+0x224>)
 80085c6:	681b      	ldr	r3, [r3, #0]
 80085c8:	791b      	ldrb	r3, [r3, #4]
 80085ca:	2b00      	cmp	r3, #0
 80085cc:	d005      	beq.n	80085da <mem_malloc+0x19e>
 80085ce:	4b25      	ldr	r3, [pc, #148]	; (8008664 <mem_malloc+0x228>)
 80085d0:	4a29      	ldr	r2, [pc, #164]	; (8008678 <mem_malloc+0x23c>)
 80085d2:	492a      	ldr	r1, [pc, #168]	; (800867c <mem_malloc+0x240>)
 80085d4:	4826      	ldr	r0, [pc, #152]	; (8008670 <mem_malloc+0x234>)
 80085d6:	f7f9 fdf9 	bl	80021cc <app_debug_rtt_raw>
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
 80085da:	231c      	movs	r3, #28
 80085dc:	18fb      	adds	r3, r7, r3
 80085de:	881a      	ldrh	r2, [r3, #0]
 80085e0:	697b      	ldr	r3, [r7, #20]
 80085e2:	18d3      	adds	r3, r2, r3
 80085e4:	3308      	adds	r3, #8
 80085e6:	001a      	movs	r2, r3
 80085e8:	4b22      	ldr	r3, [pc, #136]	; (8008674 <mem_malloc+0x238>)
 80085ea:	681b      	ldr	r3, [r3, #0]
 80085ec:	429a      	cmp	r2, r3
 80085ee:	d905      	bls.n	80085fc <mem_malloc+0x1c0>
 80085f0:	4b1c      	ldr	r3, [pc, #112]	; (8008664 <mem_malloc+0x228>)
 80085f2:	4a23      	ldr	r2, [pc, #140]	; (8008680 <mem_malloc+0x244>)
 80085f4:	4923      	ldr	r1, [pc, #140]	; (8008684 <mem_malloc+0x248>)
 80085f6:	481e      	ldr	r0, [pc, #120]	; (8008670 <mem_malloc+0x234>)
 80085f8:	f7f9 fde8 	bl	80021cc <app_debug_rtt_raw>
                    (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
 80085fc:	697b      	ldr	r3, [r7, #20]
 80085fe:	2203      	movs	r2, #3
 8008600:	4013      	ands	r3, r2
 8008602:	d005      	beq.n	8008610 <mem_malloc+0x1d4>
 8008604:	4b17      	ldr	r3, [pc, #92]	; (8008664 <mem_malloc+0x228>)
 8008606:	4a20      	ldr	r2, [pc, #128]	; (8008688 <mem_malloc+0x24c>)
 8008608:	4920      	ldr	r1, [pc, #128]	; (800868c <mem_malloc+0x250>)
 800860a:	4819      	ldr	r0, [pc, #100]	; (8008670 <mem_malloc+0x234>)
 800860c:	f7f9 fdde 	bl	80021cc <app_debug_rtt_raw>
                    ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
 8008610:	697b      	ldr	r3, [r7, #20]
 8008612:	2203      	movs	r2, #3
 8008614:	4013      	ands	r3, r2
 8008616:	d005      	beq.n	8008624 <mem_malloc+0x1e8>
 8008618:	4b12      	ldr	r3, [pc, #72]	; (8008664 <mem_malloc+0x228>)
 800861a:	4a1d      	ldr	r2, [pc, #116]	; (8008690 <mem_malloc+0x254>)
 800861c:	491d      	ldr	r1, [pc, #116]	; (8008694 <mem_malloc+0x258>)
 800861e:	4814      	ldr	r0, [pc, #80]	; (8008670 <mem_malloc+0x234>)
 8008620:	f7f9 fdd4 	bl	80021cc <app_debug_rtt_raw>

#if MEM_OVERFLOW_CHECK
        mem_overflow_init_element(mem, size_in);
#endif
        MEM_SANITY();
        return (u8_t *)mem + SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET;
 8008624:	697b      	ldr	r3, [r7, #20]
 8008626:	3308      	adds	r3, #8
 8008628:	e016      	b.n	8008658 <mem_malloc+0x21c>
         ptr = ptr_to_mem(ptr)->next) {
 800862a:	241e      	movs	r4, #30
 800862c:	193b      	adds	r3, r7, r4
 800862e:	881b      	ldrh	r3, [r3, #0]
 8008630:	0018      	movs	r0, r3
 8008632:	f7ff fbff 	bl	8007e34 <ptr_to_mem>
 8008636:	0002      	movs	r2, r0
 8008638:	193b      	adds	r3, r7, r4
 800863a:	8812      	ldrh	r2, [r2, #0]
 800863c:	801a      	strh	r2, [r3, #0]
    for (ptr = mem_to_ptr(lfree); ptr < MEM_SIZE_ALIGNED - size;
 800863e:	231e      	movs	r3, #30
 8008640:	18fb      	adds	r3, r7, r3
 8008642:	881a      	ldrh	r2, [r3, #0]
 8008644:	231c      	movs	r3, #28
 8008646:	18fb      	adds	r3, r7, r3
 8008648:	881b      	ldrh	r3, [r3, #0]
 800864a:	2180      	movs	r1, #128	; 0x80
 800864c:	00c9      	lsls	r1, r1, #3
 800864e:	1acb      	subs	r3, r1, r3
 8008650:	429a      	cmp	r2, r3
 8008652:	d200      	bcs.n	8008656 <mem_malloc+0x21a>
 8008654:	e727      	b.n	80084a6 <mem_malloc+0x6a>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  return NULL;
 8008656:	2300      	movs	r3, #0
}
 8008658:	0018      	movs	r0, r3
 800865a:	46bd      	mov	sp, r7
 800865c:	b009      	add	sp, #36	; 0x24
 800865e:	bd90      	pop	{r4, r7, pc}
 8008660:	20001338 	.word	0x20001338
 8008664:	0801e6ec 	.word	0x0801e6ec
 8008668:	00000387 	.word	0x00000387
 800866c:	0801e890 	.word	0x0801e890
 8008670:	0801e72c 	.word	0x0801e72c
 8008674:	20001334 	.word	0x20001334
 8008678:	000003b5 	.word	0x000003b5
 800867c:	0801e8a4 	.word	0x0801e8a4
 8008680:	000003b9 	.word	0x000003b9
 8008684:	0801e8c0 	.word	0x0801e8c0
 8008688:	000003bb 	.word	0x000003bb
 800868c:	0801e8f0 	.word	0x0801e8f0
 8008690:	000003bd 	.word	0x000003bd
 8008694:	0801e920 	.word	0x0801e920

08008698 <memp_init_pool>:
 *
 * @param desc pool to initialize
 */
void
memp_init_pool(const struct memp_desc *desc)
{
 8008698:	b580      	push	{r7, lr}
 800869a:	b084      	sub	sp, #16
 800869c:	af00      	add	r7, sp, #0
 800869e:	6078      	str	r0, [r7, #4]
  LWIP_UNUSED_ARG(desc);
#else
  int i;
  struct memp *memp;

  *desc->tab = NULL;
 80086a0:	687b      	ldr	r3, [r7, #4]
 80086a2:	68db      	ldr	r3, [r3, #12]
 80086a4:	2200      	movs	r2, #0
 80086a6:	601a      	str	r2, [r3, #0]
  memp = (struct memp *)LWIP_MEM_ALIGN(desc->base);
 80086a8:	687b      	ldr	r3, [r7, #4]
 80086aa:	689b      	ldr	r3, [r3, #8]
 80086ac:	3303      	adds	r3, #3
 80086ae:	2203      	movs	r2, #3
 80086b0:	4393      	bics	r3, r2
 80086b2:	60bb      	str	r3, [r7, #8]
                                       + MEM_SANITY_REGION_AFTER_ALIGNED
#endif
                                      ));
#endif
  /* create a linked list of memp elements */
  for (i = 0; i < desc->num; ++i) {
 80086b4:	2300      	movs	r3, #0
 80086b6:	60fb      	str	r3, [r7, #12]
 80086b8:	e011      	b.n	80086de <memp_init_pool+0x46>
    memp->next = *desc->tab;
 80086ba:	687b      	ldr	r3, [r7, #4]
 80086bc:	68db      	ldr	r3, [r3, #12]
 80086be:	681a      	ldr	r2, [r3, #0]
 80086c0:	68bb      	ldr	r3, [r7, #8]
 80086c2:	601a      	str	r2, [r3, #0]
    *desc->tab = memp;
 80086c4:	687b      	ldr	r3, [r7, #4]
 80086c6:	68db      	ldr	r3, [r3, #12]
 80086c8:	68ba      	ldr	r2, [r7, #8]
 80086ca:	601a      	str	r2, [r3, #0]
#if MEMP_OVERFLOW_CHECK
    memp_overflow_init_element(memp, desc);
#endif /* MEMP_OVERFLOW_CHECK */
    /* cast through void* to get rid of alignment warnings */
    memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + desc->size
 80086cc:	687b      	ldr	r3, [r7, #4]
 80086ce:	889b      	ldrh	r3, [r3, #4]
 80086d0:	001a      	movs	r2, r3
 80086d2:	68bb      	ldr	r3, [r7, #8]
 80086d4:	189b      	adds	r3, r3, r2
 80086d6:	60bb      	str	r3, [r7, #8]
  for (i = 0; i < desc->num; ++i) {
 80086d8:	68fb      	ldr	r3, [r7, #12]
 80086da:	3301      	adds	r3, #1
 80086dc:	60fb      	str	r3, [r7, #12]
 80086de:	687b      	ldr	r3, [r7, #4]
 80086e0:	88db      	ldrh	r3, [r3, #6]
 80086e2:	001a      	movs	r2, r3
 80086e4:	68fb      	ldr	r3, [r7, #12]
 80086e6:	4293      	cmp	r3, r2
 80086e8:	dbe7      	blt.n	80086ba <memp_init_pool+0x22>
#endif /* !MEMP_MEM_MALLOC */

#if MEMP_STATS && (defined(LWIP_DEBUG) || LWIP_STATS_DISPLAY)
  desc->stats->name  = desc->desc;
#endif /* MEMP_STATS && (defined(LWIP_DEBUG) || LWIP_STATS_DISPLAY) */
}
 80086ea:	46c0      	nop			; (mov r8, r8)
 80086ec:	46c0      	nop			; (mov r8, r8)
 80086ee:	46bd      	mov	sp, r7
 80086f0:	b004      	add	sp, #16
 80086f2:	bd80      	pop	{r7, pc}

080086f4 <memp_init>:
 *
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
 80086f4:	b580      	push	{r7, lr}
 80086f6:	b082      	sub	sp, #8
 80086f8:	af00      	add	r7, sp, #0
  u16_t i;

  /* for every pool: */
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
 80086fa:	1dbb      	adds	r3, r7, #6
 80086fc:	2200      	movs	r2, #0
 80086fe:	801a      	strh	r2, [r3, #0]
 8008700:	e00c      	b.n	800871c <memp_init+0x28>
    memp_init_pool(memp_pools[i]);
 8008702:	1dbb      	adds	r3, r7, #6
 8008704:	881a      	ldrh	r2, [r3, #0]
 8008706:	4b0a      	ldr	r3, [pc, #40]	; (8008730 <memp_init+0x3c>)
 8008708:	0092      	lsls	r2, r2, #2
 800870a:	58d3      	ldr	r3, [r2, r3]
 800870c:	0018      	movs	r0, r3
 800870e:	f7ff ffc3 	bl	8008698 <memp_init_pool>
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
 8008712:	1dbb      	adds	r3, r7, #6
 8008714:	881a      	ldrh	r2, [r3, #0]
 8008716:	1dbb      	adds	r3, r7, #6
 8008718:	3201      	adds	r2, #1
 800871a:	801a      	strh	r2, [r3, #0]
 800871c:	1dbb      	adds	r3, r7, #6
 800871e:	881b      	ldrh	r3, [r3, #0]
 8008720:	2b06      	cmp	r3, #6
 8008722:	d9ee      	bls.n	8008702 <memp_init+0xe>

#if MEMP_OVERFLOW_CHECK >= 2
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
}
 8008724:	46c0      	nop			; (mov r8, r8)
 8008726:	46c0      	nop			; (mov r8, r8)
 8008728:	46bd      	mov	sp, r7
 800872a:	b002      	add	sp, #8
 800872c:	bd80      	pop	{r7, pc}
 800872e:	46c0      	nop			; (mov r8, r8)
 8008730:	080219d4 	.word	0x080219d4

08008734 <do_memp_malloc_pool>:
#if !MEMP_OVERFLOW_CHECK
do_memp_malloc_pool(const struct memp_desc *desc)
#else
do_memp_malloc_pool_fn(const struct memp_desc *desc, const char *file, const int line)
#endif
{
 8008734:	b580      	push	{r7, lr}
 8008736:	b084      	sub	sp, #16
 8008738:	af00      	add	r7, sp, #0
 800873a:	6078      	str	r0, [r7, #4]
  memp = (struct memp *)mem_malloc(MEMP_SIZE + MEMP_ALIGN_SIZE(desc->size));
  SYS_ARCH_PROTECT(old_level);
#else /* MEMP_MEM_MALLOC */
  SYS_ARCH_PROTECT(old_level);

  memp = *desc->tab;
 800873c:	687b      	ldr	r3, [r7, #4]
 800873e:	68db      	ldr	r3, [r3, #12]
 8008740:	681b      	ldr	r3, [r3, #0]
 8008742:	60fb      	str	r3, [r7, #12]
#endif /* MEMP_MEM_MALLOC */

  if (memp != NULL) {
 8008744:	68fb      	ldr	r3, [r7, #12]
 8008746:	2b00      	cmp	r3, #0
 8008748:	d011      	beq.n	800876e <do_memp_malloc_pool+0x3a>
#if !MEMP_MEM_MALLOC
#if MEMP_OVERFLOW_CHECK == 1
    memp_overflow_check_element(memp, desc);
#endif /* MEMP_OVERFLOW_CHECK */

    *desc->tab = memp->next;
 800874a:	687b      	ldr	r3, [r7, #4]
 800874c:	68db      	ldr	r3, [r3, #12]
 800874e:	68fa      	ldr	r2, [r7, #12]
 8008750:	6812      	ldr	r2, [r2, #0]
 8008752:	601a      	str	r2, [r3, #0]
    memp->line = line;
#if MEMP_MEM_MALLOC
    memp_overflow_init_element(memp, desc);
#endif /* MEMP_MEM_MALLOC */
#endif /* MEMP_OVERFLOW_CHECK */
    LWIP_ASSERT("memp_malloc: memp properly aligned",
 8008754:	68fb      	ldr	r3, [r7, #12]
 8008756:	2203      	movs	r2, #3
 8008758:	4013      	ands	r3, r2
 800875a:	d006      	beq.n	800876a <do_memp_malloc_pool+0x36>
 800875c:	4b06      	ldr	r3, [pc, #24]	; (8008778 <do_memp_malloc_pool+0x44>)
 800875e:	228c      	movs	r2, #140	; 0x8c
 8008760:	0052      	lsls	r2, r2, #1
 8008762:	4906      	ldr	r1, [pc, #24]	; (800877c <do_memp_malloc_pool+0x48>)
 8008764:	4806      	ldr	r0, [pc, #24]	; (8008780 <do_memp_malloc_pool+0x4c>)
 8008766:	f7f9 fd31 	bl	80021cc <app_debug_rtt_raw>
      desc->stats->max = desc->stats->used;
    }
#endif
    SYS_ARCH_UNPROTECT(old_level);
    /* cast through u8_t* to get rid of alignment warnings */
    return ((u8_t *)memp + MEMP_SIZE);
 800876a:	68fb      	ldr	r3, [r7, #12]
 800876c:	e000      	b.n	8008770 <do_memp_malloc_pool+0x3c>
#endif
    SYS_ARCH_UNPROTECT(old_level);
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", desc->desc));
  }

  return NULL;
 800876e:	2300      	movs	r3, #0
}
 8008770:	0018      	movs	r0, r3
 8008772:	46bd      	mov	sp, r7
 8008774:	b004      	add	sp, #16
 8008776:	bd80      	pop	{r7, pc}
 8008778:	0801e994 	.word	0x0801e994
 800877c:	0801e9bc 	.word	0x0801e9bc
 8008780:	0801e9e0 	.word	0x0801e9e0

08008784 <memp_malloc_pool>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc_pool(const struct memp_desc *desc)
#else
memp_malloc_pool_fn(const struct memp_desc *desc, const char *file, const int line)
#endif
{
 8008784:	b580      	push	{r7, lr}
 8008786:	b082      	sub	sp, #8
 8008788:	af00      	add	r7, sp, #0
 800878a:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("invalid pool desc", desc != NULL);
 800878c:	687b      	ldr	r3, [r7, #4]
 800878e:	2b00      	cmp	r3, #0
 8008790:	d106      	bne.n	80087a0 <memp_malloc_pool+0x1c>
 8008792:	4b0a      	ldr	r3, [pc, #40]	; (80087bc <memp_malloc_pool+0x38>)
 8008794:	229e      	movs	r2, #158	; 0x9e
 8008796:	0052      	lsls	r2, r2, #1
 8008798:	4909      	ldr	r1, [pc, #36]	; (80087c0 <memp_malloc_pool+0x3c>)
 800879a:	480a      	ldr	r0, [pc, #40]	; (80087c4 <memp_malloc_pool+0x40>)
 800879c:	f7f9 fd16 	bl	80021cc <app_debug_rtt_raw>
  if (desc == NULL) {
 80087a0:	687b      	ldr	r3, [r7, #4]
 80087a2:	2b00      	cmp	r3, #0
 80087a4:	d101      	bne.n	80087aa <memp_malloc_pool+0x26>
    return NULL;
 80087a6:	2300      	movs	r3, #0
 80087a8:	e004      	b.n	80087b4 <memp_malloc_pool+0x30>
  }

#if !MEMP_OVERFLOW_CHECK
  return do_memp_malloc_pool(desc);
 80087aa:	687b      	ldr	r3, [r7, #4]
 80087ac:	0018      	movs	r0, r3
 80087ae:	f7ff ffc1 	bl	8008734 <do_memp_malloc_pool>
 80087b2:	0003      	movs	r3, r0
#else
  return do_memp_malloc_pool_fn(desc, file, line);
#endif
}
 80087b4:	0018      	movs	r0, r3
 80087b6:	46bd      	mov	sp, r7
 80087b8:	b002      	add	sp, #8
 80087ba:	bd80      	pop	{r7, pc}
 80087bc:	0801e994 	.word	0x0801e994
 80087c0:	0801ea0c 	.word	0x0801ea0c
 80087c4:	0801e9e0 	.word	0x0801e9e0

080087c8 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char *file, const int line)
#endif
{
 80087c8:	b580      	push	{r7, lr}
 80087ca:	b084      	sub	sp, #16
 80087cc:	af00      	add	r7, sp, #0
 80087ce:	0002      	movs	r2, r0
 80087d0:	1dfb      	adds	r3, r7, #7
 80087d2:	701a      	strb	r2, [r3, #0]
  void *memp;
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 80087d4:	1dfb      	adds	r3, r7, #7
 80087d6:	781b      	ldrb	r3, [r3, #0]
 80087d8:	2b06      	cmp	r3, #6
 80087da:	d905      	bls.n	80087e8 <memp_malloc+0x20>
 80087dc:	4b0a      	ldr	r3, [pc, #40]	; (8008808 <memp_malloc+0x40>)
 80087de:	0018      	movs	r0, r3
 80087e0:	f7f9 fcf4 	bl	80021cc <app_debug_rtt_raw>
 80087e4:	2300      	movs	r3, #0
 80087e6:	e00a      	b.n	80087fe <memp_malloc+0x36>
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

#if !MEMP_OVERFLOW_CHECK
  memp = do_memp_malloc_pool(memp_pools[type]);
 80087e8:	1dfb      	adds	r3, r7, #7
 80087ea:	781a      	ldrb	r2, [r3, #0]
 80087ec:	4b07      	ldr	r3, [pc, #28]	; (800880c <memp_malloc+0x44>)
 80087ee:	0092      	lsls	r2, r2, #2
 80087f0:	58d3      	ldr	r3, [r2, r3]
 80087f2:	0018      	movs	r0, r3
 80087f4:	f7ff ff9e 	bl	8008734 <do_memp_malloc_pool>
 80087f8:	0003      	movs	r3, r0
 80087fa:	60fb      	str	r3, [r7, #12]
#else
  memp = do_memp_malloc_pool_fn(memp_pools[type], file, line);
#endif

  return memp;
 80087fc:	68fb      	ldr	r3, [r7, #12]
}
 80087fe:	0018      	movs	r0, r3
 8008800:	46bd      	mov	sp, r7
 8008802:	b004      	add	sp, #16
 8008804:	bd80      	pop	{r7, pc}
 8008806:	46c0      	nop			; (mov r8, r8)
 8008808:	0801ea20 	.word	0x0801ea20
 800880c:	080219d4 	.word	0x080219d4

08008810 <do_memp_free_pool>:

static void
do_memp_free_pool(const struct memp_desc *desc, void *mem)
{
 8008810:	b580      	push	{r7, lr}
 8008812:	b084      	sub	sp, #16
 8008814:	af00      	add	r7, sp, #0
 8008816:	6078      	str	r0, [r7, #4]
 8008818:	6039      	str	r1, [r7, #0]
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  LWIP_ASSERT("memp_free: mem properly aligned",
 800881a:	683b      	ldr	r3, [r7, #0]
 800881c:	2203      	movs	r2, #3
 800881e:	4013      	ands	r3, r2
 8008820:	d006      	beq.n	8008830 <do_memp_free_pool+0x20>
 8008822:	4b0b      	ldr	r3, [pc, #44]	; (8008850 <do_memp_free_pool+0x40>)
 8008824:	22b6      	movs	r2, #182	; 0xb6
 8008826:	0052      	lsls	r2, r2, #1
 8008828:	490a      	ldr	r1, [pc, #40]	; (8008854 <do_memp_free_pool+0x44>)
 800882a:	480b      	ldr	r0, [pc, #44]	; (8008858 <do_memp_free_pool+0x48>)
 800882c:	f7f9 fcce 	bl	80021cc <app_debug_rtt_raw>
              ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  /* cast through void* to get rid of alignment warnings */
  memp = (struct memp *)(void *)((u8_t *)mem - MEMP_SIZE);
 8008830:	683b      	ldr	r3, [r7, #0]
 8008832:	60fb      	str	r3, [r7, #12]
#if MEMP_MEM_MALLOC
  LWIP_UNUSED_ARG(desc);
  SYS_ARCH_UNPROTECT(old_level);
  mem_free(memp);
#else /* MEMP_MEM_MALLOC */
  memp->next = *desc->tab;
 8008834:	687b      	ldr	r3, [r7, #4]
 8008836:	68db      	ldr	r3, [r3, #12]
 8008838:	681a      	ldr	r2, [r3, #0]
 800883a:	68fb      	ldr	r3, [r7, #12]
 800883c:	601a      	str	r2, [r3, #0]
  *desc->tab = memp;
 800883e:	687b      	ldr	r3, [r7, #4]
 8008840:	68db      	ldr	r3, [r3, #12]
 8008842:	68fa      	ldr	r2, [r7, #12]
 8008844:	601a      	str	r2, [r3, #0]
  LWIP_ASSERT("memp sanity", memp_sanity(desc));
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
#endif /* !MEMP_MEM_MALLOC */
}
 8008846:	46c0      	nop			; (mov r8, r8)
 8008848:	46bd      	mov	sp, r7
 800884a:	b004      	add	sp, #16
 800884c:	bd80      	pop	{r7, pc}
 800884e:	46c0      	nop			; (mov r8, r8)
 8008850:	0801e994 	.word	0x0801e994
 8008854:	0801ea40 	.word	0x0801ea40
 8008858:	0801e9e0 	.word	0x0801e9e0

0800885c <memp_free_pool>:
 * @param desc the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free_pool(const struct memp_desc *desc, void *mem)
{
 800885c:	b580      	push	{r7, lr}
 800885e:	b082      	sub	sp, #8
 8008860:	af00      	add	r7, sp, #0
 8008862:	6078      	str	r0, [r7, #4]
 8008864:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT("invalid pool desc", desc != NULL);
 8008866:	687b      	ldr	r3, [r7, #4]
 8008868:	2b00      	cmp	r3, #0
 800886a:	d106      	bne.n	800887a <memp_free_pool+0x1e>
 800886c:	4b0b      	ldr	r3, [pc, #44]	; (800889c <memp_free_pool+0x40>)
 800886e:	2296      	movs	r2, #150	; 0x96
 8008870:	32ff      	adds	r2, #255	; 0xff
 8008872:	490b      	ldr	r1, [pc, #44]	; (80088a0 <memp_free_pool+0x44>)
 8008874:	480b      	ldr	r0, [pc, #44]	; (80088a4 <memp_free_pool+0x48>)
 8008876:	f7f9 fca9 	bl	80021cc <app_debug_rtt_raw>
  if ((desc == NULL) || (mem == NULL)) {
 800887a:	687b      	ldr	r3, [r7, #4]
 800887c:	2b00      	cmp	r3, #0
 800887e:	d009      	beq.n	8008894 <memp_free_pool+0x38>
 8008880:	683b      	ldr	r3, [r7, #0]
 8008882:	2b00      	cmp	r3, #0
 8008884:	d006      	beq.n	8008894 <memp_free_pool+0x38>
    return;
  }

  do_memp_free_pool(desc, mem);
 8008886:	683a      	ldr	r2, [r7, #0]
 8008888:	687b      	ldr	r3, [r7, #4]
 800888a:	0011      	movs	r1, r2
 800888c:	0018      	movs	r0, r3
 800888e:	f7ff ffbf 	bl	8008810 <do_memp_free_pool>
 8008892:	e000      	b.n	8008896 <memp_free_pool+0x3a>
    return;
 8008894:	46c0      	nop			; (mov r8, r8)
}
 8008896:	46bd      	mov	sp, r7
 8008898:	b002      	add	sp, #8
 800889a:	bd80      	pop	{r7, pc}
 800889c:	0801e994 	.word	0x0801e994
 80088a0:	0801ea0c 	.word	0x0801ea0c
 80088a4:	0801e9e0 	.word	0x0801e9e0

080088a8 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
 80088a8:	b580      	push	{r7, lr}
 80088aa:	b082      	sub	sp, #8
 80088ac:	af00      	add	r7, sp, #0
 80088ae:	0002      	movs	r2, r0
 80088b0:	6039      	str	r1, [r7, #0]
 80088b2:	1dfb      	adds	r3, r7, #7
 80088b4:	701a      	strb	r2, [r3, #0]
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  struct memp *old_first;
#endif

  LWIP_ERROR("memp_free: type < MEMP_MAX", (type < MEMP_MAX), return;);
 80088b6:	1dfb      	adds	r3, r7, #7
 80088b8:	781b      	ldrb	r3, [r3, #0]
 80088ba:	2b06      	cmp	r3, #6
 80088bc:	d904      	bls.n	80088c8 <memp_free+0x20>
 80088be:	4b0b      	ldr	r3, [pc, #44]	; (80088ec <memp_free+0x44>)
 80088c0:	0018      	movs	r0, r3
 80088c2:	f7f9 fc83 	bl	80021cc <app_debug_rtt_raw>
 80088c6:	e00e      	b.n	80088e6 <memp_free+0x3e>

  if (mem == NULL) {
 80088c8:	683b      	ldr	r3, [r7, #0]
 80088ca:	2b00      	cmp	r3, #0
 80088cc:	d00a      	beq.n	80088e4 <memp_free+0x3c>

#ifdef LWIP_HOOK_MEMP_AVAILABLE
  old_first = *memp_pools[type]->tab;
#endif

  do_memp_free_pool(memp_pools[type], mem);
 80088ce:	1dfb      	adds	r3, r7, #7
 80088d0:	781a      	ldrb	r2, [r3, #0]
 80088d2:	4b07      	ldr	r3, [pc, #28]	; (80088f0 <memp_free+0x48>)
 80088d4:	0092      	lsls	r2, r2, #2
 80088d6:	58d3      	ldr	r3, [r2, r3]
 80088d8:	683a      	ldr	r2, [r7, #0]
 80088da:	0011      	movs	r1, r2
 80088dc:	0018      	movs	r0, r3
 80088de:	f7ff ff97 	bl	8008810 <do_memp_free_pool>
 80088e2:	e000      	b.n	80088e6 <memp_free+0x3e>
    return;
 80088e4:	46c0      	nop			; (mov r8, r8)
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  if (old_first == NULL) {
    LWIP_HOOK_MEMP_AVAILABLE(type);
  }
#endif
}
 80088e6:	46bd      	mov	sp, r7
 80088e8:	b002      	add	sp, #8
 80088ea:	bd80      	pop	{r7, pc}
 80088ec:	0801ea60 	.word	0x0801ea60
 80088f0:	080219d4 	.word	0x080219d4

080088f4 <netif_init>:
}
#endif /* LWIP_HAVE_LOOPIF */

void
netif_init(void)
{
 80088f4:	b580      	push	{r7, lr}
 80088f6:	af00      	add	r7, sp, #0

  netif_set_link_up(&loop_netif);
  netif_set_up(&loop_netif);

#endif /* LWIP_HAVE_LOOPIF */
}
 80088f8:	46c0      	nop			; (mov r8, r8)
 80088fa:	46bd      	mov	sp, r7
 80088fc:	bd80      	pop	{r7, pc}
	...

08008900 <netif_add>:
netif_add(struct netif *netif,
#if LWIP_IPV4
          const ip4_addr_t *ipaddr, const ip4_addr_t *netmask, const ip4_addr_t *gw,
#endif /* LWIP_IPV4 */
          void *state, netif_init_fn init, netif_input_fn input)
{
 8008900:	b580      	push	{r7, lr}
 8008902:	b086      	sub	sp, #24
 8008904:	af00      	add	r7, sp, #0
 8008906:	60f8      	str	r0, [r7, #12]
 8008908:	60b9      	str	r1, [r7, #8]
 800890a:	607a      	str	r2, [r7, #4]
 800890c:	603b      	str	r3, [r7, #0]
    LWIP_ASSERT("single netif already set", 0);
    return NULL;
  }
#endif

  LWIP_ERROR("netif_add: invalid netif", netif != NULL, return NULL);
 800890e:	68fb      	ldr	r3, [r7, #12]
 8008910:	2b00      	cmp	r3, #0
 8008912:	d105      	bne.n	8008920 <netif_add+0x20>
 8008914:	4b57      	ldr	r3, [pc, #348]	; (8008a74 <netif_add+0x174>)
 8008916:	0018      	movs	r0, r3
 8008918:	f7f9 fc58 	bl	80021cc <app_debug_rtt_raw>
 800891c:	2300      	movs	r3, #0
 800891e:	e0a5      	b.n	8008a6c <netif_add+0x16c>
  LWIP_ERROR("netif_add: No init function given", init != NULL, return NULL);
 8008920:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008922:	2b00      	cmp	r3, #0
 8008924:	d105      	bne.n	8008932 <netif_add+0x32>
 8008926:	4b54      	ldr	r3, [pc, #336]	; (8008a78 <netif_add+0x178>)
 8008928:	0018      	movs	r0, r3
 800892a:	f7f9 fc4f 	bl	80021cc <app_debug_rtt_raw>
 800892e:	2300      	movs	r3, #0
 8008930:	e09c      	b.n	8008a6c <netif_add+0x16c>

#if LWIP_IPV4
  if (ipaddr == NULL) {
 8008932:	68bb      	ldr	r3, [r7, #8]
 8008934:	2b00      	cmp	r3, #0
 8008936:	d101      	bne.n	800893c <netif_add+0x3c>
    ipaddr = ip_2_ip4(IP4_ADDR_ANY);
 8008938:	4b50      	ldr	r3, [pc, #320]	; (8008a7c <netif_add+0x17c>)
 800893a:	60bb      	str	r3, [r7, #8]
  }
  if (netmask == NULL) {
 800893c:	687b      	ldr	r3, [r7, #4]
 800893e:	2b00      	cmp	r3, #0
 8008940:	d101      	bne.n	8008946 <netif_add+0x46>
    netmask = ip_2_ip4(IP4_ADDR_ANY);
 8008942:	4b4e      	ldr	r3, [pc, #312]	; (8008a7c <netif_add+0x17c>)
 8008944:	607b      	str	r3, [r7, #4]
  }
  if (gw == NULL) {
 8008946:	683b      	ldr	r3, [r7, #0]
 8008948:	2b00      	cmp	r3, #0
 800894a:	d101      	bne.n	8008950 <netif_add+0x50>
    gw = ip_2_ip4(IP4_ADDR_ANY);
 800894c:	4b4b      	ldr	r3, [pc, #300]	; (8008a7c <netif_add+0x17c>)
 800894e:	603b      	str	r3, [r7, #0]
  }

  /* reset new interface configuration state */
  ip_addr_set_zero_ip4(&netif->ip_addr);
 8008950:	68fb      	ldr	r3, [r7, #12]
 8008952:	2200      	movs	r2, #0
 8008954:	605a      	str	r2, [r3, #4]
  ip_addr_set_zero_ip4(&netif->netmask);
 8008956:	68fb      	ldr	r3, [r7, #12]
 8008958:	2200      	movs	r2, #0
 800895a:	609a      	str	r2, [r3, #8]
  ip_addr_set_zero_ip4(&netif->gw);
 800895c:	68fb      	ldr	r3, [r7, #12]
 800895e:	2200      	movs	r2, #0
 8008960:	60da      	str	r2, [r3, #12]
  netif->output = netif_null_output_ip4;
 8008962:	68fb      	ldr	r3, [r7, #12]
 8008964:	4a46      	ldr	r2, [pc, #280]	; (8008a80 <netif_add+0x180>)
 8008966:	615a      	str	r2, [r3, #20]
#endif /* LWIP_IPV6_ADDRESS_LIFETIMES */
  }
  netif->output_ip6 = netif_null_output_ip6;
#endif /* LWIP_IPV6 */
  NETIF_SET_CHECKSUM_CTRL(netif, NETIF_CHECKSUM_ENABLE_ALL);
  netif->mtu = 0;
 8008968:	68fb      	ldr	r3, [r7, #12]
 800896a:	2200      	movs	r2, #0
 800896c:	851a      	strh	r2, [r3, #40]	; 0x28
  netif->flags = 0;
 800896e:	68fb      	ldr	r3, [r7, #12]
 8008970:	2231      	movs	r2, #49	; 0x31
 8008972:	2100      	movs	r1, #0
 8008974:	5499      	strb	r1, [r3, r2]
  netif->ip6_autoconfig_enabled = 0;
#endif /* LWIP_IPV6_AUTOCONFIG */
  nd6_restart_netif(netif);
#endif /* LWIP_IPV6 */
#if LWIP_NETIF_STATUS_CALLBACK
  netif->status_callback = NULL;
 8008976:	68fb      	ldr	r3, [r7, #12]
 8008978:	2200      	movs	r2, #0
 800897a:	61da      	str	r2, [r3, #28]
#endif /* LWIP_NETIF_STATUS_CALLBACK */
#if LWIP_NETIF_LINK_CALLBACK
  netif->link_callback = NULL;
 800897c:	68fb      	ldr	r3, [r7, #12]
 800897e:	2200      	movs	r2, #0
 8008980:	621a      	str	r2, [r3, #32]
#if LWIP_IPV6 && LWIP_IPV6_MLD
  netif->mld_mac_filter = NULL;
#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */

  /* remember netif specific state information data */
  netif->state = state;
 8008982:	68fb      	ldr	r3, [r7, #12]
 8008984:	6a3a      	ldr	r2, [r7, #32]
 8008986:	625a      	str	r2, [r3, #36]	; 0x24
  netif->num = netif_num;
 8008988:	4b3e      	ldr	r3, [pc, #248]	; (8008a84 <netif_add+0x184>)
 800898a:	7819      	ldrb	r1, [r3, #0]
 800898c:	68fb      	ldr	r3, [r7, #12]
 800898e:	2234      	movs	r2, #52	; 0x34
 8008990:	5499      	strb	r1, [r3, r2]
  netif->input = input;
 8008992:	68fb      	ldr	r3, [r7, #12]
 8008994:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8008996:	611a      	str	r2, [r3, #16]

  NETIF_RESET_HINTS(netif);
 8008998:	68fb      	ldr	r3, [r7, #12]
 800899a:	2200      	movs	r2, #0
 800899c:	639a      	str	r2, [r3, #56]	; 0x38
  netif->reschedule_poll = 0;
#endif /* LWIP_NETIF_LOOPBACK_MULTITHREADING */
#endif /* ENABLE_LOOPBACK */

#if LWIP_IPV4
  netif_set_addr(netif, ipaddr, netmask, gw);
 800899e:	683b      	ldr	r3, [r7, #0]
 80089a0:	687a      	ldr	r2, [r7, #4]
 80089a2:	68b9      	ldr	r1, [r7, #8]
 80089a4:	68f8      	ldr	r0, [r7, #12]
 80089a6:	f000 f91d 	bl	8008be4 <netif_set_addr>
#endif /* LWIP_IPV4 */

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
 80089aa:	68fa      	ldr	r2, [r7, #12]
 80089ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80089ae:	0010      	movs	r0, r2
 80089b0:	4798      	blx	r3
 80089b2:	1e03      	subs	r3, r0, #0
 80089b4:	d001      	beq.n	80089ba <netif_add+0xba>
    return NULL;
 80089b6:	2300      	movs	r3, #0
 80089b8:	e058      	b.n	8008a6c <netif_add+0x16c>
     */
  {
    struct netif *netif2;
    int num_netifs;
    do {
      if (netif->num == 255) {
 80089ba:	68fb      	ldr	r3, [r7, #12]
 80089bc:	2234      	movs	r2, #52	; 0x34
 80089be:	5c9b      	ldrb	r3, [r3, r2]
 80089c0:	2bff      	cmp	r3, #255	; 0xff
 80089c2:	d103      	bne.n	80089cc <netif_add+0xcc>
        netif->num = 0;
 80089c4:	68fb      	ldr	r3, [r7, #12]
 80089c6:	2234      	movs	r2, #52	; 0x34
 80089c8:	2100      	movs	r1, #0
 80089ca:	5499      	strb	r1, [r3, r2]
      }
      num_netifs = 0;
 80089cc:	2300      	movs	r3, #0
 80089ce:	613b      	str	r3, [r7, #16]
      for (netif2 = netif_list; netif2 != NULL; netif2 = netif2->next) {
 80089d0:	4b2d      	ldr	r3, [pc, #180]	; (8008a88 <netif_add+0x188>)
 80089d2:	681b      	ldr	r3, [r3, #0]
 80089d4:	617b      	str	r3, [r7, #20]
 80089d6:	e02b      	b.n	8008a30 <netif_add+0x130>
        LWIP_ASSERT("netif already added", netif2 != netif);
 80089d8:	697a      	ldr	r2, [r7, #20]
 80089da:	68fb      	ldr	r3, [r7, #12]
 80089dc:	429a      	cmp	r2, r3
 80089de:	d106      	bne.n	80089ee <netif_add+0xee>
 80089e0:	4b2a      	ldr	r3, [pc, #168]	; (8008a8c <netif_add+0x18c>)
 80089e2:	22c7      	movs	r2, #199	; 0xc7
 80089e4:	0052      	lsls	r2, r2, #1
 80089e6:	492a      	ldr	r1, [pc, #168]	; (8008a90 <netif_add+0x190>)
 80089e8:	482a      	ldr	r0, [pc, #168]	; (8008a94 <netif_add+0x194>)
 80089ea:	f7f9 fbef 	bl	80021cc <app_debug_rtt_raw>
        num_netifs++;
 80089ee:	693b      	ldr	r3, [r7, #16]
 80089f0:	3301      	adds	r3, #1
 80089f2:	613b      	str	r3, [r7, #16]
        LWIP_ASSERT("too many netifs, max. supported number is 255", num_netifs <= 255);
 80089f4:	693b      	ldr	r3, [r7, #16]
 80089f6:	2bff      	cmp	r3, #255	; 0xff
 80089f8:	dd06      	ble.n	8008a08 <netif_add+0x108>
 80089fa:	4b24      	ldr	r3, [pc, #144]	; (8008a8c <netif_add+0x18c>)
 80089fc:	22c8      	movs	r2, #200	; 0xc8
 80089fe:	0052      	lsls	r2, r2, #1
 8008a00:	4925      	ldr	r1, [pc, #148]	; (8008a98 <netif_add+0x198>)
 8008a02:	4824      	ldr	r0, [pc, #144]	; (8008a94 <netif_add+0x194>)
 8008a04:	f7f9 fbe2 	bl	80021cc <app_debug_rtt_raw>
        if (netif2->num == netif->num) {
 8008a08:	697b      	ldr	r3, [r7, #20]
 8008a0a:	2234      	movs	r2, #52	; 0x34
 8008a0c:	5c9a      	ldrb	r2, [r3, r2]
 8008a0e:	68fb      	ldr	r3, [r7, #12]
 8008a10:	2134      	movs	r1, #52	; 0x34
 8008a12:	5c5b      	ldrb	r3, [r3, r1]
 8008a14:	429a      	cmp	r2, r3
 8008a16:	d108      	bne.n	8008a2a <netif_add+0x12a>
          netif->num++;
 8008a18:	68fb      	ldr	r3, [r7, #12]
 8008a1a:	2234      	movs	r2, #52	; 0x34
 8008a1c:	5c9b      	ldrb	r3, [r3, r2]
 8008a1e:	3301      	adds	r3, #1
 8008a20:	b2d9      	uxtb	r1, r3
 8008a22:	68fb      	ldr	r3, [r7, #12]
 8008a24:	2234      	movs	r2, #52	; 0x34
 8008a26:	5499      	strb	r1, [r3, r2]
          break;
 8008a28:	e005      	b.n	8008a36 <netif_add+0x136>
      for (netif2 = netif_list; netif2 != NULL; netif2 = netif2->next) {
 8008a2a:	697b      	ldr	r3, [r7, #20]
 8008a2c:	681b      	ldr	r3, [r3, #0]
 8008a2e:	617b      	str	r3, [r7, #20]
 8008a30:	697b      	ldr	r3, [r7, #20]
 8008a32:	2b00      	cmp	r3, #0
 8008a34:	d1d0      	bne.n	80089d8 <netif_add+0xd8>
        }
      }
    } while (netif2 != NULL);
 8008a36:	697b      	ldr	r3, [r7, #20]
 8008a38:	2b00      	cmp	r3, #0
 8008a3a:	d1be      	bne.n	80089ba <netif_add+0xba>
  }
  if (netif->num == 254) {
 8008a3c:	68fb      	ldr	r3, [r7, #12]
 8008a3e:	2234      	movs	r2, #52	; 0x34
 8008a40:	5c9b      	ldrb	r3, [r3, r2]
 8008a42:	2bfe      	cmp	r3, #254	; 0xfe
 8008a44:	d103      	bne.n	8008a4e <netif_add+0x14e>
    netif_num = 0;
 8008a46:	4b0f      	ldr	r3, [pc, #60]	; (8008a84 <netif_add+0x184>)
 8008a48:	2200      	movs	r2, #0
 8008a4a:	701a      	strb	r2, [r3, #0]
 8008a4c:	e006      	b.n	8008a5c <netif_add+0x15c>
  } else {
    netif_num = (u8_t)(netif->num + 1);
 8008a4e:	68fb      	ldr	r3, [r7, #12]
 8008a50:	2234      	movs	r2, #52	; 0x34
 8008a52:	5c9b      	ldrb	r3, [r3, r2]
 8008a54:	3301      	adds	r3, #1
 8008a56:	b2da      	uxtb	r2, r3
 8008a58:	4b0a      	ldr	r3, [pc, #40]	; (8008a84 <netif_add+0x184>)
 8008a5a:	701a      	strb	r2, [r3, #0]
  }

  /* add this netif to the list */
  netif->next = netif_list;
 8008a5c:	4b0a      	ldr	r3, [pc, #40]	; (8008a88 <netif_add+0x188>)
 8008a5e:	681a      	ldr	r2, [r3, #0]
 8008a60:	68fb      	ldr	r3, [r7, #12]
 8008a62:	601a      	str	r2, [r3, #0]
  netif_list = netif;
 8008a64:	4b08      	ldr	r3, [pc, #32]	; (8008a88 <netif_add+0x188>)
 8008a66:	68fa      	ldr	r2, [r7, #12]
 8008a68:	601a      	str	r2, [r3, #0]
#endif /* LWIP_IPV4 */
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));

  netif_invoke_ext_callback(netif, LWIP_NSC_NETIF_ADDED, NULL);

  return netif;
 8008a6a:	68fb      	ldr	r3, [r7, #12]
}
 8008a6c:	0018      	movs	r0, r3
 8008a6e:	46bd      	mov	sp, r7
 8008a70:	b006      	add	sp, #24
 8008a72:	bd80      	pop	{r7, pc}
 8008a74:	0801eb08 	.word	0x0801eb08
 8008a78:	0801eb24 	.word	0x0801eb24
 8008a7c:	08021a50 	.word	0x08021a50
 8008a80:	08008e91 	.word	0x08008e91
 8008a84:	20001358 	.word	0x20001358
 8008a88:	20002b08 	.word	0x20002b08
 8008a8c:	0801ea7c 	.word	0x0801ea7c
 8008a90:	0801eb48 	.word	0x0801eb48
 8008a94:	0801eac0 	.word	0x0801eac0
 8008a98:	0801eb5c 	.word	0x0801eb5c

08008a9c <netif_do_ip_addr_changed>:

static void
netif_do_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
 8008a9c:	b580      	push	{r7, lr}
 8008a9e:	b082      	sub	sp, #8
 8008aa0:	af00      	add	r7, sp, #0
 8008aa2:	6078      	str	r0, [r7, #4]
 8008aa4:	6039      	str	r1, [r7, #0]
#if LWIP_TCP
  tcp_netif_ip_addr_changed(old_addr, new_addr);
 8008aa6:	683a      	ldr	r2, [r7, #0]
 8008aa8:	687b      	ldr	r3, [r7, #4]
 8008aaa:	0011      	movs	r1, r2
 8008aac:	0018      	movs	r0, r3
 8008aae:	f003 facb 	bl	800c048 <tcp_netif_ip_addr_changed>
#endif /* LWIP_TCP */
#if LWIP_UDP
  udp_netif_ip_addr_changed(old_addr, new_addr);
 8008ab2:	683a      	ldr	r2, [r7, #0]
 8008ab4:	687b      	ldr	r3, [r7, #4]
 8008ab6:	0011      	movs	r1, r2
 8008ab8:	0018      	movs	r0, r3
 8008aba:	f009 ff13 	bl	80128e4 <udp_netif_ip_addr_changed>
#endif /* LWIP_UDP */
#if LWIP_RAW
  raw_netif_ip_addr_changed(old_addr, new_addr);
#endif /* LWIP_RAW */
}
 8008abe:	46c0      	nop			; (mov r8, r8)
 8008ac0:	46bd      	mov	sp, r7
 8008ac2:	b002      	add	sp, #8
 8008ac4:	bd80      	pop	{r7, pc}
	...

08008ac8 <netif_do_set_ipaddr>:

#if LWIP_IPV4
static int
netif_do_set_ipaddr(struct netif *netif, const ip4_addr_t *ipaddr, ip_addr_t *old_addr)
{
 8008ac8:	b580      	push	{r7, lr}
 8008aca:	b086      	sub	sp, #24
 8008acc:	af00      	add	r7, sp, #0
 8008ace:	60f8      	str	r0, [r7, #12]
 8008ad0:	60b9      	str	r1, [r7, #8]
 8008ad2:	607a      	str	r2, [r7, #4]
  LWIP_ASSERT("invalid pointer", ipaddr != NULL);
 8008ad4:	68bb      	ldr	r3, [r7, #8]
 8008ad6:	2b00      	cmp	r3, #0
 8008ad8:	d106      	bne.n	8008ae8 <netif_do_set_ipaddr+0x20>
 8008ada:	4b22      	ldr	r3, [pc, #136]	; (8008b64 <netif_do_set_ipaddr+0x9c>)
 8008adc:	22e7      	movs	r2, #231	; 0xe7
 8008ade:	0052      	lsls	r2, r2, #1
 8008ae0:	4921      	ldr	r1, [pc, #132]	; (8008b68 <netif_do_set_ipaddr+0xa0>)
 8008ae2:	4822      	ldr	r0, [pc, #136]	; (8008b6c <netif_do_set_ipaddr+0xa4>)
 8008ae4:	f7f9 fb72 	bl	80021cc <app_debug_rtt_raw>
  LWIP_ASSERT("invalid pointer", old_addr != NULL);
 8008ae8:	687b      	ldr	r3, [r7, #4]
 8008aea:	2b00      	cmp	r3, #0
 8008aec:	d106      	bne.n	8008afc <netif_do_set_ipaddr+0x34>
 8008aee:	4b1d      	ldr	r3, [pc, #116]	; (8008b64 <netif_do_set_ipaddr+0x9c>)
 8008af0:	22d0      	movs	r2, #208	; 0xd0
 8008af2:	32ff      	adds	r2, #255	; 0xff
 8008af4:	491c      	ldr	r1, [pc, #112]	; (8008b68 <netif_do_set_ipaddr+0xa0>)
 8008af6:	481d      	ldr	r0, [pc, #116]	; (8008b6c <netif_do_set_ipaddr+0xa4>)
 8008af8:	f7f9 fb68 	bl	80021cc <app_debug_rtt_raw>

  /* address is actually being changed? */
  if (ip4_addr_cmp(ipaddr, netif_ip4_addr(netif)) == 0) {
 8008afc:	68bb      	ldr	r3, [r7, #8]
 8008afe:	681a      	ldr	r2, [r3, #0]
 8008b00:	68fb      	ldr	r3, [r7, #12]
 8008b02:	3304      	adds	r3, #4
 8008b04:	681b      	ldr	r3, [r3, #0]
 8008b06:	429a      	cmp	r2, r3
 8008b08:	d027      	beq.n	8008b5a <netif_do_set_ipaddr+0x92>
    ip_addr_t new_addr;
    *ip_2_ip4(&new_addr) = *ipaddr;
 8008b0a:	68bb      	ldr	r3, [r7, #8]
 8008b0c:	681b      	ldr	r3, [r3, #0]
 8008b0e:	617b      	str	r3, [r7, #20]
    IP_SET_TYPE_VAL(new_addr, IPADDR_TYPE_V4);

    ip_addr_copy(*old_addr, *netif_ip_addr4(netif));
 8008b10:	68fb      	ldr	r3, [r7, #12]
 8008b12:	3304      	adds	r3, #4
 8008b14:	681a      	ldr	r2, [r3, #0]
 8008b16:	687b      	ldr	r3, [r7, #4]
 8008b18:	601a      	str	r2, [r3, #0]

    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    netif_do_ip_addr_changed(old_addr, &new_addr);
 8008b1a:	2314      	movs	r3, #20
 8008b1c:	18fa      	adds	r2, r7, r3
 8008b1e:	687b      	ldr	r3, [r7, #4]
 8008b20:	0011      	movs	r1, r2
 8008b22:	0018      	movs	r0, r3
 8008b24:	f7ff ffba 	bl	8008a9c <netif_do_ip_addr_changed>

    mib2_remove_ip4(netif);
    mib2_remove_route_ip4(0, netif);
    /* set new IP address to netif */
    ip4_addr_set(ip_2_ip4(&netif->ip_addr), ipaddr);
 8008b28:	68bb      	ldr	r3, [r7, #8]
 8008b2a:	2b00      	cmp	r3, #0
 8008b2c:	d002      	beq.n	8008b34 <netif_do_set_ipaddr+0x6c>
 8008b2e:	68bb      	ldr	r3, [r7, #8]
 8008b30:	681a      	ldr	r2, [r3, #0]
 8008b32:	e000      	b.n	8008b36 <netif_do_set_ipaddr+0x6e>
 8008b34:	2200      	movs	r2, #0
 8008b36:	68fb      	ldr	r3, [r7, #12]
 8008b38:	605a      	str	r2, [r3, #4]
    IP_SET_TYPE_VAL(netif->ip_addr, IPADDR_TYPE_V4);
    mib2_add_ip4(netif);
    mib2_add_route_ip4(0, netif);

    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4);
 8008b3a:	68fb      	ldr	r3, [r7, #12]
 8008b3c:	2101      	movs	r1, #1
 8008b3e:	0018      	movs	r0, r3
 8008b40:	f000 f8f8 	bl	8008d34 <netif_issue_reports>

    NETIF_STATUS_CALLBACK(netif);
 8008b44:	68fb      	ldr	r3, [r7, #12]
 8008b46:	69db      	ldr	r3, [r3, #28]
 8008b48:	2b00      	cmp	r3, #0
 8008b4a:	d004      	beq.n	8008b56 <netif_do_set_ipaddr+0x8e>
 8008b4c:	68fb      	ldr	r3, [r7, #12]
 8008b4e:	69db      	ldr	r3, [r3, #28]
 8008b50:	68fa      	ldr	r2, [r7, #12]
 8008b52:	0010      	movs	r0, r2
 8008b54:	4798      	blx	r3
    return 1; /* address changed */
 8008b56:	2301      	movs	r3, #1
 8008b58:	e000      	b.n	8008b5c <netif_do_set_ipaddr+0x94>
  }
  return 0; /* address unchanged */
 8008b5a:	2300      	movs	r3, #0
}
 8008b5c:	0018      	movs	r0, r3
 8008b5e:	46bd      	mov	sp, r7
 8008b60:	b006      	add	sp, #24
 8008b62:	bd80      	pop	{r7, pc}
 8008b64:	0801ea7c 	.word	0x0801ea7c
 8008b68:	0801eb8c 	.word	0x0801eb8c
 8008b6c:	0801eac0 	.word	0x0801eac0

08008b70 <netif_do_set_netmask>:
  }
}

static int
netif_do_set_netmask(struct netif *netif, const ip4_addr_t *netmask, ip_addr_t *old_nm)
{
 8008b70:	b580      	push	{r7, lr}
 8008b72:	b084      	sub	sp, #16
 8008b74:	af00      	add	r7, sp, #0
 8008b76:	60f8      	str	r0, [r7, #12]
 8008b78:	60b9      	str	r1, [r7, #8]
 8008b7a:	607a      	str	r2, [r7, #4]
  /* address is actually being changed? */
  if (ip4_addr_cmp(netmask, netif_ip4_netmask(netif)) == 0) {
 8008b7c:	68bb      	ldr	r3, [r7, #8]
 8008b7e:	681a      	ldr	r2, [r3, #0]
 8008b80:	68fb      	ldr	r3, [r7, #12]
 8008b82:	3308      	adds	r3, #8
 8008b84:	681b      	ldr	r3, [r3, #0]
 8008b86:	429a      	cmp	r2, r3
 8008b88:	d00a      	beq.n	8008ba0 <netif_do_set_netmask+0x30>
#else
    LWIP_UNUSED_ARG(old_nm);
#endif
    mib2_remove_route_ip4(0, netif);
    /* set new netmask to netif */
    ip4_addr_set(ip_2_ip4(&netif->netmask), netmask);
 8008b8a:	68bb      	ldr	r3, [r7, #8]
 8008b8c:	2b00      	cmp	r3, #0
 8008b8e:	d002      	beq.n	8008b96 <netif_do_set_netmask+0x26>
 8008b90:	68bb      	ldr	r3, [r7, #8]
 8008b92:	681a      	ldr	r2, [r3, #0]
 8008b94:	e000      	b.n	8008b98 <netif_do_set_netmask+0x28>
 8008b96:	2200      	movs	r2, #0
 8008b98:	68fb      	ldr	r3, [r7, #12]
 8008b9a:	609a      	str	r2, [r3, #8]
                netif->name[0], netif->name[1],
                ip4_addr1_16(netif_ip4_netmask(netif)),
                ip4_addr2_16(netif_ip4_netmask(netif)),
                ip4_addr3_16(netif_ip4_netmask(netif)),
                ip4_addr4_16(netif_ip4_netmask(netif))));
    return 1; /* netmask changed */
 8008b9c:	2301      	movs	r3, #1
 8008b9e:	e000      	b.n	8008ba2 <netif_do_set_netmask+0x32>
  }
  return 0; /* netmask unchanged */
 8008ba0:	2300      	movs	r3, #0
}
 8008ba2:	0018      	movs	r0, r3
 8008ba4:	46bd      	mov	sp, r7
 8008ba6:	b004      	add	sp, #16
 8008ba8:	bd80      	pop	{r7, pc}

08008baa <netif_do_set_gw>:
  }
}

static int
netif_do_set_gw(struct netif *netif, const ip4_addr_t *gw, ip_addr_t *old_gw)
{
 8008baa:	b580      	push	{r7, lr}
 8008bac:	b084      	sub	sp, #16
 8008bae:	af00      	add	r7, sp, #0
 8008bb0:	60f8      	str	r0, [r7, #12]
 8008bb2:	60b9      	str	r1, [r7, #8]
 8008bb4:	607a      	str	r2, [r7, #4]
  /* address is actually being changed? */
  if (ip4_addr_cmp(gw, netif_ip4_gw(netif)) == 0) {
 8008bb6:	68bb      	ldr	r3, [r7, #8]
 8008bb8:	681a      	ldr	r2, [r3, #0]
 8008bba:	68fb      	ldr	r3, [r7, #12]
 8008bbc:	330c      	adds	r3, #12
 8008bbe:	681b      	ldr	r3, [r3, #0]
 8008bc0:	429a      	cmp	r2, r3
 8008bc2:	d00a      	beq.n	8008bda <netif_do_set_gw+0x30>
    ip_addr_copy(*old_gw, *netif_ip_gw4(netif));
#else
    LWIP_UNUSED_ARG(old_gw);
#endif

    ip4_addr_set(ip_2_ip4(&netif->gw), gw);
 8008bc4:	68bb      	ldr	r3, [r7, #8]
 8008bc6:	2b00      	cmp	r3, #0
 8008bc8:	d002      	beq.n	8008bd0 <netif_do_set_gw+0x26>
 8008bca:	68bb      	ldr	r3, [r7, #8]
 8008bcc:	681a      	ldr	r2, [r3, #0]
 8008bce:	e000      	b.n	8008bd2 <netif_do_set_gw+0x28>
 8008bd0:	2200      	movs	r2, #0
 8008bd2:	68fb      	ldr	r3, [r7, #12]
 8008bd4:	60da      	str	r2, [r3, #12]
                netif->name[0], netif->name[1],
                ip4_addr1_16(netif_ip4_gw(netif)),
                ip4_addr2_16(netif_ip4_gw(netif)),
                ip4_addr3_16(netif_ip4_gw(netif)),
                ip4_addr4_16(netif_ip4_gw(netif))));
    return 1; /* gateway changed */
 8008bd6:	2301      	movs	r3, #1
 8008bd8:	e000      	b.n	8008bdc <netif_do_set_gw+0x32>
  }
  return 0; /* gateway unchanged */
 8008bda:	2300      	movs	r3, #0
}
 8008bdc:	0018      	movs	r0, r3
 8008bde:	46bd      	mov	sp, r7
 8008be0:	b004      	add	sp, #16
 8008be2:	bd80      	pop	{r7, pc}

08008be4 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, const ip4_addr_t *ipaddr, const ip4_addr_t *netmask,
               const ip4_addr_t *gw)
{
 8008be4:	b580      	push	{r7, lr}
 8008be6:	b088      	sub	sp, #32
 8008be8:	af00      	add	r7, sp, #0
 8008bea:	60f8      	str	r0, [r7, #12]
 8008bec:	60b9      	str	r1, [r7, #8]
 8008bee:	607a      	str	r2, [r7, #4]
 8008bf0:	603b      	str	r3, [r7, #0]
  ip_addr_t old_nm_val;
  ip_addr_t old_gw_val;
  ip_addr_t *old_nm = &old_nm_val;
  ip_addr_t *old_gw = &old_gw_val;
#else
  ip_addr_t *old_nm = NULL;
 8008bf2:	2300      	movs	r3, #0
 8008bf4:	61fb      	str	r3, [r7, #28]
  ip_addr_t *old_gw = NULL;
 8008bf6:	2300      	movs	r3, #0
 8008bf8:	61bb      	str	r3, [r7, #24]
  int remove;

  LWIP_ASSERT_CORE_LOCKED();

  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
 8008bfa:	68bb      	ldr	r3, [r7, #8]
 8008bfc:	2b00      	cmp	r3, #0
 8008bfe:	d101      	bne.n	8008c04 <netif_set_addr+0x20>
    ipaddr = IP4_ADDR_ANY4;
 8008c00:	4b1d      	ldr	r3, [pc, #116]	; (8008c78 <netif_set_addr+0x94>)
 8008c02:	60bb      	str	r3, [r7, #8]
  }
  if (netmask == NULL) {
 8008c04:	687b      	ldr	r3, [r7, #4]
 8008c06:	2b00      	cmp	r3, #0
 8008c08:	d101      	bne.n	8008c0e <netif_set_addr+0x2a>
    netmask = IP4_ADDR_ANY4;
 8008c0a:	4b1b      	ldr	r3, [pc, #108]	; (8008c78 <netif_set_addr+0x94>)
 8008c0c:	607b      	str	r3, [r7, #4]
  }
  if (gw == NULL) {
 8008c0e:	683b      	ldr	r3, [r7, #0]
 8008c10:	2b00      	cmp	r3, #0
 8008c12:	d101      	bne.n	8008c18 <netif_set_addr+0x34>
    gw = IP4_ADDR_ANY4;
 8008c14:	4b18      	ldr	r3, [pc, #96]	; (8008c78 <netif_set_addr+0x94>)
 8008c16:	603b      	str	r3, [r7, #0]
  }

  remove = ip4_addr_isany(ipaddr);
 8008c18:	68bb      	ldr	r3, [r7, #8]
 8008c1a:	2b00      	cmp	r3, #0
 8008c1c:	d003      	beq.n	8008c26 <netif_set_addr+0x42>
 8008c1e:	68bb      	ldr	r3, [r7, #8]
 8008c20:	681b      	ldr	r3, [r3, #0]
 8008c22:	2b00      	cmp	r3, #0
 8008c24:	d101      	bne.n	8008c2a <netif_set_addr+0x46>
 8008c26:	2301      	movs	r3, #1
 8008c28:	e000      	b.n	8008c2c <netif_set_addr+0x48>
 8008c2a:	2300      	movs	r3, #0
 8008c2c:	617b      	str	r3, [r7, #20]
  if (remove) {
 8008c2e:	697b      	ldr	r3, [r7, #20]
 8008c30:	2b00      	cmp	r3, #0
 8008c32:	d006      	beq.n	8008c42 <netif_set_addr+0x5e>
    /* when removing an address, we have to remove it *before* changing netmask/gw
       to ensure that tcp RST segment can be sent correctly */
    if (netif_do_set_ipaddr(netif, ipaddr, &old_addr)) {
 8008c34:	2310      	movs	r3, #16
 8008c36:	18fa      	adds	r2, r7, r3
 8008c38:	68b9      	ldr	r1, [r7, #8]
 8008c3a:	68fb      	ldr	r3, [r7, #12]
 8008c3c:	0018      	movs	r0, r3
 8008c3e:	f7ff ff43 	bl	8008ac8 <netif_do_set_ipaddr>
      change_reason |= LWIP_NSC_IPV4_ADDRESS_CHANGED;
      cb_args.ipv4_changed.old_address = &old_addr;
#endif
    }
  }
  if (netif_do_set_netmask(netif, netmask, old_nm)) {
 8008c42:	69fa      	ldr	r2, [r7, #28]
 8008c44:	6879      	ldr	r1, [r7, #4]
 8008c46:	68fb      	ldr	r3, [r7, #12]
 8008c48:	0018      	movs	r0, r3
 8008c4a:	f7ff ff91 	bl	8008b70 <netif_do_set_netmask>
#if LWIP_NETIF_EXT_STATUS_CALLBACK
    change_reason |= LWIP_NSC_IPV4_NETMASK_CHANGED;
    cb_args.ipv4_changed.old_netmask = old_nm;
#endif
  }
  if (netif_do_set_gw(netif, gw, old_gw)) {
 8008c4e:	69ba      	ldr	r2, [r7, #24]
 8008c50:	6839      	ldr	r1, [r7, #0]
 8008c52:	68fb      	ldr	r3, [r7, #12]
 8008c54:	0018      	movs	r0, r3
 8008c56:	f7ff ffa8 	bl	8008baa <netif_do_set_gw>
#if LWIP_NETIF_EXT_STATUS_CALLBACK
    change_reason |= LWIP_NSC_IPV4_GATEWAY_CHANGED;
    cb_args.ipv4_changed.old_gw = old_gw;
#endif
  }
  if (!remove) {
 8008c5a:	697b      	ldr	r3, [r7, #20]
 8008c5c:	2b00      	cmp	r3, #0
 8008c5e:	d106      	bne.n	8008c6e <netif_set_addr+0x8a>
    /* set ipaddr last to ensure netmask/gw have been set when status callback is called */
    if (netif_do_set_ipaddr(netif, ipaddr, &old_addr)) {
 8008c60:	2310      	movs	r3, #16
 8008c62:	18fa      	adds	r2, r7, r3
 8008c64:	68b9      	ldr	r1, [r7, #8]
 8008c66:	68fb      	ldr	r3, [r7, #12]
 8008c68:	0018      	movs	r0, r3
 8008c6a:	f7ff ff2d 	bl	8008ac8 <netif_do_set_ipaddr>
  if (change_reason != LWIP_NSC_NONE) {
    change_reason |= LWIP_NSC_IPV4_SETTINGS_CHANGED;
    netif_invoke_ext_callback(netif, change_reason, &cb_args);
  }
#endif
}
 8008c6e:	46c0      	nop			; (mov r8, r8)
 8008c70:	46bd      	mov	sp, r7
 8008c72:	b008      	add	sp, #32
 8008c74:	bd80      	pop	{r7, pc}
 8008c76:	46c0      	nop			; (mov r8, r8)
 8008c78:	08021a50 	.word	0x08021a50

08008c7c <netif_remove>:
 *
 * @param netif the network interface to remove
 */
void
netif_remove(struct netif *netif)
{
 8008c7c:	b580      	push	{r7, lr}
 8008c7e:	b084      	sub	sp, #16
 8008c80:	af00      	add	r7, sp, #0
 8008c82:	6078      	str	r0, [r7, #4]
  int i;
#endif

  LWIP_ASSERT_CORE_LOCKED();

  if (netif == NULL) {
 8008c84:	687b      	ldr	r3, [r7, #4]
 8008c86:	2b00      	cmp	r3, #0
 8008c88:	d03e      	beq.n	8008d08 <netif_remove+0x8c>
  }

  netif_invoke_ext_callback(netif, LWIP_NSC_NETIF_REMOVED, NULL);

#if LWIP_IPV4
  if (!ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 8008c8a:	687b      	ldr	r3, [r7, #4]
 8008c8c:	3304      	adds	r3, #4
 8008c8e:	681b      	ldr	r3, [r3, #0]
 8008c90:	2b00      	cmp	r3, #0
 8008c92:	d005      	beq.n	8008ca0 <netif_remove+0x24>
    netif_do_ip_addr_changed(netif_ip_addr4(netif), NULL);
 8008c94:	687b      	ldr	r3, [r7, #4]
 8008c96:	3304      	adds	r3, #4
 8008c98:	2100      	movs	r1, #0
 8008c9a:	0018      	movs	r0, r3
 8008c9c:	f7ff fefe 	bl	8008a9c <netif_do_ip_addr_changed>
#if LWIP_IPV6_MLD
  /* stop MLD processing */
  mld6_stop(netif);
#endif /* LWIP_IPV6_MLD */
#endif /* LWIP_IPV6 */
  if (netif_is_up(netif)) {
 8008ca0:	687b      	ldr	r3, [r7, #4]
 8008ca2:	2231      	movs	r2, #49	; 0x31
 8008ca4:	5c9b      	ldrb	r3, [r3, r2]
 8008ca6:	1c1a      	adds	r2, r3, #0
 8008ca8:	2301      	movs	r3, #1
 8008caa:	4013      	ands	r3, r2
 8008cac:	b2db      	uxtb	r3, r3
 8008cae:	2b00      	cmp	r3, #0
 8008cb0:	d003      	beq.n	8008cba <netif_remove+0x3e>
    /* set netif down before removing (call callback function) */
    netif_set_down(netif);
 8008cb2:	687b      	ldr	r3, [r7, #4]
 8008cb4:	0018      	movs	r0, r3
 8008cb6:	f000 f867 	bl	8008d88 <netif_set_down>
  }

  mib2_remove_ip4(netif);

  /* this netif is default? */
  if (netif_default == netif) {
 8008cba:	4b15      	ldr	r3, [pc, #84]	; (8008d10 <netif_remove+0x94>)
 8008cbc:	681b      	ldr	r3, [r3, #0]
 8008cbe:	687a      	ldr	r2, [r7, #4]
 8008cc0:	429a      	cmp	r2, r3
 8008cc2:	d102      	bne.n	8008cca <netif_remove+0x4e>
    /* reset default netif */
    netif_set_default(NULL);
 8008cc4:	2000      	movs	r0, #0
 8008cc6:	f000 f827 	bl	8008d18 <netif_set_default>
  }
#if !LWIP_SINGLE_NETIF
  /*  is it the first netif? */
  if (netif_list == netif) {
 8008cca:	4b12      	ldr	r3, [pc, #72]	; (8008d14 <netif_remove+0x98>)
 8008ccc:	681b      	ldr	r3, [r3, #0]
 8008cce:	687a      	ldr	r2, [r7, #4]
 8008cd0:	429a      	cmp	r2, r3
 8008cd2:	d104      	bne.n	8008cde <netif_remove+0x62>
    netif_list = netif->next;
 8008cd4:	687b      	ldr	r3, [r7, #4]
 8008cd6:	681a      	ldr	r2, [r3, #0]
 8008cd8:	4b0e      	ldr	r3, [pc, #56]	; (8008d14 <netif_remove+0x98>)
 8008cda:	601a      	str	r2, [r3, #0]
 8008cdc:	e015      	b.n	8008d0a <netif_remove+0x8e>
  } else {
    /*  look for netif further down the list */
    struct netif *tmp_netif;
    NETIF_FOREACH(tmp_netif) {
 8008cde:	4b0d      	ldr	r3, [pc, #52]	; (8008d14 <netif_remove+0x98>)
 8008ce0:	681b      	ldr	r3, [r3, #0]
 8008ce2:	60fb      	str	r3, [r7, #12]
 8008ce4:	e00c      	b.n	8008d00 <netif_remove+0x84>
      if (tmp_netif->next == netif) {
 8008ce6:	68fb      	ldr	r3, [r7, #12]
 8008ce8:	681b      	ldr	r3, [r3, #0]
 8008cea:	687a      	ldr	r2, [r7, #4]
 8008cec:	429a      	cmp	r2, r3
 8008cee:	d104      	bne.n	8008cfa <netif_remove+0x7e>
        tmp_netif->next = netif->next;
 8008cf0:	687b      	ldr	r3, [r7, #4]
 8008cf2:	681a      	ldr	r2, [r3, #0]
 8008cf4:	68fb      	ldr	r3, [r7, #12]
 8008cf6:	601a      	str	r2, [r3, #0]
        break;
 8008cf8:	e007      	b.n	8008d0a <netif_remove+0x8e>
    NETIF_FOREACH(tmp_netif) {
 8008cfa:	68fb      	ldr	r3, [r7, #12]
 8008cfc:	681b      	ldr	r3, [r3, #0]
 8008cfe:	60fb      	str	r3, [r7, #12]
 8008d00:	68fb      	ldr	r3, [r7, #12]
 8008d02:	2b00      	cmp	r3, #0
 8008d04:	d1ef      	bne.n	8008ce6 <netif_remove+0x6a>
 8008d06:	e000      	b.n	8008d0a <netif_remove+0x8e>
    return;
 8008d08:	46c0      	nop			; (mov r8, r8)
  if (netif->remove_callback) {
    netif->remove_callback(netif);
  }
#endif /* LWIP_NETIF_REMOVE_CALLBACK */
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
 8008d0a:	46bd      	mov	sp, r7
 8008d0c:	b004      	add	sp, #16
 8008d0e:	bd80      	pop	{r7, pc}
 8008d10:	20002b0c 	.word	0x20002b0c
 8008d14:	20002b08 	.word	0x20002b08

08008d18 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
 8008d18:	b580      	push	{r7, lr}
 8008d1a:	b082      	sub	sp, #8
 8008d1c:	af00      	add	r7, sp, #0
 8008d1e:	6078      	str	r0, [r7, #4]
    mib2_remove_route_ip4(1, netif);
  } else {
    /* install default route */
    mib2_add_route_ip4(1, netif);
  }
  netif_default = netif;
 8008d20:	4b03      	ldr	r3, [pc, #12]	; (8008d30 <netif_set_default+0x18>)
 8008d22:	687a      	ldr	r2, [r7, #4]
 8008d24:	601a      	str	r2, [r3, #0]
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
                            netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
 8008d26:	46c0      	nop			; (mov r8, r8)
 8008d28:	46bd      	mov	sp, r7
 8008d2a:	b002      	add	sp, #8
 8008d2c:	bd80      	pop	{r7, pc}
 8008d2e:	46c0      	nop			; (mov r8, r8)
 8008d30:	20002b0c 	.word	0x20002b0c

08008d34 <netif_issue_reports>:

/** Send ARP/IGMP/MLD/RS events, e.g. on link-up/netif-up or addr-change
 */
static void
netif_issue_reports(struct netif *netif, u8_t report_type)
{
 8008d34:	b580      	push	{r7, lr}
 8008d36:	b082      	sub	sp, #8
 8008d38:	af00      	add	r7, sp, #0
 8008d3a:	6078      	str	r0, [r7, #4]
 8008d3c:	000a      	movs	r2, r1
 8008d3e:	1cfb      	adds	r3, r7, #3
 8008d40:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT("netif_issue_reports: invalid netif", netif != NULL);
 8008d42:	687b      	ldr	r3, [r7, #4]
 8008d44:	2b00      	cmp	r3, #0
 8008d46:	d106      	bne.n	8008d56 <netif_issue_reports+0x22>
 8008d48:	4b0c      	ldr	r3, [pc, #48]	; (8008d7c <netif_issue_reports+0x48>)
 8008d4a:	22dc      	movs	r2, #220	; 0xdc
 8008d4c:	0092      	lsls	r2, r2, #2
 8008d4e:	490c      	ldr	r1, [pc, #48]	; (8008d80 <netif_issue_reports+0x4c>)
 8008d50:	480c      	ldr	r0, [pc, #48]	; (8008d84 <netif_issue_reports+0x50>)
 8008d52:	f7f9 fa3b 	bl	80021cc <app_debug_rtt_raw>

  /* Only send reports when both link and admin states are up */
  if (!(netif->flags & NETIF_FLAG_LINK_UP) ||
 8008d56:	687b      	ldr	r3, [r7, #4]
 8008d58:	2231      	movs	r2, #49	; 0x31
 8008d5a:	5c9b      	ldrb	r3, [r3, r2]
 8008d5c:	001a      	movs	r2, r3
 8008d5e:	2304      	movs	r3, #4
 8008d60:	4013      	ands	r3, r2
 8008d62:	d007      	beq.n	8008d74 <netif_issue_reports+0x40>
      !(netif->flags & NETIF_FLAG_UP)) {
 8008d64:	687b      	ldr	r3, [r7, #4]
 8008d66:	2231      	movs	r2, #49	; 0x31
 8008d68:	5c9b      	ldrb	r3, [r3, r2]
 8008d6a:	001a      	movs	r2, r3
 8008d6c:	2301      	movs	r3, #1
 8008d6e:	4013      	ands	r3, r2
  if (!(netif->flags & NETIF_FLAG_LINK_UP) ||
 8008d70:	d000      	beq.n	8008d74 <netif_issue_reports+0x40>
 8008d72:	e000      	b.n	8008d76 <netif_issue_reports+0x42>
    return;
 8008d74:	46c0      	nop			; (mov r8, r8)
    /* send mld memberships */
    mld6_report_groups(netif);
#endif /* LWIP_IPV6_MLD */
  }
#endif /* LWIP_IPV6 */
}
 8008d76:	46bd      	mov	sp, r7
 8008d78:	b002      	add	sp, #8
 8008d7a:	bd80      	pop	{r7, pc}
 8008d7c:	0801ea7c 	.word	0x0801ea7c
 8008d80:	0801ec18 	.word	0x0801ec18
 8008d84:	0801eac0 	.word	0x0801eac0

08008d88 <netif_set_down>:
 * @ingroup netif
 * Bring an interface down, disabling any traffic processing.
 */
void
netif_set_down(struct netif *netif)
{
 8008d88:	b580      	push	{r7, lr}
 8008d8a:	b082      	sub	sp, #8
 8008d8c:	af00      	add	r7, sp, #0
 8008d8e:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_down: invalid netif", netif != NULL, return);
 8008d90:	687b      	ldr	r3, [r7, #4]
 8008d92:	2b00      	cmp	r3, #0
 8008d94:	d104      	bne.n	8008da0 <netif_set_down+0x18>
 8008d96:	4b10      	ldr	r3, [pc, #64]	; (8008dd8 <netif_set_down+0x50>)
 8008d98:	0018      	movs	r0, r3
 8008d9a:	f7f9 fa17 	bl	80021cc <app_debug_rtt_raw>
 8008d9e:	e018      	b.n	8008dd2 <netif_set_down+0x4a>

  if (netif->flags & NETIF_FLAG_UP) {
 8008da0:	687b      	ldr	r3, [r7, #4]
 8008da2:	2231      	movs	r2, #49	; 0x31
 8008da4:	5c9b      	ldrb	r3, [r3, r2]
 8008da6:	001a      	movs	r2, r3
 8008da8:	2301      	movs	r3, #1
 8008daa:	4013      	ands	r3, r2
 8008dac:	d011      	beq.n	8008dd2 <netif_set_down+0x4a>
      args.status_changed.state = 0;
      netif_invoke_ext_callback(netif, LWIP_NSC_STATUS_CHANGED, &args);
    }
#endif

    netif_clear_flags(netif, NETIF_FLAG_UP);
 8008dae:	687b      	ldr	r3, [r7, #4]
 8008db0:	2231      	movs	r2, #49	; 0x31
 8008db2:	5c9b      	ldrb	r3, [r3, r2]
 8008db4:	2201      	movs	r2, #1
 8008db6:	4393      	bics	r3, r2
 8008db8:	b2d9      	uxtb	r1, r3
 8008dba:	687b      	ldr	r3, [r7, #4]
 8008dbc:	2231      	movs	r2, #49	; 0x31
 8008dbe:	5499      	strb	r1, [r3, r2]

#if LWIP_IPV6
    nd6_cleanup_netif(netif);
#endif /* LWIP_IPV6 */

    NETIF_STATUS_CALLBACK(netif);
 8008dc0:	687b      	ldr	r3, [r7, #4]
 8008dc2:	69db      	ldr	r3, [r3, #28]
 8008dc4:	2b00      	cmp	r3, #0
 8008dc6:	d004      	beq.n	8008dd2 <netif_set_down+0x4a>
 8008dc8:	687b      	ldr	r3, [r7, #4]
 8008dca:	69db      	ldr	r3, [r3, #28]
 8008dcc:	687a      	ldr	r2, [r7, #4]
 8008dce:	0010      	movs	r0, r2
 8008dd0:	4798      	blx	r3
  }
}
 8008dd2:	46bd      	mov	sp, r7
 8008dd4:	b002      	add	sp, #8
 8008dd6:	bd80      	pop	{r7, pc}
 8008dd8:	0801ec3c 	.word	0x0801ec3c

08008ddc <netif_set_link_up>:
 * @ingroup netif
 * Called by a driver when its link goes up
 */
void
netif_set_link_up(struct netif *netif)
{
 8008ddc:	b580      	push	{r7, lr}
 8008dde:	b082      	sub	sp, #8
 8008de0:	af00      	add	r7, sp, #0
 8008de2:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_link_up: invalid netif", netif != NULL, return);
 8008de4:	687b      	ldr	r3, [r7, #4]
 8008de6:	2b00      	cmp	r3, #0
 8008de8:	d104      	bne.n	8008df4 <netif_set_link_up+0x18>
 8008dea:	4b13      	ldr	r3, [pc, #76]	; (8008e38 <netif_set_link_up+0x5c>)
 8008dec:	0018      	movs	r0, r3
 8008dee:	f7f9 f9ed 	bl	80021cc <app_debug_rtt_raw>
 8008df2:	e01d      	b.n	8008e30 <netif_set_link_up+0x54>

  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
 8008df4:	687b      	ldr	r3, [r7, #4]
 8008df6:	2231      	movs	r2, #49	; 0x31
 8008df8:	5c9b      	ldrb	r3, [r3, r2]
 8008dfa:	001a      	movs	r2, r3
 8008dfc:	2304      	movs	r3, #4
 8008dfe:	4013      	ands	r3, r2
 8008e00:	d116      	bne.n	8008e30 <netif_set_link_up+0x54>
    netif_set_flags(netif, NETIF_FLAG_LINK_UP);
 8008e02:	687b      	ldr	r3, [r7, #4]
 8008e04:	2231      	movs	r2, #49	; 0x31
 8008e06:	5c9b      	ldrb	r3, [r3, r2]
 8008e08:	2204      	movs	r2, #4
 8008e0a:	4313      	orrs	r3, r2
 8008e0c:	b2d9      	uxtb	r1, r3
 8008e0e:	687b      	ldr	r3, [r7, #4]
 8008e10:	2231      	movs	r2, #49	; 0x31
 8008e12:	5499      	strb	r1, [r3, r2]

#if LWIP_AUTOIP
    autoip_network_changed(netif);
#endif /* LWIP_AUTOIP */

    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4 | NETIF_REPORT_TYPE_IPV6);
 8008e14:	687b      	ldr	r3, [r7, #4]
 8008e16:	2103      	movs	r1, #3
 8008e18:	0018      	movs	r0, r3
 8008e1a:	f7ff ff8b 	bl	8008d34 <netif_issue_reports>
#if LWIP_IPV6
    nd6_restart_netif(netif);
#endif /* LWIP_IPV6 */

    NETIF_LINK_CALLBACK(netif);
 8008e1e:	687b      	ldr	r3, [r7, #4]
 8008e20:	6a1b      	ldr	r3, [r3, #32]
 8008e22:	2b00      	cmp	r3, #0
 8008e24:	d004      	beq.n	8008e30 <netif_set_link_up+0x54>
 8008e26:	687b      	ldr	r3, [r7, #4]
 8008e28:	6a1b      	ldr	r3, [r3, #32]
 8008e2a:	687a      	ldr	r2, [r7, #4]
 8008e2c:	0010      	movs	r0, r2
 8008e2e:	4798      	blx	r3
      args.link_changed.state = 1;
      netif_invoke_ext_callback(netif, LWIP_NSC_LINK_CHANGED, &args);
    }
#endif
  }
}
 8008e30:	46bd      	mov	sp, r7
 8008e32:	b002      	add	sp, #8
 8008e34:	bd80      	pop	{r7, pc}
 8008e36:	46c0      	nop			; (mov r8, r8)
 8008e38:	0801ec5c 	.word	0x0801ec5c

08008e3c <netif_set_link_down>:
 * @ingroup netif
 * Called by a driver when its link goes down
 */
void
netif_set_link_down(struct netif *netif)
{
 8008e3c:	b580      	push	{r7, lr}
 8008e3e:	b082      	sub	sp, #8
 8008e40:	af00      	add	r7, sp, #0
 8008e42:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_link_down: invalid netif", netif != NULL, return);
 8008e44:	687b      	ldr	r3, [r7, #4]
 8008e46:	2b00      	cmp	r3, #0
 8008e48:	d104      	bne.n	8008e54 <netif_set_link_down+0x18>
 8008e4a:	4b10      	ldr	r3, [pc, #64]	; (8008e8c <netif_set_link_down+0x50>)
 8008e4c:	0018      	movs	r0, r3
 8008e4e:	f7f9 f9bd 	bl	80021cc <app_debug_rtt_raw>
 8008e52:	e018      	b.n	8008e86 <netif_set_link_down+0x4a>

  if (netif->flags & NETIF_FLAG_LINK_UP) {
 8008e54:	687b      	ldr	r3, [r7, #4]
 8008e56:	2231      	movs	r2, #49	; 0x31
 8008e58:	5c9b      	ldrb	r3, [r3, r2]
 8008e5a:	001a      	movs	r2, r3
 8008e5c:	2304      	movs	r3, #4
 8008e5e:	4013      	ands	r3, r2
 8008e60:	d011      	beq.n	8008e86 <netif_set_link_down+0x4a>
    netif_clear_flags(netif, NETIF_FLAG_LINK_UP);
 8008e62:	687b      	ldr	r3, [r7, #4]
 8008e64:	2231      	movs	r2, #49	; 0x31
 8008e66:	5c9b      	ldrb	r3, [r3, r2]
 8008e68:	2204      	movs	r2, #4
 8008e6a:	4393      	bics	r3, r2
 8008e6c:	b2d9      	uxtb	r1, r3
 8008e6e:	687b      	ldr	r3, [r7, #4]
 8008e70:	2231      	movs	r2, #49	; 0x31
 8008e72:	5499      	strb	r1, [r3, r2]
#if LWIP_IPV6 && LWIP_ND6_ALLOW_RA_UPDATES
    netif->mtu6 = netif->mtu;
#endif

    NETIF_LINK_CALLBACK(netif);
 8008e74:	687b      	ldr	r3, [r7, #4]
 8008e76:	6a1b      	ldr	r3, [r3, #32]
 8008e78:	2b00      	cmp	r3, #0
 8008e7a:	d004      	beq.n	8008e86 <netif_set_link_down+0x4a>
 8008e7c:	687b      	ldr	r3, [r7, #4]
 8008e7e:	6a1b      	ldr	r3, [r3, #32]
 8008e80:	687a      	ldr	r2, [r7, #4]
 8008e82:	0010      	movs	r0, r2
 8008e84:	4798      	blx	r3
      args.link_changed.state = 0;
      netif_invoke_ext_callback(netif, LWIP_NSC_LINK_CHANGED, &args);
    }
#endif
  }
}
 8008e86:	46bd      	mov	sp, r7
 8008e88:	b002      	add	sp, #8
 8008e8a:	bd80      	pop	{r7, pc}
 8008e8c:	0801ec80 	.word	0x0801ec80

08008e90 <netif_null_output_ip4>:
#if LWIP_IPV4
/** Dummy IPv4 output function for netifs not supporting IPv4
 */
static err_t
netif_null_output_ip4(struct netif *netif, struct pbuf *p, const ip4_addr_t *ipaddr)
{
 8008e90:	b580      	push	{r7, lr}
 8008e92:	b084      	sub	sp, #16
 8008e94:	af00      	add	r7, sp, #0
 8008e96:	60f8      	str	r0, [r7, #12]
 8008e98:	60b9      	str	r1, [r7, #8]
 8008e9a:	607a      	str	r2, [r7, #4]
  LWIP_UNUSED_ARG(netif);
  LWIP_UNUSED_ARG(p);
  LWIP_UNUSED_ARG(ipaddr);

  return ERR_IF;
 8008e9c:	230c      	movs	r3, #12
 8008e9e:	425b      	negs	r3, r3
}
 8008ea0:	0018      	movs	r0, r3
 8008ea2:	46bd      	mov	sp, r7
 8008ea4:	b004      	add	sp, #16
 8008ea6:	bd80      	pop	{r7, pc}

08008ea8 <netif_get_by_index>:
*
* @param idx index of netif to find
*/
struct netif *
netif_get_by_index(u8_t idx)
{
 8008ea8:	b580      	push	{r7, lr}
 8008eaa:	b084      	sub	sp, #16
 8008eac:	af00      	add	r7, sp, #0
 8008eae:	0002      	movs	r2, r0
 8008eb0:	1dfb      	adds	r3, r7, #7
 8008eb2:	701a      	strb	r2, [r3, #0]
  struct netif *netif;

  LWIP_ASSERT_CORE_LOCKED();

  if (idx != NETIF_NO_INDEX) {
 8008eb4:	1dfb      	adds	r3, r7, #7
 8008eb6:	781b      	ldrb	r3, [r3, #0]
 8008eb8:	2b00      	cmp	r3, #0
 8008eba:	d014      	beq.n	8008ee6 <netif_get_by_index+0x3e>
    NETIF_FOREACH(netif) {
 8008ebc:	4b0c      	ldr	r3, [pc, #48]	; (8008ef0 <netif_get_by_index+0x48>)
 8008ebe:	681b      	ldr	r3, [r3, #0]
 8008ec0:	60fb      	str	r3, [r7, #12]
 8008ec2:	e00d      	b.n	8008ee0 <netif_get_by_index+0x38>
      if (idx == netif_get_index(netif)) {
 8008ec4:	68fb      	ldr	r3, [r7, #12]
 8008ec6:	2234      	movs	r2, #52	; 0x34
 8008ec8:	5c9b      	ldrb	r3, [r3, r2]
 8008eca:	3301      	adds	r3, #1
 8008ecc:	b2db      	uxtb	r3, r3
 8008ece:	1dfa      	adds	r2, r7, #7
 8008ed0:	7812      	ldrb	r2, [r2, #0]
 8008ed2:	429a      	cmp	r2, r3
 8008ed4:	d101      	bne.n	8008eda <netif_get_by_index+0x32>
        return netif; /* found! */
 8008ed6:	68fb      	ldr	r3, [r7, #12]
 8008ed8:	e006      	b.n	8008ee8 <netif_get_by_index+0x40>
    NETIF_FOREACH(netif) {
 8008eda:	68fb      	ldr	r3, [r7, #12]
 8008edc:	681b      	ldr	r3, [r3, #0]
 8008ede:	60fb      	str	r3, [r7, #12]
 8008ee0:	68fb      	ldr	r3, [r7, #12]
 8008ee2:	2b00      	cmp	r3, #0
 8008ee4:	d1ee      	bne.n	8008ec4 <netif_get_by_index+0x1c>
      }
    }
  }

  return NULL;
 8008ee6:	2300      	movs	r3, #0
}
 8008ee8:	0018      	movs	r0, r3
 8008eea:	46bd      	mov	sp, r7
 8008eec:	b004      	add	sp, #16
 8008eee:	bd80      	pop	{r7, pc}
 8008ef0:	20002b08 	.word	0x20002b08

08008ef4 <pbuf_free_ooseq>:
#if !NO_SYS
static
#endif /* !NO_SYS */
void
pbuf_free_ooseq(void)
{
 8008ef4:	b580      	push	{r7, lr}
 8008ef6:	b082      	sub	sp, #8
 8008ef8:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb;
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 0);
 8008efa:	4b0c      	ldr	r3, [pc, #48]	; (8008f2c <pbuf_free_ooseq+0x38>)
 8008efc:	2200      	movs	r2, #0
 8008efe:	701a      	strb	r2, [r3, #0]

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 8008f00:	4b0b      	ldr	r3, [pc, #44]	; (8008f30 <pbuf_free_ooseq+0x3c>)
 8008f02:	681b      	ldr	r3, [r3, #0]
 8008f04:	607b      	str	r3, [r7, #4]
 8008f06:	e00b      	b.n	8008f20 <pbuf_free_ooseq+0x2c>
    if (pcb->ooseq != NULL) {
 8008f08:	687b      	ldr	r3, [r7, #4]
 8008f0a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8008f0c:	2b00      	cmp	r3, #0
 8008f0e:	d004      	beq.n	8008f1a <pbuf_free_ooseq+0x26>
      /** Free the ooseq pbufs of one PCB only */
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
      tcp_free_ooseq(pcb);
 8008f10:	687b      	ldr	r3, [r7, #4]
 8008f12:	0018      	movs	r0, r3
 8008f14:	f003 f8d8 	bl	800c0c8 <tcp_free_ooseq>
      return;
 8008f18:	e005      	b.n	8008f26 <pbuf_free_ooseq+0x32>
  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 8008f1a:	687b      	ldr	r3, [r7, #4]
 8008f1c:	691b      	ldr	r3, [r3, #16]
 8008f1e:	607b      	str	r3, [r7, #4]
 8008f20:	687b      	ldr	r3, [r7, #4]
 8008f22:	2b00      	cmp	r3, #0
 8008f24:	d1f0      	bne.n	8008f08 <pbuf_free_ooseq+0x14>
    }
  }
}
 8008f26:	46bd      	mov	sp, r7
 8008f28:	b002      	add	sp, #8
 8008f2a:	bd80      	pop	{r7, pc}
 8008f2c:	20002b10 	.word	0x20002b10
 8008f30:	20002b18 	.word	0x20002b18

08008f34 <pbuf_pool_is_empty>:
#endif /* !NO_SYS */

/** Queue a call to pbuf_free_ooseq if not already queued. */
static void
pbuf_pool_is_empty(void)
{
 8008f34:	b580      	push	{r7, lr}
 8008f36:	af00      	add	r7, sp, #0
#ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 1);
 8008f38:	4b02      	ldr	r3, [pc, #8]	; (8008f44 <pbuf_pool_is_empty+0x10>)
 8008f3a:	2201      	movs	r2, #1
 8008f3c:	701a      	strb	r2, [r3, #0]
  if (!queued) {
    /* queue a call to pbuf_free_ooseq if not already queued */
    PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
  }
#endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
}
 8008f3e:	46c0      	nop			; (mov r8, r8)
 8008f40:	46bd      	mov	sp, r7
 8008f42:	bd80      	pop	{r7, pc}
 8008f44:	20002b10 	.word	0x20002b10

08008f48 <pbuf_init_alloced_pbuf>:
#endif /* !LWIP_TCP || !TCP_QUEUE_OOSEQ || !PBUF_POOL_FREE_OOSEQ */

/* Initialize members of struct pbuf after allocation */
static void
pbuf_init_alloced_pbuf(struct pbuf *p, void *payload, u16_t tot_len, u16_t len, pbuf_type type, u8_t flags)
{
 8008f48:	b580      	push	{r7, lr}
 8008f4a:	b084      	sub	sp, #16
 8008f4c:	af00      	add	r7, sp, #0
 8008f4e:	60f8      	str	r0, [r7, #12]
 8008f50:	60b9      	str	r1, [r7, #8]
 8008f52:	0019      	movs	r1, r3
 8008f54:	1dbb      	adds	r3, r7, #6
 8008f56:	801a      	strh	r2, [r3, #0]
 8008f58:	1d3b      	adds	r3, r7, #4
 8008f5a:	1c0a      	adds	r2, r1, #0
 8008f5c:	801a      	strh	r2, [r3, #0]
  p->next = NULL;
 8008f5e:	68fb      	ldr	r3, [r7, #12]
 8008f60:	2200      	movs	r2, #0
 8008f62:	601a      	str	r2, [r3, #0]
  p->payload = payload;
 8008f64:	68fb      	ldr	r3, [r7, #12]
 8008f66:	68ba      	ldr	r2, [r7, #8]
 8008f68:	605a      	str	r2, [r3, #4]
  p->tot_len = tot_len;
 8008f6a:	68fb      	ldr	r3, [r7, #12]
 8008f6c:	1dba      	adds	r2, r7, #6
 8008f6e:	8812      	ldrh	r2, [r2, #0]
 8008f70:	811a      	strh	r2, [r3, #8]
  p->len = len;
 8008f72:	68fb      	ldr	r3, [r7, #12]
 8008f74:	1d3a      	adds	r2, r7, #4
 8008f76:	8812      	ldrh	r2, [r2, #0]
 8008f78:	815a      	strh	r2, [r3, #10]
  p->type_internal = (u8_t)type;
 8008f7a:	2318      	movs	r3, #24
 8008f7c:	18fb      	adds	r3, r7, r3
 8008f7e:	881b      	ldrh	r3, [r3, #0]
 8008f80:	b2da      	uxtb	r2, r3
 8008f82:	68fb      	ldr	r3, [r7, #12]
 8008f84:	731a      	strb	r2, [r3, #12]
  p->flags = flags;
 8008f86:	68fb      	ldr	r3, [r7, #12]
 8008f88:	221c      	movs	r2, #28
 8008f8a:	18ba      	adds	r2, r7, r2
 8008f8c:	7812      	ldrb	r2, [r2, #0]
 8008f8e:	735a      	strb	r2, [r3, #13]
  p->ref = 1;
 8008f90:	68fb      	ldr	r3, [r7, #12]
 8008f92:	2201      	movs	r2, #1
 8008f94:	739a      	strb	r2, [r3, #14]
  p->if_idx = NETIF_NO_INDEX;
 8008f96:	68fb      	ldr	r3, [r7, #12]
 8008f98:	2200      	movs	r2, #0
 8008f9a:	73da      	strb	r2, [r3, #15]
}
 8008f9c:	46c0      	nop			; (mov r8, r8)
 8008f9e:	46bd      	mov	sp, r7
 8008fa0:	b004      	add	sp, #16
 8008fa2:	bd80      	pop	{r7, pc}

08008fa4 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
 8008fa4:	b590      	push	{r4, r7, lr}
 8008fa6:	b08d      	sub	sp, #52	; 0x34
 8008fa8:	af02      	add	r7, sp, #8
 8008faa:	0004      	movs	r4, r0
 8008fac:	0008      	movs	r0, r1
 8008fae:	0011      	movs	r1, r2
 8008fb0:	1dfb      	adds	r3, r7, #7
 8008fb2:	1c22      	adds	r2, r4, #0
 8008fb4:	701a      	strb	r2, [r3, #0]
 8008fb6:	1d3b      	adds	r3, r7, #4
 8008fb8:	1c02      	adds	r2, r0, #0
 8008fba:	801a      	strh	r2, [r3, #0]
 8008fbc:	1cbb      	adds	r3, r7, #2
 8008fbe:	1c0a      	adds	r2, r1, #0
 8008fc0:	801a      	strh	r2, [r3, #0]
  struct pbuf *p;
  u16_t offset = (u16_t)layer;
 8008fc2:	2322      	movs	r3, #34	; 0x22
 8008fc4:	18fb      	adds	r3, r7, r3
 8008fc6:	1dfa      	adds	r2, r7, #7
 8008fc8:	7812      	ldrb	r2, [r2, #0]
 8008fca:	801a      	strh	r2, [r3, #0]
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  switch (type) {
 8008fcc:	1cbb      	adds	r3, r7, #2
 8008fce:	881b      	ldrh	r3, [r3, #0]
 8008fd0:	22a0      	movs	r2, #160	; 0xa0
 8008fd2:	0092      	lsls	r2, r2, #2
 8008fd4:	4293      	cmp	r3, r2
 8008fd6:	d100      	bne.n	8008fda <pbuf_alloc+0x36>
 8008fd8:	e0a8      	b.n	800912c <pbuf_alloc+0x188>
 8008fda:	22a0      	movs	r2, #160	; 0xa0
 8008fdc:	0092      	lsls	r2, r2, #2
 8008fde:	4293      	cmp	r3, r2
 8008fe0:	dd00      	ble.n	8008fe4 <pbuf_alloc+0x40>
 8008fe2:	e103      	b.n	80091ec <pbuf_alloc+0x248>
 8008fe4:	22c1      	movs	r2, #193	; 0xc1
 8008fe6:	0052      	lsls	r2, r2, #1
 8008fe8:	4293      	cmp	r3, r2
 8008fea:	d014      	beq.n	8009016 <pbuf_alloc+0x72>
 8008fec:	22c1      	movs	r2, #193	; 0xc1
 8008fee:	0052      	lsls	r2, r2, #1
 8008ff0:	4293      	cmp	r3, r2
 8008ff2:	dd00      	ble.n	8008ff6 <pbuf_alloc+0x52>
 8008ff4:	e0fa      	b.n	80091ec <pbuf_alloc+0x248>
 8008ff6:	2b01      	cmp	r3, #1
 8008ff8:	d002      	beq.n	8009000 <pbuf_alloc+0x5c>
 8008ffa:	2b41      	cmp	r3, #65	; 0x41
 8008ffc:	d000      	beq.n	8009000 <pbuf_alloc+0x5c>
 8008ffe:	e0f5      	b.n	80091ec <pbuf_alloc+0x248>
    case PBUF_REF: /* fall through */
    case PBUF_ROM:
      p = pbuf_alloc_reference(NULL, length, type);
 8009000:	1cbb      	adds	r3, r7, #2
 8009002:	881a      	ldrh	r2, [r3, #0]
 8009004:	1d3b      	adds	r3, r7, #4
 8009006:	881b      	ldrh	r3, [r3, #0]
 8009008:	0019      	movs	r1, r3
 800900a:	2000      	movs	r0, #0
 800900c:	f000 f90a 	bl	8009224 <pbuf_alloc_reference>
 8009010:	0003      	movs	r3, r0
 8009012:	627b      	str	r3, [r7, #36]	; 0x24
      break;
 8009014:	e0f4      	b.n	8009200 <pbuf_alloc+0x25c>
    case PBUF_POOL: {
      struct pbuf *q, *last;
      u16_t rem_len; /* remaining length */
      p = NULL;
 8009016:	2300      	movs	r3, #0
 8009018:	627b      	str	r3, [r7, #36]	; 0x24
      last = NULL;
 800901a:	2300      	movs	r3, #0
 800901c:	61fb      	str	r3, [r7, #28]
      rem_len = length;
 800901e:	231a      	movs	r3, #26
 8009020:	18fb      	adds	r3, r7, r3
 8009022:	1d3a      	adds	r2, r7, #4
 8009024:	8812      	ldrh	r2, [r2, #0]
 8009026:	801a      	strh	r2, [r3, #0]
      do {
        u16_t qlen;
        q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 8009028:	2006      	movs	r0, #6
 800902a:	f7ff fbcd 	bl	80087c8 <memp_malloc>
 800902e:	0003      	movs	r3, r0
 8009030:	613b      	str	r3, [r7, #16]
        if (q == NULL) {
 8009032:	693b      	ldr	r3, [r7, #16]
 8009034:	2b00      	cmp	r3, #0
 8009036:	d10a      	bne.n	800904e <pbuf_alloc+0xaa>
          PBUF_POOL_IS_EMPTY();
 8009038:	f7ff ff7c 	bl	8008f34 <pbuf_pool_is_empty>
          /* free chain so far allocated */
          if (p) {
 800903c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800903e:	2b00      	cmp	r3, #0
 8009040:	d003      	beq.n	800904a <pbuf_alloc+0xa6>
            pbuf_free(p);
 8009042:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009044:	0018      	movs	r0, r3
 8009046:	f000 fb25 	bl	8009694 <pbuf_free>
          }
          /* bail out unsuccessfully */
          return NULL;
 800904a:	2300      	movs	r3, #0
 800904c:	e0d9      	b.n	8009202 <pbuf_alloc+0x25e>
        }
        qlen = LWIP_MIN(rem_len, (u16_t)(PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)));
 800904e:	2322      	movs	r3, #34	; 0x22
 8009050:	18fb      	adds	r3, r7, r3
 8009052:	881b      	ldrh	r3, [r3, #0]
 8009054:	3303      	adds	r3, #3
 8009056:	b29b      	uxth	r3, r3
 8009058:	2203      	movs	r2, #3
 800905a:	4393      	bics	r3, r2
 800905c:	b29b      	uxth	r3, r3
 800905e:	2294      	movs	r2, #148	; 0x94
 8009060:	0092      	lsls	r2, r2, #2
 8009062:	1ad3      	subs	r3, r2, r3
 8009064:	b299      	uxth	r1, r3
 8009066:	230e      	movs	r3, #14
 8009068:	18fa      	adds	r2, r7, r3
 800906a:	231a      	movs	r3, #26
 800906c:	18fb      	adds	r3, r7, r3
 800906e:	1c0c      	adds	r4, r1, #0
 8009070:	881b      	ldrh	r3, [r3, #0]
 8009072:	b298      	uxth	r0, r3
 8009074:	b2a1      	uxth	r1, r4
 8009076:	4288      	cmp	r0, r1
 8009078:	d900      	bls.n	800907c <pbuf_alloc+0xd8>
 800907a:	1c23      	adds	r3, r4, #0
 800907c:	8013      	strh	r3, [r2, #0]
        pbuf_init_alloced_pbuf(q, LWIP_MEM_ALIGN((void *)((u8_t *)q + SIZEOF_STRUCT_PBUF + offset)),
 800907e:	2322      	movs	r3, #34	; 0x22
 8009080:	18fb      	adds	r3, r7, r3
 8009082:	881b      	ldrh	r3, [r3, #0]
 8009084:	3310      	adds	r3, #16
 8009086:	693a      	ldr	r2, [r7, #16]
 8009088:	18d3      	adds	r3, r2, r3
 800908a:	3303      	adds	r3, #3
 800908c:	2203      	movs	r2, #3
 800908e:	4393      	bics	r3, r2
 8009090:	001c      	movs	r4, r3
 8009092:	230e      	movs	r3, #14
 8009094:	18fb      	adds	r3, r7, r3
 8009096:	8819      	ldrh	r1, [r3, #0]
 8009098:	231a      	movs	r3, #26
 800909a:	18fb      	adds	r3, r7, r3
 800909c:	881a      	ldrh	r2, [r3, #0]
 800909e:	6938      	ldr	r0, [r7, #16]
 80090a0:	2300      	movs	r3, #0
 80090a2:	9301      	str	r3, [sp, #4]
 80090a4:	1cbb      	adds	r3, r7, #2
 80090a6:	881b      	ldrh	r3, [r3, #0]
 80090a8:	9300      	str	r3, [sp, #0]
 80090aa:	000b      	movs	r3, r1
 80090ac:	0021      	movs	r1, r4
 80090ae:	f7ff ff4b 	bl	8008f48 <pbuf_init_alloced_pbuf>
                               rem_len, qlen, type, 0);
        LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
 80090b2:	693b      	ldr	r3, [r7, #16]
 80090b4:	685b      	ldr	r3, [r3, #4]
 80090b6:	001a      	movs	r2, r3
 80090b8:	2303      	movs	r3, #3
 80090ba:	4013      	ands	r3, r2
 80090bc:	d006      	beq.n	80090cc <pbuf_alloc+0x128>
 80090be:	4b53      	ldr	r3, [pc, #332]	; (800920c <pbuf_alloc+0x268>)
 80090c0:	2280      	movs	r2, #128	; 0x80
 80090c2:	0052      	lsls	r2, r2, #1
 80090c4:	4952      	ldr	r1, [pc, #328]	; (8009210 <pbuf_alloc+0x26c>)
 80090c6:	4853      	ldr	r0, [pc, #332]	; (8009214 <pbuf_alloc+0x270>)
 80090c8:	f7f9 f880 	bl	80021cc <app_debug_rtt_raw>
                    ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
        LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
 80090cc:	2322      	movs	r3, #34	; 0x22
 80090ce:	18fb      	adds	r3, r7, r3
 80090d0:	881b      	ldrh	r3, [r3, #0]
 80090d2:	3303      	adds	r3, #3
 80090d4:	2203      	movs	r2, #3
 80090d6:	4393      	bics	r3, r2
 80090d8:	001a      	movs	r2, r3
 80090da:	2394      	movs	r3, #148	; 0x94
 80090dc:	009b      	lsls	r3, r3, #2
 80090de:	429a      	cmp	r2, r3
 80090e0:	d106      	bne.n	80090f0 <pbuf_alloc+0x14c>
 80090e2:	4b4a      	ldr	r3, [pc, #296]	; (800920c <pbuf_alloc+0x268>)
 80090e4:	2281      	movs	r2, #129	; 0x81
 80090e6:	0052      	lsls	r2, r2, #1
 80090e8:	494b      	ldr	r1, [pc, #300]	; (8009218 <pbuf_alloc+0x274>)
 80090ea:	484a      	ldr	r0, [pc, #296]	; (8009214 <pbuf_alloc+0x270>)
 80090ec:	f7f9 f86e 	bl	80021cc <app_debug_rtt_raw>
                    (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
        if (p == NULL) {
 80090f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80090f2:	2b00      	cmp	r3, #0
 80090f4:	d102      	bne.n	80090fc <pbuf_alloc+0x158>
          /* allocated head of pbuf chain (into p) */
          p = q;
 80090f6:	693b      	ldr	r3, [r7, #16]
 80090f8:	627b      	str	r3, [r7, #36]	; 0x24
 80090fa:	e002      	b.n	8009102 <pbuf_alloc+0x15e>
        } else {
          /* make previous pbuf point to this pbuf */
          last->next = q;
 80090fc:	69fb      	ldr	r3, [r7, #28]
 80090fe:	693a      	ldr	r2, [r7, #16]
 8009100:	601a      	str	r2, [r3, #0]
        }
        last = q;
 8009102:	693b      	ldr	r3, [r7, #16]
 8009104:	61fb      	str	r3, [r7, #28]
        rem_len = (u16_t)(rem_len - qlen);
 8009106:	201a      	movs	r0, #26
 8009108:	183b      	adds	r3, r7, r0
 800910a:	1839      	adds	r1, r7, r0
 800910c:	220e      	movs	r2, #14
 800910e:	18ba      	adds	r2, r7, r2
 8009110:	8809      	ldrh	r1, [r1, #0]
 8009112:	8812      	ldrh	r2, [r2, #0]
 8009114:	1a8a      	subs	r2, r1, r2
 8009116:	801a      	strh	r2, [r3, #0]
        offset = 0;
 8009118:	2322      	movs	r3, #34	; 0x22
 800911a:	18fb      	adds	r3, r7, r3
 800911c:	2200      	movs	r2, #0
 800911e:	801a      	strh	r2, [r3, #0]
      } while (rem_len > 0);
 8009120:	183b      	adds	r3, r7, r0
 8009122:	881b      	ldrh	r3, [r3, #0]
 8009124:	2b00      	cmp	r3, #0
 8009126:	d000      	beq.n	800912a <pbuf_alloc+0x186>
 8009128:	e77e      	b.n	8009028 <pbuf_alloc+0x84>
      break;
 800912a:	e069      	b.n	8009200 <pbuf_alloc+0x25c>
    }
    case PBUF_RAM: {
      mem_size_t payload_len = (mem_size_t)(LWIP_MEM_ALIGN_SIZE(offset) + LWIP_MEM_ALIGN_SIZE(length));
 800912c:	2322      	movs	r3, #34	; 0x22
 800912e:	18fb      	adds	r3, r7, r3
 8009130:	881b      	ldrh	r3, [r3, #0]
 8009132:	3303      	adds	r3, #3
 8009134:	b29b      	uxth	r3, r3
 8009136:	2203      	movs	r2, #3
 8009138:	4393      	bics	r3, r2
 800913a:	b299      	uxth	r1, r3
 800913c:	1d3b      	adds	r3, r7, #4
 800913e:	881b      	ldrh	r3, [r3, #0]
 8009140:	3303      	adds	r3, #3
 8009142:	b29b      	uxth	r3, r3
 8009144:	2203      	movs	r2, #3
 8009146:	4393      	bics	r3, r2
 8009148:	b29a      	uxth	r2, r3
 800914a:	2018      	movs	r0, #24
 800914c:	183b      	adds	r3, r7, r0
 800914e:	188a      	adds	r2, r1, r2
 8009150:	801a      	strh	r2, [r3, #0]
      mem_size_t alloc_len = (mem_size_t)(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF) + payload_len);
 8009152:	2416      	movs	r4, #22
 8009154:	193b      	adds	r3, r7, r4
 8009156:	183a      	adds	r2, r7, r0
 8009158:	8812      	ldrh	r2, [r2, #0]
 800915a:	3210      	adds	r2, #16
 800915c:	801a      	strh	r2, [r3, #0]

      /* bug #50040: Check for integer overflow when calculating alloc_len */
      if ((payload_len < LWIP_MEM_ALIGN_SIZE(length)) ||
 800915e:	183b      	adds	r3, r7, r0
 8009160:	881a      	ldrh	r2, [r3, #0]
 8009162:	1d3b      	adds	r3, r7, #4
 8009164:	881b      	ldrh	r3, [r3, #0]
 8009166:	3303      	adds	r3, #3
 8009168:	2103      	movs	r1, #3
 800916a:	438b      	bics	r3, r1
 800916c:	429a      	cmp	r2, r3
 800916e:	d308      	bcc.n	8009182 <pbuf_alloc+0x1de>
          (alloc_len < LWIP_MEM_ALIGN_SIZE(length))) {
 8009170:	193b      	adds	r3, r7, r4
 8009172:	881a      	ldrh	r2, [r3, #0]
 8009174:	1d3b      	adds	r3, r7, #4
 8009176:	881b      	ldrh	r3, [r3, #0]
 8009178:	3303      	adds	r3, #3
 800917a:	2103      	movs	r1, #3
 800917c:	438b      	bics	r3, r1
      if ((payload_len < LWIP_MEM_ALIGN_SIZE(length)) ||
 800917e:	429a      	cmp	r2, r3
 8009180:	d201      	bcs.n	8009186 <pbuf_alloc+0x1e2>
        return NULL;
 8009182:	2300      	movs	r3, #0
 8009184:	e03d      	b.n	8009202 <pbuf_alloc+0x25e>
      }

      /* If pbuf is to be allocated in RAM, allocate memory for it. */
      p = (struct pbuf *)mem_malloc(alloc_len);
 8009186:	2316      	movs	r3, #22
 8009188:	18fb      	adds	r3, r7, r3
 800918a:	881b      	ldrh	r3, [r3, #0]
 800918c:	0018      	movs	r0, r3
 800918e:	f7ff f955 	bl	800843c <mem_malloc>
 8009192:	0003      	movs	r3, r0
 8009194:	627b      	str	r3, [r7, #36]	; 0x24
      if (p == NULL) {
 8009196:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009198:	2b00      	cmp	r3, #0
 800919a:	d101      	bne.n	80091a0 <pbuf_alloc+0x1fc>
        return NULL;
 800919c:	2300      	movs	r3, #0
 800919e:	e030      	b.n	8009202 <pbuf_alloc+0x25e>
      }
      pbuf_init_alloced_pbuf(p, LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset)),
 80091a0:	2322      	movs	r3, #34	; 0x22
 80091a2:	18fb      	adds	r3, r7, r3
 80091a4:	881b      	ldrh	r3, [r3, #0]
 80091a6:	3310      	adds	r3, #16
 80091a8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80091aa:	18d3      	adds	r3, r2, r3
 80091ac:	3303      	adds	r3, #3
 80091ae:	2203      	movs	r2, #3
 80091b0:	4393      	bics	r3, r2
 80091b2:	001c      	movs	r4, r3
 80091b4:	1d3b      	adds	r3, r7, #4
 80091b6:	8819      	ldrh	r1, [r3, #0]
 80091b8:	1d3b      	adds	r3, r7, #4
 80091ba:	881a      	ldrh	r2, [r3, #0]
 80091bc:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80091be:	2300      	movs	r3, #0
 80091c0:	9301      	str	r3, [sp, #4]
 80091c2:	1cbb      	adds	r3, r7, #2
 80091c4:	881b      	ldrh	r3, [r3, #0]
 80091c6:	9300      	str	r3, [sp, #0]
 80091c8:	000b      	movs	r3, r1
 80091ca:	0021      	movs	r1, r4
 80091cc:	f7ff febc 	bl	8008f48 <pbuf_init_alloced_pbuf>
                             length, length, type, 0);
      LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
 80091d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80091d2:	685b      	ldr	r3, [r3, #4]
 80091d4:	001a      	movs	r2, r3
 80091d6:	2303      	movs	r3, #3
 80091d8:	4013      	ands	r3, r2
 80091da:	d010      	beq.n	80091fe <pbuf_alloc+0x25a>
 80091dc:	4b0b      	ldr	r3, [pc, #44]	; (800920c <pbuf_alloc+0x268>)
 80091de:	2291      	movs	r2, #145	; 0x91
 80091e0:	0052      	lsls	r2, r2, #1
 80091e2:	490e      	ldr	r1, [pc, #56]	; (800921c <pbuf_alloc+0x278>)
 80091e4:	480b      	ldr	r0, [pc, #44]	; (8009214 <pbuf_alloc+0x270>)
 80091e6:	f7f8 fff1 	bl	80021cc <app_debug_rtt_raw>
                  ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
      break;
 80091ea:	e008      	b.n	80091fe <pbuf_alloc+0x25a>
    }
    default:
      LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
 80091ec:	4b07      	ldr	r3, [pc, #28]	; (800920c <pbuf_alloc+0x268>)
 80091ee:	2228      	movs	r2, #40	; 0x28
 80091f0:	32ff      	adds	r2, #255	; 0xff
 80091f2:	490b      	ldr	r1, [pc, #44]	; (8009220 <pbuf_alloc+0x27c>)
 80091f4:	4807      	ldr	r0, [pc, #28]	; (8009214 <pbuf_alloc+0x270>)
 80091f6:	f7f8 ffe9 	bl	80021cc <app_debug_rtt_raw>
      return NULL;
 80091fa:	2300      	movs	r3, #0
 80091fc:	e001      	b.n	8009202 <pbuf_alloc+0x25e>
      break;
 80091fe:	46c0      	nop			; (mov r8, r8)
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
 8009200:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 8009202:	0018      	movs	r0, r3
 8009204:	46bd      	mov	sp, r7
 8009206:	b00b      	add	sp, #44	; 0x2c
 8009208:	bd90      	pop	{r4, r7, pc}
 800920a:	46c0      	nop			; (mov r8, r8)
 800920c:	0801eca4 	.word	0x0801eca4
 8009210:	0801eccc 	.word	0x0801eccc
 8009214:	0801ecfc 	.word	0x0801ecfc
 8009218:	0801ed28 	.word	0x0801ed28
 800921c:	0801ed5c 	.word	0x0801ed5c
 8009220:	0801ed88 	.word	0x0801ed88

08009224 <pbuf_alloc_reference>:
 *
 * @return the allocated pbuf.
 */
struct pbuf *
pbuf_alloc_reference(void *payload, u16_t length, pbuf_type type)
{
 8009224:	b590      	push	{r4, r7, lr}
 8009226:	b087      	sub	sp, #28
 8009228:	af02      	add	r7, sp, #8
 800922a:	6078      	str	r0, [r7, #4]
 800922c:	0008      	movs	r0, r1
 800922e:	0011      	movs	r1, r2
 8009230:	1cbb      	adds	r3, r7, #2
 8009232:	1c02      	adds	r2, r0, #0
 8009234:	801a      	strh	r2, [r3, #0]
 8009236:	003b      	movs	r3, r7
 8009238:	1c0a      	adds	r2, r1, #0
 800923a:	801a      	strh	r2, [r3, #0]
  struct pbuf *p;
  LWIP_ASSERT("invalid pbuf_type", (type == PBUF_REF) || (type == PBUF_ROM));
 800923c:	003b      	movs	r3, r7
 800923e:	881b      	ldrh	r3, [r3, #0]
 8009240:	2b41      	cmp	r3, #65	; 0x41
 8009242:	d00a      	beq.n	800925a <pbuf_alloc_reference+0x36>
 8009244:	003b      	movs	r3, r7
 8009246:	881b      	ldrh	r3, [r3, #0]
 8009248:	2b01      	cmp	r3, #1
 800924a:	d006      	beq.n	800925a <pbuf_alloc_reference+0x36>
 800924c:	4b11      	ldr	r3, [pc, #68]	; (8009294 <pbuf_alloc_reference+0x70>)
 800924e:	22a5      	movs	r2, #165	; 0xa5
 8009250:	0052      	lsls	r2, r2, #1
 8009252:	4911      	ldr	r1, [pc, #68]	; (8009298 <pbuf_alloc_reference+0x74>)
 8009254:	4811      	ldr	r0, [pc, #68]	; (800929c <pbuf_alloc_reference+0x78>)
 8009256:	f7f8 ffb9 	bl	80021cc <app_debug_rtt_raw>
  /* only allocate memory for the pbuf structure */
  p = (struct pbuf *)memp_malloc(MEMP_PBUF);
 800925a:	2005      	movs	r0, #5
 800925c:	f7ff fab4 	bl	80087c8 <memp_malloc>
 8009260:	0003      	movs	r3, r0
 8009262:	60fb      	str	r3, [r7, #12]
  if (p == NULL) {
 8009264:	68fb      	ldr	r3, [r7, #12]
 8009266:	2b00      	cmp	r3, #0
 8009268:	d101      	bne.n	800926e <pbuf_alloc_reference+0x4a>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                ("pbuf_alloc_reference: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                 (type == PBUF_ROM) ? "ROM" : "REF"));
    return NULL;
 800926a:	2300      	movs	r3, #0
 800926c:	e00e      	b.n	800928c <pbuf_alloc_reference+0x68>
  }
  pbuf_init_alloced_pbuf(p, payload, length, length, type, 0);
 800926e:	1cbb      	adds	r3, r7, #2
 8009270:	881c      	ldrh	r4, [r3, #0]
 8009272:	1cbb      	adds	r3, r7, #2
 8009274:	881a      	ldrh	r2, [r3, #0]
 8009276:	6879      	ldr	r1, [r7, #4]
 8009278:	68f8      	ldr	r0, [r7, #12]
 800927a:	2300      	movs	r3, #0
 800927c:	9301      	str	r3, [sp, #4]
 800927e:	003b      	movs	r3, r7
 8009280:	881b      	ldrh	r3, [r3, #0]
 8009282:	9300      	str	r3, [sp, #0]
 8009284:	0023      	movs	r3, r4
 8009286:	f7ff fe5f 	bl	8008f48 <pbuf_init_alloced_pbuf>
  return p;
 800928a:	68fb      	ldr	r3, [r7, #12]
}
 800928c:	0018      	movs	r0, r3
 800928e:	46bd      	mov	sp, r7
 8009290:	b005      	add	sp, #20
 8009292:	bd90      	pop	{r4, r7, pc}
 8009294:	0801eca4 	.word	0x0801eca4
 8009298:	0801eda4 	.word	0x0801eda4
 800929c:	0801ecfc 	.word	0x0801ecfc

080092a0 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
 80092a0:	b580      	push	{r7, lr}
 80092a2:	b084      	sub	sp, #16
 80092a4:	af00      	add	r7, sp, #0
 80092a6:	6078      	str	r0, [r7, #4]
 80092a8:	000a      	movs	r2, r1
 80092aa:	1cbb      	adds	r3, r7, #2
 80092ac:	801a      	strh	r2, [r3, #0]
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  u16_t shrink;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
 80092ae:	687b      	ldr	r3, [r7, #4]
 80092b0:	2b00      	cmp	r3, #0
 80092b2:	d106      	bne.n	80092c2 <pbuf_realloc+0x22>
 80092b4:	4b44      	ldr	r3, [pc, #272]	; (80093c8 <pbuf_realloc+0x128>)
 80092b6:	22cc      	movs	r2, #204	; 0xcc
 80092b8:	0052      	lsls	r2, r2, #1
 80092ba:	4944      	ldr	r1, [pc, #272]	; (80093cc <pbuf_realloc+0x12c>)
 80092bc:	4844      	ldr	r0, [pc, #272]	; (80093d0 <pbuf_realloc+0x130>)
 80092be:	f7f8 ff85 	bl	80021cc <app_debug_rtt_raw>

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
 80092c2:	687b      	ldr	r3, [r7, #4]
 80092c4:	891b      	ldrh	r3, [r3, #8]
 80092c6:	1cba      	adds	r2, r7, #2
 80092c8:	8812      	ldrh	r2, [r2, #0]
 80092ca:	429a      	cmp	r2, r3
 80092cc:	d300      	bcc.n	80092d0 <pbuf_realloc+0x30>
 80092ce:	e076      	b.n	80093be <pbuf_realloc+0x11e>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  shrink = (u16_t)(p->tot_len - new_len);
 80092d0:	687b      	ldr	r3, [r7, #4]
 80092d2:	8919      	ldrh	r1, [r3, #8]
 80092d4:	2308      	movs	r3, #8
 80092d6:	18fb      	adds	r3, r7, r3
 80092d8:	1cba      	adds	r2, r7, #2
 80092da:	8812      	ldrh	r2, [r2, #0]
 80092dc:	1a8a      	subs	r2, r1, r2
 80092de:	801a      	strh	r2, [r3, #0]

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
 80092e0:	230a      	movs	r3, #10
 80092e2:	18fb      	adds	r3, r7, r3
 80092e4:	1cba      	adds	r2, r7, #2
 80092e6:	8812      	ldrh	r2, [r2, #0]
 80092e8:	801a      	strh	r2, [r3, #0]
  q = p;
 80092ea:	687b      	ldr	r3, [r7, #4]
 80092ec:	60fb      	str	r3, [r7, #12]
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 80092ee:	e01d      	b.n	800932c <pbuf_realloc+0x8c>
    /* decrease remaining length by pbuf length */
    rem_len = (u16_t)(rem_len - q->len);
 80092f0:	68fb      	ldr	r3, [r7, #12]
 80092f2:	895a      	ldrh	r2, [r3, #10]
 80092f4:	210a      	movs	r1, #10
 80092f6:	187b      	adds	r3, r7, r1
 80092f8:	1879      	adds	r1, r7, r1
 80092fa:	8809      	ldrh	r1, [r1, #0]
 80092fc:	1a8a      	subs	r2, r1, r2
 80092fe:	801a      	strh	r2, [r3, #0]
    /* decrease total length indicator */
    q->tot_len = (u16_t)(q->tot_len - shrink);
 8009300:	68fb      	ldr	r3, [r7, #12]
 8009302:	891a      	ldrh	r2, [r3, #8]
 8009304:	2308      	movs	r3, #8
 8009306:	18fb      	adds	r3, r7, r3
 8009308:	881b      	ldrh	r3, [r3, #0]
 800930a:	1ad3      	subs	r3, r2, r3
 800930c:	b29a      	uxth	r2, r3
 800930e:	68fb      	ldr	r3, [r7, #12]
 8009310:	811a      	strh	r2, [r3, #8]
    /* proceed to next pbuf in chain */
    q = q->next;
 8009312:	68fb      	ldr	r3, [r7, #12]
 8009314:	681b      	ldr	r3, [r3, #0]
 8009316:	60fb      	str	r3, [r7, #12]
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
 8009318:	68fb      	ldr	r3, [r7, #12]
 800931a:	2b00      	cmp	r3, #0
 800931c:	d106      	bne.n	800932c <pbuf_realloc+0x8c>
 800931e:	4b2a      	ldr	r3, [pc, #168]	; (80093c8 <pbuf_realloc+0x128>)
 8009320:	22b0      	movs	r2, #176	; 0xb0
 8009322:	32ff      	adds	r2, #255	; 0xff
 8009324:	492b      	ldr	r1, [pc, #172]	; (80093d4 <pbuf_realloc+0x134>)
 8009326:	482a      	ldr	r0, [pc, #168]	; (80093d0 <pbuf_realloc+0x130>)
 8009328:	f7f8 ff50 	bl	80021cc <app_debug_rtt_raw>
  while (rem_len > q->len) {
 800932c:	68fb      	ldr	r3, [r7, #12]
 800932e:	895b      	ldrh	r3, [r3, #10]
 8009330:	210a      	movs	r1, #10
 8009332:	187a      	adds	r2, r7, r1
 8009334:	8812      	ldrh	r2, [r2, #0]
 8009336:	429a      	cmp	r2, r3
 8009338:	d8da      	bhi.n	80092f0 <pbuf_realloc+0x50>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if (pbuf_match_allocsrc(q, PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP) && (rem_len != q->len)
 800933a:	68fb      	ldr	r3, [r7, #12]
 800933c:	7b1b      	ldrb	r3, [r3, #12]
 800933e:	001a      	movs	r2, r3
 8009340:	230f      	movs	r3, #15
 8009342:	4013      	ands	r3, r2
 8009344:	d125      	bne.n	8009392 <pbuf_realloc+0xf2>
 8009346:	68fb      	ldr	r3, [r7, #12]
 8009348:	895b      	ldrh	r3, [r3, #10]
 800934a:	187a      	adds	r2, r7, r1
 800934c:	8812      	ldrh	r2, [r2, #0]
 800934e:	429a      	cmp	r2, r3
 8009350:	d01f      	beq.n	8009392 <pbuf_realloc+0xf2>
#if LWIP_SUPPORT_CUSTOM_PBUF
      && ((q->flags & PBUF_FLAG_IS_CUSTOM) == 0)
 8009352:	68fb      	ldr	r3, [r7, #12]
 8009354:	7b5b      	ldrb	r3, [r3, #13]
 8009356:	001a      	movs	r2, r3
 8009358:	2302      	movs	r3, #2
 800935a:	4013      	ands	r3, r2
 800935c:	d119      	bne.n	8009392 <pbuf_realloc+0xf2>
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
     ) {
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (mem_size_t)(((u8_t *)q->payload - (u8_t *)q) + rem_len));
 800935e:	68fb      	ldr	r3, [r7, #12]
 8009360:	685a      	ldr	r2, [r3, #4]
 8009362:	68fb      	ldr	r3, [r7, #12]
 8009364:	1ad3      	subs	r3, r2, r3
 8009366:	b29a      	uxth	r2, r3
 8009368:	187b      	adds	r3, r7, r1
 800936a:	881b      	ldrh	r3, [r3, #0]
 800936c:	18d3      	adds	r3, r2, r3
 800936e:	b29a      	uxth	r2, r3
 8009370:	68fb      	ldr	r3, [r7, #12]
 8009372:	0011      	movs	r1, r2
 8009374:	0018      	movs	r0, r3
 8009376:	f7fe ff1d 	bl	80081b4 <mem_trim>
 800937a:	0003      	movs	r3, r0
 800937c:	60fb      	str	r3, [r7, #12]
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
 800937e:	68fb      	ldr	r3, [r7, #12]
 8009380:	2b00      	cmp	r3, #0
 8009382:	d106      	bne.n	8009392 <pbuf_realloc+0xf2>
 8009384:	4b10      	ldr	r3, [pc, #64]	; (80093c8 <pbuf_realloc+0x128>)
 8009386:	22be      	movs	r2, #190	; 0xbe
 8009388:	32ff      	adds	r2, #255	; 0xff
 800938a:	4913      	ldr	r1, [pc, #76]	; (80093d8 <pbuf_realloc+0x138>)
 800938c:	4810      	ldr	r0, [pc, #64]	; (80093d0 <pbuf_realloc+0x130>)
 800938e:	f7f8 ff1d 	bl	80021cc <app_debug_rtt_raw>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
 8009392:	68fb      	ldr	r3, [r7, #12]
 8009394:	220a      	movs	r2, #10
 8009396:	18ba      	adds	r2, r7, r2
 8009398:	8812      	ldrh	r2, [r2, #0]
 800939a:	815a      	strh	r2, [r3, #10]
  q->tot_len = q->len;
 800939c:	68fb      	ldr	r3, [r7, #12]
 800939e:	895a      	ldrh	r2, [r3, #10]
 80093a0:	68fb      	ldr	r3, [r7, #12]
 80093a2:	811a      	strh	r2, [r3, #8]

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
 80093a4:	68fb      	ldr	r3, [r7, #12]
 80093a6:	681b      	ldr	r3, [r3, #0]
 80093a8:	2b00      	cmp	r3, #0
 80093aa:	d004      	beq.n	80093b6 <pbuf_realloc+0x116>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
 80093ac:	68fb      	ldr	r3, [r7, #12]
 80093ae:	681b      	ldr	r3, [r3, #0]
 80093b0:	0018      	movs	r0, r3
 80093b2:	f000 f96f 	bl	8009694 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
 80093b6:	68fb      	ldr	r3, [r7, #12]
 80093b8:	2200      	movs	r2, #0
 80093ba:	601a      	str	r2, [r3, #0]
 80093bc:	e000      	b.n	80093c0 <pbuf_realloc+0x120>
    return;
 80093be:	46c0      	nop			; (mov r8, r8)

}
 80093c0:	46bd      	mov	sp, r7
 80093c2:	b004      	add	sp, #16
 80093c4:	bd80      	pop	{r7, pc}
 80093c6:	46c0      	nop			; (mov r8, r8)
 80093c8:	0801eca4 	.word	0x0801eca4
 80093cc:	0801edb8 	.word	0x0801edb8
 80093d0:	0801ecfc 	.word	0x0801ecfc
 80093d4:	0801edd0 	.word	0x0801edd0
 80093d8:	0801ede8 	.word	0x0801ede8

080093dc <pbuf_add_header_impl>:
 * @return non-zero on failure, zero on success.
 *
 */
static u8_t
pbuf_add_header_impl(struct pbuf *p, size_t header_size_increment, u8_t force)
{
 80093dc:	b580      	push	{r7, lr}
 80093de:	b086      	sub	sp, #24
 80093e0:	af00      	add	r7, sp, #0
 80093e2:	60f8      	str	r0, [r7, #12]
 80093e4:	60b9      	str	r1, [r7, #8]
 80093e6:	1dfb      	adds	r3, r7, #7
 80093e8:	701a      	strb	r2, [r3, #0]
  u16_t type_internal;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
 80093ea:	68fb      	ldr	r3, [r7, #12]
 80093ec:	2b00      	cmp	r3, #0
 80093ee:	d106      	bne.n	80093fe <pbuf_add_header_impl+0x22>
 80093f0:	4b31      	ldr	r3, [pc, #196]	; (80094b8 <pbuf_add_header_impl+0xdc>)
 80093f2:	22e0      	movs	r2, #224	; 0xe0
 80093f4:	32ff      	adds	r2, #255	; 0xff
 80093f6:	4931      	ldr	r1, [pc, #196]	; (80094bc <pbuf_add_header_impl+0xe0>)
 80093f8:	4831      	ldr	r0, [pc, #196]	; (80094c0 <pbuf_add_header_impl+0xe4>)
 80093fa:	f7f8 fee7 	bl	80021cc <app_debug_rtt_raw>
  if ((p == NULL) || (header_size_increment > 0xFFFF)) {
 80093fe:	68fb      	ldr	r3, [r7, #12]
 8009400:	2b00      	cmp	r3, #0
 8009402:	d004      	beq.n	800940e <pbuf_add_header_impl+0x32>
 8009404:	68ba      	ldr	r2, [r7, #8]
 8009406:	2380      	movs	r3, #128	; 0x80
 8009408:	025b      	lsls	r3, r3, #9
 800940a:	429a      	cmp	r2, r3
 800940c:	d301      	bcc.n	8009412 <pbuf_add_header_impl+0x36>
    return 1;
 800940e:	2301      	movs	r3, #1
 8009410:	e04d      	b.n	80094ae <pbuf_add_header_impl+0xd2>
  }
  if (header_size_increment == 0) {
 8009412:	68bb      	ldr	r3, [r7, #8]
 8009414:	2b00      	cmp	r3, #0
 8009416:	d101      	bne.n	800941c <pbuf_add_header_impl+0x40>
    return 0;
 8009418:	2300      	movs	r3, #0
 800941a:	e048      	b.n	80094ae <pbuf_add_header_impl+0xd2>
  }

  increment_magnitude = (u16_t)header_size_increment;
 800941c:	2112      	movs	r1, #18
 800941e:	187b      	adds	r3, r7, r1
 8009420:	68ba      	ldr	r2, [r7, #8]
 8009422:	801a      	strh	r2, [r3, #0]
  /* Do not allow tot_len to wrap as a result. */
  if ((u16_t)(increment_magnitude + p->tot_len) < increment_magnitude) {
 8009424:	68fb      	ldr	r3, [r7, #12]
 8009426:	891a      	ldrh	r2, [r3, #8]
 8009428:	187b      	adds	r3, r7, r1
 800942a:	881b      	ldrh	r3, [r3, #0]
 800942c:	18d3      	adds	r3, r2, r3
 800942e:	b29b      	uxth	r3, r3
 8009430:	187a      	adds	r2, r7, r1
 8009432:	8812      	ldrh	r2, [r2, #0]
 8009434:	429a      	cmp	r2, r3
 8009436:	d901      	bls.n	800943c <pbuf_add_header_impl+0x60>
    return 1;
 8009438:	2301      	movs	r3, #1
 800943a:	e038      	b.n	80094ae <pbuf_add_header_impl+0xd2>
  }

  type_internal = p->type_internal;
 800943c:	68fb      	ldr	r3, [r7, #12]
 800943e:	7b1a      	ldrb	r2, [r3, #12]
 8009440:	2110      	movs	r1, #16
 8009442:	187b      	adds	r3, r7, r1
 8009444:	801a      	strh	r2, [r3, #0]

  /* pbuf types containing payloads? */
  if (type_internal & PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS) {
 8009446:	187b      	adds	r3, r7, r1
 8009448:	881b      	ldrh	r3, [r3, #0]
 800944a:	2280      	movs	r2, #128	; 0x80
 800944c:	4013      	ands	r3, r2
 800944e:	d00c      	beq.n	800946a <pbuf_add_header_impl+0x8e>
    /* set new payload pointer */
    payload = (u8_t *)p->payload - header_size_increment;
 8009450:	68fb      	ldr	r3, [r7, #12]
 8009452:	685a      	ldr	r2, [r3, #4]
 8009454:	68bb      	ldr	r3, [r7, #8]
 8009456:	425b      	negs	r3, r3
 8009458:	18d3      	adds	r3, r2, r3
 800945a:	617b      	str	r3, [r7, #20]
    /* boundary check fails? */
    if ((u8_t *)payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 800945c:	68fb      	ldr	r3, [r7, #12]
 800945e:	3310      	adds	r3, #16
 8009460:	697a      	ldr	r2, [r7, #20]
 8009462:	429a      	cmp	r2, r3
 8009464:	d20e      	bcs.n	8009484 <pbuf_add_header_impl+0xa8>
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE,
                   ("pbuf_add_header: failed as %p < %p (not enough space for new header size)\n",
                    (void *)payload, (void *)((u8_t *)p + SIZEOF_STRUCT_PBUF)));
      /* bail out unsuccessfully */
      return 1;
 8009466:	2301      	movs	r3, #1
 8009468:	e021      	b.n	80094ae <pbuf_add_header_impl+0xd2>
    }
    /* pbuf types referring to external payloads? */
  } else {
    /* hide a header in the payload? */
    if (force) {
 800946a:	1dfb      	adds	r3, r7, #7
 800946c:	781b      	ldrb	r3, [r3, #0]
 800946e:	2b00      	cmp	r3, #0
 8009470:	d006      	beq.n	8009480 <pbuf_add_header_impl+0xa4>
      payload = (u8_t *)p->payload - header_size_increment;
 8009472:	68fb      	ldr	r3, [r7, #12]
 8009474:	685a      	ldr	r2, [r3, #4]
 8009476:	68bb      	ldr	r3, [r7, #8]
 8009478:	425b      	negs	r3, r3
 800947a:	18d3      	adds	r3, r2, r3
 800947c:	617b      	str	r3, [r7, #20]
 800947e:	e001      	b.n	8009484 <pbuf_add_header_impl+0xa8>
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccessfully */
      return 1;
 8009480:	2301      	movs	r3, #1
 8009482:	e014      	b.n	80094ae <pbuf_add_header_impl+0xd2>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_add_header: old %p new %p (%"U16_F")\n",
              (void *)p->payload, (void *)payload, increment_magnitude));

  /* modify pbuf fields */
  p->payload = payload;
 8009484:	68fb      	ldr	r3, [r7, #12]
 8009486:	697a      	ldr	r2, [r7, #20]
 8009488:	605a      	str	r2, [r3, #4]
  p->len = (u16_t)(p->len + increment_magnitude);
 800948a:	68fb      	ldr	r3, [r7, #12]
 800948c:	895a      	ldrh	r2, [r3, #10]
 800948e:	2112      	movs	r1, #18
 8009490:	187b      	adds	r3, r7, r1
 8009492:	881b      	ldrh	r3, [r3, #0]
 8009494:	18d3      	adds	r3, r2, r3
 8009496:	b29a      	uxth	r2, r3
 8009498:	68fb      	ldr	r3, [r7, #12]
 800949a:	815a      	strh	r2, [r3, #10]
  p->tot_len = (u16_t)(p->tot_len + increment_magnitude);
 800949c:	68fb      	ldr	r3, [r7, #12]
 800949e:	891a      	ldrh	r2, [r3, #8]
 80094a0:	187b      	adds	r3, r7, r1
 80094a2:	881b      	ldrh	r3, [r3, #0]
 80094a4:	18d3      	adds	r3, r2, r3
 80094a6:	b29a      	uxth	r2, r3
 80094a8:	68fb      	ldr	r3, [r7, #12]
 80094aa:	811a      	strh	r2, [r3, #8]


  return 0;
 80094ac:	2300      	movs	r3, #0
}
 80094ae:	0018      	movs	r0, r3
 80094b0:	46bd      	mov	sp, r7
 80094b2:	b006      	add	sp, #24
 80094b4:	bd80      	pop	{r7, pc}
 80094b6:	46c0      	nop			; (mov r8, r8)
 80094b8:	0801eca4 	.word	0x0801eca4
 80094bc:	0801ee04 	.word	0x0801ee04
 80094c0:	0801ecfc 	.word	0x0801ecfc

080094c4 <pbuf_add_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_add_header(struct pbuf *p, size_t header_size_increment)
{
 80094c4:	b580      	push	{r7, lr}
 80094c6:	b082      	sub	sp, #8
 80094c8:	af00      	add	r7, sp, #0
 80094ca:	6078      	str	r0, [r7, #4]
 80094cc:	6039      	str	r1, [r7, #0]
  return pbuf_add_header_impl(p, header_size_increment, 0);
 80094ce:	6839      	ldr	r1, [r7, #0]
 80094d0:	687b      	ldr	r3, [r7, #4]
 80094d2:	2200      	movs	r2, #0
 80094d4:	0018      	movs	r0, r3
 80094d6:	f7ff ff81 	bl	80093dc <pbuf_add_header_impl>
 80094da:	0003      	movs	r3, r0
}
 80094dc:	0018      	movs	r0, r3
 80094de:	46bd      	mov	sp, r7
 80094e0:	b002      	add	sp, #8
 80094e2:	bd80      	pop	{r7, pc}

080094e4 <pbuf_remove_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_remove_header(struct pbuf *p, size_t header_size_decrement)
{
 80094e4:	b580      	push	{r7, lr}
 80094e6:	b084      	sub	sp, #16
 80094e8:	af00      	add	r7, sp, #0
 80094ea:	6078      	str	r0, [r7, #4]
 80094ec:	6039      	str	r1, [r7, #0]
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
 80094ee:	687b      	ldr	r3, [r7, #4]
 80094f0:	2b00      	cmp	r3, #0
 80094f2:	d105      	bne.n	8009500 <pbuf_remove_header+0x1c>
 80094f4:	4b21      	ldr	r3, [pc, #132]	; (800957c <pbuf_remove_header+0x98>)
 80094f6:	4a22      	ldr	r2, [pc, #136]	; (8009580 <pbuf_remove_header+0x9c>)
 80094f8:	4922      	ldr	r1, [pc, #136]	; (8009584 <pbuf_remove_header+0xa0>)
 80094fa:	4823      	ldr	r0, [pc, #140]	; (8009588 <pbuf_remove_header+0xa4>)
 80094fc:	f7f8 fe66 	bl	80021cc <app_debug_rtt_raw>
  if ((p == NULL) || (header_size_decrement > 0xFFFF)) {
 8009500:	687b      	ldr	r3, [r7, #4]
 8009502:	2b00      	cmp	r3, #0
 8009504:	d004      	beq.n	8009510 <pbuf_remove_header+0x2c>
 8009506:	683a      	ldr	r2, [r7, #0]
 8009508:	2380      	movs	r3, #128	; 0x80
 800950a:	025b      	lsls	r3, r3, #9
 800950c:	429a      	cmp	r2, r3
 800950e:	d301      	bcc.n	8009514 <pbuf_remove_header+0x30>
    return 1;
 8009510:	2301      	movs	r3, #1
 8009512:	e02f      	b.n	8009574 <pbuf_remove_header+0x90>
  }
  if (header_size_decrement == 0) {
 8009514:	683b      	ldr	r3, [r7, #0]
 8009516:	2b00      	cmp	r3, #0
 8009518:	d101      	bne.n	800951e <pbuf_remove_header+0x3a>
    return 0;
 800951a:	2300      	movs	r3, #0
 800951c:	e02a      	b.n	8009574 <pbuf_remove_header+0x90>
  }

  increment_magnitude = (u16_t)header_size_decrement;
 800951e:	210e      	movs	r1, #14
 8009520:	187b      	adds	r3, r7, r1
 8009522:	683a      	ldr	r2, [r7, #0]
 8009524:	801a      	strh	r2, [r3, #0]
  /* Check that we aren't going to move off the end of the pbuf */
  LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 8009526:	687b      	ldr	r3, [r7, #4]
 8009528:	895b      	ldrh	r3, [r3, #10]
 800952a:	187a      	adds	r2, r7, r1
 800952c:	8812      	ldrh	r2, [r2, #0]
 800952e:	429a      	cmp	r2, r3
 8009530:	d905      	bls.n	800953e <pbuf_remove_header+0x5a>
 8009532:	4b16      	ldr	r3, [pc, #88]	; (800958c <pbuf_remove_header+0xa8>)
 8009534:	0018      	movs	r0, r3
 8009536:	f7f8 fe49 	bl	80021cc <app_debug_rtt_raw>
 800953a:	2301      	movs	r3, #1
 800953c:	e01a      	b.n	8009574 <pbuf_remove_header+0x90>

  /* remember current payload pointer */
  payload = p->payload;
 800953e:	687b      	ldr	r3, [r7, #4]
 8009540:	685b      	ldr	r3, [r3, #4]
 8009542:	60bb      	str	r3, [r7, #8]
  LWIP_UNUSED_ARG(payload); /* only used in LWIP_DEBUGF below */

  /* increase payload pointer (guarded by length check above) */
  p->payload = (u8_t *)p->payload + header_size_decrement;
 8009544:	687b      	ldr	r3, [r7, #4]
 8009546:	685a      	ldr	r2, [r3, #4]
 8009548:	683b      	ldr	r3, [r7, #0]
 800954a:	18d2      	adds	r2, r2, r3
 800954c:	687b      	ldr	r3, [r7, #4]
 800954e:	605a      	str	r2, [r3, #4]
  /* modify pbuf length fields */
  p->len = (u16_t)(p->len - increment_magnitude);
 8009550:	687b      	ldr	r3, [r7, #4]
 8009552:	895a      	ldrh	r2, [r3, #10]
 8009554:	210e      	movs	r1, #14
 8009556:	187b      	adds	r3, r7, r1
 8009558:	881b      	ldrh	r3, [r3, #0]
 800955a:	1ad3      	subs	r3, r2, r3
 800955c:	b29a      	uxth	r2, r3
 800955e:	687b      	ldr	r3, [r7, #4]
 8009560:	815a      	strh	r2, [r3, #10]
  p->tot_len = (u16_t)(p->tot_len - increment_magnitude);
 8009562:	687b      	ldr	r3, [r7, #4]
 8009564:	891a      	ldrh	r2, [r3, #8]
 8009566:	187b      	adds	r3, r7, r1
 8009568:	881b      	ldrh	r3, [r3, #0]
 800956a:	1ad3      	subs	r3, r2, r3
 800956c:	b29a      	uxth	r2, r3
 800956e:	687b      	ldr	r3, [r7, #4]
 8009570:	811a      	strh	r2, [r3, #8]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_remove_header: old %p new %p (%"U16_F")\n",
              (void *)payload, (void *)p->payload, increment_magnitude));

  return 0;
 8009572:	2300      	movs	r3, #0
}
 8009574:	0018      	movs	r0, r3
 8009576:	46bd      	mov	sp, r7
 8009578:	b004      	add	sp, #16
 800957a:	bd80      	pop	{r7, pc}
 800957c:	0801eca4 	.word	0x0801eca4
 8009580:	0000024b 	.word	0x0000024b
 8009584:	0801ee04 	.word	0x0801ee04
 8009588:	0801ecfc 	.word	0x0801ecfc
 800958c:	0801ee10 	.word	0x0801ee10

08009590 <pbuf_header_impl>:

static u8_t
pbuf_header_impl(struct pbuf *p, s16_t header_size_increment, u8_t force)
{
 8009590:	b580      	push	{r7, lr}
 8009592:	b082      	sub	sp, #8
 8009594:	af00      	add	r7, sp, #0
 8009596:	6078      	str	r0, [r7, #4]
 8009598:	0008      	movs	r0, r1
 800959a:	0011      	movs	r1, r2
 800959c:	1cbb      	adds	r3, r7, #2
 800959e:	1c02      	adds	r2, r0, #0
 80095a0:	801a      	strh	r2, [r3, #0]
 80095a2:	1c7b      	adds	r3, r7, #1
 80095a4:	1c0a      	adds	r2, r1, #0
 80095a6:	701a      	strb	r2, [r3, #0]
  if (header_size_increment < 0) {
 80095a8:	1cbb      	adds	r3, r7, #2
 80095aa:	2200      	movs	r2, #0
 80095ac:	5e9b      	ldrsh	r3, [r3, r2]
 80095ae:	2b00      	cmp	r3, #0
 80095b0:	da0b      	bge.n	80095ca <pbuf_header_impl+0x3a>
    return pbuf_remove_header(p, (size_t) - header_size_increment);
 80095b2:	1cbb      	adds	r3, r7, #2
 80095b4:	2200      	movs	r2, #0
 80095b6:	5e9b      	ldrsh	r3, [r3, r2]
 80095b8:	425b      	negs	r3, r3
 80095ba:	001a      	movs	r2, r3
 80095bc:	687b      	ldr	r3, [r7, #4]
 80095be:	0011      	movs	r1, r2
 80095c0:	0018      	movs	r0, r3
 80095c2:	f7ff ff8f 	bl	80094e4 <pbuf_remove_header>
 80095c6:	0003      	movs	r3, r0
 80095c8:	e009      	b.n	80095de <pbuf_header_impl+0x4e>
  } else {
    return pbuf_add_header_impl(p, (size_t)header_size_increment, force);
 80095ca:	1cbb      	adds	r3, r7, #2
 80095cc:	2100      	movs	r1, #0
 80095ce:	5e59      	ldrsh	r1, [r3, r1]
 80095d0:	1c7b      	adds	r3, r7, #1
 80095d2:	781a      	ldrb	r2, [r3, #0]
 80095d4:	687b      	ldr	r3, [r7, #4]
 80095d6:	0018      	movs	r0, r3
 80095d8:	f7ff ff00 	bl	80093dc <pbuf_add_header_impl>
 80095dc:	0003      	movs	r3, r0
  }
}
 80095de:	0018      	movs	r0, r3
 80095e0:	46bd      	mov	sp, r7
 80095e2:	b002      	add	sp, #8
 80095e4:	bd80      	pop	{r7, pc}

080095e6 <pbuf_header_force>:
 * Same as pbuf_header but does not check if 'header_size > 0' is allowed.
 * This is used internally only, to allow PBUF_REF for RX.
 */
u8_t
pbuf_header_force(struct pbuf *p, s16_t header_size_increment)
{
 80095e6:	b580      	push	{r7, lr}
 80095e8:	b082      	sub	sp, #8
 80095ea:	af00      	add	r7, sp, #0
 80095ec:	6078      	str	r0, [r7, #4]
 80095ee:	000a      	movs	r2, r1
 80095f0:	1cbb      	adds	r3, r7, #2
 80095f2:	801a      	strh	r2, [r3, #0]
  return pbuf_header_impl(p, header_size_increment, 1);
 80095f4:	1cbb      	adds	r3, r7, #2
 80095f6:	2100      	movs	r1, #0
 80095f8:	5e59      	ldrsh	r1, [r3, r1]
 80095fa:	687b      	ldr	r3, [r7, #4]
 80095fc:	2201      	movs	r2, #1
 80095fe:	0018      	movs	r0, r3
 8009600:	f7ff ffc6 	bl	8009590 <pbuf_header_impl>
 8009604:	0003      	movs	r3, r0
}
 8009606:	0018      	movs	r0, r3
 8009608:	46bd      	mov	sp, r7
 800960a:	b002      	add	sp, #8
 800960c:	bd80      	pop	{r7, pc}

0800960e <pbuf_free_header>:
 *                   takes an u16_t not s16_t!
 * @return the new head pbuf
 */
struct pbuf *
pbuf_free_header(struct pbuf *q, u16_t size)
{
 800960e:	b590      	push	{r4, r7, lr}
 8009610:	b087      	sub	sp, #28
 8009612:	af00      	add	r7, sp, #0
 8009614:	6078      	str	r0, [r7, #4]
 8009616:	000a      	movs	r2, r1
 8009618:	1cbb      	adds	r3, r7, #2
 800961a:	801a      	strh	r2, [r3, #0]
  struct pbuf *p = q;
 800961c:	687b      	ldr	r3, [r7, #4]
 800961e:	617b      	str	r3, [r7, #20]
  u16_t free_left = size;
 8009620:	2312      	movs	r3, #18
 8009622:	18fb      	adds	r3, r7, r3
 8009624:	1cba      	adds	r2, r7, #2
 8009626:	8812      	ldrh	r2, [r2, #0]
 8009628:	801a      	strh	r2, [r3, #0]
  while (free_left && p) {
 800962a:	e025      	b.n	8009678 <pbuf_free_header+0x6a>
    if (free_left >= p->len) {
 800962c:	697b      	ldr	r3, [r7, #20]
 800962e:	895b      	ldrh	r3, [r3, #10]
 8009630:	2112      	movs	r1, #18
 8009632:	187a      	adds	r2, r7, r1
 8009634:	8812      	ldrh	r2, [r2, #0]
 8009636:	429a      	cmp	r2, r3
 8009638:	d313      	bcc.n	8009662 <pbuf_free_header+0x54>
      struct pbuf *f = p;
 800963a:	697b      	ldr	r3, [r7, #20]
 800963c:	60fb      	str	r3, [r7, #12]
      free_left = (u16_t)(free_left - p->len);
 800963e:	697b      	ldr	r3, [r7, #20]
 8009640:	895a      	ldrh	r2, [r3, #10]
 8009642:	187b      	adds	r3, r7, r1
 8009644:	1879      	adds	r1, r7, r1
 8009646:	8809      	ldrh	r1, [r1, #0]
 8009648:	1a8a      	subs	r2, r1, r2
 800964a:	801a      	strh	r2, [r3, #0]
      p = p->next;
 800964c:	697b      	ldr	r3, [r7, #20]
 800964e:	681b      	ldr	r3, [r3, #0]
 8009650:	617b      	str	r3, [r7, #20]
      f->next = 0;
 8009652:	68fb      	ldr	r3, [r7, #12]
 8009654:	2200      	movs	r2, #0
 8009656:	601a      	str	r2, [r3, #0]
      pbuf_free(f);
 8009658:	68fb      	ldr	r3, [r7, #12]
 800965a:	0018      	movs	r0, r3
 800965c:	f000 f81a 	bl	8009694 <pbuf_free>
 8009660:	e00a      	b.n	8009678 <pbuf_free_header+0x6a>
    } else {
      pbuf_remove_header(p, free_left);
 8009662:	2412      	movs	r4, #18
 8009664:	193b      	adds	r3, r7, r4
 8009666:	881a      	ldrh	r2, [r3, #0]
 8009668:	697b      	ldr	r3, [r7, #20]
 800966a:	0011      	movs	r1, r2
 800966c:	0018      	movs	r0, r3
 800966e:	f7ff ff39 	bl	80094e4 <pbuf_remove_header>
      free_left = 0;
 8009672:	193b      	adds	r3, r7, r4
 8009674:	2200      	movs	r2, #0
 8009676:	801a      	strh	r2, [r3, #0]
  while (free_left && p) {
 8009678:	2312      	movs	r3, #18
 800967a:	18fb      	adds	r3, r7, r3
 800967c:	881b      	ldrh	r3, [r3, #0]
 800967e:	2b00      	cmp	r3, #0
 8009680:	d002      	beq.n	8009688 <pbuf_free_header+0x7a>
 8009682:	697b      	ldr	r3, [r7, #20]
 8009684:	2b00      	cmp	r3, #0
 8009686:	d1d1      	bne.n	800962c <pbuf_free_header+0x1e>
    }
  }
  return p;
 8009688:	697b      	ldr	r3, [r7, #20]
}
 800968a:	0018      	movs	r0, r3
 800968c:	46bd      	mov	sp, r7
 800968e:	b007      	add	sp, #28
 8009690:	bd90      	pop	{r4, r7, pc}
	...

08009694 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
 8009694:	b580      	push	{r7, lr}
 8009696:	b086      	sub	sp, #24
 8009698:	af00      	add	r7, sp, #0
 800969a:	6078      	str	r0, [r7, #4]
  u8_t alloc_src;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
 800969c:	687b      	ldr	r3, [r7, #4]
 800969e:	2b00      	cmp	r3, #0
 80096a0:	d10b      	bne.n	80096ba <pbuf_free+0x26>
    LWIP_ASSERT("p != NULL", p != NULL);
 80096a2:	687b      	ldr	r3, [r7, #4]
 80096a4:	2b00      	cmp	r3, #0
 80096a6:	d106      	bne.n	80096b6 <pbuf_free+0x22>
 80096a8:	4b41      	ldr	r3, [pc, #260]	; (80097b0 <pbuf_free+0x11c>)
 80096aa:	22b7      	movs	r2, #183	; 0xb7
 80096ac:	0092      	lsls	r2, r2, #2
 80096ae:	4941      	ldr	r1, [pc, #260]	; (80097b4 <pbuf_free+0x120>)
 80096b0:	4841      	ldr	r0, [pc, #260]	; (80097b8 <pbuf_free+0x124>)
 80096b2:	f7f8 fd8b 	bl	80021cc <app_debug_rtt_raw>
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                ("pbuf_free(p == NULL) was called.\n"));
    return 0;
 80096b6:	2300      	movs	r3, #0
 80096b8:	e076      	b.n	80097a8 <pbuf_free+0x114>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  count = 0;
 80096ba:	2317      	movs	r3, #23
 80096bc:	18fb      	adds	r3, r7, r3
 80096be:	2200      	movs	r2, #0
 80096c0:	701a      	strb	r2, [r3, #0]
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 80096c2:	e06b      	b.n	800979c <pbuf_free+0x108>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 80096c4:	687b      	ldr	r3, [r7, #4]
 80096c6:	7b9b      	ldrb	r3, [r3, #14]
 80096c8:	2b00      	cmp	r3, #0
 80096ca:	d105      	bne.n	80096d8 <pbuf_free+0x44>
 80096cc:	4b38      	ldr	r3, [pc, #224]	; (80097b0 <pbuf_free+0x11c>)
 80096ce:	4a3b      	ldr	r2, [pc, #236]	; (80097bc <pbuf_free+0x128>)
 80096d0:	493b      	ldr	r1, [pc, #236]	; (80097c0 <pbuf_free+0x12c>)
 80096d2:	4839      	ldr	r0, [pc, #228]	; (80097b8 <pbuf_free+0x124>)
 80096d4:	f7f8 fd7a 	bl	80021cc <app_debug_rtt_raw>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
 80096d8:	687b      	ldr	r3, [r7, #4]
 80096da:	7b9b      	ldrb	r3, [r3, #14]
 80096dc:	3b01      	subs	r3, #1
 80096de:	b2da      	uxtb	r2, r3
 80096e0:	687b      	ldr	r3, [r7, #4]
 80096e2:	739a      	strb	r2, [r3, #14]
 80096e4:	2116      	movs	r1, #22
 80096e6:	187b      	adds	r3, r7, r1
 80096e8:	687a      	ldr	r2, [r7, #4]
 80096ea:	7b92      	ldrb	r2, [r2, #14]
 80096ec:	701a      	strb	r2, [r3, #0]
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
 80096ee:	187b      	adds	r3, r7, r1
 80096f0:	781b      	ldrb	r3, [r3, #0]
 80096f2:	2b00      	cmp	r3, #0
 80096f4:	d150      	bne.n	8009798 <pbuf_free+0x104>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
 80096f6:	687b      	ldr	r3, [r7, #4]
 80096f8:	681b      	ldr	r3, [r3, #0]
 80096fa:	613b      	str	r3, [r7, #16]
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      alloc_src = pbuf_get_allocsrc(p);
 80096fc:	687b      	ldr	r3, [r7, #4]
 80096fe:	7b1a      	ldrb	r2, [r3, #12]
 8009700:	230f      	movs	r3, #15
 8009702:	18fb      	adds	r3, r7, r3
 8009704:	210f      	movs	r1, #15
 8009706:	400a      	ands	r2, r1
 8009708:	701a      	strb	r2, [r3, #0]
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 800970a:	687b      	ldr	r3, [r7, #4]
 800970c:	7b5b      	ldrb	r3, [r3, #13]
 800970e:	001a      	movs	r2, r3
 8009710:	2302      	movs	r3, #2
 8009712:	4013      	ands	r3, r2
 8009714:	d011      	beq.n	800973a <pbuf_free+0xa6>
        struct pbuf_custom *pc = (struct pbuf_custom *)p;
 8009716:	687b      	ldr	r3, [r7, #4]
 8009718:	60bb      	str	r3, [r7, #8]
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
 800971a:	68bb      	ldr	r3, [r7, #8]
 800971c:	691b      	ldr	r3, [r3, #16]
 800971e:	2b00      	cmp	r3, #0
 8009720:	d105      	bne.n	800972e <pbuf_free+0x9a>
 8009722:	4b23      	ldr	r3, [pc, #140]	; (80097b0 <pbuf_free+0x11c>)
 8009724:	4a27      	ldr	r2, [pc, #156]	; (80097c4 <pbuf_free+0x130>)
 8009726:	4928      	ldr	r1, [pc, #160]	; (80097c8 <pbuf_free+0x134>)
 8009728:	4823      	ldr	r0, [pc, #140]	; (80097b8 <pbuf_free+0x124>)
 800972a:	f7f8 fd4f 	bl	80021cc <app_debug_rtt_raw>
        pc->custom_free_function(p);
 800972e:	68bb      	ldr	r3, [r7, #8]
 8009730:	691b      	ldr	r3, [r3, #16]
 8009732:	687a      	ldr	r2, [r7, #4]
 8009734:	0010      	movs	r0, r2
 8009736:	4798      	blx	r3
 8009738:	e025      	b.n	8009786 <pbuf_free+0xf2>
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF_POOL) {
 800973a:	230f      	movs	r3, #15
 800973c:	18fb      	adds	r3, r7, r3
 800973e:	781b      	ldrb	r3, [r3, #0]
 8009740:	2b02      	cmp	r3, #2
 8009742:	d105      	bne.n	8009750 <pbuf_free+0xbc>
          memp_free(MEMP_PBUF_POOL, p);
 8009744:	687b      	ldr	r3, [r7, #4]
 8009746:	0019      	movs	r1, r3
 8009748:	2006      	movs	r0, #6
 800974a:	f7ff f8ad 	bl	80088a8 <memp_free>
 800974e:	e01a      	b.n	8009786 <pbuf_free+0xf2>
          /* is this a ROM or RAM referencing pbuf? */
        } else if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF) {
 8009750:	230f      	movs	r3, #15
 8009752:	18fb      	adds	r3, r7, r3
 8009754:	781b      	ldrb	r3, [r3, #0]
 8009756:	2b01      	cmp	r3, #1
 8009758:	d105      	bne.n	8009766 <pbuf_free+0xd2>
          memp_free(MEMP_PBUF, p);
 800975a:	687b      	ldr	r3, [r7, #4]
 800975c:	0019      	movs	r1, r3
 800975e:	2005      	movs	r0, #5
 8009760:	f7ff f8a2 	bl	80088a8 <memp_free>
 8009764:	e00f      	b.n	8009786 <pbuf_free+0xf2>
          /* type == PBUF_RAM */
        } else if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP) {
 8009766:	230f      	movs	r3, #15
 8009768:	18fb      	adds	r3, r7, r3
 800976a:	781b      	ldrb	r3, [r3, #0]
 800976c:	2b00      	cmp	r3, #0
 800976e:	d104      	bne.n	800977a <pbuf_free+0xe6>
          mem_free(p);
 8009770:	687b      	ldr	r3, [r7, #4]
 8009772:	0018      	movs	r0, r3
 8009774:	f7fe fcb0 	bl	80080d8 <mem_free>
 8009778:	e005      	b.n	8009786 <pbuf_free+0xf2>
        } else {
          /* @todo: support freeing other types */
          LWIP_ASSERT("invalid pbuf type", 0);
 800977a:	4b0d      	ldr	r3, [pc, #52]	; (80097b0 <pbuf_free+0x11c>)
 800977c:	4a13      	ldr	r2, [pc, #76]	; (80097cc <pbuf_free+0x138>)
 800977e:	4914      	ldr	r1, [pc, #80]	; (80097d0 <pbuf_free+0x13c>)
 8009780:	480d      	ldr	r0, [pc, #52]	; (80097b8 <pbuf_free+0x124>)
 8009782:	f7f8 fd23 	bl	80021cc <app_debug_rtt_raw>
        }
      }
      count++;
 8009786:	2117      	movs	r1, #23
 8009788:	187b      	adds	r3, r7, r1
 800978a:	781a      	ldrb	r2, [r3, #0]
 800978c:	187b      	adds	r3, r7, r1
 800978e:	3201      	adds	r2, #1
 8009790:	701a      	strb	r2, [r3, #0]
      /* proceed to next pbuf */
      p = q;
 8009792:	693b      	ldr	r3, [r7, #16]
 8009794:	607b      	str	r3, [r7, #4]
 8009796:	e001      	b.n	800979c <pbuf_free+0x108>
      /* p->ref > 0, this pbuf is still referenced to */
      /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, (u16_t)ref));
      /* stop walking through the chain */
      p = NULL;
 8009798:	2300      	movs	r3, #0
 800979a:	607b      	str	r3, [r7, #4]
  while (p != NULL) {
 800979c:	687b      	ldr	r3, [r7, #4]
 800979e:	2b00      	cmp	r3, #0
 80097a0:	d190      	bne.n	80096c4 <pbuf_free+0x30>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
 80097a2:	2317      	movs	r3, #23
 80097a4:	18fb      	adds	r3, r7, r3
 80097a6:	781b      	ldrb	r3, [r3, #0]
}
 80097a8:	0018      	movs	r0, r3
 80097aa:	46bd      	mov	sp, r7
 80097ac:	b006      	add	sp, #24
 80097ae:	bd80      	pop	{r7, pc}
 80097b0:	0801eca4 	.word	0x0801eca4
 80097b4:	0801ee04 	.word	0x0801ee04
 80097b8:	0801ecfc 	.word	0x0801ecfc
 80097bc:	000002f1 	.word	0x000002f1
 80097c0:	0801ee30 	.word	0x0801ee30
 80097c4:	000002ff 	.word	0x000002ff
 80097c8:	0801ee48 	.word	0x0801ee48
 80097cc:	0000030f 	.word	0x0000030f
 80097d0:	0801ee6c 	.word	0x0801ee6c

080097d4 <pbuf_clen>:
 * @param p first pbuf of chain
 * @return the number of pbufs in a chain
 */
u16_t
pbuf_clen(const struct pbuf *p)
{
 80097d4:	b580      	push	{r7, lr}
 80097d6:	b084      	sub	sp, #16
 80097d8:	af00      	add	r7, sp, #0
 80097da:	6078      	str	r0, [r7, #4]
  u16_t len;

  len = 0;
 80097dc:	230e      	movs	r3, #14
 80097de:	18fb      	adds	r3, r7, r3
 80097e0:	2200      	movs	r2, #0
 80097e2:	801a      	strh	r2, [r3, #0]
  while (p != NULL) {
 80097e4:	e008      	b.n	80097f8 <pbuf_clen+0x24>
    ++len;
 80097e6:	220e      	movs	r2, #14
 80097e8:	18bb      	adds	r3, r7, r2
 80097ea:	18ba      	adds	r2, r7, r2
 80097ec:	8812      	ldrh	r2, [r2, #0]
 80097ee:	3201      	adds	r2, #1
 80097f0:	801a      	strh	r2, [r3, #0]
    p = p->next;
 80097f2:	687b      	ldr	r3, [r7, #4]
 80097f4:	681b      	ldr	r3, [r3, #0]
 80097f6:	607b      	str	r3, [r7, #4]
  while (p != NULL) {
 80097f8:	687b      	ldr	r3, [r7, #4]
 80097fa:	2b00      	cmp	r3, #0
 80097fc:	d1f3      	bne.n	80097e6 <pbuf_clen+0x12>
  }
  return len;
 80097fe:	230e      	movs	r3, #14
 8009800:	18fb      	adds	r3, r7, r3
 8009802:	881b      	ldrh	r3, [r3, #0]
}
 8009804:	0018      	movs	r0, r3
 8009806:	46bd      	mov	sp, r7
 8009808:	b004      	add	sp, #16
 800980a:	bd80      	pop	{r7, pc}

0800980c <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
 800980c:	b580      	push	{r7, lr}
 800980e:	b082      	sub	sp, #8
 8009810:	af00      	add	r7, sp, #0
 8009812:	6078      	str	r0, [r7, #4]
  /* pbuf given? */
  if (p != NULL) {
 8009814:	687b      	ldr	r3, [r7, #4]
 8009816:	2b00      	cmp	r3, #0
 8009818:	d00f      	beq.n	800983a <pbuf_ref+0x2e>
    SYS_ARCH_SET(p->ref, (LWIP_PBUF_REF_T)(p->ref + 1));
 800981a:	687b      	ldr	r3, [r7, #4]
 800981c:	7b9b      	ldrb	r3, [r3, #14]
 800981e:	3301      	adds	r3, #1
 8009820:	b2da      	uxtb	r2, r3
 8009822:	687b      	ldr	r3, [r7, #4]
 8009824:	739a      	strb	r2, [r3, #14]
    LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
 8009826:	687b      	ldr	r3, [r7, #4]
 8009828:	7b9b      	ldrb	r3, [r3, #14]
 800982a:	2b00      	cmp	r3, #0
 800982c:	d105      	bne.n	800983a <pbuf_ref+0x2e>
 800982e:	4b05      	ldr	r3, [pc, #20]	; (8009844 <pbuf_ref+0x38>)
 8009830:	4a05      	ldr	r2, [pc, #20]	; (8009848 <pbuf_ref+0x3c>)
 8009832:	4906      	ldr	r1, [pc, #24]	; (800984c <pbuf_ref+0x40>)
 8009834:	4806      	ldr	r0, [pc, #24]	; (8009850 <pbuf_ref+0x44>)
 8009836:	f7f8 fcc9 	bl	80021cc <app_debug_rtt_raw>
  }
}
 800983a:	46c0      	nop			; (mov r8, r8)
 800983c:	46bd      	mov	sp, r7
 800983e:	b002      	add	sp, #8
 8009840:	bd80      	pop	{r7, pc}
 8009842:	46c0      	nop			; (mov r8, r8)
 8009844:	0801eca4 	.word	0x0801eca4
 8009848:	00000342 	.word	0x00000342
 800984c:	0801ee80 	.word	0x0801ee80
 8009850:	0801ecfc 	.word	0x0801ecfc

08009854 <pbuf_cat>:
 *
 * @see pbuf_chain()
 */
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
 8009854:	b580      	push	{r7, lr}
 8009856:	b084      	sub	sp, #16
 8009858:	af00      	add	r7, sp, #0
 800985a:	6078      	str	r0, [r7, #4]
 800985c:	6039      	str	r1, [r7, #0]
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 800985e:	687b      	ldr	r3, [r7, #4]
 8009860:	2b00      	cmp	r3, #0
 8009862:	d002      	beq.n	800986a <pbuf_cat+0x16>
 8009864:	683b      	ldr	r3, [r7, #0]
 8009866:	2b00      	cmp	r3, #0
 8009868:	d104      	bne.n	8009874 <pbuf_cat+0x20>
 800986a:	4b1d      	ldr	r3, [pc, #116]	; (80098e0 <pbuf_cat+0x8c>)
 800986c:	0018      	movs	r0, r3
 800986e:	f7f8 fcad 	bl	80021cc <app_debug_rtt_raw>
 8009872:	e032      	b.n	80098da <pbuf_cat+0x86>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 8009874:	687b      	ldr	r3, [r7, #4]
 8009876:	60fb      	str	r3, [r7, #12]
 8009878:	e00a      	b.n	8009890 <pbuf_cat+0x3c>
    /* add total length of second chain to all totals of first chain */
    p->tot_len = (u16_t)(p->tot_len + t->tot_len);
 800987a:	68fb      	ldr	r3, [r7, #12]
 800987c:	891a      	ldrh	r2, [r3, #8]
 800987e:	683b      	ldr	r3, [r7, #0]
 8009880:	891b      	ldrh	r3, [r3, #8]
 8009882:	18d3      	adds	r3, r2, r3
 8009884:	b29a      	uxth	r2, r3
 8009886:	68fb      	ldr	r3, [r7, #12]
 8009888:	811a      	strh	r2, [r3, #8]
  for (p = h; p->next != NULL; p = p->next) {
 800988a:	68fb      	ldr	r3, [r7, #12]
 800988c:	681b      	ldr	r3, [r3, #0]
 800988e:	60fb      	str	r3, [r7, #12]
 8009890:	68fb      	ldr	r3, [r7, #12]
 8009892:	681b      	ldr	r3, [r3, #0]
 8009894:	2b00      	cmp	r3, #0
 8009896:	d1f0      	bne.n	800987a <pbuf_cat+0x26>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
 8009898:	68fb      	ldr	r3, [r7, #12]
 800989a:	891a      	ldrh	r2, [r3, #8]
 800989c:	68fb      	ldr	r3, [r7, #12]
 800989e:	895b      	ldrh	r3, [r3, #10]
 80098a0:	429a      	cmp	r2, r3
 80098a2:	d005      	beq.n	80098b0 <pbuf_cat+0x5c>
 80098a4:	4b0f      	ldr	r3, [pc, #60]	; (80098e4 <pbuf_cat+0x90>)
 80098a6:	4a10      	ldr	r2, [pc, #64]	; (80098e8 <pbuf_cat+0x94>)
 80098a8:	4910      	ldr	r1, [pc, #64]	; (80098ec <pbuf_cat+0x98>)
 80098aa:	4811      	ldr	r0, [pc, #68]	; (80098f0 <pbuf_cat+0x9c>)
 80098ac:	f7f8 fc8e 	bl	80021cc <app_debug_rtt_raw>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
 80098b0:	68fb      	ldr	r3, [r7, #12]
 80098b2:	681b      	ldr	r3, [r3, #0]
 80098b4:	2b00      	cmp	r3, #0
 80098b6:	d005      	beq.n	80098c4 <pbuf_cat+0x70>
 80098b8:	4b0a      	ldr	r3, [pc, #40]	; (80098e4 <pbuf_cat+0x90>)
 80098ba:	4a0e      	ldr	r2, [pc, #56]	; (80098f4 <pbuf_cat+0xa0>)
 80098bc:	490e      	ldr	r1, [pc, #56]	; (80098f8 <pbuf_cat+0xa4>)
 80098be:	480c      	ldr	r0, [pc, #48]	; (80098f0 <pbuf_cat+0x9c>)
 80098c0:	f7f8 fc84 	bl	80021cc <app_debug_rtt_raw>
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len = (u16_t)(p->tot_len + t->tot_len);
 80098c4:	68fb      	ldr	r3, [r7, #12]
 80098c6:	891a      	ldrh	r2, [r3, #8]
 80098c8:	683b      	ldr	r3, [r7, #0]
 80098ca:	891b      	ldrh	r3, [r3, #8]
 80098cc:	18d3      	adds	r3, r2, r3
 80098ce:	b29a      	uxth	r2, r3
 80098d0:	68fb      	ldr	r3, [r7, #12]
 80098d2:	811a      	strh	r2, [r3, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
 80098d4:	68fb      	ldr	r3, [r7, #12]
 80098d6:	683a      	ldr	r2, [r7, #0]
 80098d8:	601a      	str	r2, [r3, #0]
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
 80098da:	46bd      	mov	sp, r7
 80098dc:	b004      	add	sp, #16
 80098de:	bd80      	pop	{r7, pc}
 80098e0:	0801ee94 	.word	0x0801ee94
 80098e4:	0801eca4 	.word	0x0801eca4
 80098e8:	00000362 	.word	0x00000362
 80098ec:	0801eecc 	.word	0x0801eecc
 80098f0:	0801ecfc 	.word	0x0801ecfc
 80098f4:	00000363 	.word	0x00000363
 80098f8:	0801eefc 	.word	0x0801eefc

080098fc <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
 80098fc:	b580      	push	{r7, lr}
 80098fe:	b082      	sub	sp, #8
 8009900:	af00      	add	r7, sp, #0
 8009902:	6078      	str	r0, [r7, #4]
 8009904:	6039      	str	r1, [r7, #0]
  pbuf_cat(h, t);
 8009906:	683a      	ldr	r2, [r7, #0]
 8009908:	687b      	ldr	r3, [r7, #4]
 800990a:	0011      	movs	r1, r2
 800990c:	0018      	movs	r0, r3
 800990e:	f7ff ffa1 	bl	8009854 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
 8009912:	683b      	ldr	r3, [r7, #0]
 8009914:	0018      	movs	r0, r3
 8009916:	f7ff ff79 	bl	800980c <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
 800991a:	46c0      	nop			; (mov r8, r8)
 800991c:	46bd      	mov	sp, r7
 800991e:	b002      	add	sp, #8
 8009920:	bd80      	pop	{r7, pc}
	...

08009924 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
 8009924:	b590      	push	{r4, r7, lr}
 8009926:	b085      	sub	sp, #20
 8009928:	af00      	add	r7, sp, #0
 800992a:	6078      	str	r0, [r7, #4]
  struct pbuf *q;
  u8_t tail_gone = 1;
 800992c:	230f      	movs	r3, #15
 800992e:	18fb      	adds	r3, r7, r3
 8009930:	2201      	movs	r2, #1
 8009932:	701a      	strb	r2, [r3, #0]
  /* tail */
  q = p->next;
 8009934:	687b      	ldr	r3, [r7, #4]
 8009936:	681b      	ldr	r3, [r3, #0]
 8009938:	60bb      	str	r3, [r7, #8]
  /* pbuf has successor in chain? */
  if (q != NULL) {
 800993a:	68bb      	ldr	r3, [r7, #8]
 800993c:	2b00      	cmp	r3, #0
 800993e:	d027      	beq.n	8009990 <pbuf_dechain+0x6c>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
 8009940:	68bb      	ldr	r3, [r7, #8]
 8009942:	891b      	ldrh	r3, [r3, #8]
 8009944:	001a      	movs	r2, r3
 8009946:	687b      	ldr	r3, [r7, #4]
 8009948:	891b      	ldrh	r3, [r3, #8]
 800994a:	0019      	movs	r1, r3
 800994c:	687b      	ldr	r3, [r7, #4]
 800994e:	895b      	ldrh	r3, [r3, #10]
 8009950:	1acb      	subs	r3, r1, r3
 8009952:	429a      	cmp	r2, r3
 8009954:	d005      	beq.n	8009962 <pbuf_dechain+0x3e>
 8009956:	4b1a      	ldr	r3, [pc, #104]	; (80099c0 <pbuf_dechain+0x9c>)
 8009958:	4a1a      	ldr	r2, [pc, #104]	; (80099c4 <pbuf_dechain+0xa0>)
 800995a:	491b      	ldr	r1, [pc, #108]	; (80099c8 <pbuf_dechain+0xa4>)
 800995c:	481b      	ldr	r0, [pc, #108]	; (80099cc <pbuf_dechain+0xa8>)
 800995e:	f7f8 fc35 	bl	80021cc <app_debug_rtt_raw>
    /* enforce invariant if assertion is disabled */
    q->tot_len = (u16_t)(p->tot_len - p->len);
 8009962:	687b      	ldr	r3, [r7, #4]
 8009964:	891a      	ldrh	r2, [r3, #8]
 8009966:	687b      	ldr	r3, [r7, #4]
 8009968:	895b      	ldrh	r3, [r3, #10]
 800996a:	1ad3      	subs	r3, r2, r3
 800996c:	b29a      	uxth	r2, r3
 800996e:	68bb      	ldr	r3, [r7, #8]
 8009970:	811a      	strh	r2, [r3, #8]
    /* decouple pbuf from remainder */
    p->next = NULL;
 8009972:	687b      	ldr	r3, [r7, #4]
 8009974:	2200      	movs	r2, #0
 8009976:	601a      	str	r2, [r3, #0]
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
 8009978:	687b      	ldr	r3, [r7, #4]
 800997a:	895a      	ldrh	r2, [r3, #10]
 800997c:	687b      	ldr	r3, [r7, #4]
 800997e:	811a      	strh	r2, [r3, #8]
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
 8009980:	230f      	movs	r3, #15
 8009982:	18fc      	adds	r4, r7, r3
 8009984:	68bb      	ldr	r3, [r7, #8]
 8009986:	0018      	movs	r0, r3
 8009988:	f7ff fe84 	bl	8009694 <pbuf_free>
 800998c:	0003      	movs	r3, r0
 800998e:	7023      	strb	r3, [r4, #0]
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
 8009990:	687b      	ldr	r3, [r7, #4]
 8009992:	891a      	ldrh	r2, [r3, #8]
 8009994:	687b      	ldr	r3, [r7, #4]
 8009996:	895b      	ldrh	r3, [r3, #10]
 8009998:	429a      	cmp	r2, r3
 800999a:	d005      	beq.n	80099a8 <pbuf_dechain+0x84>
 800999c:	4b08      	ldr	r3, [pc, #32]	; (80099c0 <pbuf_dechain+0x9c>)
 800999e:	4a0c      	ldr	r2, [pc, #48]	; (80099d0 <pbuf_dechain+0xac>)
 80099a0:	490c      	ldr	r1, [pc, #48]	; (80099d4 <pbuf_dechain+0xb0>)
 80099a2:	480a      	ldr	r0, [pc, #40]	; (80099cc <pbuf_dechain+0xa8>)
 80099a4:	f7f8 fc12 	bl	80021cc <app_debug_rtt_raw>
  return ((tail_gone > 0) ? NULL : q);
 80099a8:	230f      	movs	r3, #15
 80099aa:	18fb      	adds	r3, r7, r3
 80099ac:	781b      	ldrb	r3, [r3, #0]
 80099ae:	2b00      	cmp	r3, #0
 80099b0:	d101      	bne.n	80099b6 <pbuf_dechain+0x92>
 80099b2:	68bb      	ldr	r3, [r7, #8]
 80099b4:	e000      	b.n	80099b8 <pbuf_dechain+0x94>
 80099b6:	2300      	movs	r3, #0
}
 80099b8:	0018      	movs	r0, r3
 80099ba:	46bd      	mov	sp, r7
 80099bc:	b005      	add	sp, #20
 80099be:	bd90      	pop	{r4, r7, pc}
 80099c0:	0801eca4 	.word	0x0801eca4
 80099c4:	00000399 	.word	0x00000399
 80099c8:	0801ef0c 	.word	0x0801ef0c
 80099cc:	0801ecfc 	.word	0x0801ecfc
 80099d0:	000003aa 	.word	0x000003aa
 80099d4:	0801ef30 	.word	0x0801ef30

080099d8 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, const struct pbuf *p_from)
{
 80099d8:	b580      	push	{r7, lr}
 80099da:	b082      	sub	sp, #8
 80099dc:	af00      	add	r7, sp, #0
 80099de:	6078      	str	r0, [r7, #4]
 80099e0:	6039      	str	r1, [r7, #0]
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
              (const void *)p_to, (const void *)p_from));

  LWIP_ERROR("pbuf_copy: invalid source", p_from != NULL, return ERR_ARG;);
 80099e2:	683b      	ldr	r3, [r7, #0]
 80099e4:	2b00      	cmp	r3, #0
 80099e6:	d106      	bne.n	80099f6 <pbuf_copy+0x1e>
 80099e8:	4b09      	ldr	r3, [pc, #36]	; (8009a10 <pbuf_copy+0x38>)
 80099ea:	0018      	movs	r0, r3
 80099ec:	f7f8 fbee 	bl	80021cc <app_debug_rtt_raw>
 80099f0:	2310      	movs	r3, #16
 80099f2:	425b      	negs	r3, r3
 80099f4:	e007      	b.n	8009a06 <pbuf_copy+0x2e>
  return pbuf_copy_partial_pbuf(p_to, p_from, p_from->tot_len, 0);
 80099f6:	683b      	ldr	r3, [r7, #0]
 80099f8:	891a      	ldrh	r2, [r3, #8]
 80099fa:	6839      	ldr	r1, [r7, #0]
 80099fc:	6878      	ldr	r0, [r7, #4]
 80099fe:	2300      	movs	r3, #0
 8009a00:	f000 f808 	bl	8009a14 <pbuf_copy_partial_pbuf>
 8009a04:	0003      	movs	r3, r0
}
 8009a06:	0018      	movs	r0, r3
 8009a08:	46bd      	mov	sp, r7
 8009a0a:	b002      	add	sp, #8
 8009a0c:	bd80      	pop	{r7, pc}
 8009a0e:	46c0      	nop			; (mov r8, r8)
 8009a10:	0801ef48 	.word	0x0801ef48

08009a14 <pbuf_copy_partial_pbuf>:
 *                 or p_to is not big enough to hold copy_len at offset
 *         ERR_VAL if any of the pbufs are part of a queue
 */
err_t
pbuf_copy_partial_pbuf(struct pbuf *p_to, const struct pbuf *p_from, u16_t copy_len, u16_t offset)
{
 8009a14:	b590      	push	{r4, r7, lr}
 8009a16:	b089      	sub	sp, #36	; 0x24
 8009a18:	af00      	add	r7, sp, #0
 8009a1a:	60f8      	str	r0, [r7, #12]
 8009a1c:	60b9      	str	r1, [r7, #8]
 8009a1e:	0019      	movs	r1, r3
 8009a20:	1dbb      	adds	r3, r7, #6
 8009a22:	801a      	strh	r2, [r3, #0]
 8009a24:	1d3b      	adds	r3, r7, #4
 8009a26:	1c0a      	adds	r2, r1, #0
 8009a28:	801a      	strh	r2, [r3, #0]
  size_t offset_to = offset, offset_from = 0, len_calc;
 8009a2a:	1d3b      	adds	r3, r7, #4
 8009a2c:	881b      	ldrh	r3, [r3, #0]
 8009a2e:	61fb      	str	r3, [r7, #28]
 8009a30:	2300      	movs	r3, #0
 8009a32:	61bb      	str	r3, [r7, #24]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy_partial_pbuf(%p, %p, %"U16_F", %"U16_F")\n",
              (const void *)p_to, (const void *)p_from, copy_len, offset));

  /* is the copy_len in range? */
  LWIP_ERROR("pbuf_copy_partial_pbuf: copy_len bigger than source", ((p_from != NULL) &&
 8009a34:	68bb      	ldr	r3, [r7, #8]
 8009a36:	2b00      	cmp	r3, #0
 8009a38:	d005      	beq.n	8009a46 <pbuf_copy_partial_pbuf+0x32>
 8009a3a:	68bb      	ldr	r3, [r7, #8]
 8009a3c:	891b      	ldrh	r3, [r3, #8]
 8009a3e:	1dba      	adds	r2, r7, #6
 8009a40:	8812      	ldrh	r2, [r2, #0]
 8009a42:	429a      	cmp	r2, r3
 8009a44:	d906      	bls.n	8009a54 <pbuf_copy_partial_pbuf+0x40>
 8009a46:	4b6d      	ldr	r3, [pc, #436]	; (8009bfc <pbuf_copy_partial_pbuf+0x1e8>)
 8009a48:	0018      	movs	r0, r3
 8009a4a:	f7f8 fbbf 	bl	80021cc <app_debug_rtt_raw>
 8009a4e:	2310      	movs	r3, #16
 8009a50:	425b      	negs	r3, r3
 8009a52:	e0cf      	b.n	8009bf4 <pbuf_copy_partial_pbuf+0x1e0>
             (p_from->tot_len >= copy_len)), return ERR_ARG;);
  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy_partial_pbuf: target not big enough", ((p_to != NULL) &&
 8009a54:	68fb      	ldr	r3, [r7, #12]
 8009a56:	2b00      	cmp	r3, #0
 8009a58:	d009      	beq.n	8009a6e <pbuf_copy_partial_pbuf+0x5a>
 8009a5a:	68fb      	ldr	r3, [r7, #12]
 8009a5c:	891b      	ldrh	r3, [r3, #8]
 8009a5e:	0019      	movs	r1, r3
 8009a60:	1d3b      	adds	r3, r7, #4
 8009a62:	881a      	ldrh	r2, [r3, #0]
 8009a64:	1dbb      	adds	r3, r7, #6
 8009a66:	881b      	ldrh	r3, [r3, #0]
 8009a68:	18d3      	adds	r3, r2, r3
 8009a6a:	4299      	cmp	r1, r3
 8009a6c:	da06      	bge.n	8009a7c <pbuf_copy_partial_pbuf+0x68>
 8009a6e:	4b64      	ldr	r3, [pc, #400]	; (8009c00 <pbuf_copy_partial_pbuf+0x1ec>)
 8009a70:	0018      	movs	r0, r3
 8009a72:	f7f8 fbab 	bl	80021cc <app_debug_rtt_raw>
 8009a76:	2310      	movs	r3, #16
 8009a78:	425b      	negs	r3, r3
 8009a7a:	e0bb      	b.n	8009bf4 <pbuf_copy_partial_pbuf+0x1e0>
             (p_to->tot_len >= (offset + copy_len))), return ERR_ARG;);

  /* iterate through pbuf chain */
  do {
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 8009a7c:	68fb      	ldr	r3, [r7, #12]
 8009a7e:	895b      	ldrh	r3, [r3, #10]
 8009a80:	001a      	movs	r2, r3
 8009a82:	69fb      	ldr	r3, [r7, #28]
 8009a84:	1ad2      	subs	r2, r2, r3
 8009a86:	68bb      	ldr	r3, [r7, #8]
 8009a88:	895b      	ldrh	r3, [r3, #10]
 8009a8a:	0019      	movs	r1, r3
 8009a8c:	69bb      	ldr	r3, [r7, #24]
 8009a8e:	1acb      	subs	r3, r1, r3
 8009a90:	429a      	cmp	r2, r3
 8009a92:	d306      	bcc.n	8009aa2 <pbuf_copy_partial_pbuf+0x8e>
      /* complete current p_from fits into current p_to */
      len_calc = p_from->len - offset_from;
 8009a94:	68bb      	ldr	r3, [r7, #8]
 8009a96:	895b      	ldrh	r3, [r3, #10]
 8009a98:	001a      	movs	r2, r3
 8009a9a:	69bb      	ldr	r3, [r7, #24]
 8009a9c:	1ad3      	subs	r3, r2, r3
 8009a9e:	617b      	str	r3, [r7, #20]
 8009aa0:	e005      	b.n	8009aae <pbuf_copy_partial_pbuf+0x9a>
    } else {
      /* current p_from does not fit into current p_to */
      len_calc = p_to->len - offset_to;
 8009aa2:	68fb      	ldr	r3, [r7, #12]
 8009aa4:	895b      	ldrh	r3, [r3, #10]
 8009aa6:	001a      	movs	r2, r3
 8009aa8:	69fb      	ldr	r3, [r7, #28]
 8009aaa:	1ad3      	subs	r3, r2, r3
 8009aac:	617b      	str	r3, [r7, #20]
    }
    len = (u16_t)LWIP_MIN(copy_len, len_calc);
 8009aae:	1dbb      	adds	r3, r7, #6
 8009ab0:	881b      	ldrh	r3, [r3, #0]
 8009ab2:	697a      	ldr	r2, [r7, #20]
 8009ab4:	429a      	cmp	r2, r3
 8009ab6:	d802      	bhi.n	8009abe <pbuf_copy_partial_pbuf+0xaa>
 8009ab8:	697b      	ldr	r3, [r7, #20]
 8009aba:	b29b      	uxth	r3, r3
 8009abc:	e001      	b.n	8009ac2 <pbuf_copy_partial_pbuf+0xae>
 8009abe:	1dbb      	adds	r3, r7, #6
 8009ac0:	881b      	ldrh	r3, [r3, #0]
 8009ac2:	2412      	movs	r4, #18
 8009ac4:	193a      	adds	r2, r7, r4
 8009ac6:	8013      	strh	r3, [r2, #0]
    MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
 8009ac8:	68fb      	ldr	r3, [r7, #12]
 8009aca:	685a      	ldr	r2, [r3, #4]
 8009acc:	69fb      	ldr	r3, [r7, #28]
 8009ace:	18d0      	adds	r0, r2, r3
 8009ad0:	68bb      	ldr	r3, [r7, #8]
 8009ad2:	685a      	ldr	r2, [r3, #4]
 8009ad4:	69bb      	ldr	r3, [r7, #24]
 8009ad6:	18d1      	adds	r1, r2, r3
 8009ad8:	193b      	adds	r3, r7, r4
 8009ada:	881b      	ldrh	r3, [r3, #0]
 8009adc:	001a      	movs	r2, r3
 8009ade:	f012 fe89 	bl	801c7f4 <memcpy>
    offset_to += len;
 8009ae2:	193b      	adds	r3, r7, r4
 8009ae4:	881b      	ldrh	r3, [r3, #0]
 8009ae6:	69fa      	ldr	r2, [r7, #28]
 8009ae8:	18d3      	adds	r3, r2, r3
 8009aea:	61fb      	str	r3, [r7, #28]
    offset_from += len;
 8009aec:	193b      	adds	r3, r7, r4
 8009aee:	881b      	ldrh	r3, [r3, #0]
 8009af0:	69ba      	ldr	r2, [r7, #24]
 8009af2:	18d3      	adds	r3, r2, r3
 8009af4:	61bb      	str	r3, [r7, #24]
    copy_len -= len;
 8009af6:	1dbb      	adds	r3, r7, #6
 8009af8:	1db9      	adds	r1, r7, #6
 8009afa:	193a      	adds	r2, r7, r4
 8009afc:	8809      	ldrh	r1, [r1, #0]
 8009afe:	8812      	ldrh	r2, [r2, #0]
 8009b00:	1a8a      	subs	r2, r1, r2
 8009b02:	801a      	strh	r2, [r3, #0]
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 8009b04:	68fb      	ldr	r3, [r7, #12]
 8009b06:	895b      	ldrh	r3, [r3, #10]
 8009b08:	001a      	movs	r2, r3
 8009b0a:	69fb      	ldr	r3, [r7, #28]
 8009b0c:	4293      	cmp	r3, r2
 8009b0e:	d905      	bls.n	8009b1c <pbuf_copy_partial_pbuf+0x108>
 8009b10:	4b3c      	ldr	r3, [pc, #240]	; (8009c04 <pbuf_copy_partial_pbuf+0x1f0>)
 8009b12:	4a3d      	ldr	r2, [pc, #244]	; (8009c08 <pbuf_copy_partial_pbuf+0x1f4>)
 8009b14:	493d      	ldr	r1, [pc, #244]	; (8009c0c <pbuf_copy_partial_pbuf+0x1f8>)
 8009b16:	483e      	ldr	r0, [pc, #248]	; (8009c10 <pbuf_copy_partial_pbuf+0x1fc>)
 8009b18:	f7f8 fb58 	bl	80021cc <app_debug_rtt_raw>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
 8009b1c:	68bb      	ldr	r3, [r7, #8]
 8009b1e:	895b      	ldrh	r3, [r3, #10]
 8009b20:	001a      	movs	r2, r3
 8009b22:	69bb      	ldr	r3, [r7, #24]
 8009b24:	4293      	cmp	r3, r2
 8009b26:	d905      	bls.n	8009b34 <pbuf_copy_partial_pbuf+0x120>
 8009b28:	4b36      	ldr	r3, [pc, #216]	; (8009c04 <pbuf_copy_partial_pbuf+0x1f0>)
 8009b2a:	4a3a      	ldr	r2, [pc, #232]	; (8009c14 <pbuf_copy_partial_pbuf+0x200>)
 8009b2c:	493a      	ldr	r1, [pc, #232]	; (8009c18 <pbuf_copy_partial_pbuf+0x204>)
 8009b2e:	4838      	ldr	r0, [pc, #224]	; (8009c10 <pbuf_copy_partial_pbuf+0x1fc>)
 8009b30:	f7f8 fb4c 	bl	80021cc <app_debug_rtt_raw>
    if (offset_from >= p_from->len) {
 8009b34:	68bb      	ldr	r3, [r7, #8]
 8009b36:	895b      	ldrh	r3, [r3, #10]
 8009b38:	001a      	movs	r2, r3
 8009b3a:	69bb      	ldr	r3, [r7, #24]
 8009b3c:	4293      	cmp	r3, r2
 8009b3e:	d312      	bcc.n	8009b66 <pbuf_copy_partial_pbuf+0x152>
      /* on to next p_from (if any) */
      offset_from = 0;
 8009b40:	2300      	movs	r3, #0
 8009b42:	61bb      	str	r3, [r7, #24]
      p_from = p_from->next;
 8009b44:	68bb      	ldr	r3, [r7, #8]
 8009b46:	681b      	ldr	r3, [r3, #0]
 8009b48:	60bb      	str	r3, [r7, #8]
      LWIP_ERROR("p_from != NULL", (p_from != NULL) || (copy_len == 0), return ERR_ARG;);
 8009b4a:	68bb      	ldr	r3, [r7, #8]
 8009b4c:	2b00      	cmp	r3, #0
 8009b4e:	d10a      	bne.n	8009b66 <pbuf_copy_partial_pbuf+0x152>
 8009b50:	1dbb      	adds	r3, r7, #6
 8009b52:	881b      	ldrh	r3, [r3, #0]
 8009b54:	2b00      	cmp	r3, #0
 8009b56:	d006      	beq.n	8009b66 <pbuf_copy_partial_pbuf+0x152>
 8009b58:	4b30      	ldr	r3, [pc, #192]	; (8009c1c <pbuf_copy_partial_pbuf+0x208>)
 8009b5a:	0018      	movs	r0, r3
 8009b5c:	f7f8 fb36 	bl	80021cc <app_debug_rtt_raw>
 8009b60:	2310      	movs	r3, #16
 8009b62:	425b      	negs	r3, r3
 8009b64:	e046      	b.n	8009bf4 <pbuf_copy_partial_pbuf+0x1e0>
    }
    if (offset_to == p_to->len) {
 8009b66:	68fb      	ldr	r3, [r7, #12]
 8009b68:	895b      	ldrh	r3, [r3, #10]
 8009b6a:	001a      	movs	r2, r3
 8009b6c:	69fb      	ldr	r3, [r7, #28]
 8009b6e:	4293      	cmp	r3, r2
 8009b70:	d112      	bne.n	8009b98 <pbuf_copy_partial_pbuf+0x184>
      /* on to next p_to (if any) */
      offset_to = 0;
 8009b72:	2300      	movs	r3, #0
 8009b74:	61fb      	str	r3, [r7, #28]
      p_to = p_to->next;
 8009b76:	68fb      	ldr	r3, [r7, #12]
 8009b78:	681b      	ldr	r3, [r3, #0]
 8009b7a:	60fb      	str	r3, [r7, #12]
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (copy_len == 0), return ERR_ARG;);
 8009b7c:	68fb      	ldr	r3, [r7, #12]
 8009b7e:	2b00      	cmp	r3, #0
 8009b80:	d10a      	bne.n	8009b98 <pbuf_copy_partial_pbuf+0x184>
 8009b82:	1dbb      	adds	r3, r7, #6
 8009b84:	881b      	ldrh	r3, [r3, #0]
 8009b86:	2b00      	cmp	r3, #0
 8009b88:	d006      	beq.n	8009b98 <pbuf_copy_partial_pbuf+0x184>
 8009b8a:	4b25      	ldr	r3, [pc, #148]	; (8009c20 <pbuf_copy_partial_pbuf+0x20c>)
 8009b8c:	0018      	movs	r0, r3
 8009b8e:	f7f8 fb1d 	bl	80021cc <app_debug_rtt_raw>
 8009b92:	2310      	movs	r3, #16
 8009b94:	425b      	negs	r3, r3
 8009b96:	e02d      	b.n	8009bf4 <pbuf_copy_partial_pbuf+0x1e0>
    }

    if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 8009b98:	68bb      	ldr	r3, [r7, #8]
 8009b9a:	2b00      	cmp	r3, #0
 8009b9c:	d010      	beq.n	8009bc0 <pbuf_copy_partial_pbuf+0x1ac>
 8009b9e:	68bb      	ldr	r3, [r7, #8]
 8009ba0:	895a      	ldrh	r2, [r3, #10]
 8009ba2:	68bb      	ldr	r3, [r7, #8]
 8009ba4:	891b      	ldrh	r3, [r3, #8]
 8009ba6:	429a      	cmp	r2, r3
 8009ba8:	d10a      	bne.n	8009bc0 <pbuf_copy_partial_pbuf+0x1ac>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy_partial_pbuf() does not allow packet queues!",
 8009baa:	68bb      	ldr	r3, [r7, #8]
 8009bac:	681b      	ldr	r3, [r3, #0]
 8009bae:	2b00      	cmp	r3, #0
 8009bb0:	d006      	beq.n	8009bc0 <pbuf_copy_partial_pbuf+0x1ac>
 8009bb2:	4b1c      	ldr	r3, [pc, #112]	; (8009c24 <pbuf_copy_partial_pbuf+0x210>)
 8009bb4:	0018      	movs	r0, r3
 8009bb6:	f7f8 fb09 	bl	80021cc <app_debug_rtt_raw>
 8009bba:	2306      	movs	r3, #6
 8009bbc:	425b      	negs	r3, r3
 8009bbe:	e019      	b.n	8009bf4 <pbuf_copy_partial_pbuf+0x1e0>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 8009bc0:	68fb      	ldr	r3, [r7, #12]
 8009bc2:	2b00      	cmp	r3, #0
 8009bc4:	d010      	beq.n	8009be8 <pbuf_copy_partial_pbuf+0x1d4>
 8009bc6:	68fb      	ldr	r3, [r7, #12]
 8009bc8:	895a      	ldrh	r2, [r3, #10]
 8009bca:	68fb      	ldr	r3, [r7, #12]
 8009bcc:	891b      	ldrh	r3, [r3, #8]
 8009bce:	429a      	cmp	r2, r3
 8009bd0:	d10a      	bne.n	8009be8 <pbuf_copy_partial_pbuf+0x1d4>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy_partial_pbuf() does not allow packet queues!",
 8009bd2:	68fb      	ldr	r3, [r7, #12]
 8009bd4:	681b      	ldr	r3, [r3, #0]
 8009bd6:	2b00      	cmp	r3, #0
 8009bd8:	d006      	beq.n	8009be8 <pbuf_copy_partial_pbuf+0x1d4>
 8009bda:	4b12      	ldr	r3, [pc, #72]	; (8009c24 <pbuf_copy_partial_pbuf+0x210>)
 8009bdc:	0018      	movs	r0, r3
 8009bde:	f7f8 faf5 	bl	80021cc <app_debug_rtt_raw>
 8009be2:	2306      	movs	r3, #6
 8009be4:	425b      	negs	r3, r3
 8009be6:	e005      	b.n	8009bf4 <pbuf_copy_partial_pbuf+0x1e0>
                 (p_to->next == NULL), return ERR_VAL;);
    }
  } while (copy_len);
 8009be8:	1dbb      	adds	r3, r7, #6
 8009bea:	881b      	ldrh	r3, [r3, #0]
 8009bec:	2b00      	cmp	r3, #0
 8009bee:	d000      	beq.n	8009bf2 <pbuf_copy_partial_pbuf+0x1de>
 8009bf0:	e744      	b.n	8009a7c <pbuf_copy_partial_pbuf+0x68>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy_partial_pbuf: copy complete.\n"));
  return ERR_OK;
 8009bf2:	2300      	movs	r3, #0
}
 8009bf4:	0018      	movs	r0, r3
 8009bf6:	46bd      	mov	sp, r7
 8009bf8:	b009      	add	sp, #36	; 0x24
 8009bfa:	bd90      	pop	{r4, r7, pc}
 8009bfc:	0801ef64 	.word	0x0801ef64
 8009c00:	0801ef98 	.word	0x0801ef98
 8009c04:	0801eca4 	.word	0x0801eca4
 8009c08:	000003fa 	.word	0x000003fa
 8009c0c:	0801efc8 	.word	0x0801efc8
 8009c10:	0801ecfc 	.word	0x0801ecfc
 8009c14:	000003fb 	.word	0x000003fb
 8009c18:	0801efe0 	.word	0x0801efe0
 8009c1c:	0801effc 	.word	0x0801effc
 8009c20:	0801f00c 	.word	0x0801f00c
 8009c24:	0801f01c 	.word	0x0801f01c

08009c28 <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(const struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
 8009c28:	b5b0      	push	{r4, r5, r7, lr}
 8009c2a:	b088      	sub	sp, #32
 8009c2c:	af00      	add	r7, sp, #0
 8009c2e:	60f8      	str	r0, [r7, #12]
 8009c30:	60b9      	str	r1, [r7, #8]
 8009c32:	0019      	movs	r1, r3
 8009c34:	1dbb      	adds	r3, r7, #6
 8009c36:	801a      	strh	r2, [r3, #0]
 8009c38:	1d3b      	adds	r3, r7, #4
 8009c3a:	1c0a      	adds	r2, r1, #0
 8009c3c:	801a      	strh	r2, [r3, #0]
  const struct pbuf *p;
  u16_t left = 0;
 8009c3e:	231a      	movs	r3, #26
 8009c40:	18fb      	adds	r3, r7, r3
 8009c42:	2200      	movs	r2, #0
 8009c44:	801a      	strh	r2, [r3, #0]
  u16_t buf_copy_len;
  u16_t copied_total = 0;
 8009c46:	2316      	movs	r3, #22
 8009c48:	18fb      	adds	r3, r7, r3
 8009c4a:	2200      	movs	r2, #0
 8009c4c:	801a      	strh	r2, [r3, #0]

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 8009c4e:	68fb      	ldr	r3, [r7, #12]
 8009c50:	2b00      	cmp	r3, #0
 8009c52:	d105      	bne.n	8009c60 <pbuf_copy_partial+0x38>
 8009c54:	4b38      	ldr	r3, [pc, #224]	; (8009d38 <pbuf_copy_partial+0x110>)
 8009c56:	0018      	movs	r0, r3
 8009c58:	f7f8 fab8 	bl	80021cc <app_debug_rtt_raw>
 8009c5c:	2300      	movs	r3, #0
 8009c5e:	e066      	b.n	8009d2e <pbuf_copy_partial+0x106>
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 8009c60:	68bb      	ldr	r3, [r7, #8]
 8009c62:	2b00      	cmp	r3, #0
 8009c64:	d105      	bne.n	8009c72 <pbuf_copy_partial+0x4a>
 8009c66:	4b35      	ldr	r3, [pc, #212]	; (8009d3c <pbuf_copy_partial+0x114>)
 8009c68:	0018      	movs	r0, r3
 8009c6a:	f7f8 faaf 	bl	80021cc <app_debug_rtt_raw>
 8009c6e:	2300      	movs	r3, #0
 8009c70:	e05d      	b.n	8009d2e <pbuf_copy_partial+0x106>

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for (p = buf; len != 0 && p != NULL; p = p->next) {
 8009c72:	68fb      	ldr	r3, [r7, #12]
 8009c74:	61fb      	str	r3, [r7, #28]
 8009c76:	e050      	b.n	8009d1a <pbuf_copy_partial+0xf2>
    if ((offset != 0) && (offset >= p->len)) {
 8009c78:	1d3b      	adds	r3, r7, #4
 8009c7a:	881b      	ldrh	r3, [r3, #0]
 8009c7c:	2b00      	cmp	r3, #0
 8009c7e:	d00d      	beq.n	8009c9c <pbuf_copy_partial+0x74>
 8009c80:	69fb      	ldr	r3, [r7, #28]
 8009c82:	895b      	ldrh	r3, [r3, #10]
 8009c84:	1d3a      	adds	r2, r7, #4
 8009c86:	8812      	ldrh	r2, [r2, #0]
 8009c88:	429a      	cmp	r2, r3
 8009c8a:	d307      	bcc.n	8009c9c <pbuf_copy_partial+0x74>
      /* don't copy from this buffer -> on to the next */
      offset = (u16_t)(offset - p->len);
 8009c8c:	69fb      	ldr	r3, [r7, #28]
 8009c8e:	895a      	ldrh	r2, [r3, #10]
 8009c90:	1d3b      	adds	r3, r7, #4
 8009c92:	1d39      	adds	r1, r7, #4
 8009c94:	8809      	ldrh	r1, [r1, #0]
 8009c96:	1a8a      	subs	r2, r1, r2
 8009c98:	801a      	strh	r2, [r3, #0]
 8009c9a:	e03b      	b.n	8009d14 <pbuf_copy_partial+0xec>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = (u16_t)(p->len - offset);
 8009c9c:	69fb      	ldr	r3, [r7, #28]
 8009c9e:	8959      	ldrh	r1, [r3, #10]
 8009ca0:	2018      	movs	r0, #24
 8009ca2:	183b      	adds	r3, r7, r0
 8009ca4:	1d3a      	adds	r2, r7, #4
 8009ca6:	8812      	ldrh	r2, [r2, #0]
 8009ca8:	1a8a      	subs	r2, r1, r2
 8009caa:	801a      	strh	r2, [r3, #0]
      if (buf_copy_len > len) {
 8009cac:	183a      	adds	r2, r7, r0
 8009cae:	1dbb      	adds	r3, r7, #6
 8009cb0:	8812      	ldrh	r2, [r2, #0]
 8009cb2:	881b      	ldrh	r3, [r3, #0]
 8009cb4:	429a      	cmp	r2, r3
 8009cb6:	d903      	bls.n	8009cc0 <pbuf_copy_partial+0x98>
        buf_copy_len = len;
 8009cb8:	183b      	adds	r3, r7, r0
 8009cba:	1dba      	adds	r2, r7, #6
 8009cbc:	8812      	ldrh	r2, [r2, #0]
 8009cbe:	801a      	strh	r2, [r3, #0]
      }
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
 8009cc0:	251a      	movs	r5, #26
 8009cc2:	197b      	adds	r3, r7, r5
 8009cc4:	881b      	ldrh	r3, [r3, #0]
 8009cc6:	68ba      	ldr	r2, [r7, #8]
 8009cc8:	18d0      	adds	r0, r2, r3
 8009cca:	69fb      	ldr	r3, [r7, #28]
 8009ccc:	685a      	ldr	r2, [r3, #4]
 8009cce:	1d3b      	adds	r3, r7, #4
 8009cd0:	881b      	ldrh	r3, [r3, #0]
 8009cd2:	18d1      	adds	r1, r2, r3
 8009cd4:	2418      	movs	r4, #24
 8009cd6:	193b      	adds	r3, r7, r4
 8009cd8:	881b      	ldrh	r3, [r3, #0]
 8009cda:	001a      	movs	r2, r3
 8009cdc:	f012 fd8a 	bl	801c7f4 <memcpy>
      copied_total = (u16_t)(copied_total + buf_copy_len);
 8009ce0:	2216      	movs	r2, #22
 8009ce2:	18bb      	adds	r3, r7, r2
 8009ce4:	18b9      	adds	r1, r7, r2
 8009ce6:	0020      	movs	r0, r4
 8009ce8:	183a      	adds	r2, r7, r0
 8009cea:	8809      	ldrh	r1, [r1, #0]
 8009cec:	8812      	ldrh	r2, [r2, #0]
 8009cee:	188a      	adds	r2, r1, r2
 8009cf0:	801a      	strh	r2, [r3, #0]
      left = (u16_t)(left + buf_copy_len);
 8009cf2:	197b      	adds	r3, r7, r5
 8009cf4:	1979      	adds	r1, r7, r5
 8009cf6:	183a      	adds	r2, r7, r0
 8009cf8:	8809      	ldrh	r1, [r1, #0]
 8009cfa:	8812      	ldrh	r2, [r2, #0]
 8009cfc:	188a      	adds	r2, r1, r2
 8009cfe:	801a      	strh	r2, [r3, #0]
      len = (u16_t)(len - buf_copy_len);
 8009d00:	1dbb      	adds	r3, r7, #6
 8009d02:	1db9      	adds	r1, r7, #6
 8009d04:	183a      	adds	r2, r7, r0
 8009d06:	8809      	ldrh	r1, [r1, #0]
 8009d08:	8812      	ldrh	r2, [r2, #0]
 8009d0a:	1a8a      	subs	r2, r1, r2
 8009d0c:	801a      	strh	r2, [r3, #0]
      offset = 0;
 8009d0e:	1d3b      	adds	r3, r7, #4
 8009d10:	2200      	movs	r2, #0
 8009d12:	801a      	strh	r2, [r3, #0]
  for (p = buf; len != 0 && p != NULL; p = p->next) {
 8009d14:	69fb      	ldr	r3, [r7, #28]
 8009d16:	681b      	ldr	r3, [r3, #0]
 8009d18:	61fb      	str	r3, [r7, #28]
 8009d1a:	1dbb      	adds	r3, r7, #6
 8009d1c:	881b      	ldrh	r3, [r3, #0]
 8009d1e:	2b00      	cmp	r3, #0
 8009d20:	d002      	beq.n	8009d28 <pbuf_copy_partial+0x100>
 8009d22:	69fb      	ldr	r3, [r7, #28]
 8009d24:	2b00      	cmp	r3, #0
 8009d26:	d1a7      	bne.n	8009c78 <pbuf_copy_partial+0x50>
    }
  }
  return copied_total;
 8009d28:	2316      	movs	r3, #22
 8009d2a:	18fb      	adds	r3, r7, r3
 8009d2c:	881b      	ldrh	r3, [r3, #0]
}
 8009d2e:	0018      	movs	r0, r3
 8009d30:	46bd      	mov	sp, r7
 8009d32:	b008      	add	sp, #32
 8009d34:	bdb0      	pop	{r4, r5, r7, pc}
 8009d36:	46c0      	nop			; (mov r8, r8)
 8009d38:	0801f054 	.word	0x0801f054
 8009d3c:	0801f074 	.word	0x0801f074

08009d40 <pbuf_skip_const>:
#endif /* LWIP_TCP && TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */

/* Actual implementation of pbuf_skip() but returning const pointer... */
static const struct pbuf *
pbuf_skip_const(const struct pbuf *in, u16_t in_offset, u16_t *out_offset)
{
 8009d40:	b580      	push	{r7, lr}
 8009d42:	b086      	sub	sp, #24
 8009d44:	af00      	add	r7, sp, #0
 8009d46:	60f8      	str	r0, [r7, #12]
 8009d48:	607a      	str	r2, [r7, #4]
 8009d4a:	200a      	movs	r0, #10
 8009d4c:	183b      	adds	r3, r7, r0
 8009d4e:	1c0a      	adds	r2, r1, #0
 8009d50:	801a      	strh	r2, [r3, #0]
  u16_t offset_left = in_offset;
 8009d52:	2316      	movs	r3, #22
 8009d54:	18fb      	adds	r3, r7, r3
 8009d56:	183a      	adds	r2, r7, r0
 8009d58:	8812      	ldrh	r2, [r2, #0]
 8009d5a:	801a      	strh	r2, [r3, #0]
  const struct pbuf *q = in;
 8009d5c:	68fb      	ldr	r3, [r7, #12]
 8009d5e:	613b      	str	r3, [r7, #16]

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= offset_left)) {
 8009d60:	e00a      	b.n	8009d78 <pbuf_skip_const+0x38>
    offset_left = (u16_t)(offset_left - q->len);
 8009d62:	693b      	ldr	r3, [r7, #16]
 8009d64:	895a      	ldrh	r2, [r3, #10]
 8009d66:	2116      	movs	r1, #22
 8009d68:	187b      	adds	r3, r7, r1
 8009d6a:	1879      	adds	r1, r7, r1
 8009d6c:	8809      	ldrh	r1, [r1, #0]
 8009d6e:	1a8a      	subs	r2, r1, r2
 8009d70:	801a      	strh	r2, [r3, #0]
    q = q->next;
 8009d72:	693b      	ldr	r3, [r7, #16]
 8009d74:	681b      	ldr	r3, [r3, #0]
 8009d76:	613b      	str	r3, [r7, #16]
  while ((q != NULL) && (q->len <= offset_left)) {
 8009d78:	693b      	ldr	r3, [r7, #16]
 8009d7a:	2b00      	cmp	r3, #0
 8009d7c:	d006      	beq.n	8009d8c <pbuf_skip_const+0x4c>
 8009d7e:	693b      	ldr	r3, [r7, #16]
 8009d80:	895b      	ldrh	r3, [r3, #10]
 8009d82:	2216      	movs	r2, #22
 8009d84:	18ba      	adds	r2, r7, r2
 8009d86:	8812      	ldrh	r2, [r2, #0]
 8009d88:	429a      	cmp	r2, r3
 8009d8a:	d2ea      	bcs.n	8009d62 <pbuf_skip_const+0x22>
  }
  if (out_offset != NULL) {
 8009d8c:	687b      	ldr	r3, [r7, #4]
 8009d8e:	2b00      	cmp	r3, #0
 8009d90:	d004      	beq.n	8009d9c <pbuf_skip_const+0x5c>
    *out_offset = offset_left;
 8009d92:	687b      	ldr	r3, [r7, #4]
 8009d94:	2216      	movs	r2, #22
 8009d96:	18ba      	adds	r2, r7, r2
 8009d98:	8812      	ldrh	r2, [r2, #0]
 8009d9a:	801a      	strh	r2, [r3, #0]
  }
  return q;
 8009d9c:	693b      	ldr	r3, [r7, #16]
}
 8009d9e:	0018      	movs	r0, r3
 8009da0:	46bd      	mov	sp, r7
 8009da2:	b006      	add	sp, #24
 8009da4:	bd80      	pop	{r7, pc}

08009da6 <pbuf_skip>:
 * @param out_offset resulting offset in the returned pbuf
 * @return the pbuf in the queue where the offset is
 */
struct pbuf *
pbuf_skip(struct pbuf *in, u16_t in_offset, u16_t *out_offset)
{
 8009da6:	b580      	push	{r7, lr}
 8009da8:	b086      	sub	sp, #24
 8009daa:	af00      	add	r7, sp, #0
 8009dac:	60f8      	str	r0, [r7, #12]
 8009dae:	607a      	str	r2, [r7, #4]
 8009db0:	200a      	movs	r0, #10
 8009db2:	183b      	adds	r3, r7, r0
 8009db4:	1c0a      	adds	r2, r1, #0
 8009db6:	801a      	strh	r2, [r3, #0]
  const struct pbuf *out = pbuf_skip_const(in, in_offset, out_offset);
 8009db8:	687a      	ldr	r2, [r7, #4]
 8009dba:	183b      	adds	r3, r7, r0
 8009dbc:	8819      	ldrh	r1, [r3, #0]
 8009dbe:	68fb      	ldr	r3, [r7, #12]
 8009dc0:	0018      	movs	r0, r3
 8009dc2:	f7ff ffbd 	bl	8009d40 <pbuf_skip_const>
 8009dc6:	0003      	movs	r3, r0
 8009dc8:	617b      	str	r3, [r7, #20]
  return LWIP_CONST_CAST(struct pbuf *, out);
 8009dca:	697b      	ldr	r3, [r7, #20]
}
 8009dcc:	0018      	movs	r0, r3
 8009dce:	46bd      	mov	sp, r7
 8009dd0:	b006      	add	sp, #24
 8009dd2:	bd80      	pop	{r7, pc}

08009dd4 <pbuf_take>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
 8009dd4:	b580      	push	{r7, lr}
 8009dd6:	b088      	sub	sp, #32
 8009dd8:	af00      	add	r7, sp, #0
 8009dda:	60f8      	str	r0, [r7, #12]
 8009ddc:	60b9      	str	r1, [r7, #8]
 8009dde:	1dbb      	adds	r3, r7, #6
 8009de0:	801a      	strh	r2, [r3, #0]
  struct pbuf *p;
  size_t buf_copy_len;
  size_t total_copy_len = len;
 8009de2:	1dbb      	adds	r3, r7, #6
 8009de4:	881b      	ldrh	r3, [r3, #0]
 8009de6:	617b      	str	r3, [r7, #20]
  size_t copied_total = 0;
 8009de8:	2300      	movs	r3, #0
 8009dea:	613b      	str	r3, [r7, #16]

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return ERR_ARG;);
 8009dec:	68fb      	ldr	r3, [r7, #12]
 8009dee:	2b00      	cmp	r3, #0
 8009df0:	d106      	bne.n	8009e00 <pbuf_take+0x2c>
 8009df2:	4b37      	ldr	r3, [pc, #220]	; (8009ed0 <pbuf_take+0xfc>)
 8009df4:	0018      	movs	r0, r3
 8009df6:	f7f8 f9e9 	bl	80021cc <app_debug_rtt_raw>
 8009dfa:	2310      	movs	r3, #16
 8009dfc:	425b      	negs	r3, r3
 8009dfe:	e062      	b.n	8009ec6 <pbuf_take+0xf2>
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 8009e00:	68bb      	ldr	r3, [r7, #8]
 8009e02:	2b00      	cmp	r3, #0
 8009e04:	d106      	bne.n	8009e14 <pbuf_take+0x40>
 8009e06:	4b33      	ldr	r3, [pc, #204]	; (8009ed4 <pbuf_take+0x100>)
 8009e08:	0018      	movs	r0, r3
 8009e0a:	f7f8 f9df 	bl	80021cc <app_debug_rtt_raw>
 8009e0e:	2310      	movs	r3, #16
 8009e10:	425b      	negs	r3, r3
 8009e12:	e058      	b.n	8009ec6 <pbuf_take+0xf2>
  LWIP_ERROR("pbuf_take: buf not large enough", (buf->tot_len >= len), return ERR_MEM;);
 8009e14:	68fb      	ldr	r3, [r7, #12]
 8009e16:	891b      	ldrh	r3, [r3, #8]
 8009e18:	1dba      	adds	r2, r7, #6
 8009e1a:	8812      	ldrh	r2, [r2, #0]
 8009e1c:	429a      	cmp	r2, r3
 8009e1e:	d906      	bls.n	8009e2e <pbuf_take+0x5a>
 8009e20:	4b2d      	ldr	r3, [pc, #180]	; (8009ed8 <pbuf_take+0x104>)
 8009e22:	0018      	movs	r0, r3
 8009e24:	f7f8 f9d2 	bl	80021cc <app_debug_rtt_raw>
 8009e28:	2301      	movs	r3, #1
 8009e2a:	425b      	negs	r3, r3
 8009e2c:	e04b      	b.n	8009ec6 <pbuf_take+0xf2>

  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
 8009e2e:	68fb      	ldr	r3, [r7, #12]
 8009e30:	2b00      	cmp	r3, #0
 8009e32:	d008      	beq.n	8009e46 <pbuf_take+0x72>
 8009e34:	68bb      	ldr	r3, [r7, #8]
 8009e36:	2b00      	cmp	r3, #0
 8009e38:	d005      	beq.n	8009e46 <pbuf_take+0x72>
 8009e3a:	68fb      	ldr	r3, [r7, #12]
 8009e3c:	891b      	ldrh	r3, [r3, #8]
 8009e3e:	1dba      	adds	r2, r7, #6
 8009e40:	8812      	ldrh	r2, [r2, #0]
 8009e42:	429a      	cmp	r2, r3
 8009e44:	d902      	bls.n	8009e4c <pbuf_take+0x78>
    return ERR_ARG;
 8009e46:	2310      	movs	r3, #16
 8009e48:	425b      	negs	r3, r3
 8009e4a:	e03c      	b.n	8009ec6 <pbuf_take+0xf2>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for (p = buf; total_copy_len != 0; p = p->next) {
 8009e4c:	68fb      	ldr	r3, [r7, #12]
 8009e4e:	61fb      	str	r3, [r7, #28]
 8009e50:	e027      	b.n	8009ea2 <pbuf_take+0xce>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
 8009e52:	69fb      	ldr	r3, [r7, #28]
 8009e54:	2b00      	cmp	r3, #0
 8009e56:	d105      	bne.n	8009e64 <pbuf_take+0x90>
 8009e58:	4b20      	ldr	r3, [pc, #128]	; (8009edc <pbuf_take+0x108>)
 8009e5a:	4a21      	ldr	r2, [pc, #132]	; (8009ee0 <pbuf_take+0x10c>)
 8009e5c:	4921      	ldr	r1, [pc, #132]	; (8009ee4 <pbuf_take+0x110>)
 8009e5e:	4822      	ldr	r0, [pc, #136]	; (8009ee8 <pbuf_take+0x114>)
 8009e60:	f7f8 f9b4 	bl	80021cc <app_debug_rtt_raw>
    buf_copy_len = total_copy_len;
 8009e64:	697b      	ldr	r3, [r7, #20]
 8009e66:	61bb      	str	r3, [r7, #24]
    if (buf_copy_len > p->len) {
 8009e68:	69fb      	ldr	r3, [r7, #28]
 8009e6a:	895b      	ldrh	r3, [r3, #10]
 8009e6c:	001a      	movs	r2, r3
 8009e6e:	69bb      	ldr	r3, [r7, #24]
 8009e70:	4293      	cmp	r3, r2
 8009e72:	d902      	bls.n	8009e7a <pbuf_take+0xa6>
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
 8009e74:	69fb      	ldr	r3, [r7, #28]
 8009e76:	895b      	ldrh	r3, [r3, #10]
 8009e78:	61bb      	str	r3, [r7, #24]
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((const char *)dataptr)[copied_total], buf_copy_len);
 8009e7a:	69fb      	ldr	r3, [r7, #28]
 8009e7c:	6858      	ldr	r0, [r3, #4]
 8009e7e:	68ba      	ldr	r2, [r7, #8]
 8009e80:	693b      	ldr	r3, [r7, #16]
 8009e82:	18d3      	adds	r3, r2, r3
 8009e84:	69ba      	ldr	r2, [r7, #24]
 8009e86:	0019      	movs	r1, r3
 8009e88:	f012 fcb4 	bl	801c7f4 <memcpy>
    total_copy_len -= buf_copy_len;
 8009e8c:	697a      	ldr	r2, [r7, #20]
 8009e8e:	69bb      	ldr	r3, [r7, #24]
 8009e90:	1ad3      	subs	r3, r2, r3
 8009e92:	617b      	str	r3, [r7, #20]
    copied_total += buf_copy_len;
 8009e94:	693a      	ldr	r2, [r7, #16]
 8009e96:	69bb      	ldr	r3, [r7, #24]
 8009e98:	18d3      	adds	r3, r2, r3
 8009e9a:	613b      	str	r3, [r7, #16]
  for (p = buf; total_copy_len != 0; p = p->next) {
 8009e9c:	69fb      	ldr	r3, [r7, #28]
 8009e9e:	681b      	ldr	r3, [r3, #0]
 8009ea0:	61fb      	str	r3, [r7, #28]
 8009ea2:	697b      	ldr	r3, [r7, #20]
 8009ea4:	2b00      	cmp	r3, #0
 8009ea6:	d1d4      	bne.n	8009e52 <pbuf_take+0x7e>
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
 8009ea8:	697b      	ldr	r3, [r7, #20]
 8009eaa:	2b00      	cmp	r3, #0
 8009eac:	d104      	bne.n	8009eb8 <pbuf_take+0xe4>
 8009eae:	1dbb      	adds	r3, r7, #6
 8009eb0:	881b      	ldrh	r3, [r3, #0]
 8009eb2:	693a      	ldr	r2, [r7, #16]
 8009eb4:	429a      	cmp	r2, r3
 8009eb6:	d005      	beq.n	8009ec4 <pbuf_take+0xf0>
 8009eb8:	4b08      	ldr	r3, [pc, #32]	; (8009edc <pbuf_take+0x108>)
 8009eba:	4a0c      	ldr	r2, [pc, #48]	; (8009eec <pbuf_take+0x118>)
 8009ebc:	490c      	ldr	r1, [pc, #48]	; (8009ef0 <pbuf_take+0x11c>)
 8009ebe:	480a      	ldr	r0, [pc, #40]	; (8009ee8 <pbuf_take+0x114>)
 8009ec0:	f7f8 f984 	bl	80021cc <app_debug_rtt_raw>
  return ERR_OK;
 8009ec4:	2300      	movs	r3, #0
}
 8009ec6:	0018      	movs	r0, r3
 8009ec8:	46bd      	mov	sp, r7
 8009eca:	b008      	add	sp, #32
 8009ecc:	bd80      	pop	{r7, pc}
 8009ece:	46c0      	nop			; (mov r8, r8)
 8009ed0:	0801f0e4 	.word	0x0801f0e4
 8009ed4:	0801f0fc 	.word	0x0801f0fc
 8009ed8:	0801f118 	.word	0x0801f118
 8009edc:	0801eca4 	.word	0x0801eca4
 8009ee0:	000004df 	.word	0x000004df
 8009ee4:	0801f138 	.word	0x0801f138
 8009ee8:	0801ecfc 	.word	0x0801ecfc
 8009eec:	000004ea 	.word	0x000004ea
 8009ef0:	0801f150 	.word	0x0801f150

08009ef4 <pbuf_take_at>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take_at(struct pbuf *buf, const void *dataptr, u16_t len, u16_t offset)
{
 8009ef4:	b590      	push	{r4, r7, lr}
 8009ef6:	b089      	sub	sp, #36	; 0x24
 8009ef8:	af00      	add	r7, sp, #0
 8009efa:	60f8      	str	r0, [r7, #12]
 8009efc:	60b9      	str	r1, [r7, #8]
 8009efe:	0019      	movs	r1, r3
 8009f00:	1dbb      	adds	r3, r7, #6
 8009f02:	801a      	strh	r2, [r3, #0]
 8009f04:	1d3b      	adds	r3, r7, #4
 8009f06:	1c0a      	adds	r2, r1, #0
 8009f08:	801a      	strh	r2, [r3, #0]
  u16_t target_offset;
  struct pbuf *q = pbuf_skip(buf, offset, &target_offset);
 8009f0a:	2410      	movs	r4, #16
 8009f0c:	193a      	adds	r2, r7, r4
 8009f0e:	1d3b      	adds	r3, r7, #4
 8009f10:	8819      	ldrh	r1, [r3, #0]
 8009f12:	68fb      	ldr	r3, [r7, #12]
 8009f14:	0018      	movs	r0, r3
 8009f16:	f7ff ff46 	bl	8009da6 <pbuf_skip>
 8009f1a:	0003      	movs	r3, r0
 8009f1c:	61fb      	str	r3, [r7, #28]

  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->tot_len >= target_offset + len)) {
 8009f1e:	69fb      	ldr	r3, [r7, #28]
 8009f20:	2b00      	cmp	r3, #0
 8009f22:	d060      	beq.n	8009fe6 <pbuf_take_at+0xf2>
 8009f24:	69fb      	ldr	r3, [r7, #28]
 8009f26:	891b      	ldrh	r3, [r3, #8]
 8009f28:	001a      	movs	r2, r3
 8009f2a:	0020      	movs	r0, r4
 8009f2c:	183b      	adds	r3, r7, r0
 8009f2e:	881b      	ldrh	r3, [r3, #0]
 8009f30:	0019      	movs	r1, r3
 8009f32:	1dbb      	adds	r3, r7, #6
 8009f34:	881b      	ldrh	r3, [r3, #0]
 8009f36:	18cb      	adds	r3, r1, r3
 8009f38:	429a      	cmp	r2, r3
 8009f3a:	db54      	blt.n	8009fe6 <pbuf_take_at+0xf2>
    u16_t remaining_len = len;
 8009f3c:	231a      	movs	r3, #26
 8009f3e:	18fb      	adds	r3, r7, r3
 8009f40:	1dba      	adds	r2, r7, #6
 8009f42:	8812      	ldrh	r2, [r2, #0]
 8009f44:	801a      	strh	r2, [r3, #0]
    const u8_t *src_ptr = (const u8_t *)dataptr;
 8009f46:	68bb      	ldr	r3, [r7, #8]
 8009f48:	617b      	str	r3, [r7, #20]
    /* copy the part that goes into the first pbuf */
    u16_t first_copy_len;
    LWIP_ASSERT("check pbuf_skip result", target_offset < q->len);
 8009f4a:	69fb      	ldr	r3, [r7, #28]
 8009f4c:	895a      	ldrh	r2, [r3, #10]
 8009f4e:	183b      	adds	r3, r7, r0
 8009f50:	881b      	ldrh	r3, [r3, #0]
 8009f52:	429a      	cmp	r2, r3
 8009f54:	d805      	bhi.n	8009f62 <pbuf_take_at+0x6e>
 8009f56:	4b27      	ldr	r3, [pc, #156]	; (8009ff4 <pbuf_take_at+0x100>)
 8009f58:	4a27      	ldr	r2, [pc, #156]	; (8009ff8 <pbuf_take_at+0x104>)
 8009f5a:	4928      	ldr	r1, [pc, #160]	; (8009ffc <pbuf_take_at+0x108>)
 8009f5c:	4828      	ldr	r0, [pc, #160]	; (800a000 <pbuf_take_at+0x10c>)
 8009f5e:	f7f8 f935 	bl	80021cc <app_debug_rtt_raw>
    first_copy_len = (u16_t)LWIP_MIN(q->len - target_offset, len);
 8009f62:	69fb      	ldr	r3, [r7, #28]
 8009f64:	895b      	ldrh	r3, [r3, #10]
 8009f66:	001a      	movs	r2, r3
 8009f68:	2110      	movs	r1, #16
 8009f6a:	187b      	adds	r3, r7, r1
 8009f6c:	881b      	ldrh	r3, [r3, #0]
 8009f6e:	1ad2      	subs	r2, r2, r3
 8009f70:	1dbb      	adds	r3, r7, #6
 8009f72:	881b      	ldrh	r3, [r3, #0]
 8009f74:	429a      	cmp	r2, r3
 8009f76:	da06      	bge.n	8009f86 <pbuf_take_at+0x92>
 8009f78:	69fb      	ldr	r3, [r7, #28]
 8009f7a:	895a      	ldrh	r2, [r3, #10]
 8009f7c:	187b      	adds	r3, r7, r1
 8009f7e:	881b      	ldrh	r3, [r3, #0]
 8009f80:	1ad3      	subs	r3, r2, r3
 8009f82:	b29b      	uxth	r3, r3
 8009f84:	e001      	b.n	8009f8a <pbuf_take_at+0x96>
 8009f86:	1dbb      	adds	r3, r7, #6
 8009f88:	881b      	ldrh	r3, [r3, #0]
 8009f8a:	2112      	movs	r1, #18
 8009f8c:	187a      	adds	r2, r7, r1
 8009f8e:	8013      	strh	r3, [r2, #0]
    MEMCPY(((u8_t *)q->payload) + target_offset, dataptr, first_copy_len);
 8009f90:	69fb      	ldr	r3, [r7, #28]
 8009f92:	685b      	ldr	r3, [r3, #4]
 8009f94:	2210      	movs	r2, #16
 8009f96:	18ba      	adds	r2, r7, r2
 8009f98:	8812      	ldrh	r2, [r2, #0]
 8009f9a:	1898      	adds	r0, r3, r2
 8009f9c:	000c      	movs	r4, r1
 8009f9e:	187b      	adds	r3, r7, r1
 8009fa0:	881a      	ldrh	r2, [r3, #0]
 8009fa2:	68bb      	ldr	r3, [r7, #8]
 8009fa4:	0019      	movs	r1, r3
 8009fa6:	f012 fc25 	bl	801c7f4 <memcpy>
    remaining_len = (u16_t)(remaining_len - first_copy_len);
 8009faa:	201a      	movs	r0, #26
 8009fac:	183b      	adds	r3, r7, r0
 8009fae:	1839      	adds	r1, r7, r0
 8009fb0:	193a      	adds	r2, r7, r4
 8009fb2:	8809      	ldrh	r1, [r1, #0]
 8009fb4:	8812      	ldrh	r2, [r2, #0]
 8009fb6:	1a8a      	subs	r2, r1, r2
 8009fb8:	801a      	strh	r2, [r3, #0]
    src_ptr += first_copy_len;
 8009fba:	193b      	adds	r3, r7, r4
 8009fbc:	881b      	ldrh	r3, [r3, #0]
 8009fbe:	697a      	ldr	r2, [r7, #20]
 8009fc0:	18d3      	adds	r3, r2, r3
 8009fc2:	617b      	str	r3, [r7, #20]
    if (remaining_len > 0) {
 8009fc4:	0002      	movs	r2, r0
 8009fc6:	18bb      	adds	r3, r7, r2
 8009fc8:	881b      	ldrh	r3, [r3, #0]
 8009fca:	2b00      	cmp	r3, #0
 8009fcc:	d009      	beq.n	8009fe2 <pbuf_take_at+0xee>
      return pbuf_take(q->next, src_ptr, remaining_len);
 8009fce:	69fb      	ldr	r3, [r7, #28]
 8009fd0:	6818      	ldr	r0, [r3, #0]
 8009fd2:	18bb      	adds	r3, r7, r2
 8009fd4:	881a      	ldrh	r2, [r3, #0]
 8009fd6:	697b      	ldr	r3, [r7, #20]
 8009fd8:	0019      	movs	r1, r3
 8009fda:	f7ff fefb 	bl	8009dd4 <pbuf_take>
 8009fde:	0003      	movs	r3, r0
 8009fe0:	e003      	b.n	8009fea <pbuf_take_at+0xf6>
    }
    return ERR_OK;
 8009fe2:	2300      	movs	r3, #0
 8009fe4:	e001      	b.n	8009fea <pbuf_take_at+0xf6>
  }
  return ERR_MEM;
 8009fe6:	2301      	movs	r3, #1
 8009fe8:	425b      	negs	r3, r3
}
 8009fea:	0018      	movs	r0, r3
 8009fec:	46bd      	mov	sp, r7
 8009fee:	b009      	add	sp, #36	; 0x24
 8009ff0:	bd90      	pop	{r4, r7, pc}
 8009ff2:	46c0      	nop			; (mov r8, r8)
 8009ff4:	0801eca4 	.word	0x0801eca4
 8009ff8:	00000505 	.word	0x00000505
 8009ffc:	0801f168 	.word	0x0801f168
 800a000:	0801ecfc 	.word	0x0801ecfc

0800a004 <pbuf_coalesce>:
 * @return a new, single pbuf (p->next is NULL)
 *         or the old pbuf if allocation fails
 */
struct pbuf *
pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
{
 800a004:	b580      	push	{r7, lr}
 800a006:	b084      	sub	sp, #16
 800a008:	af00      	add	r7, sp, #0
 800a00a:	6078      	str	r0, [r7, #4]
 800a00c:	000a      	movs	r2, r1
 800a00e:	1cfb      	adds	r3, r7, #3
 800a010:	701a      	strb	r2, [r3, #0]
  struct pbuf *q;
  if (p->next == NULL) {
 800a012:	687b      	ldr	r3, [r7, #4]
 800a014:	681b      	ldr	r3, [r3, #0]
 800a016:	2b00      	cmp	r3, #0
 800a018:	d101      	bne.n	800a01e <pbuf_coalesce+0x1a>
    return p;
 800a01a:	687b      	ldr	r3, [r7, #4]
 800a01c:	e013      	b.n	800a046 <pbuf_coalesce+0x42>
  }
  q = pbuf_clone(layer, PBUF_RAM, p);
 800a01e:	687a      	ldr	r2, [r7, #4]
 800a020:	23a0      	movs	r3, #160	; 0xa0
 800a022:	0099      	lsls	r1, r3, #2
 800a024:	1cfb      	adds	r3, r7, #3
 800a026:	781b      	ldrb	r3, [r3, #0]
 800a028:	0018      	movs	r0, r3
 800a02a:	f000 f811 	bl	800a050 <pbuf_clone>
 800a02e:	0003      	movs	r3, r0
 800a030:	60fb      	str	r3, [r7, #12]
  if (q == NULL) {
 800a032:	68fb      	ldr	r3, [r7, #12]
 800a034:	2b00      	cmp	r3, #0
 800a036:	d101      	bne.n	800a03c <pbuf_coalesce+0x38>
    /* @todo: what do we do now? */
    return p;
 800a038:	687b      	ldr	r3, [r7, #4]
 800a03a:	e004      	b.n	800a046 <pbuf_coalesce+0x42>
  }
  pbuf_free(p);
 800a03c:	687b      	ldr	r3, [r7, #4]
 800a03e:	0018      	movs	r0, r3
 800a040:	f7ff fb28 	bl	8009694 <pbuf_free>
  return q;
 800a044:	68fb      	ldr	r3, [r7, #12]
}
 800a046:	0018      	movs	r0, r3
 800a048:	46bd      	mov	sp, r7
 800a04a:	b004      	add	sp, #16
 800a04c:	bd80      	pop	{r7, pc}
	...

0800a050 <pbuf_clone>:
 *
 * @return a new pbuf or NULL if allocation fails
 */
struct pbuf *
pbuf_clone(pbuf_layer layer, pbuf_type type, struct pbuf *p)
{
 800a050:	b5b0      	push	{r4, r5, r7, lr}
 800a052:	b084      	sub	sp, #16
 800a054:	af00      	add	r7, sp, #0
 800a056:	603a      	str	r2, [r7, #0]
 800a058:	1dfb      	adds	r3, r7, #7
 800a05a:	1c02      	adds	r2, r0, #0
 800a05c:	701a      	strb	r2, [r3, #0]
 800a05e:	1d3b      	adds	r3, r7, #4
 800a060:	1c0a      	adds	r2, r1, #0
 800a062:	801a      	strh	r2, [r3, #0]
  struct pbuf *q;
  err_t err;
  q = pbuf_alloc(layer, p->tot_len, type);
 800a064:	683b      	ldr	r3, [r7, #0]
 800a066:	8919      	ldrh	r1, [r3, #8]
 800a068:	1d3b      	adds	r3, r7, #4
 800a06a:	881a      	ldrh	r2, [r3, #0]
 800a06c:	1dfb      	adds	r3, r7, #7
 800a06e:	781b      	ldrb	r3, [r3, #0]
 800a070:	0018      	movs	r0, r3
 800a072:	f7fe ff97 	bl	8008fa4 <pbuf_alloc>
 800a076:	0003      	movs	r3, r0
 800a078:	60fb      	str	r3, [r7, #12]
  if (q == NULL) {
 800a07a:	68fb      	ldr	r3, [r7, #12]
 800a07c:	2b00      	cmp	r3, #0
 800a07e:	d101      	bne.n	800a084 <pbuf_clone+0x34>
    return NULL;
 800a080:	2300      	movs	r3, #0
 800a082:	e015      	b.n	800a0b0 <pbuf_clone+0x60>
  }
  err = pbuf_copy(q, p);
 800a084:	250b      	movs	r5, #11
 800a086:	197c      	adds	r4, r7, r5
 800a088:	683a      	ldr	r2, [r7, #0]
 800a08a:	68fb      	ldr	r3, [r7, #12]
 800a08c:	0011      	movs	r1, r2
 800a08e:	0018      	movs	r0, r3
 800a090:	f7ff fca2 	bl	80099d8 <pbuf_copy>
 800a094:	0003      	movs	r3, r0
 800a096:	7023      	strb	r3, [r4, #0]
  LWIP_UNUSED_ARG(err); /* in case of LWIP_NOASSERT */
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
 800a098:	197b      	adds	r3, r7, r5
 800a09a:	781b      	ldrb	r3, [r3, #0]
 800a09c:	b25b      	sxtb	r3, r3
 800a09e:	2b00      	cmp	r3, #0
 800a0a0:	d005      	beq.n	800a0ae <pbuf_clone+0x5e>
 800a0a2:	4b05      	ldr	r3, [pc, #20]	; (800a0b8 <pbuf_clone+0x68>)
 800a0a4:	4a05      	ldr	r2, [pc, #20]	; (800a0bc <pbuf_clone+0x6c>)
 800a0a6:	4906      	ldr	r1, [pc, #24]	; (800a0c0 <pbuf_clone+0x70>)
 800a0a8:	4806      	ldr	r0, [pc, #24]	; (800a0c4 <pbuf_clone+0x74>)
 800a0aa:	f7f8 f88f 	bl	80021cc <app_debug_rtt_raw>
  return q;
 800a0ae:	68fb      	ldr	r3, [r7, #12]
}
 800a0b0:	0018      	movs	r0, r3
 800a0b2:	46bd      	mov	sp, r7
 800a0b4:	b004      	add	sp, #16
 800a0b6:	bdb0      	pop	{r4, r5, r7, pc}
 800a0b8:	0801eca4 	.word	0x0801eca4
 800a0bc:	00000546 	.word	0x00000546
 800a0c0:	0801f180 	.word	0x0801f180
 800a0c4:	0801ecfc 	.word	0x0801ecfc

0800a0c8 <pbuf_get_at>:
 * @param offset offset into p of the byte to return
 * @return byte at an offset into p OR ZERO IF 'offset' >= p->tot_len
 */
u8_t
pbuf_get_at(const struct pbuf *p, u16_t offset)
{
 800a0c8:	b580      	push	{r7, lr}
 800a0ca:	b084      	sub	sp, #16
 800a0cc:	af00      	add	r7, sp, #0
 800a0ce:	6078      	str	r0, [r7, #4]
 800a0d0:	000a      	movs	r2, r1
 800a0d2:	1cbb      	adds	r3, r7, #2
 800a0d4:	801a      	strh	r2, [r3, #0]
  int ret = pbuf_try_get_at(p, offset);
 800a0d6:	1cbb      	adds	r3, r7, #2
 800a0d8:	881a      	ldrh	r2, [r3, #0]
 800a0da:	687b      	ldr	r3, [r7, #4]
 800a0dc:	0011      	movs	r1, r2
 800a0de:	0018      	movs	r0, r3
 800a0e0:	f000 f80d 	bl	800a0fe <pbuf_try_get_at>
 800a0e4:	0003      	movs	r3, r0
 800a0e6:	60fb      	str	r3, [r7, #12]
  if (ret >= 0) {
 800a0e8:	68fb      	ldr	r3, [r7, #12]
 800a0ea:	2b00      	cmp	r3, #0
 800a0ec:	db02      	blt.n	800a0f4 <pbuf_get_at+0x2c>
    return (u8_t)ret;
 800a0ee:	68fb      	ldr	r3, [r7, #12]
 800a0f0:	b2db      	uxtb	r3, r3
 800a0f2:	e000      	b.n	800a0f6 <pbuf_get_at+0x2e>
  }
  return 0;
 800a0f4:	2300      	movs	r3, #0
}
 800a0f6:	0018      	movs	r0, r3
 800a0f8:	46bd      	mov	sp, r7
 800a0fa:	b004      	add	sp, #16
 800a0fc:	bd80      	pop	{r7, pc}

0800a0fe <pbuf_try_get_at>:
 * @param offset offset into p of the byte to return
 * @return byte at an offset into p [0..0xFF] OR negative if 'offset' >= p->tot_len
 */
int
pbuf_try_get_at(const struct pbuf *p, u16_t offset)
{
 800a0fe:	b590      	push	{r4, r7, lr}
 800a100:	b085      	sub	sp, #20
 800a102:	af00      	add	r7, sp, #0
 800a104:	6078      	str	r0, [r7, #4]
 800a106:	000a      	movs	r2, r1
 800a108:	1cbb      	adds	r3, r7, #2
 800a10a:	801a      	strh	r2, [r3, #0]
  u16_t q_idx;
  const struct pbuf *q = pbuf_skip_const(p, offset, &q_idx);
 800a10c:	240a      	movs	r4, #10
 800a10e:	193a      	adds	r2, r7, r4
 800a110:	1cbb      	adds	r3, r7, #2
 800a112:	8819      	ldrh	r1, [r3, #0]
 800a114:	687b      	ldr	r3, [r7, #4]
 800a116:	0018      	movs	r0, r3
 800a118:	f7ff fe12 	bl	8009d40 <pbuf_skip_const>
 800a11c:	0003      	movs	r3, r0
 800a11e:	60fb      	str	r3, [r7, #12]

  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > q_idx)) {
 800a120:	68fb      	ldr	r3, [r7, #12]
 800a122:	2b00      	cmp	r3, #0
 800a124:	d00c      	beq.n	800a140 <pbuf_try_get_at+0x42>
 800a126:	68fb      	ldr	r3, [r7, #12]
 800a128:	895a      	ldrh	r2, [r3, #10]
 800a12a:	193b      	adds	r3, r7, r4
 800a12c:	881b      	ldrh	r3, [r3, #0]
 800a12e:	429a      	cmp	r2, r3
 800a130:	d906      	bls.n	800a140 <pbuf_try_get_at+0x42>
    return ((u8_t *)q->payload)[q_idx];
 800a132:	68fb      	ldr	r3, [r7, #12]
 800a134:	685b      	ldr	r3, [r3, #4]
 800a136:	193a      	adds	r2, r7, r4
 800a138:	8812      	ldrh	r2, [r2, #0]
 800a13a:	189b      	adds	r3, r3, r2
 800a13c:	781b      	ldrb	r3, [r3, #0]
 800a13e:	e001      	b.n	800a144 <pbuf_try_get_at+0x46>
  }
  return -1;
 800a140:	2301      	movs	r3, #1
 800a142:	425b      	negs	r3, r3
}
 800a144:	0018      	movs	r0, r3
 800a146:	46bd      	mov	sp, r7
 800a148:	b005      	add	sp, #20
 800a14a:	bd90      	pop	{r4, r7, pc}

0800a14c <pbuf_put_at>:
 * @param offset offset into p of the byte to write
 * @param data byte to write at an offset into p
 */
void
pbuf_put_at(struct pbuf *p, u16_t offset, u8_t data)
{
 800a14c:	b590      	push	{r4, r7, lr}
 800a14e:	b085      	sub	sp, #20
 800a150:	af00      	add	r7, sp, #0
 800a152:	6078      	str	r0, [r7, #4]
 800a154:	0008      	movs	r0, r1
 800a156:	0011      	movs	r1, r2
 800a158:	1cbb      	adds	r3, r7, #2
 800a15a:	1c02      	adds	r2, r0, #0
 800a15c:	801a      	strh	r2, [r3, #0]
 800a15e:	1c7b      	adds	r3, r7, #1
 800a160:	1c0a      	adds	r2, r1, #0
 800a162:	701a      	strb	r2, [r3, #0]
  u16_t q_idx;
  struct pbuf *q = pbuf_skip(p, offset, &q_idx);
 800a164:	240a      	movs	r4, #10
 800a166:	193a      	adds	r2, r7, r4
 800a168:	1cbb      	adds	r3, r7, #2
 800a16a:	8819      	ldrh	r1, [r3, #0]
 800a16c:	687b      	ldr	r3, [r7, #4]
 800a16e:	0018      	movs	r0, r3
 800a170:	f7ff fe19 	bl	8009da6 <pbuf_skip>
 800a174:	0003      	movs	r3, r0
 800a176:	60fb      	str	r3, [r7, #12]

  /* write requested data if pbuf is OK */
  if ((q != NULL) && (q->len > q_idx)) {
 800a178:	68fb      	ldr	r3, [r7, #12]
 800a17a:	2b00      	cmp	r3, #0
 800a17c:	d00d      	beq.n	800a19a <pbuf_put_at+0x4e>
 800a17e:	68fb      	ldr	r3, [r7, #12]
 800a180:	895a      	ldrh	r2, [r3, #10]
 800a182:	193b      	adds	r3, r7, r4
 800a184:	881b      	ldrh	r3, [r3, #0]
 800a186:	429a      	cmp	r2, r3
 800a188:	d907      	bls.n	800a19a <pbuf_put_at+0x4e>
    ((u8_t *)q->payload)[q_idx] = data;
 800a18a:	68fb      	ldr	r3, [r7, #12]
 800a18c:	685b      	ldr	r3, [r3, #4]
 800a18e:	193a      	adds	r2, r7, r4
 800a190:	8812      	ldrh	r2, [r2, #0]
 800a192:	189b      	adds	r3, r3, r2
 800a194:	1c7a      	adds	r2, r7, #1
 800a196:	7812      	ldrb	r2, [r2, #0]
 800a198:	701a      	strb	r2, [r3, #0]
  }
}
 800a19a:	46c0      	nop			; (mov r8, r8)
 800a19c:	46bd      	mov	sp, r7
 800a19e:	b005      	add	sp, #20
 800a1a0:	bd90      	pop	{r4, r7, pc}
	...

0800a1a4 <pbuf_memcmp>:
 * @return zero if equal, nonzero otherwise
 *         (0xffff if p is too short, diffoffset+1 otherwise)
 */
u16_t
pbuf_memcmp(const struct pbuf *p, u16_t offset, const void *s2, u16_t n)
{
 800a1a4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a1a6:	b089      	sub	sp, #36	; 0x24
 800a1a8:	af00      	add	r7, sp, #0
 800a1aa:	60f8      	str	r0, [r7, #12]
 800a1ac:	0008      	movs	r0, r1
 800a1ae:	607a      	str	r2, [r7, #4]
 800a1b0:	0019      	movs	r1, r3
 800a1b2:	240a      	movs	r4, #10
 800a1b4:	193b      	adds	r3, r7, r4
 800a1b6:	1c02      	adds	r2, r0, #0
 800a1b8:	801a      	strh	r2, [r3, #0]
 800a1ba:	2008      	movs	r0, #8
 800a1bc:	183b      	adds	r3, r7, r0
 800a1be:	1c0a      	adds	r2, r1, #0
 800a1c0:	801a      	strh	r2, [r3, #0]
  u16_t start = offset;
 800a1c2:	231e      	movs	r3, #30
 800a1c4:	18fb      	adds	r3, r7, r3
 800a1c6:	193a      	adds	r2, r7, r4
 800a1c8:	8812      	ldrh	r2, [r2, #0]
 800a1ca:	801a      	strh	r2, [r3, #0]
  const struct pbuf *q = p;
 800a1cc:	68fb      	ldr	r3, [r7, #12]
 800a1ce:	61bb      	str	r3, [r7, #24]
  u16_t i;

  /* pbuf long enough to perform check? */
  if (p->tot_len < (offset + n)) {
 800a1d0:	68fb      	ldr	r3, [r7, #12]
 800a1d2:	891b      	ldrh	r3, [r3, #8]
 800a1d4:	0019      	movs	r1, r3
 800a1d6:	193b      	adds	r3, r7, r4
 800a1d8:	881a      	ldrh	r2, [r3, #0]
 800a1da:	183b      	adds	r3, r7, r0
 800a1dc:	881b      	ldrh	r3, [r3, #0]
 800a1de:	18d3      	adds	r3, r2, r3
 800a1e0:	4299      	cmp	r1, r3
 800a1e2:	da0c      	bge.n	800a1fe <pbuf_memcmp+0x5a>
    return 0xffff;
 800a1e4:	4b2d      	ldr	r3, [pc, #180]	; (800a29c <pbuf_memcmp+0xf8>)
 800a1e6:	e054      	b.n	800a292 <pbuf_memcmp+0xee>
  }

  /* get the correct pbuf from chain. We know it succeeds because of p->tot_len check above. */
  while ((q != NULL) && (q->len <= start)) {
    start = (u16_t)(start - q->len);
 800a1e8:	69bb      	ldr	r3, [r7, #24]
 800a1ea:	895a      	ldrh	r2, [r3, #10]
 800a1ec:	211e      	movs	r1, #30
 800a1ee:	187b      	adds	r3, r7, r1
 800a1f0:	1879      	adds	r1, r7, r1
 800a1f2:	8809      	ldrh	r1, [r1, #0]
 800a1f4:	1a8a      	subs	r2, r1, r2
 800a1f6:	801a      	strh	r2, [r3, #0]
    q = q->next;
 800a1f8:	69bb      	ldr	r3, [r7, #24]
 800a1fa:	681b      	ldr	r3, [r3, #0]
 800a1fc:	61bb      	str	r3, [r7, #24]
  while ((q != NULL) && (q->len <= start)) {
 800a1fe:	69bb      	ldr	r3, [r7, #24]
 800a200:	2b00      	cmp	r3, #0
 800a202:	d006      	beq.n	800a212 <pbuf_memcmp+0x6e>
 800a204:	69bb      	ldr	r3, [r7, #24]
 800a206:	895b      	ldrh	r3, [r3, #10]
 800a208:	221e      	movs	r2, #30
 800a20a:	18ba      	adds	r2, r7, r2
 800a20c:	8812      	ldrh	r2, [r2, #0]
 800a20e:	429a      	cmp	r2, r3
 800a210:	d2ea      	bcs.n	800a1e8 <pbuf_memcmp+0x44>
  }

  /* return requested data if pbuf is OK */
  for (i = 0; i < n; i++) {
 800a212:	2316      	movs	r3, #22
 800a214:	18fb      	adds	r3, r7, r3
 800a216:	2200      	movs	r2, #0
 800a218:	801a      	strh	r2, [r3, #0]
 800a21a:	e031      	b.n	800a280 <pbuf_memcmp+0xdc>
    /* We know pbuf_get_at() succeeds because of p->tot_len check above. */
    u8_t a = pbuf_get_at(q, (u16_t)(start + i));
 800a21c:	231e      	movs	r3, #30
 800a21e:	18fa      	adds	r2, r7, r3
 800a220:	2516      	movs	r5, #22
 800a222:	197b      	adds	r3, r7, r5
 800a224:	8812      	ldrh	r2, [r2, #0]
 800a226:	881b      	ldrh	r3, [r3, #0]
 800a228:	18d3      	adds	r3, r2, r3
 800a22a:	b29a      	uxth	r2, r3
 800a22c:	2615      	movs	r6, #21
 800a22e:	19bc      	adds	r4, r7, r6
 800a230:	69bb      	ldr	r3, [r7, #24]
 800a232:	0011      	movs	r1, r2
 800a234:	0018      	movs	r0, r3
 800a236:	f7ff ff47 	bl	800a0c8 <pbuf_get_at>
 800a23a:	0003      	movs	r3, r0
 800a23c:	7023      	strb	r3, [r4, #0]
    u8_t b = ((const u8_t *)s2)[i];
 800a23e:	0029      	movs	r1, r5
 800a240:	187b      	adds	r3, r7, r1
 800a242:	881b      	ldrh	r3, [r3, #0]
 800a244:	687a      	ldr	r2, [r7, #4]
 800a246:	18d2      	adds	r2, r2, r3
 800a248:	2014      	movs	r0, #20
 800a24a:	183b      	adds	r3, r7, r0
 800a24c:	7812      	ldrb	r2, [r2, #0]
 800a24e:	701a      	strb	r2, [r3, #0]
    if (a != b) {
 800a250:	19ba      	adds	r2, r7, r6
 800a252:	183b      	adds	r3, r7, r0
 800a254:	7812      	ldrb	r2, [r2, #0]
 800a256:	781b      	ldrb	r3, [r3, #0]
 800a258:	429a      	cmp	r2, r3
 800a25a:	d00b      	beq.n	800a274 <pbuf_memcmp+0xd0>
      return (u16_t)LWIP_MIN(i + 1, 0xFFFF);
 800a25c:	187b      	adds	r3, r7, r1
 800a25e:	881b      	ldrh	r3, [r3, #0]
 800a260:	b29a      	uxth	r2, r3
 800a262:	490f      	ldr	r1, [pc, #60]	; (800a2a0 <pbuf_memcmp+0xfc>)
 800a264:	428a      	cmp	r2, r1
 800a266:	d901      	bls.n	800a26c <pbuf_memcmp+0xc8>
 800a268:	2302      	movs	r3, #2
 800a26a:	425b      	negs	r3, r3
 800a26c:	b29b      	uxth	r3, r3
 800a26e:	3301      	adds	r3, #1
 800a270:	b29b      	uxth	r3, r3
 800a272:	e00e      	b.n	800a292 <pbuf_memcmp+0xee>
  for (i = 0; i < n; i++) {
 800a274:	2116      	movs	r1, #22
 800a276:	187b      	adds	r3, r7, r1
 800a278:	881a      	ldrh	r2, [r3, #0]
 800a27a:	187b      	adds	r3, r7, r1
 800a27c:	3201      	adds	r2, #1
 800a27e:	801a      	strh	r2, [r3, #0]
 800a280:	2316      	movs	r3, #22
 800a282:	18fa      	adds	r2, r7, r3
 800a284:	2308      	movs	r3, #8
 800a286:	18fb      	adds	r3, r7, r3
 800a288:	8812      	ldrh	r2, [r2, #0]
 800a28a:	881b      	ldrh	r3, [r3, #0]
 800a28c:	429a      	cmp	r2, r3
 800a28e:	d3c5      	bcc.n	800a21c <pbuf_memcmp+0x78>
    }
  }
  return 0;
 800a290:	2300      	movs	r3, #0
}
 800a292:	0018      	movs	r0, r3
 800a294:	46bd      	mov	sp, r7
 800a296:	b009      	add	sp, #36	; 0x24
 800a298:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a29a:	46c0      	nop			; (mov r8, r8)
 800a29c:	0000ffff 	.word	0x0000ffff
 800a2a0:	0000fffe 	.word	0x0000fffe

0800a2a4 <pbuf_memfind>:
 * @param start_offset offset into p at which to start searching
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_memfind(const struct pbuf *p, const void *mem, u16_t mem_len, u16_t start_offset)
{
 800a2a4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a2a6:	b087      	sub	sp, #28
 800a2a8:	af00      	add	r7, sp, #0
 800a2aa:	60f8      	str	r0, [r7, #12]
 800a2ac:	60b9      	str	r1, [r7, #8]
 800a2ae:	0019      	movs	r1, r3
 800a2b0:	1dbb      	adds	r3, r7, #6
 800a2b2:	801a      	strh	r2, [r3, #0]
 800a2b4:	1d3b      	adds	r3, r7, #4
 800a2b6:	1c0a      	adds	r2, r1, #0
 800a2b8:	801a      	strh	r2, [r3, #0]
  u16_t i;
  u16_t max_cmp_start = (u16_t)(p->tot_len - mem_len);
 800a2ba:	68fb      	ldr	r3, [r7, #12]
 800a2bc:	8919      	ldrh	r1, [r3, #8]
 800a2be:	2314      	movs	r3, #20
 800a2c0:	18fb      	adds	r3, r7, r3
 800a2c2:	1dba      	adds	r2, r7, #6
 800a2c4:	8812      	ldrh	r2, [r2, #0]
 800a2c6:	1a8a      	subs	r2, r1, r2
 800a2c8:	801a      	strh	r2, [r3, #0]
  if (p->tot_len >= mem_len + start_offset) {
 800a2ca:	68fb      	ldr	r3, [r7, #12]
 800a2cc:	891b      	ldrh	r3, [r3, #8]
 800a2ce:	0019      	movs	r1, r3
 800a2d0:	1dbb      	adds	r3, r7, #6
 800a2d2:	881a      	ldrh	r2, [r3, #0]
 800a2d4:	1d3b      	adds	r3, r7, #4
 800a2d6:	881b      	ldrh	r3, [r3, #0]
 800a2d8:	18d3      	adds	r3, r2, r3
 800a2da:	4299      	cmp	r1, r3
 800a2dc:	db29      	blt.n	800a332 <pbuf_memfind+0x8e>
    for (i = start_offset; i <= max_cmp_start; i++) {
 800a2de:	2316      	movs	r3, #22
 800a2e0:	18fb      	adds	r3, r7, r3
 800a2e2:	1d3a      	adds	r2, r7, #4
 800a2e4:	8812      	ldrh	r2, [r2, #0]
 800a2e6:	801a      	strh	r2, [r3, #0]
 800a2e8:	e01b      	b.n	800a322 <pbuf_memfind+0x7e>
      u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
 800a2ea:	2612      	movs	r6, #18
 800a2ec:	19bc      	adds	r4, r7, r6
 800a2ee:	1dbb      	adds	r3, r7, #6
 800a2f0:	881d      	ldrh	r5, [r3, #0]
 800a2f2:	68ba      	ldr	r2, [r7, #8]
 800a2f4:	2316      	movs	r3, #22
 800a2f6:	18fb      	adds	r3, r7, r3
 800a2f8:	8819      	ldrh	r1, [r3, #0]
 800a2fa:	68f8      	ldr	r0, [r7, #12]
 800a2fc:	002b      	movs	r3, r5
 800a2fe:	f7ff ff51 	bl	800a1a4 <pbuf_memcmp>
 800a302:	0003      	movs	r3, r0
 800a304:	8023      	strh	r3, [r4, #0]
      if (plus == 0) {
 800a306:	19bb      	adds	r3, r7, r6
 800a308:	881b      	ldrh	r3, [r3, #0]
 800a30a:	2b00      	cmp	r3, #0
 800a30c:	d103      	bne.n	800a316 <pbuf_memfind+0x72>
        return i;
 800a30e:	2316      	movs	r3, #22
 800a310:	18fb      	adds	r3, r7, r3
 800a312:	881b      	ldrh	r3, [r3, #0]
 800a314:	e00e      	b.n	800a334 <pbuf_memfind+0x90>
    for (i = start_offset; i <= max_cmp_start; i++) {
 800a316:	2116      	movs	r1, #22
 800a318:	187b      	adds	r3, r7, r1
 800a31a:	881a      	ldrh	r2, [r3, #0]
 800a31c:	187b      	adds	r3, r7, r1
 800a31e:	3201      	adds	r2, #1
 800a320:	801a      	strh	r2, [r3, #0]
 800a322:	2316      	movs	r3, #22
 800a324:	18fa      	adds	r2, r7, r3
 800a326:	2314      	movs	r3, #20
 800a328:	18fb      	adds	r3, r7, r3
 800a32a:	8812      	ldrh	r2, [r2, #0]
 800a32c:	881b      	ldrh	r3, [r3, #0]
 800a32e:	429a      	cmp	r2, r3
 800a330:	d9db      	bls.n	800a2ea <pbuf_memfind+0x46>
      }
    }
  }
  return 0xFFFF;
 800a332:	4b02      	ldr	r3, [pc, #8]	; (800a33c <pbuf_memfind+0x98>)
}
 800a334:	0018      	movs	r0, r3
 800a336:	46bd      	mov	sp, r7
 800a338:	b007      	add	sp, #28
 800a33a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a33c:	0000ffff 	.word	0x0000ffff

0800a340 <tcp_init>:
/**
 * Initialize this module.
 */
void
tcp_init(void)
{
 800a340:	b580      	push	{r7, lr}
 800a342:	af00      	add	r7, sp, #0
#ifdef LWIP_RAND
  tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
 800a344:	f012 f9f2 	bl	801c72c <sys_rand>
 800a348:	0003      	movs	r3, r0
 800a34a:	b29b      	uxth	r3, r3
 800a34c:	049b      	lsls	r3, r3, #18
 800a34e:	0c9b      	lsrs	r3, r3, #18
 800a350:	b29b      	uxth	r3, r3
 800a352:	4a04      	ldr	r2, [pc, #16]	; (800a364 <tcp_init+0x24>)
 800a354:	4694      	mov	ip, r2
 800a356:	4463      	add	r3, ip
 800a358:	b29a      	uxth	r2, r3
 800a35a:	4b03      	ldr	r3, [pc, #12]	; (800a368 <tcp_init+0x28>)
 800a35c:	801a      	strh	r2, [r3, #0]
#endif /* LWIP_RAND */
}
 800a35e:	46c0      	nop			; (mov r8, r8)
 800a360:	46bd      	mov	sp, r7
 800a362:	bd80      	pop	{r7, pc}
 800a364:	ffffc000 	.word	0xffffc000
 800a368:	2000020e 	.word	0x2000020e

0800a36c <tcp_free>:

/** Free a tcp pcb */
void
tcp_free(struct tcp_pcb *pcb)
{
 800a36c:	b580      	push	{r7, lr}
 800a36e:	b082      	sub	sp, #8
 800a370:	af00      	add	r7, sp, #0
 800a372:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_free: LISTEN", pcb->state != LISTEN);
 800a374:	687b      	ldr	r3, [r7, #4]
 800a376:	7e1b      	ldrb	r3, [r3, #24]
 800a378:	2b01      	cmp	r3, #1
 800a37a:	d105      	bne.n	800a388 <tcp_free+0x1c>
 800a37c:	4b07      	ldr	r3, [pc, #28]	; (800a39c <tcp_free+0x30>)
 800a37e:	4908      	ldr	r1, [pc, #32]	; (800a3a0 <tcp_free+0x34>)
 800a380:	4808      	ldr	r0, [pc, #32]	; (800a3a4 <tcp_free+0x38>)
 800a382:	22d4      	movs	r2, #212	; 0xd4
 800a384:	f7f7 ff22 	bl	80021cc <app_debug_rtt_raw>
#if LWIP_TCP_PCB_NUM_EXT_ARGS
  tcp_ext_arg_invoke_callbacks_destroyed(pcb->ext_args);
#endif
  memp_free(MEMP_TCP_PCB, pcb);
 800a388:	687b      	ldr	r3, [r7, #4]
 800a38a:	0019      	movs	r1, r3
 800a38c:	2001      	movs	r0, #1
 800a38e:	f7fe fa8b 	bl	80088a8 <memp_free>
}
 800a392:	46c0      	nop			; (mov r8, r8)
 800a394:	46bd      	mov	sp, r7
 800a396:	b002      	add	sp, #8
 800a398:	bd80      	pop	{r7, pc}
 800a39a:	46c0      	nop			; (mov r8, r8)
 800a39c:	0801f238 	.word	0x0801f238
 800a3a0:	0801f260 	.word	0x0801f260
 800a3a4:	0801f274 	.word	0x0801f274

0800a3a8 <tcp_free_listen>:

/** Free a tcp listen pcb */
static void
tcp_free_listen(struct tcp_pcb *pcb)
{
 800a3a8:	b580      	push	{r7, lr}
 800a3aa:	b082      	sub	sp, #8
 800a3ac:	af00      	add	r7, sp, #0
 800a3ae:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_free_listen: !LISTEN", pcb->state != LISTEN);
 800a3b0:	687b      	ldr	r3, [r7, #4]
 800a3b2:	7e1b      	ldrb	r3, [r3, #24]
 800a3b4:	2b01      	cmp	r3, #1
 800a3b6:	d105      	bne.n	800a3c4 <tcp_free_listen+0x1c>
 800a3b8:	4b07      	ldr	r3, [pc, #28]	; (800a3d8 <tcp_free_listen+0x30>)
 800a3ba:	4908      	ldr	r1, [pc, #32]	; (800a3dc <tcp_free_listen+0x34>)
 800a3bc:	4808      	ldr	r0, [pc, #32]	; (800a3e0 <tcp_free_listen+0x38>)
 800a3be:	22df      	movs	r2, #223	; 0xdf
 800a3c0:	f7f7 ff04 	bl	80021cc <app_debug_rtt_raw>
#if LWIP_TCP_PCB_NUM_EXT_ARGS
  tcp_ext_arg_invoke_callbacks_destroyed(pcb->ext_args);
#endif
  memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 800a3c4:	687b      	ldr	r3, [r7, #4]
 800a3c6:	0019      	movs	r1, r3
 800a3c8:	2002      	movs	r0, #2
 800a3ca:	f7fe fa6d 	bl	80088a8 <memp_free>
}
 800a3ce:	46c0      	nop			; (mov r8, r8)
 800a3d0:	46bd      	mov	sp, r7
 800a3d2:	b002      	add	sp, #8
 800a3d4:	bd80      	pop	{r7, pc}
 800a3d6:	46c0      	nop			; (mov r8, r8)
 800a3d8:	0801f238 	.word	0x0801f238
 800a3dc:	0801f2a0 	.word	0x0801f2a0
 800a3e0:	0801f274 	.word	0x0801f274

0800a3e4 <tcp_tmr>:
/**
 * Called periodically to dispatch TCP timers.
 */
void
tcp_tmr(void)
{
 800a3e4:	b580      	push	{r7, lr}
 800a3e6:	af00      	add	r7, sp, #0
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
 800a3e8:	f001 f8d0 	bl	800b58c <tcp_fasttmr>

  if (++tcp_timer & 1) {
 800a3ec:	4b08      	ldr	r3, [pc, #32]	; (800a410 <tcp_tmr+0x2c>)
 800a3ee:	781b      	ldrb	r3, [r3, #0]
 800a3f0:	3301      	adds	r3, #1
 800a3f2:	b2da      	uxtb	r2, r3
 800a3f4:	4b06      	ldr	r3, [pc, #24]	; (800a410 <tcp_tmr+0x2c>)
 800a3f6:	701a      	strb	r2, [r3, #0]
 800a3f8:	4b05      	ldr	r3, [pc, #20]	; (800a410 <tcp_tmr+0x2c>)
 800a3fa:	781b      	ldrb	r3, [r3, #0]
 800a3fc:	001a      	movs	r2, r3
 800a3fe:	2301      	movs	r3, #1
 800a400:	4013      	ands	r3, r2
 800a402:	d001      	beq.n	800a408 <tcp_tmr+0x24>
    /* Call tcp_slowtmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
 800a404:	f000 fd36 	bl	800ae74 <tcp_slowtmr>
  }
}
 800a408:	46c0      	nop			; (mov r8, r8)
 800a40a:	46bd      	mov	sp, r7
 800a40c:	bd80      	pop	{r7, pc}
 800a40e:	46c0      	nop			; (mov r8, r8)
 800a410:	20001359 	.word	0x20001359

0800a414 <tcp_remove_listener>:
/** Called when a listen pcb is closed. Iterates one pcb list and removes the
 * closed listener pcb from pcb->listener if matching.
 */
static void
tcp_remove_listener(struct tcp_pcb *list, struct tcp_pcb_listen *lpcb)
{
 800a414:	b580      	push	{r7, lr}
 800a416:	b084      	sub	sp, #16
 800a418:	af00      	add	r7, sp, #0
 800a41a:	6078      	str	r0, [r7, #4]
 800a41c:	6039      	str	r1, [r7, #0]
  struct tcp_pcb *pcb;

  LWIP_ASSERT("tcp_remove_listener: invalid listener", lpcb != NULL);
 800a41e:	683b      	ldr	r3, [r7, #0]
 800a420:	2b00      	cmp	r3, #0
 800a422:	d105      	bne.n	800a430 <tcp_remove_listener+0x1c>
 800a424:	4b0e      	ldr	r3, [pc, #56]	; (800a460 <tcp_remove_listener+0x4c>)
 800a426:	490f      	ldr	r1, [pc, #60]	; (800a464 <tcp_remove_listener+0x50>)
 800a428:	480f      	ldr	r0, [pc, #60]	; (800a468 <tcp_remove_listener+0x54>)
 800a42a:	22ff      	movs	r2, #255	; 0xff
 800a42c:	f7f7 fece 	bl	80021cc <app_debug_rtt_raw>

  for (pcb = list; pcb != NULL; pcb = pcb->next) {
 800a430:	687b      	ldr	r3, [r7, #4]
 800a432:	60fb      	str	r3, [r7, #12]
 800a434:	e00c      	b.n	800a450 <tcp_remove_listener+0x3c>
    if (pcb->listener == lpcb) {
 800a436:	68fb      	ldr	r3, [r7, #12]
 800a438:	2280      	movs	r2, #128	; 0x80
 800a43a:	589b      	ldr	r3, [r3, r2]
 800a43c:	683a      	ldr	r2, [r7, #0]
 800a43e:	429a      	cmp	r2, r3
 800a440:	d103      	bne.n	800a44a <tcp_remove_listener+0x36>
      pcb->listener = NULL;
 800a442:	68fb      	ldr	r3, [r7, #12]
 800a444:	2280      	movs	r2, #128	; 0x80
 800a446:	2100      	movs	r1, #0
 800a448:	5099      	str	r1, [r3, r2]
  for (pcb = list; pcb != NULL; pcb = pcb->next) {
 800a44a:	68fb      	ldr	r3, [r7, #12]
 800a44c:	691b      	ldr	r3, [r3, #16]
 800a44e:	60fb      	str	r3, [r7, #12]
 800a450:	68fb      	ldr	r3, [r7, #12]
 800a452:	2b00      	cmp	r3, #0
 800a454:	d1ef      	bne.n	800a436 <tcp_remove_listener+0x22>
    }
  }
}
 800a456:	46c0      	nop			; (mov r8, r8)
 800a458:	46c0      	nop			; (mov r8, r8)
 800a45a:	46bd      	mov	sp, r7
 800a45c:	b004      	add	sp, #16
 800a45e:	bd80      	pop	{r7, pc}
 800a460:	0801f238 	.word	0x0801f238
 800a464:	0801f2bc 	.word	0x0801f2bc
 800a468:	0801f274 	.word	0x0801f274

0800a46c <tcp_listen_closed>:
/** Called when a listen pcb is closed. Iterates all pcb lists and removes the
 * closed listener pcb from pcb->listener if matching.
 */
static void
tcp_listen_closed(struct tcp_pcb *pcb)
{
 800a46c:	b580      	push	{r7, lr}
 800a46e:	b084      	sub	sp, #16
 800a470:	af00      	add	r7, sp, #0
 800a472:	6078      	str	r0, [r7, #4]
#if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
  size_t i;
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 800a474:	687b      	ldr	r3, [r7, #4]
 800a476:	2b00      	cmp	r3, #0
 800a478:	d106      	bne.n	800a488 <tcp_listen_closed+0x1c>
 800a47a:	4b15      	ldr	r3, [pc, #84]	; (800a4d0 <tcp_listen_closed+0x64>)
 800a47c:	2212      	movs	r2, #18
 800a47e:	32ff      	adds	r2, #255	; 0xff
 800a480:	4914      	ldr	r1, [pc, #80]	; (800a4d4 <tcp_listen_closed+0x68>)
 800a482:	4815      	ldr	r0, [pc, #84]	; (800a4d8 <tcp_listen_closed+0x6c>)
 800a484:	f7f7 fea2 	bl	80021cc <app_debug_rtt_raw>
  LWIP_ASSERT("pcb->state == LISTEN", pcb->state == LISTEN);
 800a488:	687b      	ldr	r3, [r7, #4]
 800a48a:	7e1b      	ldrb	r3, [r3, #24]
 800a48c:	2b01      	cmp	r3, #1
 800a48e:	d006      	beq.n	800a49e <tcp_listen_closed+0x32>
 800a490:	4b0f      	ldr	r3, [pc, #60]	; (800a4d0 <tcp_listen_closed+0x64>)
 800a492:	2289      	movs	r2, #137	; 0x89
 800a494:	0052      	lsls	r2, r2, #1
 800a496:	4911      	ldr	r1, [pc, #68]	; (800a4dc <tcp_listen_closed+0x70>)
 800a498:	480f      	ldr	r0, [pc, #60]	; (800a4d8 <tcp_listen_closed+0x6c>)
 800a49a:	f7f7 fe97 	bl	80021cc <app_debug_rtt_raw>
  for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
 800a49e:	2301      	movs	r3, #1
 800a4a0:	60fb      	str	r3, [r7, #12]
 800a4a2:	e00c      	b.n	800a4be <tcp_listen_closed+0x52>
    tcp_remove_listener(*tcp_pcb_lists[i], (struct tcp_pcb_listen *)pcb);
 800a4a4:	4b0e      	ldr	r3, [pc, #56]	; (800a4e0 <tcp_listen_closed+0x74>)
 800a4a6:	68fa      	ldr	r2, [r7, #12]
 800a4a8:	0092      	lsls	r2, r2, #2
 800a4aa:	58d3      	ldr	r3, [r2, r3]
 800a4ac:	681b      	ldr	r3, [r3, #0]
 800a4ae:	687a      	ldr	r2, [r7, #4]
 800a4b0:	0011      	movs	r1, r2
 800a4b2:	0018      	movs	r0, r3
 800a4b4:	f7ff ffae 	bl	800a414 <tcp_remove_listener>
  for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
 800a4b8:	68fb      	ldr	r3, [r7, #12]
 800a4ba:	3301      	adds	r3, #1
 800a4bc:	60fb      	str	r3, [r7, #12]
 800a4be:	68fb      	ldr	r3, [r7, #12]
 800a4c0:	2b03      	cmp	r3, #3
 800a4c2:	d9ef      	bls.n	800a4a4 <tcp_listen_closed+0x38>
  }
#endif
  LWIP_UNUSED_ARG(pcb);
}
 800a4c4:	46c0      	nop			; (mov r8, r8)
 800a4c6:	46c0      	nop			; (mov r8, r8)
 800a4c8:	46bd      	mov	sp, r7
 800a4ca:	b004      	add	sp, #16
 800a4cc:	bd80      	pop	{r7, pc}
 800a4ce:	46c0      	nop			; (mov r8, r8)
 800a4d0:	0801f238 	.word	0x0801f238
 800a4d4:	0801f2e4 	.word	0x0801f2e4
 800a4d8:	0801f274 	.word	0x0801f274
 800a4dc:	0801f2f0 	.word	0x0801f2f0
 800a4e0:	08021a08 	.word	0x08021a08

0800a4e4 <tcp_close_shutdown>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
 800a4e4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a4e6:	b089      	sub	sp, #36	; 0x24
 800a4e8:	af04      	add	r7, sp, #16
 800a4ea:	6078      	str	r0, [r7, #4]
 800a4ec:	000a      	movs	r2, r1
 800a4ee:	1cfb      	adds	r3, r7, #3
 800a4f0:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT("tcp_close_shutdown: invalid pcb", pcb != NULL);
 800a4f2:	687b      	ldr	r3, [r7, #4]
 800a4f4:	2b00      	cmp	r3, #0
 800a4f6:	d106      	bne.n	800a506 <tcp_close_shutdown+0x22>
 800a4f8:	4b69      	ldr	r3, [pc, #420]	; (800a6a0 <tcp_close_shutdown+0x1bc>)
 800a4fa:	22af      	movs	r2, #175	; 0xaf
 800a4fc:	0052      	lsls	r2, r2, #1
 800a4fe:	4969      	ldr	r1, [pc, #420]	; (800a6a4 <tcp_close_shutdown+0x1c0>)
 800a500:	4869      	ldr	r0, [pc, #420]	; (800a6a8 <tcp_close_shutdown+0x1c4>)
 800a502:	f7f7 fe63 	bl	80021cc <app_debug_rtt_raw>

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 800a506:	1cfb      	adds	r3, r7, #3
 800a508:	781b      	ldrb	r3, [r3, #0]
 800a50a:	2b00      	cmp	r3, #0
 800a50c:	d100      	bne.n	800a510 <tcp_close_shutdown+0x2c>
 800a50e:	e069      	b.n	800a5e4 <tcp_close_shutdown+0x100>
 800a510:	687b      	ldr	r3, [r7, #4]
 800a512:	7e1b      	ldrb	r3, [r3, #24]
 800a514:	2b04      	cmp	r3, #4
 800a516:	d003      	beq.n	800a520 <tcp_close_shutdown+0x3c>
 800a518:	687b      	ldr	r3, [r7, #4]
 800a51a:	7e1b      	ldrb	r3, [r3, #24]
 800a51c:	2b07      	cmp	r3, #7
 800a51e:	d161      	bne.n	800a5e4 <tcp_close_shutdown+0x100>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND_MAX(pcb))) {
 800a520:	687b      	ldr	r3, [r7, #4]
 800a522:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800a524:	2b00      	cmp	r3, #0
 800a526:	d105      	bne.n	800a534 <tcp_close_shutdown+0x50>
 800a528:	687b      	ldr	r3, [r7, #4]
 800a52a:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800a52c:	2386      	movs	r3, #134	; 0x86
 800a52e:	00db      	lsls	r3, r3, #3
 800a530:	429a      	cmp	r2, r3
 800a532:	d057      	beq.n	800a5e4 <tcp_close_shutdown+0x100>
      /* Not all data received by application, send RST to tell the remote
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
 800a534:	687b      	ldr	r3, [r7, #4]
 800a536:	8bdb      	ldrh	r3, [r3, #30]
 800a538:	001a      	movs	r2, r3
 800a53a:	2310      	movs	r3, #16
 800a53c:	4013      	ands	r3, r2
 800a53e:	d106      	bne.n	800a54e <tcp_close_shutdown+0x6a>
 800a540:	4b57      	ldr	r3, [pc, #348]	; (800a6a0 <tcp_close_shutdown+0x1bc>)
 800a542:	22b2      	movs	r2, #178	; 0xb2
 800a544:	0052      	lsls	r2, r2, #1
 800a546:	4959      	ldr	r1, [pc, #356]	; (800a6ac <tcp_close_shutdown+0x1c8>)
 800a548:	4857      	ldr	r0, [pc, #348]	; (800a6a8 <tcp_close_shutdown+0x1c4>)
 800a54a:	f7f7 fe3f 	bl	80021cc <app_debug_rtt_raw>

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 800a54e:	687b      	ldr	r3, [r7, #4]
 800a550:	6d5c      	ldr	r4, [r3, #84]	; 0x54
 800a552:	687b      	ldr	r3, [r7, #4]
 800a554:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 800a556:	687e      	ldr	r6, [r7, #4]
 800a558:	687b      	ldr	r3, [r7, #4]
 800a55a:	3304      	adds	r3, #4
 800a55c:	687a      	ldr	r2, [r7, #4]
 800a55e:	8b52      	ldrh	r2, [r2, #26]
 800a560:	6879      	ldr	r1, [r7, #4]
 800a562:	8b89      	ldrh	r1, [r1, #28]
 800a564:	6878      	ldr	r0, [r7, #4]
 800a566:	9102      	str	r1, [sp, #8]
 800a568:	9201      	str	r2, [sp, #4]
 800a56a:	9300      	str	r3, [sp, #0]
 800a56c:	0033      	movs	r3, r6
 800a56e:	002a      	movs	r2, r5
 800a570:	0021      	movs	r1, r4
 800a572:	f007 f859 	bl	8011628 <tcp_rst>
              pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
 800a576:	687b      	ldr	r3, [r7, #4]
 800a578:	0018      	movs	r0, r3
 800a57a:	f001 fbd5 	bl	800bd28 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 800a57e:	4b4c      	ldr	r3, [pc, #304]	; (800a6b0 <tcp_close_shutdown+0x1cc>)
 800a580:	681b      	ldr	r3, [r3, #0]
 800a582:	687a      	ldr	r2, [r7, #4]
 800a584:	429a      	cmp	r2, r3
 800a586:	d105      	bne.n	800a594 <tcp_close_shutdown+0xb0>
 800a588:	4b49      	ldr	r3, [pc, #292]	; (800a6b0 <tcp_close_shutdown+0x1cc>)
 800a58a:	681b      	ldr	r3, [r3, #0]
 800a58c:	691a      	ldr	r2, [r3, #16]
 800a58e:	4b48      	ldr	r3, [pc, #288]	; (800a6b0 <tcp_close_shutdown+0x1cc>)
 800a590:	601a      	str	r2, [r3, #0]
 800a592:	e013      	b.n	800a5bc <tcp_close_shutdown+0xd8>
 800a594:	4b46      	ldr	r3, [pc, #280]	; (800a6b0 <tcp_close_shutdown+0x1cc>)
 800a596:	681b      	ldr	r3, [r3, #0]
 800a598:	60fb      	str	r3, [r7, #12]
 800a59a:	e00c      	b.n	800a5b6 <tcp_close_shutdown+0xd2>
 800a59c:	68fb      	ldr	r3, [r7, #12]
 800a59e:	691b      	ldr	r3, [r3, #16]
 800a5a0:	687a      	ldr	r2, [r7, #4]
 800a5a2:	429a      	cmp	r2, r3
 800a5a4:	d104      	bne.n	800a5b0 <tcp_close_shutdown+0xcc>
 800a5a6:	687b      	ldr	r3, [r7, #4]
 800a5a8:	691a      	ldr	r2, [r3, #16]
 800a5aa:	68fb      	ldr	r3, [r7, #12]
 800a5ac:	611a      	str	r2, [r3, #16]
 800a5ae:	e005      	b.n	800a5bc <tcp_close_shutdown+0xd8>
 800a5b0:	68fb      	ldr	r3, [r7, #12]
 800a5b2:	691b      	ldr	r3, [r3, #16]
 800a5b4:	60fb      	str	r3, [r7, #12]
 800a5b6:	68fb      	ldr	r3, [r7, #12]
 800a5b8:	2b00      	cmp	r3, #0
 800a5ba:	d1ef      	bne.n	800a59c <tcp_close_shutdown+0xb8>
 800a5bc:	687b      	ldr	r3, [r7, #4]
 800a5be:	2200      	movs	r2, #0
 800a5c0:	611a      	str	r2, [r3, #16]
 800a5c2:	4b3c      	ldr	r3, [pc, #240]	; (800a6b4 <tcp_close_shutdown+0x1d0>)
 800a5c4:	2201      	movs	r2, #1
 800a5c6:	701a      	strb	r2, [r3, #0]
      /* Deallocate the pcb since we already sent a RST for it */
      if (tcp_input_pcb == pcb) {
 800a5c8:	4b3b      	ldr	r3, [pc, #236]	; (800a6b8 <tcp_close_shutdown+0x1d4>)
 800a5ca:	681b      	ldr	r3, [r3, #0]
 800a5cc:	687a      	ldr	r2, [r7, #4]
 800a5ce:	429a      	cmp	r2, r3
 800a5d0:	d102      	bne.n	800a5d8 <tcp_close_shutdown+0xf4>
        /* prevent using a deallocated pcb: free it from tcp_input later */
        tcp_trigger_input_pcb_close();
 800a5d2:	f004 fc25 	bl	800ee20 <tcp_trigger_input_pcb_close>
 800a5d6:	e003      	b.n	800a5e0 <tcp_close_shutdown+0xfc>
      } else {
        tcp_free(pcb);
 800a5d8:	687b      	ldr	r3, [r7, #4]
 800a5da:	0018      	movs	r0, r3
 800a5dc:	f7ff fec6 	bl	800a36c <tcp_free>
      }
      return ERR_OK;
 800a5e0:	2300      	movs	r3, #0
 800a5e2:	e058      	b.n	800a696 <tcp_close_shutdown+0x1b2>
    }
  }

  /* - states which free the pcb are handled here,
     - states which send FIN and change state are handled in tcp_close_shutdown_fin() */
  switch (pcb->state) {
 800a5e4:	687b      	ldr	r3, [r7, #4]
 800a5e6:	7e1b      	ldrb	r3, [r3, #24]
 800a5e8:	2b02      	cmp	r3, #2
 800a5ea:	d03f      	beq.n	800a66c <tcp_close_shutdown+0x188>
 800a5ec:	dc4c      	bgt.n	800a688 <tcp_close_shutdown+0x1a4>
 800a5ee:	2b00      	cmp	r3, #0
 800a5f0:	d002      	beq.n	800a5f8 <tcp_close_shutdown+0x114>
 800a5f2:	2b01      	cmp	r3, #1
 800a5f4:	d02b      	beq.n	800a64e <tcp_close_shutdown+0x16a>
 800a5f6:	e047      	b.n	800a688 <tcp_close_shutdown+0x1a4>
       * and the user needs some way to free it should the need arise.
       * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
       * or for a pcb that has been used and then entered the CLOSED state
       * is erroneous, but this should never happen as the pcb has in those cases
       * been freed, and so any remaining handles are bogus. */
      if (pcb->local_port != 0) {
 800a5f8:	687b      	ldr	r3, [r7, #4]
 800a5fa:	8b5b      	ldrh	r3, [r3, #26]
 800a5fc:	2b00      	cmp	r3, #0
 800a5fe:	d021      	beq.n	800a644 <tcp_close_shutdown+0x160>
        TCP_RMV(&tcp_bound_pcbs, pcb);
 800a600:	4b2e      	ldr	r3, [pc, #184]	; (800a6bc <tcp_close_shutdown+0x1d8>)
 800a602:	681b      	ldr	r3, [r3, #0]
 800a604:	687a      	ldr	r2, [r7, #4]
 800a606:	429a      	cmp	r2, r3
 800a608:	d105      	bne.n	800a616 <tcp_close_shutdown+0x132>
 800a60a:	4b2c      	ldr	r3, [pc, #176]	; (800a6bc <tcp_close_shutdown+0x1d8>)
 800a60c:	681b      	ldr	r3, [r3, #0]
 800a60e:	691a      	ldr	r2, [r3, #16]
 800a610:	4b2a      	ldr	r3, [pc, #168]	; (800a6bc <tcp_close_shutdown+0x1d8>)
 800a612:	601a      	str	r2, [r3, #0]
 800a614:	e013      	b.n	800a63e <tcp_close_shutdown+0x15a>
 800a616:	4b29      	ldr	r3, [pc, #164]	; (800a6bc <tcp_close_shutdown+0x1d8>)
 800a618:	681b      	ldr	r3, [r3, #0]
 800a61a:	60bb      	str	r3, [r7, #8]
 800a61c:	e00c      	b.n	800a638 <tcp_close_shutdown+0x154>
 800a61e:	68bb      	ldr	r3, [r7, #8]
 800a620:	691b      	ldr	r3, [r3, #16]
 800a622:	687a      	ldr	r2, [r7, #4]
 800a624:	429a      	cmp	r2, r3
 800a626:	d104      	bne.n	800a632 <tcp_close_shutdown+0x14e>
 800a628:	687b      	ldr	r3, [r7, #4]
 800a62a:	691a      	ldr	r2, [r3, #16]
 800a62c:	68bb      	ldr	r3, [r7, #8]
 800a62e:	611a      	str	r2, [r3, #16]
 800a630:	e005      	b.n	800a63e <tcp_close_shutdown+0x15a>
 800a632:	68bb      	ldr	r3, [r7, #8]
 800a634:	691b      	ldr	r3, [r3, #16]
 800a636:	60bb      	str	r3, [r7, #8]
 800a638:	68bb      	ldr	r3, [r7, #8]
 800a63a:	2b00      	cmp	r3, #0
 800a63c:	d1ef      	bne.n	800a61e <tcp_close_shutdown+0x13a>
 800a63e:	687b      	ldr	r3, [r7, #4]
 800a640:	2200      	movs	r2, #0
 800a642:	611a      	str	r2, [r3, #16]
      }
      tcp_free(pcb);
 800a644:	687b      	ldr	r3, [r7, #4]
 800a646:	0018      	movs	r0, r3
 800a648:	f7ff fe90 	bl	800a36c <tcp_free>
      break;
 800a64c:	e022      	b.n	800a694 <tcp_close_shutdown+0x1b0>
    case LISTEN:
      tcp_listen_closed(pcb);
 800a64e:	687b      	ldr	r3, [r7, #4]
 800a650:	0018      	movs	r0, r3
 800a652:	f7ff ff0b 	bl	800a46c <tcp_listen_closed>
      tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
 800a656:	687a      	ldr	r2, [r7, #4]
 800a658:	4b19      	ldr	r3, [pc, #100]	; (800a6c0 <tcp_close_shutdown+0x1dc>)
 800a65a:	0011      	movs	r1, r2
 800a65c:	0018      	movs	r0, r3
 800a65e:	f001 fbad 	bl	800bdbc <tcp_pcb_remove>
      tcp_free_listen(pcb);
 800a662:	687b      	ldr	r3, [r7, #4]
 800a664:	0018      	movs	r0, r3
 800a666:	f7ff fe9f 	bl	800a3a8 <tcp_free_listen>
      break;
 800a66a:	e013      	b.n	800a694 <tcp_close_shutdown+0x1b0>
    case SYN_SENT:
      TCP_PCB_REMOVE_ACTIVE(pcb);
 800a66c:	687a      	ldr	r2, [r7, #4]
 800a66e:	4b10      	ldr	r3, [pc, #64]	; (800a6b0 <tcp_close_shutdown+0x1cc>)
 800a670:	0011      	movs	r1, r2
 800a672:	0018      	movs	r0, r3
 800a674:	f001 fba2 	bl	800bdbc <tcp_pcb_remove>
 800a678:	4b0e      	ldr	r3, [pc, #56]	; (800a6b4 <tcp_close_shutdown+0x1d0>)
 800a67a:	2201      	movs	r2, #1
 800a67c:	701a      	strb	r2, [r3, #0]
      tcp_free(pcb);
 800a67e:	687b      	ldr	r3, [r7, #4]
 800a680:	0018      	movs	r0, r3
 800a682:	f7ff fe73 	bl	800a36c <tcp_free>
      MIB2_STATS_INC(mib2.tcpattemptfails);
      break;
 800a686:	e005      	b.n	800a694 <tcp_close_shutdown+0x1b0>
    default:
      return tcp_close_shutdown_fin(pcb);
 800a688:	687b      	ldr	r3, [r7, #4]
 800a68a:	0018      	movs	r0, r3
 800a68c:	f000 f81a 	bl	800a6c4 <tcp_close_shutdown_fin>
 800a690:	0003      	movs	r3, r0
 800a692:	e000      	b.n	800a696 <tcp_close_shutdown+0x1b2>
  }
  return ERR_OK;
 800a694:	2300      	movs	r3, #0
}
 800a696:	0018      	movs	r0, r3
 800a698:	46bd      	mov	sp, r7
 800a69a:	b005      	add	sp, #20
 800a69c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a69e:	46c0      	nop			; (mov r8, r8)
 800a6a0:	0801f238 	.word	0x0801f238
 800a6a4:	0801f308 	.word	0x0801f308
 800a6a8:	0801f274 	.word	0x0801f274
 800a6ac:	0801f328 	.word	0x0801f328
 800a6b0:	20002b18 	.word	0x20002b18
 800a6b4:	20002b14 	.word	0x20002b14
 800a6b8:	20002b2c 	.word	0x20002b2c
 800a6bc:	20002b24 	.word	0x20002b24
 800a6c0:	20002b20 	.word	0x20002b20

0800a6c4 <tcp_close_shutdown_fin>:

static err_t
tcp_close_shutdown_fin(struct tcp_pcb *pcb)
{
 800a6c4:	b5b0      	push	{r4, r5, r7, lr}
 800a6c6:	b084      	sub	sp, #16
 800a6c8:	af00      	add	r7, sp, #0
 800a6ca:	6078      	str	r0, [r7, #4]
  err_t err;
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 800a6cc:	687b      	ldr	r3, [r7, #4]
 800a6ce:	2b00      	cmp	r3, #0
 800a6d0:	d106      	bne.n	800a6e0 <tcp_close_shutdown_fin+0x1c>
 800a6d2:	4b36      	ldr	r3, [pc, #216]	; (800a7ac <tcp_close_shutdown_fin+0xe8>)
 800a6d4:	22ce      	movs	r2, #206	; 0xce
 800a6d6:	0052      	lsls	r2, r2, #1
 800a6d8:	4935      	ldr	r1, [pc, #212]	; (800a7b0 <tcp_close_shutdown_fin+0xec>)
 800a6da:	4836      	ldr	r0, [pc, #216]	; (800a7b4 <tcp_close_shutdown_fin+0xf0>)
 800a6dc:	f7f7 fd76 	bl	80021cc <app_debug_rtt_raw>

  switch (pcb->state) {
 800a6e0:	687b      	ldr	r3, [r7, #4]
 800a6e2:	7e1b      	ldrb	r3, [r3, #24]
 800a6e4:	2b07      	cmp	r3, #7
 800a6e6:	d027      	beq.n	800a738 <tcp_close_shutdown_fin+0x74>
 800a6e8:	dc37      	bgt.n	800a75a <tcp_close_shutdown_fin+0x96>
 800a6ea:	2b03      	cmp	r3, #3
 800a6ec:	d002      	beq.n	800a6f4 <tcp_close_shutdown_fin+0x30>
 800a6ee:	2b04      	cmp	r3, #4
 800a6f0:	d011      	beq.n	800a716 <tcp_close_shutdown_fin+0x52>
 800a6f2:	e032      	b.n	800a75a <tcp_close_shutdown_fin+0x96>
    case SYN_RCVD:
      err = tcp_send_fin(pcb);
 800a6f4:	250f      	movs	r5, #15
 800a6f6:	197c      	adds	r4, r7, r5
 800a6f8:	687b      	ldr	r3, [r7, #4]
 800a6fa:	0018      	movs	r0, r3
 800a6fc:	f005 fdd0 	bl	80102a0 <tcp_send_fin>
 800a700:	0003      	movs	r3, r0
 800a702:	7023      	strb	r3, [r4, #0]
      if (err == ERR_OK) {
 800a704:	197b      	adds	r3, r7, r5
 800a706:	781b      	ldrb	r3, [r3, #0]
 800a708:	b25b      	sxtb	r3, r3
 800a70a:	2b00      	cmp	r3, #0
 800a70c:	d127      	bne.n	800a75e <tcp_close_shutdown_fin+0x9a>
        tcp_backlog_accepted(pcb);
        MIB2_STATS_INC(mib2.tcpattemptfails);
        pcb->state = FIN_WAIT_1;
 800a70e:	687b      	ldr	r3, [r7, #4]
 800a710:	2205      	movs	r2, #5
 800a712:	761a      	strb	r2, [r3, #24]
      }
      break;
 800a714:	e023      	b.n	800a75e <tcp_close_shutdown_fin+0x9a>
    case ESTABLISHED:
      err = tcp_send_fin(pcb);
 800a716:	250f      	movs	r5, #15
 800a718:	197c      	adds	r4, r7, r5
 800a71a:	687b      	ldr	r3, [r7, #4]
 800a71c:	0018      	movs	r0, r3
 800a71e:	f005 fdbf 	bl	80102a0 <tcp_send_fin>
 800a722:	0003      	movs	r3, r0
 800a724:	7023      	strb	r3, [r4, #0]
      if (err == ERR_OK) {
 800a726:	197b      	adds	r3, r7, r5
 800a728:	781b      	ldrb	r3, [r3, #0]
 800a72a:	b25b      	sxtb	r3, r3
 800a72c:	2b00      	cmp	r3, #0
 800a72e:	d118      	bne.n	800a762 <tcp_close_shutdown_fin+0x9e>
        MIB2_STATS_INC(mib2.tcpestabresets);
        pcb->state = FIN_WAIT_1;
 800a730:	687b      	ldr	r3, [r7, #4]
 800a732:	2205      	movs	r2, #5
 800a734:	761a      	strb	r2, [r3, #24]
      }
      break;
 800a736:	e014      	b.n	800a762 <tcp_close_shutdown_fin+0x9e>
    case CLOSE_WAIT:
      err = tcp_send_fin(pcb);
 800a738:	250f      	movs	r5, #15
 800a73a:	197c      	adds	r4, r7, r5
 800a73c:	687b      	ldr	r3, [r7, #4]
 800a73e:	0018      	movs	r0, r3
 800a740:	f005 fdae 	bl	80102a0 <tcp_send_fin>
 800a744:	0003      	movs	r3, r0
 800a746:	7023      	strb	r3, [r4, #0]
      if (err == ERR_OK) {
 800a748:	197b      	adds	r3, r7, r5
 800a74a:	781b      	ldrb	r3, [r3, #0]
 800a74c:	b25b      	sxtb	r3, r3
 800a74e:	2b00      	cmp	r3, #0
 800a750:	d109      	bne.n	800a766 <tcp_close_shutdown_fin+0xa2>
        MIB2_STATS_INC(mib2.tcpestabresets);
        pcb->state = LAST_ACK;
 800a752:	687b      	ldr	r3, [r7, #4]
 800a754:	2209      	movs	r2, #9
 800a756:	761a      	strb	r2, [r3, #24]
      }
      break;
 800a758:	e005      	b.n	800a766 <tcp_close_shutdown_fin+0xa2>
    default:
      /* Has already been closed, do nothing. */
      return ERR_OK;
 800a75a:	2300      	movs	r3, #0
 800a75c:	e022      	b.n	800a7a4 <tcp_close_shutdown_fin+0xe0>
      break;
 800a75e:	46c0      	nop			; (mov r8, r8)
 800a760:	e002      	b.n	800a768 <tcp_close_shutdown_fin+0xa4>
      break;
 800a762:	46c0      	nop			; (mov r8, r8)
 800a764:	e000      	b.n	800a768 <tcp_close_shutdown_fin+0xa4>
      break;
 800a766:	46c0      	nop			; (mov r8, r8)
  }

  if (err == ERR_OK) {
 800a768:	230f      	movs	r3, #15
 800a76a:	18fb      	adds	r3, r7, r3
 800a76c:	781b      	ldrb	r3, [r3, #0]
 800a76e:	b25b      	sxtb	r3, r3
 800a770:	2b00      	cmp	r3, #0
 800a772:	d104      	bne.n	800a77e <tcp_close_shutdown_fin+0xba>
    /* To ensure all data has been sent when tcp_close returns, we have
       to make sure tcp_output doesn't fail.
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    tcp_output(pcb);
 800a774:	687b      	ldr	r3, [r7, #4]
 800a776:	0018      	movs	r0, r3
 800a778:	f005 ff02 	bl	8010580 <tcp_output>
 800a77c:	e00e      	b.n	800a79c <tcp_close_shutdown_fin+0xd8>
  } else if (err == ERR_MEM) {
 800a77e:	230f      	movs	r3, #15
 800a780:	18fb      	adds	r3, r7, r3
 800a782:	781b      	ldrb	r3, [r3, #0]
 800a784:	b25b      	sxtb	r3, r3
 800a786:	3301      	adds	r3, #1
 800a788:	d108      	bne.n	800a79c <tcp_close_shutdown_fin+0xd8>
    /* Mark this pcb for closing. Closing is retried from tcp_tmr. */
    tcp_set_flags(pcb, TF_CLOSEPEND);
 800a78a:	687b      	ldr	r3, [r7, #4]
 800a78c:	8bdb      	ldrh	r3, [r3, #30]
 800a78e:	2208      	movs	r2, #8
 800a790:	4313      	orrs	r3, r2
 800a792:	b29a      	uxth	r2, r3
 800a794:	687b      	ldr	r3, [r7, #4]
 800a796:	83da      	strh	r2, [r3, #30]
    /* We have to return ERR_OK from here to indicate to the callers that this
       pcb should not be used any more as it will be freed soon via tcp_tmr.
       This is OK here since sending FIN does not guarantee a time frime for
       actually freeing the pcb, either (it is left in closure states for
       remote ACK or timeout) */
    return ERR_OK;
 800a798:	2300      	movs	r3, #0
 800a79a:	e003      	b.n	800a7a4 <tcp_close_shutdown_fin+0xe0>
  }
  return err;
 800a79c:	230f      	movs	r3, #15
 800a79e:	18fb      	adds	r3, r7, r3
 800a7a0:	781b      	ldrb	r3, [r3, #0]
 800a7a2:	b25b      	sxtb	r3, r3
}
 800a7a4:	0018      	movs	r0, r3
 800a7a6:	46bd      	mov	sp, r7
 800a7a8:	b004      	add	sp, #16
 800a7aa:	bdb0      	pop	{r4, r5, r7, pc}
 800a7ac:	0801f238 	.word	0x0801f238
 800a7b0:	0801f2e4 	.word	0x0801f2e4
 800a7b4:	0801f274 	.word	0x0801f274

0800a7b8 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
 800a7b8:	b580      	push	{r7, lr}
 800a7ba:	b082      	sub	sp, #8
 800a7bc:	af00      	add	r7, sp, #0
 800a7be:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_close: invalid pcb", pcb != NULL, return ERR_ARG);
 800a7c0:	687b      	ldr	r3, [r7, #4]
 800a7c2:	2b00      	cmp	r3, #0
 800a7c4:	d106      	bne.n	800a7d4 <tcp_close+0x1c>
 800a7c6:	4b0e      	ldr	r3, [pc, #56]	; (800a800 <tcp_close+0x48>)
 800a7c8:	0018      	movs	r0, r3
 800a7ca:	f7f7 fcff 	bl	80021cc <app_debug_rtt_raw>
 800a7ce:	2310      	movs	r3, #16
 800a7d0:	425b      	negs	r3, r3
 800a7d2:	e010      	b.n	800a7f6 <tcp_close+0x3e>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));

  tcp_debug_print_state(pcb->state);

  if (pcb->state != LISTEN) {
 800a7d4:	687b      	ldr	r3, [r7, #4]
 800a7d6:	7e1b      	ldrb	r3, [r3, #24]
 800a7d8:	2b01      	cmp	r3, #1
 800a7da:	d006      	beq.n	800a7ea <tcp_close+0x32>
    /* Set a flag not to receive any more data... */
    tcp_set_flags(pcb, TF_RXCLOSED);
 800a7dc:	687b      	ldr	r3, [r7, #4]
 800a7de:	8bdb      	ldrh	r3, [r3, #30]
 800a7e0:	2210      	movs	r2, #16
 800a7e2:	4313      	orrs	r3, r2
 800a7e4:	b29a      	uxth	r2, r3
 800a7e6:	687b      	ldr	r3, [r7, #4]
 800a7e8:	83da      	strh	r2, [r3, #30]
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
 800a7ea:	687b      	ldr	r3, [r7, #4]
 800a7ec:	2101      	movs	r1, #1
 800a7ee:	0018      	movs	r0, r3
 800a7f0:	f7ff fe78 	bl	800a4e4 <tcp_close_shutdown>
 800a7f4:	0003      	movs	r3, r0
}
 800a7f6:	0018      	movs	r0, r3
 800a7f8:	46bd      	mov	sp, r7
 800a7fa:	b002      	add	sp, #8
 800a7fc:	bd80      	pop	{r7, pc}
 800a7fe:	46c0      	nop			; (mov r8, r8)
 800a800:	0801f344 	.word	0x0801f344

0800a804 <tcp_abandon>:
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
 800a804:	b5b0      	push	{r4, r5, r7, lr}
 800a806:	b08e      	sub	sp, #56	; 0x38
 800a808:	af04      	add	r7, sp, #16
 800a80a:	6078      	str	r0, [r7, #4]
 800a80c:	6039      	str	r1, [r7, #0]
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_abandon: invalid pcb", pcb != NULL, return);
 800a80e:	687b      	ldr	r3, [r7, #4]
 800a810:	2b00      	cmp	r3, #0
 800a812:	d104      	bne.n	800a81e <tcp_abandon+0x1a>
 800a814:	4b58      	ldr	r3, [pc, #352]	; (800a978 <tcp_abandon+0x174>)
 800a816:	0018      	movs	r0, r3
 800a818:	f7f7 fcd8 	bl	80021cc <app_debug_rtt_raw>
 800a81c:	e0a9      	b.n	800a972 <tcp_abandon+0x16e>

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
 800a81e:	687b      	ldr	r3, [r7, #4]
 800a820:	7e1b      	ldrb	r3, [r3, #24]
 800a822:	2b01      	cmp	r3, #1
 800a824:	d106      	bne.n	800a834 <tcp_abandon+0x30>
 800a826:	4b55      	ldr	r3, [pc, #340]	; (800a97c <tcp_abandon+0x178>)
 800a828:	2290      	movs	r2, #144	; 0x90
 800a82a:	0092      	lsls	r2, r2, #2
 800a82c:	4954      	ldr	r1, [pc, #336]	; (800a980 <tcp_abandon+0x17c>)
 800a82e:	4855      	ldr	r0, [pc, #340]	; (800a984 <tcp_abandon+0x180>)
 800a830:	f7f7 fccc 	bl	80021cc <app_debug_rtt_raw>
              pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
 800a834:	687b      	ldr	r3, [r7, #4]
 800a836:	7e1b      	ldrb	r3, [r3, #24]
 800a838:	2b0a      	cmp	r3, #10
 800a83a:	d10a      	bne.n	800a852 <tcp_abandon+0x4e>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 800a83c:	687a      	ldr	r2, [r7, #4]
 800a83e:	4b52      	ldr	r3, [pc, #328]	; (800a988 <tcp_abandon+0x184>)
 800a840:	0011      	movs	r1, r2
 800a842:	0018      	movs	r0, r3
 800a844:	f001 faba 	bl	800bdbc <tcp_pcb_remove>
    tcp_free(pcb);
 800a848:	687b      	ldr	r3, [r7, #4]
 800a84a:	0018      	movs	r0, r3
 800a84c:	f7ff fd8e 	bl	800a36c <tcp_free>
 800a850:	e08f      	b.n	800a972 <tcp_abandon+0x16e>
  } else {
    int send_rst = 0;
 800a852:	2300      	movs	r3, #0
 800a854:	627b      	str	r3, [r7, #36]	; 0x24
    u16_t local_port = 0;
 800a856:	2322      	movs	r3, #34	; 0x22
 800a858:	18fb      	adds	r3, r7, r3
 800a85a:	2200      	movs	r2, #0
 800a85c:	801a      	strh	r2, [r3, #0]
    enum tcp_state last_state;
    seqno = pcb->snd_nxt;
 800a85e:	687b      	ldr	r3, [r7, #4]
 800a860:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800a862:	61bb      	str	r3, [r7, #24]
    ackno = pcb->rcv_nxt;
 800a864:	687b      	ldr	r3, [r7, #4]
 800a866:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a868:	617b      	str	r3, [r7, #20]
#if LWIP_CALLBACK_API
    errf = pcb->errf;
 800a86a:	687b      	ldr	r3, [r7, #4]
 800a86c:	2294      	movs	r2, #148	; 0x94
 800a86e:	589b      	ldr	r3, [r3, r2]
 800a870:	613b      	str	r3, [r7, #16]
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
 800a872:	687b      	ldr	r3, [r7, #4]
 800a874:	695b      	ldr	r3, [r3, #20]
 800a876:	60fb      	str	r3, [r7, #12]
    if (pcb->state == CLOSED) {
 800a878:	687b      	ldr	r3, [r7, #4]
 800a87a:	7e1b      	ldrb	r3, [r3, #24]
 800a87c:	2b00      	cmp	r3, #0
 800a87e:	d126      	bne.n	800a8ce <tcp_abandon+0xca>
      if (pcb->local_port != 0) {
 800a880:	687b      	ldr	r3, [r7, #4]
 800a882:	8b5b      	ldrh	r3, [r3, #26]
 800a884:	2b00      	cmp	r3, #0
 800a886:	d032      	beq.n	800a8ee <tcp_abandon+0xea>
        /* bound, not yet opened */
        TCP_RMV(&tcp_bound_pcbs, pcb);
 800a888:	4b40      	ldr	r3, [pc, #256]	; (800a98c <tcp_abandon+0x188>)
 800a88a:	681b      	ldr	r3, [r3, #0]
 800a88c:	687a      	ldr	r2, [r7, #4]
 800a88e:	429a      	cmp	r2, r3
 800a890:	d105      	bne.n	800a89e <tcp_abandon+0x9a>
 800a892:	4b3e      	ldr	r3, [pc, #248]	; (800a98c <tcp_abandon+0x188>)
 800a894:	681b      	ldr	r3, [r3, #0]
 800a896:	691a      	ldr	r2, [r3, #16]
 800a898:	4b3c      	ldr	r3, [pc, #240]	; (800a98c <tcp_abandon+0x188>)
 800a89a:	601a      	str	r2, [r3, #0]
 800a89c:	e013      	b.n	800a8c6 <tcp_abandon+0xc2>
 800a89e:	4b3b      	ldr	r3, [pc, #236]	; (800a98c <tcp_abandon+0x188>)
 800a8a0:	681b      	ldr	r3, [r3, #0]
 800a8a2:	61fb      	str	r3, [r7, #28]
 800a8a4:	e00c      	b.n	800a8c0 <tcp_abandon+0xbc>
 800a8a6:	69fb      	ldr	r3, [r7, #28]
 800a8a8:	691b      	ldr	r3, [r3, #16]
 800a8aa:	687a      	ldr	r2, [r7, #4]
 800a8ac:	429a      	cmp	r2, r3
 800a8ae:	d104      	bne.n	800a8ba <tcp_abandon+0xb6>
 800a8b0:	687b      	ldr	r3, [r7, #4]
 800a8b2:	691a      	ldr	r2, [r3, #16]
 800a8b4:	69fb      	ldr	r3, [r7, #28]
 800a8b6:	611a      	str	r2, [r3, #16]
 800a8b8:	e005      	b.n	800a8c6 <tcp_abandon+0xc2>
 800a8ba:	69fb      	ldr	r3, [r7, #28]
 800a8bc:	691b      	ldr	r3, [r3, #16]
 800a8be:	61fb      	str	r3, [r7, #28]
 800a8c0:	69fb      	ldr	r3, [r7, #28]
 800a8c2:	2b00      	cmp	r3, #0
 800a8c4:	d1ef      	bne.n	800a8a6 <tcp_abandon+0xa2>
 800a8c6:	687b      	ldr	r3, [r7, #4]
 800a8c8:	2200      	movs	r2, #0
 800a8ca:	611a      	str	r2, [r3, #16]
 800a8cc:	e00f      	b.n	800a8ee <tcp_abandon+0xea>
      }
    } else {
      send_rst = reset;
 800a8ce:	683b      	ldr	r3, [r7, #0]
 800a8d0:	627b      	str	r3, [r7, #36]	; 0x24
      local_port = pcb->local_port;
 800a8d2:	2322      	movs	r3, #34	; 0x22
 800a8d4:	18fb      	adds	r3, r7, r3
 800a8d6:	687a      	ldr	r2, [r7, #4]
 800a8d8:	8b52      	ldrh	r2, [r2, #26]
 800a8da:	801a      	strh	r2, [r3, #0]
      TCP_PCB_REMOVE_ACTIVE(pcb);
 800a8dc:	687a      	ldr	r2, [r7, #4]
 800a8de:	4b2c      	ldr	r3, [pc, #176]	; (800a990 <tcp_abandon+0x18c>)
 800a8e0:	0011      	movs	r1, r2
 800a8e2:	0018      	movs	r0, r3
 800a8e4:	f001 fa6a 	bl	800bdbc <tcp_pcb_remove>
 800a8e8:	4b2a      	ldr	r3, [pc, #168]	; (800a994 <tcp_abandon+0x190>)
 800a8ea:	2201      	movs	r2, #1
 800a8ec:	701a      	strb	r2, [r3, #0]
    }
    if (pcb->unacked != NULL) {
 800a8ee:	687b      	ldr	r3, [r7, #4]
 800a8f0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800a8f2:	2b00      	cmp	r3, #0
 800a8f4:	d004      	beq.n	800a900 <tcp_abandon+0xfc>
      tcp_segs_free(pcb->unacked);
 800a8f6:	687b      	ldr	r3, [r7, #4]
 800a8f8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800a8fa:	0018      	movs	r0, r3
 800a8fc:	f000 ff36 	bl	800b76c <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
 800a900:	687b      	ldr	r3, [r7, #4]
 800a902:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800a904:	2b00      	cmp	r3, #0
 800a906:	d004      	beq.n	800a912 <tcp_abandon+0x10e>
      tcp_segs_free(pcb->unsent);
 800a908:	687b      	ldr	r3, [r7, #4]
 800a90a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800a90c:	0018      	movs	r0, r3
 800a90e:	f000 ff2d 	bl	800b76c <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
 800a912:	687b      	ldr	r3, [r7, #4]
 800a914:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800a916:	2b00      	cmp	r3, #0
 800a918:	d004      	beq.n	800a924 <tcp_abandon+0x120>
      tcp_segs_free(pcb->ooseq);
 800a91a:	687b      	ldr	r3, [r7, #4]
 800a91c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800a91e:	0018      	movs	r0, r3
 800a920:	f000 ff24 	bl	800b76c <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    tcp_backlog_accepted(pcb);
    if (send_rst) {
 800a924:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a926:	2b00      	cmp	r3, #0
 800a928:	d011      	beq.n	800a94e <tcp_abandon+0x14a>
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(pcb, seqno, ackno, &pcb->local_ip, &pcb->remote_ip, local_port, pcb->remote_port);
 800a92a:	687d      	ldr	r5, [r7, #4]
 800a92c:	687b      	ldr	r3, [r7, #4]
 800a92e:	3304      	adds	r3, #4
 800a930:	687a      	ldr	r2, [r7, #4]
 800a932:	8b92      	ldrh	r2, [r2, #28]
 800a934:	697c      	ldr	r4, [r7, #20]
 800a936:	69b9      	ldr	r1, [r7, #24]
 800a938:	6878      	ldr	r0, [r7, #4]
 800a93a:	9202      	str	r2, [sp, #8]
 800a93c:	2222      	movs	r2, #34	; 0x22
 800a93e:	18ba      	adds	r2, r7, r2
 800a940:	8812      	ldrh	r2, [r2, #0]
 800a942:	9201      	str	r2, [sp, #4]
 800a944:	9300      	str	r3, [sp, #0]
 800a946:	002b      	movs	r3, r5
 800a948:	0022      	movs	r2, r4
 800a94a:	f006 fe6d 	bl	8011628 <tcp_rst>
    }
    last_state = pcb->state;
 800a94e:	230b      	movs	r3, #11
 800a950:	18fb      	adds	r3, r7, r3
 800a952:	687a      	ldr	r2, [r7, #4]
 800a954:	7e12      	ldrb	r2, [r2, #24]
 800a956:	701a      	strb	r2, [r3, #0]
    tcp_free(pcb);
 800a958:	687b      	ldr	r3, [r7, #4]
 800a95a:	0018      	movs	r0, r3
 800a95c:	f7ff fd06 	bl	800a36c <tcp_free>
    TCP_EVENT_ERR(last_state, errf, errf_arg, ERR_ABRT);
 800a960:	693b      	ldr	r3, [r7, #16]
 800a962:	2b00      	cmp	r3, #0
 800a964:	d005      	beq.n	800a972 <tcp_abandon+0x16e>
 800a966:	230d      	movs	r3, #13
 800a968:	4259      	negs	r1, r3
 800a96a:	68fa      	ldr	r2, [r7, #12]
 800a96c:	693b      	ldr	r3, [r7, #16]
 800a96e:	0010      	movs	r0, r2
 800a970:	4798      	blx	r3
  }
}
 800a972:	46bd      	mov	sp, r7
 800a974:	b00a      	add	sp, #40	; 0x28
 800a976:	bdb0      	pop	{r4, r5, r7, pc}
 800a978:	0801f378 	.word	0x0801f378
 800a97c:	0801f238 	.word	0x0801f238
 800a980:	0801f394 	.word	0x0801f394
 800a984:	0801f274 	.word	0x0801f274
 800a988:	20002b28 	.word	0x20002b28
 800a98c:	20002b24 	.word	0x20002b24
 800a990:	20002b18 	.word	0x20002b18
 800a994:	20002b14 	.word	0x20002b14

0800a998 <tcp_abort>:
 *
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
 800a998:	b580      	push	{r7, lr}
 800a99a:	b082      	sub	sp, #8
 800a99c:	af00      	add	r7, sp, #0
 800a99e:	6078      	str	r0, [r7, #4]
  tcp_abandon(pcb, 1);
 800a9a0:	687b      	ldr	r3, [r7, #4]
 800a9a2:	2101      	movs	r1, #1
 800a9a4:	0018      	movs	r0, r3
 800a9a6:	f7ff ff2d 	bl	800a804 <tcp_abandon>
}
 800a9aa:	46c0      	nop			; (mov r8, r8)
 800a9ac:	46bd      	mov	sp, r7
 800a9ae:	b002      	add	sp, #8
 800a9b0:	bd80      	pop	{r7, pc}
	...

0800a9b4 <tcp_update_rcv_ann_wnd>:
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t
tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
 800a9b4:	b580      	push	{r7, lr}
 800a9b6:	b084      	sub	sp, #16
 800a9b8:	af00      	add	r7, sp, #0
 800a9ba:	6078      	str	r0, [r7, #4]
  u32_t new_right_edge;

  LWIP_ASSERT("tcp_update_rcv_ann_wnd: invalid pcb", pcb != NULL);
 800a9bc:	687b      	ldr	r3, [r7, #4]
 800a9be:	2b00      	cmp	r3, #0
 800a9c0:	d105      	bne.n	800a9ce <tcp_update_rcv_ann_wnd+0x1a>
 800a9c2:	4b26      	ldr	r3, [pc, #152]	; (800aa5c <tcp_update_rcv_ann_wnd+0xa8>)
 800a9c4:	4a26      	ldr	r2, [pc, #152]	; (800aa60 <tcp_update_rcv_ann_wnd+0xac>)
 800a9c6:	4927      	ldr	r1, [pc, #156]	; (800aa64 <tcp_update_rcv_ann_wnd+0xb0>)
 800a9c8:	4827      	ldr	r0, [pc, #156]	; (800aa68 <tcp_update_rcv_ann_wnd+0xb4>)
 800a9ca:	f7f7 fbff 	bl	80021cc <app_debug_rtt_raw>
  new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 800a9ce:	687b      	ldr	r3, [r7, #4]
 800a9d0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a9d2:	687a      	ldr	r2, [r7, #4]
 800a9d4:	8d92      	ldrh	r2, [r2, #44]	; 0x2c
 800a9d6:	189b      	adds	r3, r3, r2
 800a9d8:	60fb      	str	r3, [r7, #12]

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 800a9da:	687b      	ldr	r3, [r7, #4]
 800a9dc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a9de:	687a      	ldr	r2, [r7, #4]
 800a9e0:	8ed2      	ldrh	r2, [r2, #54]	; 0x36
 800a9e2:	1c10      	adds	r0, r2, #0
 800a9e4:	b281      	uxth	r1, r0
 800a9e6:	2286      	movs	r2, #134	; 0x86
 800a9e8:	0092      	lsls	r2, r2, #2
 800a9ea:	4291      	cmp	r1, r2
 800a9ec:	d902      	bls.n	800a9f4 <tcp_update_rcv_ann_wnd+0x40>
 800a9ee:	2286      	movs	r2, #134	; 0x86
 800a9f0:	0092      	lsls	r2, r2, #2
 800a9f2:	1c10      	adds	r0, r2, #0
 800a9f4:	b282      	uxth	r2, r0
 800a9f6:	189b      	adds	r3, r3, r2
 800a9f8:	68fa      	ldr	r2, [r7, #12]
 800a9fa:	1ad3      	subs	r3, r2, r3
 800a9fc:	d408      	bmi.n	800aa10 <tcp_update_rcv_ann_wnd+0x5c>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 800a9fe:	687b      	ldr	r3, [r7, #4]
 800aa00:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800aa02:	687b      	ldr	r3, [r7, #4]
 800aa04:	85da      	strh	r2, [r3, #46]	; 0x2e
    return new_right_edge - pcb->rcv_ann_right_edge;
 800aa06:	687b      	ldr	r3, [r7, #4]
 800aa08:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800aa0a:	68fa      	ldr	r2, [r7, #12]
 800aa0c:	1ad3      	subs	r3, r2, r3
 800aa0e:	e020      	b.n	800aa52 <tcp_update_rcv_ann_wnd+0x9e>
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 800aa10:	687b      	ldr	r3, [r7, #4]
 800aa12:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800aa14:	687b      	ldr	r3, [r7, #4]
 800aa16:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800aa18:	1ad3      	subs	r3, r2, r3
 800aa1a:	2b00      	cmp	r3, #0
 800aa1c:	dd03      	ble.n	800aa26 <tcp_update_rcv_ann_wnd+0x72>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
 800aa1e:	687b      	ldr	r3, [r7, #4]
 800aa20:	2200      	movs	r2, #0
 800aa22:	85da      	strh	r2, [r3, #46]	; 0x2e
 800aa24:	e014      	b.n	800aa50 <tcp_update_rcv_ann_wnd+0x9c>
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
 800aa26:	687b      	ldr	r3, [r7, #4]
 800aa28:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800aa2a:	687b      	ldr	r3, [r7, #4]
 800aa2c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800aa2e:	1ad3      	subs	r3, r2, r3
 800aa30:	60bb      	str	r3, [r7, #8]
#if !LWIP_WND_SCALE
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
 800aa32:	68ba      	ldr	r2, [r7, #8]
 800aa34:	2380      	movs	r3, #128	; 0x80
 800aa36:	025b      	lsls	r3, r3, #9
 800aa38:	429a      	cmp	r2, r3
 800aa3a:	d305      	bcc.n	800aa48 <tcp_update_rcv_ann_wnd+0x94>
 800aa3c:	4b07      	ldr	r3, [pc, #28]	; (800aa5c <tcp_update_rcv_ann_wnd+0xa8>)
 800aa3e:	4a0b      	ldr	r2, [pc, #44]	; (800aa6c <tcp_update_rcv_ann_wnd+0xb8>)
 800aa40:	490b      	ldr	r1, [pc, #44]	; (800aa70 <tcp_update_rcv_ann_wnd+0xbc>)
 800aa42:	4809      	ldr	r0, [pc, #36]	; (800aa68 <tcp_update_rcv_ann_wnd+0xb4>)
 800aa44:	f7f7 fbc2 	bl	80021cc <app_debug_rtt_raw>
#endif
      pcb->rcv_ann_wnd = (tcpwnd_size_t)new_rcv_ann_wnd;
 800aa48:	68bb      	ldr	r3, [r7, #8]
 800aa4a:	b29a      	uxth	r2, r3
 800aa4c:	687b      	ldr	r3, [r7, #4]
 800aa4e:	85da      	strh	r2, [r3, #46]	; 0x2e
    }
    return 0;
 800aa50:	2300      	movs	r3, #0
  }
}
 800aa52:	0018      	movs	r0, r3
 800aa54:	46bd      	mov	sp, r7
 800aa56:	b004      	add	sp, #16
 800aa58:	bd80      	pop	{r7, pc}
 800aa5a:	46c0      	nop			; (mov r8, r8)
 800aa5c:	0801f238 	.word	0x0801f238
 800aa60:	000003a7 	.word	0x000003a7
 800aa64:	0801f490 	.word	0x0801f490
 800aa68:	0801f274 	.word	0x0801f274
 800aa6c:	000003b7 	.word	0x000003b7
 800aa70:	0801f4b4 	.word	0x0801f4b4

0800aa74 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
 800aa74:	b580      	push	{r7, lr}
 800aa76:	b084      	sub	sp, #16
 800aa78:	af00      	add	r7, sp, #0
 800aa7a:	6078      	str	r0, [r7, #4]
 800aa7c:	000a      	movs	r2, r1
 800aa7e:	1cbb      	adds	r3, r7, #2
 800aa80:	801a      	strh	r2, [r3, #0]
  u32_t wnd_inflation;
  tcpwnd_size_t rcv_wnd;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_recved: invalid pcb", pcb != NULL, return);
 800aa82:	687b      	ldr	r3, [r7, #4]
 800aa84:	2b00      	cmp	r3, #0
 800aa86:	d104      	bne.n	800aa92 <tcp_recved+0x1e>
 800aa88:	4b23      	ldr	r3, [pc, #140]	; (800ab18 <tcp_recved+0xa4>)
 800aa8a:	0018      	movs	r0, r3
 800aa8c:	f7f7 fb9e 	bl	80021cc <app_debug_rtt_raw>
 800aa90:	e03e      	b.n	800ab10 <tcp_recved+0x9c>

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
 800aa92:	687b      	ldr	r3, [r7, #4]
 800aa94:	7e1b      	ldrb	r3, [r3, #24]
 800aa96:	2b01      	cmp	r3, #1
 800aa98:	d105      	bne.n	800aaa6 <tcp_recved+0x32>
 800aa9a:	4b20      	ldr	r3, [pc, #128]	; (800ab1c <tcp_recved+0xa8>)
 800aa9c:	4a20      	ldr	r2, [pc, #128]	; (800ab20 <tcp_recved+0xac>)
 800aa9e:	4921      	ldr	r1, [pc, #132]	; (800ab24 <tcp_recved+0xb0>)
 800aaa0:	4821      	ldr	r0, [pc, #132]	; (800ab28 <tcp_recved+0xb4>)
 800aaa2:	f7f7 fb93 	bl	80021cc <app_debug_rtt_raw>
              pcb->state != LISTEN);

  rcv_wnd = (tcpwnd_size_t)(pcb->rcv_wnd + len);
 800aaa6:	687b      	ldr	r3, [r7, #4]
 800aaa8:	8d99      	ldrh	r1, [r3, #44]	; 0x2c
 800aaaa:	200e      	movs	r0, #14
 800aaac:	183b      	adds	r3, r7, r0
 800aaae:	1cba      	adds	r2, r7, #2
 800aab0:	8812      	ldrh	r2, [r2, #0]
 800aab2:	188a      	adds	r2, r1, r2
 800aab4:	801a      	strh	r2, [r3, #0]
  if ((rcv_wnd > TCP_WND_MAX(pcb)) || (rcv_wnd < pcb->rcv_wnd)) {
 800aab6:	0001      	movs	r1, r0
 800aab8:	187b      	adds	r3, r7, r1
 800aaba:	881a      	ldrh	r2, [r3, #0]
 800aabc:	2386      	movs	r3, #134	; 0x86
 800aabe:	00db      	lsls	r3, r3, #3
 800aac0:	429a      	cmp	r2, r3
 800aac2:	d805      	bhi.n	800aad0 <tcp_recved+0x5c>
 800aac4:	687b      	ldr	r3, [r7, #4]
 800aac6:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800aac8:	187a      	adds	r2, r7, r1
 800aaca:	8812      	ldrh	r2, [r2, #0]
 800aacc:	429a      	cmp	r2, r3
 800aace:	d204      	bcs.n	800aada <tcp_recved+0x66>
    /* window got too big or tcpwnd_size_t overflow */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: window got too big or tcpwnd_size_t overflow\n"));
    pcb->rcv_wnd = TCP_WND_MAX(pcb);
 800aad0:	687b      	ldr	r3, [r7, #4]
 800aad2:	2286      	movs	r2, #134	; 0x86
 800aad4:	00d2      	lsls	r2, r2, #3
 800aad6:	859a      	strh	r2, [r3, #44]	; 0x2c
 800aad8:	e004      	b.n	800aae4 <tcp_recved+0x70>
  } else  {
    pcb->rcv_wnd = rcv_wnd;
 800aada:	687b      	ldr	r3, [r7, #4]
 800aadc:	220e      	movs	r2, #14
 800aade:	18ba      	adds	r2, r7, r2
 800aae0:	8812      	ldrh	r2, [r2, #0]
 800aae2:	859a      	strh	r2, [r3, #44]	; 0x2c
  }

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
 800aae4:	687b      	ldr	r3, [r7, #4]
 800aae6:	0018      	movs	r0, r3
 800aae8:	f7ff ff64 	bl	800a9b4 <tcp_update_rcv_ann_wnd>
 800aaec:	0003      	movs	r3, r0
 800aaee:	60bb      	str	r3, [r7, #8]

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 800aaf0:	68ba      	ldr	r2, [r7, #8]
 800aaf2:	2386      	movs	r3, #134	; 0x86
 800aaf4:	005b      	lsls	r3, r3, #1
 800aaf6:	429a      	cmp	r2, r3
 800aaf8:	d30a      	bcc.n	800ab10 <tcp_recved+0x9c>
    tcp_ack_now(pcb);
 800aafa:	687b      	ldr	r3, [r7, #4]
 800aafc:	8bdb      	ldrh	r3, [r3, #30]
 800aafe:	2202      	movs	r2, #2
 800ab00:	4313      	orrs	r3, r2
 800ab02:	b29a      	uxth	r2, r3
 800ab04:	687b      	ldr	r3, [r7, #4]
 800ab06:	83da      	strh	r2, [r3, #30]
    tcp_output(pcb);
 800ab08:	687b      	ldr	r3, [r7, #4]
 800ab0a:	0018      	movs	r0, r3
 800ab0c:	f005 fd38 	bl	8010580 <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: received %"U16_F" bytes, wnd %"TCPWNDSIZE_F" (%"TCPWNDSIZE_F").\n",
                          len, pcb->rcv_wnd, (u16_t)(TCP_WND_MAX(pcb) - pcb->rcv_wnd)));
}
 800ab10:	46bd      	mov	sp, r7
 800ab12:	b004      	add	sp, #16
 800ab14:	bd80      	pop	{r7, pc}
 800ab16:	46c0      	nop			; (mov r8, r8)
 800ab18:	0801f4d0 	.word	0x0801f4d0
 800ab1c:	0801f238 	.word	0x0801f238
 800ab20:	000003d3 	.word	0x000003d3
 800ab24:	0801f4e8 	.word	0x0801f4e8
 800ab28:	0801f274 	.word	0x0801f274

0800ab2c <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
 800ab2c:	b580      	push	{r7, lr}
 800ab2e:	b082      	sub	sp, #8
 800ab30:	af00      	add	r7, sp, #0
  u8_t i;
  u16_t n = 0;
 800ab32:	1d3b      	adds	r3, r7, #4
 800ab34:	2200      	movs	r2, #0
 800ab36:	801a      	strh	r2, [r3, #0]
  struct tcp_pcb *pcb;

again:
  tcp_port++;
 800ab38:	4b20      	ldr	r3, [pc, #128]	; (800abbc <tcp_new_port+0x90>)
 800ab3a:	881b      	ldrh	r3, [r3, #0]
 800ab3c:	3301      	adds	r3, #1
 800ab3e:	b29a      	uxth	r2, r3
 800ab40:	4b1e      	ldr	r3, [pc, #120]	; (800abbc <tcp_new_port+0x90>)
 800ab42:	801a      	strh	r2, [r3, #0]
  if (tcp_port == TCP_LOCAL_PORT_RANGE_END) {
 800ab44:	4b1d      	ldr	r3, [pc, #116]	; (800abbc <tcp_new_port+0x90>)
 800ab46:	881b      	ldrh	r3, [r3, #0]
 800ab48:	4a1d      	ldr	r2, [pc, #116]	; (800abc0 <tcp_new_port+0x94>)
 800ab4a:	4293      	cmp	r3, r2
 800ab4c:	d102      	bne.n	800ab54 <tcp_new_port+0x28>
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
 800ab4e:	4b1b      	ldr	r3, [pc, #108]	; (800abbc <tcp_new_port+0x90>)
 800ab50:	4a1c      	ldr	r2, [pc, #112]	; (800abc4 <tcp_new_port+0x98>)
 800ab52:	801a      	strh	r2, [r3, #0]
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 800ab54:	1dfb      	adds	r3, r7, #7
 800ab56:	2200      	movs	r2, #0
 800ab58:	701a      	strb	r2, [r3, #0]
 800ab5a:	e025      	b.n	800aba8 <tcp_new_port+0x7c>
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 800ab5c:	1dfb      	adds	r3, r7, #7
 800ab5e:	781a      	ldrb	r2, [r3, #0]
 800ab60:	4b19      	ldr	r3, [pc, #100]	; (800abc8 <tcp_new_port+0x9c>)
 800ab62:	0092      	lsls	r2, r2, #2
 800ab64:	58d3      	ldr	r3, [r2, r3]
 800ab66:	681b      	ldr	r3, [r3, #0]
 800ab68:	603b      	str	r3, [r7, #0]
 800ab6a:	e015      	b.n	800ab98 <tcp_new_port+0x6c>
      if (pcb->local_port == tcp_port) {
 800ab6c:	683b      	ldr	r3, [r7, #0]
 800ab6e:	8b5a      	ldrh	r2, [r3, #26]
 800ab70:	4b12      	ldr	r3, [pc, #72]	; (800abbc <tcp_new_port+0x90>)
 800ab72:	881b      	ldrh	r3, [r3, #0]
 800ab74:	429a      	cmp	r2, r3
 800ab76:	d10c      	bne.n	800ab92 <tcp_new_port+0x66>
        n++;
 800ab78:	1d3b      	adds	r3, r7, #4
 800ab7a:	881a      	ldrh	r2, [r3, #0]
 800ab7c:	1d3b      	adds	r3, r7, #4
 800ab7e:	3201      	adds	r2, #1
 800ab80:	801a      	strh	r2, [r3, #0]
        if (n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
 800ab82:	1d3b      	adds	r3, r7, #4
 800ab84:	881a      	ldrh	r2, [r3, #0]
 800ab86:	2380      	movs	r3, #128	; 0x80
 800ab88:	01db      	lsls	r3, r3, #7
 800ab8a:	429a      	cmp	r2, r3
 800ab8c:	d3d4      	bcc.n	800ab38 <tcp_new_port+0xc>
          return 0;
 800ab8e:	2300      	movs	r3, #0
 800ab90:	e010      	b.n	800abb4 <tcp_new_port+0x88>
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 800ab92:	683b      	ldr	r3, [r7, #0]
 800ab94:	691b      	ldr	r3, [r3, #16]
 800ab96:	603b      	str	r3, [r7, #0]
 800ab98:	683b      	ldr	r3, [r7, #0]
 800ab9a:	2b00      	cmp	r3, #0
 800ab9c:	d1e6      	bne.n	800ab6c <tcp_new_port+0x40>
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 800ab9e:	1dfb      	adds	r3, r7, #7
 800aba0:	781a      	ldrb	r2, [r3, #0]
 800aba2:	1dfb      	adds	r3, r7, #7
 800aba4:	3201      	adds	r2, #1
 800aba6:	701a      	strb	r2, [r3, #0]
 800aba8:	1dfb      	adds	r3, r7, #7
 800abaa:	781b      	ldrb	r3, [r3, #0]
 800abac:	2b03      	cmp	r3, #3
 800abae:	d9d5      	bls.n	800ab5c <tcp_new_port+0x30>
        }
        goto again;
      }
    }
  }
  return tcp_port;
 800abb0:	4b02      	ldr	r3, [pc, #8]	; (800abbc <tcp_new_port+0x90>)
 800abb2:	881b      	ldrh	r3, [r3, #0]
}
 800abb4:	0018      	movs	r0, r3
 800abb6:	46bd      	mov	sp, r7
 800abb8:	b002      	add	sp, #8
 800abba:	bd80      	pop	{r7, pc}
 800abbc:	2000020e 	.word	0x2000020e
 800abc0:	0000ffff 	.word	0x0000ffff
 800abc4:	ffffc000 	.word	0xffffc000
 800abc8:	08021a08 	.word	0x08021a08

0800abcc <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port,
            tcp_connected_fn connected)
{
 800abcc:	b5b0      	push	{r4, r5, r7, lr}
 800abce:	b08c      	sub	sp, #48	; 0x30
 800abd0:	af00      	add	r7, sp, #0
 800abd2:	60f8      	str	r0, [r7, #12]
 800abd4:	60b9      	str	r1, [r7, #8]
 800abd6:	603b      	str	r3, [r7, #0]
 800abd8:	1dbb      	adds	r3, r7, #6
 800abda:	801a      	strh	r2, [r3, #0]
  struct netif *netif = NULL;
 800abdc:	2300      	movs	r3, #0
 800abde:	62fb      	str	r3, [r7, #44]	; 0x2c
  u32_t iss;
  u16_t old_local_port;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_connect: invalid pcb", pcb != NULL, return ERR_ARG);
 800abe0:	68fb      	ldr	r3, [r7, #12]
 800abe2:	2b00      	cmp	r3, #0
 800abe4:	d106      	bne.n	800abf4 <tcp_connect+0x28>
 800abe6:	4b9c      	ldr	r3, [pc, #624]	; (800ae58 <tcp_connect+0x28c>)
 800abe8:	0018      	movs	r0, r3
 800abea:	f7f7 faef 	bl	80021cc <app_debug_rtt_raw>
 800abee:	2310      	movs	r3, #16
 800abf0:	425b      	negs	r3, r3
 800abf2:	e12d      	b.n	800ae50 <tcp_connect+0x284>
  LWIP_ERROR("tcp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
 800abf4:	68bb      	ldr	r3, [r7, #8]
 800abf6:	2b00      	cmp	r3, #0
 800abf8:	d106      	bne.n	800ac08 <tcp_connect+0x3c>
 800abfa:	4b98      	ldr	r3, [pc, #608]	; (800ae5c <tcp_connect+0x290>)
 800abfc:	0018      	movs	r0, r3
 800abfe:	f7f7 fae5 	bl	80021cc <app_debug_rtt_raw>
 800ac02:	2310      	movs	r3, #16
 800ac04:	425b      	negs	r3, r3
 800ac06:	e123      	b.n	800ae50 <tcp_connect+0x284>

  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
 800ac08:	68fb      	ldr	r3, [r7, #12]
 800ac0a:	7e1b      	ldrb	r3, [r3, #24]
 800ac0c:	2b00      	cmp	r3, #0
 800ac0e:	d006      	beq.n	800ac1e <tcp_connect+0x52>
 800ac10:	4b93      	ldr	r3, [pc, #588]	; (800ae60 <tcp_connect+0x294>)
 800ac12:	0018      	movs	r0, r3
 800ac14:	f7f7 fada 	bl	80021cc <app_debug_rtt_raw>
 800ac18:	230a      	movs	r3, #10
 800ac1a:	425b      	negs	r3, r3
 800ac1c:	e118      	b.n	800ae50 <tcp_connect+0x284>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  ip_addr_set(&pcb->remote_ip, ipaddr);
 800ac1e:	68bb      	ldr	r3, [r7, #8]
 800ac20:	2b00      	cmp	r3, #0
 800ac22:	d002      	beq.n	800ac2a <tcp_connect+0x5e>
 800ac24:	68bb      	ldr	r3, [r7, #8]
 800ac26:	681a      	ldr	r2, [r3, #0]
 800ac28:	e000      	b.n	800ac2c <tcp_connect+0x60>
 800ac2a:	2200      	movs	r2, #0
 800ac2c:	68fb      	ldr	r3, [r7, #12]
 800ac2e:	605a      	str	r2, [r3, #4]
  pcb->remote_port = port;
 800ac30:	68fb      	ldr	r3, [r7, #12]
 800ac32:	1dba      	adds	r2, r7, #6
 800ac34:	8812      	ldrh	r2, [r2, #0]
 800ac36:	839a      	strh	r2, [r3, #28]

  if (pcb->netif_idx != NETIF_NO_INDEX) {
 800ac38:	68fb      	ldr	r3, [r7, #12]
 800ac3a:	7a1b      	ldrb	r3, [r3, #8]
 800ac3c:	2b00      	cmp	r3, #0
 800ac3e:	d007      	beq.n	800ac50 <tcp_connect+0x84>
    netif = netif_get_by_index(pcb->netif_idx);
 800ac40:	68fb      	ldr	r3, [r7, #12]
 800ac42:	7a1b      	ldrb	r3, [r3, #8]
 800ac44:	0018      	movs	r0, r3
 800ac46:	f7fe f92f 	bl	8008ea8 <netif_get_by_index>
 800ac4a:	0003      	movs	r3, r0
 800ac4c:	62fb      	str	r3, [r7, #44]	; 0x2c
 800ac4e:	e006      	b.n	800ac5e <tcp_connect+0x92>
  } else {
    /* check if we have a route to the remote host */
    netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
 800ac50:	68fb      	ldr	r3, [r7, #12]
 800ac52:	3304      	adds	r3, #4
 800ac54:	0018      	movs	r0, r3
 800ac56:	f008 f929 	bl	8012eac <ip4_route>
 800ac5a:	0003      	movs	r3, r0
 800ac5c:	62fb      	str	r3, [r7, #44]	; 0x2c
  }
  if (netif == NULL) {
 800ac5e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ac60:	2b00      	cmp	r3, #0
 800ac62:	d102      	bne.n	800ac6a <tcp_connect+0x9e>
    /* Don't even try to send a SYN packet if we have no route since that will fail. */
    return ERR_RTE;
 800ac64:	2304      	movs	r3, #4
 800ac66:	425b      	negs	r3, r3
 800ac68:	e0f2      	b.n	800ae50 <tcp_connect+0x284>
  }

  /* check if local IP has been assigned to pcb, if not, get one */
  if (ip_addr_isany(&pcb->local_ip)) {
 800ac6a:	68fb      	ldr	r3, [r7, #12]
 800ac6c:	2b00      	cmp	r3, #0
 800ac6e:	d003      	beq.n	800ac78 <tcp_connect+0xac>
 800ac70:	68fb      	ldr	r3, [r7, #12]
 800ac72:	681b      	ldr	r3, [r3, #0]
 800ac74:	2b00      	cmp	r3, #0
 800ac76:	d111      	bne.n	800ac9c <tcp_connect+0xd0>
    const ip_addr_t *local_ip = ip_netif_get_local_ip(netif, ipaddr);
 800ac78:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ac7a:	2b00      	cmp	r3, #0
 800ac7c:	d002      	beq.n	800ac84 <tcp_connect+0xb8>
 800ac7e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ac80:	3304      	adds	r3, #4
 800ac82:	e000      	b.n	800ac86 <tcp_connect+0xba>
 800ac84:	2300      	movs	r3, #0
 800ac86:	61fb      	str	r3, [r7, #28]
    if (local_ip == NULL) {
 800ac88:	69fb      	ldr	r3, [r7, #28]
 800ac8a:	2b00      	cmp	r3, #0
 800ac8c:	d102      	bne.n	800ac94 <tcp_connect+0xc8>
      return ERR_RTE;
 800ac8e:	2304      	movs	r3, #4
 800ac90:	425b      	negs	r3, r3
 800ac92:	e0dd      	b.n	800ae50 <tcp_connect+0x284>
    }
    ip_addr_copy(pcb->local_ip, *local_ip);
 800ac94:	69fb      	ldr	r3, [r7, #28]
 800ac96:	681a      	ldr	r2, [r3, #0]
 800ac98:	68fb      	ldr	r3, [r7, #12]
 800ac9a:	601a      	str	r2, [r3, #0]
      ip6_addr_lacks_zone(ip_2_ip6(&pcb->remote_ip), IP6_UNICAST)) {
    ip6_addr_assign_zone(ip_2_ip6(&pcb->remote_ip), IP6_UNICAST, netif);
  }
#endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */

  old_local_port = pcb->local_port;
 800ac9c:	231a      	movs	r3, #26
 800ac9e:	18fb      	adds	r3, r7, r3
 800aca0:	68fa      	ldr	r2, [r7, #12]
 800aca2:	8b52      	ldrh	r2, [r2, #26]
 800aca4:	801a      	strh	r2, [r3, #0]
  if (pcb->local_port == 0) {
 800aca6:	68fb      	ldr	r3, [r7, #12]
 800aca8:	8b5b      	ldrh	r3, [r3, #26]
 800acaa:	2b00      	cmp	r3, #0
 800acac:	d10c      	bne.n	800acc8 <tcp_connect+0xfc>
    pcb->local_port = tcp_new_port();
 800acae:	f7ff ff3d 	bl	800ab2c <tcp_new_port>
 800acb2:	0003      	movs	r3, r0
 800acb4:	001a      	movs	r2, r3
 800acb6:	68fb      	ldr	r3, [r7, #12]
 800acb8:	835a      	strh	r2, [r3, #26]
    if (pcb->local_port == 0) {
 800acba:	68fb      	ldr	r3, [r7, #12]
 800acbc:	8b5b      	ldrh	r3, [r3, #26]
 800acbe:	2b00      	cmp	r3, #0
 800acc0:	d139      	bne.n	800ad36 <tcp_connect+0x16a>
      return ERR_BUF;
 800acc2:	2302      	movs	r3, #2
 800acc4:	425b      	negs	r3, r3
 800acc6:	e0c3      	b.n	800ae50 <tcp_connect+0x284>
    }
  } else {
#if SO_REUSE
    if (ip_get_option(pcb, SOF_REUSEADDR)) {
 800acc8:	68fb      	ldr	r3, [r7, #12]
 800acca:	7a5b      	ldrb	r3, [r3, #9]
 800accc:	001a      	movs	r2, r3
 800acce:	2304      	movs	r3, #4
 800acd0:	4013      	ands	r3, r2
 800acd2:	d030      	beq.n	800ad36 <tcp_connect+0x16a>
      /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
         now that the 5-tuple is unique. */
      struct tcp_pcb *cpcb;
      int i;
      /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
      for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
 800acd4:	2302      	movs	r3, #2
 800acd6:	627b      	str	r3, [r7, #36]	; 0x24
 800acd8:	e02a      	b.n	800ad30 <tcp_connect+0x164>
        for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 800acda:	4b62      	ldr	r3, [pc, #392]	; (800ae64 <tcp_connect+0x298>)
 800acdc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800acde:	0092      	lsls	r2, r2, #2
 800ace0:	58d3      	ldr	r3, [r2, r3]
 800ace2:	681b      	ldr	r3, [r3, #0]
 800ace4:	62bb      	str	r3, [r7, #40]	; 0x28
 800ace6:	e01d      	b.n	800ad24 <tcp_connect+0x158>
          if ((cpcb->local_port == pcb->local_port) &&
 800ace8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800acea:	8b5a      	ldrh	r2, [r3, #26]
 800acec:	68fb      	ldr	r3, [r7, #12]
 800acee:	8b5b      	ldrh	r3, [r3, #26]
 800acf0:	429a      	cmp	r2, r3
 800acf2:	d114      	bne.n	800ad1e <tcp_connect+0x152>
              (cpcb->remote_port == port) &&
 800acf4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800acf6:	8b9b      	ldrh	r3, [r3, #28]
          if ((cpcb->local_port == pcb->local_port) &&
 800acf8:	1dba      	adds	r2, r7, #6
 800acfa:	8812      	ldrh	r2, [r2, #0]
 800acfc:	429a      	cmp	r2, r3
 800acfe:	d10e      	bne.n	800ad1e <tcp_connect+0x152>
              ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
 800ad00:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ad02:	681a      	ldr	r2, [r3, #0]
 800ad04:	68fb      	ldr	r3, [r7, #12]
 800ad06:	681b      	ldr	r3, [r3, #0]
              (cpcb->remote_port == port) &&
 800ad08:	429a      	cmp	r2, r3
 800ad0a:	d108      	bne.n	800ad1e <tcp_connect+0x152>
              ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
 800ad0c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ad0e:	685a      	ldr	r2, [r3, #4]
 800ad10:	68bb      	ldr	r3, [r7, #8]
 800ad12:	681b      	ldr	r3, [r3, #0]
              ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
 800ad14:	429a      	cmp	r2, r3
 800ad16:	d102      	bne.n	800ad1e <tcp_connect+0x152>
            /* linux returns EISCONN here, but ERR_USE should be OK for us */
            return ERR_USE;
 800ad18:	2308      	movs	r3, #8
 800ad1a:	425b      	negs	r3, r3
 800ad1c:	e098      	b.n	800ae50 <tcp_connect+0x284>
        for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 800ad1e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ad20:	691b      	ldr	r3, [r3, #16]
 800ad22:	62bb      	str	r3, [r7, #40]	; 0x28
 800ad24:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ad26:	2b00      	cmp	r3, #0
 800ad28:	d1de      	bne.n	800ace8 <tcp_connect+0x11c>
      for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
 800ad2a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ad2c:	3301      	adds	r3, #1
 800ad2e:	627b      	str	r3, [r7, #36]	; 0x24
 800ad30:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ad32:	2b03      	cmp	r3, #3
 800ad34:	ddd1      	ble.n	800acda <tcp_connect+0x10e>
      }
    }
#endif /* SO_REUSE */
  }

  iss = tcp_next_iss(pcb);
 800ad36:	68fb      	ldr	r3, [r7, #12]
 800ad38:	0018      	movs	r0, r3
 800ad3a:	f001 f8d9 	bl	800bef0 <tcp_next_iss>
 800ad3e:	0003      	movs	r3, r0
 800ad40:	617b      	str	r3, [r7, #20]
  pcb->rcv_nxt = 0;
 800ad42:	68fb      	ldr	r3, [r7, #12]
 800ad44:	2200      	movs	r2, #0
 800ad46:	629a      	str	r2, [r3, #40]	; 0x28
  pcb->snd_nxt = iss;
 800ad48:	68fb      	ldr	r3, [r7, #12]
 800ad4a:	697a      	ldr	r2, [r7, #20]
 800ad4c:	655a      	str	r2, [r3, #84]	; 0x54
  pcb->lastack = iss - 1;
 800ad4e:	697b      	ldr	r3, [r7, #20]
 800ad50:	1e5a      	subs	r2, r3, #1
 800ad52:	68fb      	ldr	r3, [r7, #12]
 800ad54:	649a      	str	r2, [r3, #72]	; 0x48
  pcb->snd_wl2 = iss - 1;
 800ad56:	697b      	ldr	r3, [r7, #20]
 800ad58:	1e5a      	subs	r2, r3, #1
 800ad5a:	68fb      	ldr	r3, [r7, #12]
 800ad5c:	65da      	str	r2, [r3, #92]	; 0x5c
  pcb->snd_lbb = iss - 1;
 800ad5e:	697b      	ldr	r3, [r7, #20]
 800ad60:	1e5a      	subs	r2, r3, #1
 800ad62:	68fb      	ldr	r3, [r7, #12]
 800ad64:	661a      	str	r2, [r3, #96]	; 0x60
  /* Start with a window that does not need scaling. When window scaling is
     enabled and used, the window is enlarged when both sides agree on scaling. */
  pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 800ad66:	68fb      	ldr	r3, [r7, #12]
 800ad68:	2286      	movs	r2, #134	; 0x86
 800ad6a:	00d2      	lsls	r2, r2, #3
 800ad6c:	85da      	strh	r2, [r3, #46]	; 0x2e
 800ad6e:	68fb      	ldr	r3, [r7, #12]
 800ad70:	8dda      	ldrh	r2, [r3, #46]	; 0x2e
 800ad72:	68fb      	ldr	r3, [r7, #12]
 800ad74:	859a      	strh	r2, [r3, #44]	; 0x2c
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 800ad76:	68fb      	ldr	r3, [r7, #12]
 800ad78:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800ad7a:	68fb      	ldr	r3, [r7, #12]
 800ad7c:	631a      	str	r2, [r3, #48]	; 0x30
  pcb->snd_wnd = TCP_WND;
 800ad7e:	68fb      	ldr	r3, [r7, #12]
 800ad80:	2264      	movs	r2, #100	; 0x64
 800ad82:	2186      	movs	r1, #134	; 0x86
 800ad84:	00c9      	lsls	r1, r1, #3
 800ad86:	5299      	strh	r1, [r3, r2]
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = INITIAL_MSS;
 800ad88:	68fb      	ldr	r3, [r7, #12]
 800ad8a:	2286      	movs	r2, #134	; 0x86
 800ad8c:	0092      	lsls	r2, r2, #2
 800ad8e:	86da      	strh	r2, [r3, #54]	; 0x36
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss_netif(pcb->mss, netif, &pcb->remote_ip);
 800ad90:	68fb      	ldr	r3, [r7, #12]
 800ad92:	8ed8      	ldrh	r0, [r3, #54]	; 0x36
 800ad94:	68fb      	ldr	r3, [r7, #12]
 800ad96:	1d1a      	adds	r2, r3, #4
 800ad98:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ad9a:	0019      	movs	r1, r3
 800ad9c:	f001 f8ce 	bl	800bf3c <tcp_eff_send_mss_netif>
 800ada0:	0003      	movs	r3, r0
 800ada2:	001a      	movs	r2, r3
 800ada4:	68fb      	ldr	r3, [r7, #12]
 800ada6:	86da      	strh	r2, [r3, #54]	; 0x36
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
 800ada8:	68fb      	ldr	r3, [r7, #12]
 800adaa:	224c      	movs	r2, #76	; 0x4c
 800adac:	2101      	movs	r1, #1
 800adae:	5299      	strh	r1, [r3, r2]
#if LWIP_CALLBACK_API
  pcb->connected = connected;
 800adb0:	68fb      	ldr	r3, [r7, #12]
 800adb2:	218c      	movs	r1, #140	; 0x8c
 800adb4:	683a      	ldr	r2, [r7, #0]
 800adb6:	505a      	str	r2, [r3, r1]
#else /* LWIP_CALLBACK_API */
  LWIP_UNUSED_ARG(connected);
#endif /* LWIP_CALLBACK_API */

  /* Send a SYN together with the MSS option. */
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
 800adb8:	2513      	movs	r5, #19
 800adba:	197c      	adds	r4, r7, r5
 800adbc:	68fb      	ldr	r3, [r7, #12]
 800adbe:	2102      	movs	r1, #2
 800adc0:	0018      	movs	r0, r3
 800adc2:	f005 fad7 	bl	8010374 <tcp_enqueue_flags>
 800adc6:	0003      	movs	r3, r0
 800adc8:	7023      	strb	r3, [r4, #0]
  if (ret == ERR_OK) {
 800adca:	197b      	adds	r3, r7, r5
 800adcc:	781b      	ldrb	r3, [r3, #0]
 800adce:	b25b      	sxtb	r3, r3
 800add0:	2b00      	cmp	r3, #0
 800add2:	d139      	bne.n	800ae48 <tcp_connect+0x27c>
    /* SYN segment was enqueued, changed the pcbs state now */
    pcb->state = SYN_SENT;
 800add4:	68fb      	ldr	r3, [r7, #12]
 800add6:	2202      	movs	r2, #2
 800add8:	761a      	strb	r2, [r3, #24]
    if (old_local_port != 0) {
 800adda:	231a      	movs	r3, #26
 800addc:	18fb      	adds	r3, r7, r3
 800adde:	881b      	ldrh	r3, [r3, #0]
 800ade0:	2b00      	cmp	r3, #0
 800ade2:	d021      	beq.n	800ae28 <tcp_connect+0x25c>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 800ade4:	4b20      	ldr	r3, [pc, #128]	; (800ae68 <tcp_connect+0x29c>)
 800ade6:	681b      	ldr	r3, [r3, #0]
 800ade8:	68fa      	ldr	r2, [r7, #12]
 800adea:	429a      	cmp	r2, r3
 800adec:	d105      	bne.n	800adfa <tcp_connect+0x22e>
 800adee:	4b1e      	ldr	r3, [pc, #120]	; (800ae68 <tcp_connect+0x29c>)
 800adf0:	681b      	ldr	r3, [r3, #0]
 800adf2:	691a      	ldr	r2, [r3, #16]
 800adf4:	4b1c      	ldr	r3, [pc, #112]	; (800ae68 <tcp_connect+0x29c>)
 800adf6:	601a      	str	r2, [r3, #0]
 800adf8:	e013      	b.n	800ae22 <tcp_connect+0x256>
 800adfa:	4b1b      	ldr	r3, [pc, #108]	; (800ae68 <tcp_connect+0x29c>)
 800adfc:	681b      	ldr	r3, [r3, #0]
 800adfe:	623b      	str	r3, [r7, #32]
 800ae00:	e00c      	b.n	800ae1c <tcp_connect+0x250>
 800ae02:	6a3b      	ldr	r3, [r7, #32]
 800ae04:	691b      	ldr	r3, [r3, #16]
 800ae06:	68fa      	ldr	r2, [r7, #12]
 800ae08:	429a      	cmp	r2, r3
 800ae0a:	d104      	bne.n	800ae16 <tcp_connect+0x24a>
 800ae0c:	68fb      	ldr	r3, [r7, #12]
 800ae0e:	691a      	ldr	r2, [r3, #16]
 800ae10:	6a3b      	ldr	r3, [r7, #32]
 800ae12:	611a      	str	r2, [r3, #16]
 800ae14:	e005      	b.n	800ae22 <tcp_connect+0x256>
 800ae16:	6a3b      	ldr	r3, [r7, #32]
 800ae18:	691b      	ldr	r3, [r3, #16]
 800ae1a:	623b      	str	r3, [r7, #32]
 800ae1c:	6a3b      	ldr	r3, [r7, #32]
 800ae1e:	2b00      	cmp	r3, #0
 800ae20:	d1ef      	bne.n	800ae02 <tcp_connect+0x236>
 800ae22:	68fb      	ldr	r3, [r7, #12]
 800ae24:	2200      	movs	r2, #0
 800ae26:	611a      	str	r2, [r3, #16]
    }
    TCP_REG_ACTIVE(pcb);
 800ae28:	4b10      	ldr	r3, [pc, #64]	; (800ae6c <tcp_connect+0x2a0>)
 800ae2a:	681a      	ldr	r2, [r3, #0]
 800ae2c:	68fb      	ldr	r3, [r7, #12]
 800ae2e:	611a      	str	r2, [r3, #16]
 800ae30:	4b0e      	ldr	r3, [pc, #56]	; (800ae6c <tcp_connect+0x2a0>)
 800ae32:	68fa      	ldr	r2, [r7, #12]
 800ae34:	601a      	str	r2, [r3, #0]
 800ae36:	f006 fe21 	bl	8011a7c <tcp_timer_needed>
 800ae3a:	4b0d      	ldr	r3, [pc, #52]	; (800ae70 <tcp_connect+0x2a4>)
 800ae3c:	2201      	movs	r2, #1
 800ae3e:	701a      	strb	r2, [r3, #0]
    MIB2_STATS_INC(mib2.tcpactiveopens);

    tcp_output(pcb);
 800ae40:	68fb      	ldr	r3, [r7, #12]
 800ae42:	0018      	movs	r0, r3
 800ae44:	f005 fb9c 	bl	8010580 <tcp_output>
  }
  return ret;
 800ae48:	2313      	movs	r3, #19
 800ae4a:	18fb      	adds	r3, r7, r3
 800ae4c:	781b      	ldrb	r3, [r3, #0]
 800ae4e:	b25b      	sxtb	r3, r3
}
 800ae50:	0018      	movs	r0, r3
 800ae52:	46bd      	mov	sp, r7
 800ae54:	b00c      	add	sp, #48	; 0x30
 800ae56:	bdb0      	pop	{r4, r5, r7, pc}
 800ae58:	0801f510 	.word	0x0801f510
 800ae5c:	0801f52c 	.word	0x0801f52c
 800ae60:	0801f548 	.word	0x0801f548
 800ae64:	08021a08 	.word	0x08021a08
 800ae68:	20002b24 	.word	0x20002b24
 800ae6c:	20002b18 	.word	0x20002b18
 800ae70:	20002b14 	.word	0x20002b14

0800ae74 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
 800ae74:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ae76:	b091      	sub	sp, #68	; 0x44
 800ae78:	af04      	add	r7, sp, #16
  tcpwnd_size_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;
 800ae7a:	2325      	movs	r3, #37	; 0x25
 800ae7c:	18fb      	adds	r3, r7, r3
 800ae7e:	2200      	movs	r2, #0
 800ae80:	701a      	strb	r2, [r3, #0]

  ++tcp_ticks;
 800ae82:	4b9c      	ldr	r3, [pc, #624]	; (800b0f4 <tcp_slowtmr+0x280>)
 800ae84:	681b      	ldr	r3, [r3, #0]
 800ae86:	1c5a      	adds	r2, r3, #1
 800ae88:	4b9a      	ldr	r3, [pc, #616]	; (800b0f4 <tcp_slowtmr+0x280>)
 800ae8a:	601a      	str	r2, [r3, #0]
  ++tcp_timer_ctr;
 800ae8c:	4b9a      	ldr	r3, [pc, #616]	; (800b0f8 <tcp_slowtmr+0x284>)
 800ae8e:	781b      	ldrb	r3, [r3, #0]
 800ae90:	3301      	adds	r3, #1
 800ae92:	b2da      	uxtb	r2, r3
 800ae94:	4b98      	ldr	r3, [pc, #608]	; (800b0f8 <tcp_slowtmr+0x284>)
 800ae96:	701a      	strb	r2, [r3, #0]

tcp_slowtmr_start:
  /* Steps through all of the active PCBs. */
  prev = NULL;
 800ae98:	2300      	movs	r3, #0
 800ae9a:	62bb      	str	r3, [r7, #40]	; 0x28
  pcb = tcp_active_pcbs;
 800ae9c:	4b97      	ldr	r3, [pc, #604]	; (800b0fc <tcp_slowtmr+0x288>)
 800ae9e:	681b      	ldr	r3, [r3, #0]
 800aea0:	62fb      	str	r3, [r7, #44]	; 0x2c
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 800aea2:	e2e2      	b.n	800b46a <tcp_slowtmr+0x5f6>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 800aea4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800aea6:	7e1b      	ldrb	r3, [r3, #24]
 800aea8:	2b00      	cmp	r3, #0
 800aeaa:	d105      	bne.n	800aeb8 <tcp_slowtmr+0x44>
 800aeac:	4b94      	ldr	r3, [pc, #592]	; (800b100 <tcp_slowtmr+0x28c>)
 800aeae:	4a95      	ldr	r2, [pc, #596]	; (800b104 <tcp_slowtmr+0x290>)
 800aeb0:	4995      	ldr	r1, [pc, #596]	; (800b108 <tcp_slowtmr+0x294>)
 800aeb2:	4896      	ldr	r0, [pc, #600]	; (800b10c <tcp_slowtmr+0x298>)
 800aeb4:	f7f7 f98a 	bl	80021cc <app_debug_rtt_raw>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
 800aeb8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800aeba:	7e1b      	ldrb	r3, [r3, #24]
 800aebc:	2b01      	cmp	r3, #1
 800aebe:	d106      	bne.n	800aece <tcp_slowtmr+0x5a>
 800aec0:	4b8f      	ldr	r3, [pc, #572]	; (800b100 <tcp_slowtmr+0x28c>)
 800aec2:	2298      	movs	r2, #152	; 0x98
 800aec4:	00d2      	lsls	r2, r2, #3
 800aec6:	4992      	ldr	r1, [pc, #584]	; (800b110 <tcp_slowtmr+0x29c>)
 800aec8:	4890      	ldr	r0, [pc, #576]	; (800b10c <tcp_slowtmr+0x298>)
 800aeca:	f7f7 f97f 	bl	80021cc <app_debug_rtt_raw>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
 800aece:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800aed0:	7e1b      	ldrb	r3, [r3, #24]
 800aed2:	2b0a      	cmp	r3, #10
 800aed4:	d105      	bne.n	800aee2 <tcp_slowtmr+0x6e>
 800aed6:	4b8a      	ldr	r3, [pc, #552]	; (800b100 <tcp_slowtmr+0x28c>)
 800aed8:	4a8e      	ldr	r2, [pc, #568]	; (800b114 <tcp_slowtmr+0x2a0>)
 800aeda:	498f      	ldr	r1, [pc, #572]	; (800b118 <tcp_slowtmr+0x2a4>)
 800aedc:	488b      	ldr	r0, [pc, #556]	; (800b10c <tcp_slowtmr+0x298>)
 800aede:	f7f7 f975 	bl	80021cc <app_debug_rtt_raw>
    if (pcb->last_timer == tcp_timer_ctr) {
 800aee2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800aee4:	2222      	movs	r2, #34	; 0x22
 800aee6:	5c9a      	ldrb	r2, [r3, r2]
 800aee8:	4b83      	ldr	r3, [pc, #524]	; (800b0f8 <tcp_slowtmr+0x284>)
 800aeea:	781b      	ldrb	r3, [r3, #0]
 800aeec:	429a      	cmp	r2, r3
 800aeee:	d105      	bne.n	800aefc <tcp_slowtmr+0x88>
      /* skip this pcb, we have already processed it */
      prev = pcb;
 800aef0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800aef2:	62bb      	str	r3, [r7, #40]	; 0x28
      pcb = pcb->next;
 800aef4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800aef6:	691b      	ldr	r3, [r3, #16]
 800aef8:	62fb      	str	r3, [r7, #44]	; 0x2c
      continue;
 800aefa:	e2b6      	b.n	800b46a <tcp_slowtmr+0x5f6>
    }
    pcb->last_timer = tcp_timer_ctr;
 800aefc:	4b7e      	ldr	r3, [pc, #504]	; (800b0f8 <tcp_slowtmr+0x284>)
 800aefe:	7819      	ldrb	r1, [r3, #0]
 800af00:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af02:	2222      	movs	r2, #34	; 0x22
 800af04:	5499      	strb	r1, [r3, r2]

    pcb_remove = 0;
 800af06:	2127      	movs	r1, #39	; 0x27
 800af08:	187b      	adds	r3, r7, r1
 800af0a:	2200      	movs	r2, #0
 800af0c:	701a      	strb	r2, [r3, #0]
    pcb_reset = 0;
 800af0e:	2326      	movs	r3, #38	; 0x26
 800af10:	18fb      	adds	r3, r7, r3
 800af12:	2200      	movs	r2, #0
 800af14:	701a      	strb	r2, [r3, #0]

    if (pcb->state == SYN_SENT && pcb->nrtx >= TCP_SYNMAXRTX) {
 800af16:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af18:	7e1b      	ldrb	r3, [r3, #24]
 800af1a:	2b02      	cmp	r3, #2
 800af1c:	d10a      	bne.n	800af34 <tcp_slowtmr+0xc0>
 800af1e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af20:	2246      	movs	r2, #70	; 0x46
 800af22:	5c9b      	ldrb	r3, [r3, r2]
 800af24:	2b05      	cmp	r3, #5
 800af26:	d905      	bls.n	800af34 <tcp_slowtmr+0xc0>
      ++pcb_remove;
 800af28:	187b      	adds	r3, r7, r1
 800af2a:	187a      	adds	r2, r7, r1
 800af2c:	7812      	ldrb	r2, [r2, #0]
 800af2e:	3201      	adds	r2, #1
 800af30:	701a      	strb	r2, [r3, #0]
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
 800af32:	e13f      	b.n	800b1b4 <tcp_slowtmr+0x340>
    } else if (pcb->nrtx >= TCP_MAXRTX) {
 800af34:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af36:	2246      	movs	r2, #70	; 0x46
 800af38:	5c9b      	ldrb	r3, [r3, r2]
 800af3a:	2b0b      	cmp	r3, #11
 800af3c:	d906      	bls.n	800af4c <tcp_slowtmr+0xd8>
      ++pcb_remove;
 800af3e:	2227      	movs	r2, #39	; 0x27
 800af40:	18bb      	adds	r3, r7, r2
 800af42:	18ba      	adds	r2, r7, r2
 800af44:	7812      	ldrb	r2, [r2, #0]
 800af46:	3201      	adds	r2, #1
 800af48:	701a      	strb	r2, [r3, #0]
 800af4a:	e133      	b.n	800b1b4 <tcp_slowtmr+0x340>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
 800af4c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af4e:	22a5      	movs	r2, #165	; 0xa5
 800af50:	5c9b      	ldrb	r3, [r3, r2]
 800af52:	2b00      	cmp	r3, #0
 800af54:	d100      	bne.n	800af58 <tcp_slowtmr+0xe4>
 800af56:	e079      	b.n	800b04c <tcp_slowtmr+0x1d8>
        LWIP_ASSERT("tcp_slowtimr: persist ticking with in-flight data", pcb->unacked == NULL);
 800af58:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af5a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800af5c:	2b00      	cmp	r3, #0
 800af5e:	d005      	beq.n	800af6c <tcp_slowtmr+0xf8>
 800af60:	4b67      	ldr	r3, [pc, #412]	; (800b100 <tcp_slowtmr+0x28c>)
 800af62:	4a6e      	ldr	r2, [pc, #440]	; (800b11c <tcp_slowtmr+0x2a8>)
 800af64:	496e      	ldr	r1, [pc, #440]	; (800b120 <tcp_slowtmr+0x2ac>)
 800af66:	4869      	ldr	r0, [pc, #420]	; (800b10c <tcp_slowtmr+0x298>)
 800af68:	f7f7 f930 	bl	80021cc <app_debug_rtt_raw>
        LWIP_ASSERT("tcp_slowtimr: persist ticking with empty send buffer", pcb->unsent != NULL);
 800af6c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af6e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800af70:	2b00      	cmp	r3, #0
 800af72:	d105      	bne.n	800af80 <tcp_slowtmr+0x10c>
 800af74:	4b62      	ldr	r3, [pc, #392]	; (800b100 <tcp_slowtmr+0x28c>)
 800af76:	4a6b      	ldr	r2, [pc, #428]	; (800b124 <tcp_slowtmr+0x2b0>)
 800af78:	496b      	ldr	r1, [pc, #428]	; (800b128 <tcp_slowtmr+0x2b4>)
 800af7a:	4864      	ldr	r0, [pc, #400]	; (800b10c <tcp_slowtmr+0x298>)
 800af7c:	f7f7 f926 	bl	80021cc <app_debug_rtt_raw>
        if (pcb->persist_probe >= TCP_MAXRTX) {
 800af80:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af82:	22a6      	movs	r2, #166	; 0xa6
 800af84:	5c9b      	ldrb	r3, [r3, r2]
 800af86:	2b0b      	cmp	r3, #11
 800af88:	d906      	bls.n	800af98 <tcp_slowtmr+0x124>
          ++pcb_remove; /* max probes reached */
 800af8a:	2227      	movs	r2, #39	; 0x27
 800af8c:	18bb      	adds	r3, r7, r2
 800af8e:	18ba      	adds	r2, r7, r2
 800af90:	7812      	ldrb	r2, [r2, #0]
 800af92:	3201      	adds	r2, #1
 800af94:	701a      	strb	r2, [r3, #0]
 800af96:	e10d      	b.n	800b1b4 <tcp_slowtmr+0x340>
        } else {
          u8_t backoff_cnt = tcp_persist_backoff[pcb->persist_backoff - 1];
 800af98:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af9a:	22a5      	movs	r2, #165	; 0xa5
 800af9c:	5c9b      	ldrb	r3, [r3, r2]
 800af9e:	1e5a      	subs	r2, r3, #1
 800afa0:	2011      	movs	r0, #17
 800afa2:	183b      	adds	r3, r7, r0
 800afa4:	4961      	ldr	r1, [pc, #388]	; (800b12c <tcp_slowtmr+0x2b8>)
 800afa6:	5c8a      	ldrb	r2, [r1, r2]
 800afa8:	701a      	strb	r2, [r3, #0]
          if (pcb->persist_cnt < backoff_cnt) {
 800afaa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800afac:	22a4      	movs	r2, #164	; 0xa4
 800afae:	5c9b      	ldrb	r3, [r3, r2]
 800afb0:	183a      	adds	r2, r7, r0
 800afb2:	7812      	ldrb	r2, [r2, #0]
 800afb4:	429a      	cmp	r2, r3
 800afb6:	d907      	bls.n	800afc8 <tcp_slowtmr+0x154>
            pcb->persist_cnt++;
 800afb8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800afba:	22a4      	movs	r2, #164	; 0xa4
 800afbc:	5c9b      	ldrb	r3, [r3, r2]
 800afbe:	3301      	adds	r3, #1
 800afc0:	b2d9      	uxtb	r1, r3
 800afc2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800afc4:	22a4      	movs	r2, #164	; 0xa4
 800afc6:	5499      	strb	r1, [r3, r2]
          }
          if (pcb->persist_cnt >= backoff_cnt) {
 800afc8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800afca:	22a4      	movs	r2, #164	; 0xa4
 800afcc:	5c9b      	ldrb	r3, [r3, r2]
 800afce:	2211      	movs	r2, #17
 800afd0:	18ba      	adds	r2, r7, r2
 800afd2:	7812      	ldrb	r2, [r2, #0]
 800afd4:	429a      	cmp	r2, r3
 800afd6:	d900      	bls.n	800afda <tcp_slowtmr+0x166>
 800afd8:	e0ec      	b.n	800b1b4 <tcp_slowtmr+0x340>
            int next_slot = 1; /* increment timer to next slot */
 800afda:	2301      	movs	r3, #1
 800afdc:	623b      	str	r3, [r7, #32]
            /* If snd_wnd is zero, send 1 byte probes */
            if (pcb->snd_wnd == 0) {
 800afde:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800afe0:	2264      	movs	r2, #100	; 0x64
 800afe2:	5a9b      	ldrh	r3, [r3, r2]
 800afe4:	2b00      	cmp	r3, #0
 800afe6:	d108      	bne.n	800affa <tcp_slowtmr+0x186>
              if (tcp_zero_window_probe(pcb) != ERR_OK) {
 800afe8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800afea:	0018      	movs	r0, r3
 800afec:	f006 fc3c 	bl	8011868 <tcp_zero_window_probe>
 800aff0:	1e03      	subs	r3, r0, #0
 800aff2:	d014      	beq.n	800b01e <tcp_slowtmr+0x1aa>
                next_slot = 0; /* try probe again with current slot */
 800aff4:	2300      	movs	r3, #0
 800aff6:	623b      	str	r3, [r7, #32]
 800aff8:	e011      	b.n	800b01e <tcp_slowtmr+0x1aa>
              }
              /* snd_wnd not fully closed, split unsent head and fill window */
            } else {
              if (tcp_split_unsent_seg(pcb, (u16_t)pcb->snd_wnd) == ERR_OK) {
 800affa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800affc:	2264      	movs	r2, #100	; 0x64
 800affe:	5a9a      	ldrh	r2, [r3, r2]
 800b000:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b002:	0011      	movs	r1, r2
 800b004:	0018      	movs	r0, r3
 800b006:	f004 ff0f 	bl	800fe28 <tcp_split_unsent_seg>
 800b00a:	1e03      	subs	r3, r0, #0
 800b00c:	d107      	bne.n	800b01e <tcp_slowtmr+0x1aa>
                if (tcp_output(pcb) == ERR_OK) {
 800b00e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b010:	0018      	movs	r0, r3
 800b012:	f005 fab5 	bl	8010580 <tcp_output>
 800b016:	1e03      	subs	r3, r0, #0
 800b018:	d101      	bne.n	800b01e <tcp_slowtmr+0x1aa>
                  /* sending will cancel persist timer, else retry with current slot */
                  next_slot = 0;
 800b01a:	2300      	movs	r3, #0
 800b01c:	623b      	str	r3, [r7, #32]
                }
              }
            }
            if (next_slot) {
 800b01e:	6a3b      	ldr	r3, [r7, #32]
 800b020:	2b00      	cmp	r3, #0
 800b022:	d100      	bne.n	800b026 <tcp_slowtmr+0x1b2>
 800b024:	e0c6      	b.n	800b1b4 <tcp_slowtmr+0x340>
              pcb->persist_cnt = 0;
 800b026:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b028:	22a4      	movs	r2, #164	; 0xa4
 800b02a:	2100      	movs	r1, #0
 800b02c:	5499      	strb	r1, [r3, r2]
              if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 800b02e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b030:	22a5      	movs	r2, #165	; 0xa5
 800b032:	5c9b      	ldrb	r3, [r3, r2]
 800b034:	2b06      	cmp	r3, #6
 800b036:	d900      	bls.n	800b03a <tcp_slowtmr+0x1c6>
 800b038:	e0bc      	b.n	800b1b4 <tcp_slowtmr+0x340>
                pcb->persist_backoff++;
 800b03a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b03c:	22a5      	movs	r2, #165	; 0xa5
 800b03e:	5c9b      	ldrb	r3, [r3, r2]
 800b040:	3301      	adds	r3, #1
 800b042:	b2d9      	uxtb	r1, r3
 800b044:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b046:	22a5      	movs	r2, #165	; 0xa5
 800b048:	5499      	strb	r1, [r3, r2]
 800b04a:	e0b3      	b.n	800b1b4 <tcp_slowtmr+0x340>
            }
          }
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if ((pcb->rtime >= 0) && (pcb->rtime < 0x7FFF)) {
 800b04c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b04e:	2234      	movs	r2, #52	; 0x34
 800b050:	5e9b      	ldrsh	r3, [r3, r2]
 800b052:	2b00      	cmp	r3, #0
 800b054:	db0e      	blt.n	800b074 <tcp_slowtmr+0x200>
 800b056:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b058:	2234      	movs	r2, #52	; 0x34
 800b05a:	5e9b      	ldrsh	r3, [r3, r2]
 800b05c:	4a34      	ldr	r2, [pc, #208]	; (800b130 <tcp_slowtmr+0x2bc>)
 800b05e:	4293      	cmp	r3, r2
 800b060:	d008      	beq.n	800b074 <tcp_slowtmr+0x200>
          ++pcb->rtime;
 800b062:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b064:	2234      	movs	r2, #52	; 0x34
 800b066:	5e9b      	ldrsh	r3, [r3, r2]
 800b068:	b29b      	uxth	r3, r3
 800b06a:	3301      	adds	r3, #1
 800b06c:	b29b      	uxth	r3, r3
 800b06e:	b21a      	sxth	r2, r3
 800b070:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b072:	869a      	strh	r2, [r3, #52]	; 0x34
        }

        if (pcb->rtime >= pcb->rto) {
 800b074:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b076:	2234      	movs	r2, #52	; 0x34
 800b078:	5e9a      	ldrsh	r2, [r3, r2]
 800b07a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b07c:	2144      	movs	r1, #68	; 0x44
 800b07e:	5e5b      	ldrsh	r3, [r3, r1]
 800b080:	429a      	cmp	r2, r3
 800b082:	da00      	bge.n	800b086 <tcp_slowtmr+0x212>
 800b084:	e096      	b.n	800b1b4 <tcp_slowtmr+0x340>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));
          /* If prepare phase fails but we have unsent data but no unacked data,
             still execute the backoff calculations below, as this means we somehow
             failed to send segment. */
          if ((tcp_rexmit_rto_prepare(pcb) == ERR_OK) || ((pcb->unacked == NULL) && (pcb->unsent != NULL))) {
 800b086:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b088:	0018      	movs	r0, r3
 800b08a:	f005 fed3 	bl	8010e34 <tcp_rexmit_rto_prepare>
 800b08e:	1e03      	subs	r3, r0, #0
 800b090:	d009      	beq.n	800b0a6 <tcp_slowtmr+0x232>
 800b092:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b094:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b096:	2b00      	cmp	r3, #0
 800b098:	d000      	beq.n	800b09c <tcp_slowtmr+0x228>
 800b09a:	e08b      	b.n	800b1b4 <tcp_slowtmr+0x340>
 800b09c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b09e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b0a0:	2b00      	cmp	r3, #0
 800b0a2:	d100      	bne.n	800b0a6 <tcp_slowtmr+0x232>
 800b0a4:	e086      	b.n	800b1b4 <tcp_slowtmr+0x340>
            /* Double retransmission time-out unless we are trying to
             * connect to somebody (i.e., we are in SYN_SENT). */
            if (pcb->state != SYN_SENT) {
 800b0a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b0a8:	7e1b      	ldrb	r3, [r3, #24]
 800b0aa:	2b02      	cmp	r3, #2
 800b0ac:	d04a      	beq.n	800b144 <tcp_slowtmr+0x2d0>
              u8_t backoff_idx = LWIP_MIN(pcb->nrtx, sizeof(tcp_backoff) - 1);
 800b0ae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b0b0:	2246      	movs	r2, #70	; 0x46
 800b0b2:	5c9b      	ldrb	r3, [r3, r2]
 800b0b4:	221b      	movs	r2, #27
 800b0b6:	18ba      	adds	r2, r7, r2
 800b0b8:	b2d9      	uxtb	r1, r3
 800b0ba:	290c      	cmp	r1, #12
 800b0bc:	d900      	bls.n	800b0c0 <tcp_slowtmr+0x24c>
 800b0be:	230c      	movs	r3, #12
 800b0c0:	7013      	strb	r3, [r2, #0]
              int calc_rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[backoff_idx];
 800b0c2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b0c4:	2240      	movs	r2, #64	; 0x40
 800b0c6:	5e9b      	ldrsh	r3, [r3, r2]
 800b0c8:	10db      	asrs	r3, r3, #3
 800b0ca:	b21b      	sxth	r3, r3
 800b0cc:	0019      	movs	r1, r3
 800b0ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b0d0:	2242      	movs	r2, #66	; 0x42
 800b0d2:	5e9b      	ldrsh	r3, [r3, r2]
 800b0d4:	18cb      	adds	r3, r1, r3
 800b0d6:	221b      	movs	r2, #27
 800b0d8:	18ba      	adds	r2, r7, r2
 800b0da:	7812      	ldrb	r2, [r2, #0]
 800b0dc:	4915      	ldr	r1, [pc, #84]	; (800b134 <tcp_slowtmr+0x2c0>)
 800b0de:	5c8a      	ldrb	r2, [r1, r2]
 800b0e0:	4093      	lsls	r3, r2
 800b0e2:	617b      	str	r3, [r7, #20]
              pcb->rto = (s16_t)LWIP_MIN(calc_rto, 0x7FFF);
 800b0e4:	697b      	ldr	r3, [r7, #20]
 800b0e6:	4a14      	ldr	r2, [pc, #80]	; (800b138 <tcp_slowtmr+0x2c4>)
 800b0e8:	4293      	cmp	r3, r2
 800b0ea:	dc27      	bgt.n	800b13c <tcp_slowtmr+0x2c8>
 800b0ec:	697b      	ldr	r3, [r7, #20]
 800b0ee:	b21a      	sxth	r2, r3
 800b0f0:	e025      	b.n	800b13e <tcp_slowtmr+0x2ca>
 800b0f2:	46c0      	nop			; (mov r8, r8)
 800b0f4:	20002b1c 	.word	0x20002b1c
 800b0f8:	2000135a 	.word	0x2000135a
 800b0fc:	20002b18 	.word	0x20002b18
 800b100:	0801f238 	.word	0x0801f238
 800b104:	000004bf 	.word	0x000004bf
 800b108:	0801f578 	.word	0x0801f578
 800b10c:	0801f274 	.word	0x0801f274
 800b110:	0801f5a4 	.word	0x0801f5a4
 800b114:	000004c1 	.word	0x000004c1
 800b118:	0801f5d0 	.word	0x0801f5d0
 800b11c:	000004d5 	.word	0x000004d5
 800b120:	0801f600 	.word	0x0801f600
 800b124:	000004d6 	.word	0x000004d6
 800b128:	0801f634 	.word	0x0801f634
 800b12c:	08021a00 	.word	0x08021a00
 800b130:	00007fff 	.word	0x00007fff
 800b134:	080219f0 	.word	0x080219f0
 800b138:	00007ffe 	.word	0x00007ffe
 800b13c:	4ad0      	ldr	r2, [pc, #832]	; (800b480 <tcp_slowtmr+0x60c>)
 800b13e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b140:	2144      	movs	r1, #68	; 0x44
 800b142:	525a      	strh	r2, [r3, r1]
            }

            /* Reset the retransmission timer. */
            pcb->rtime = 0;
 800b144:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b146:	2200      	movs	r2, #0
 800b148:	869a      	strh	r2, [r3, #52]	; 0x34

            /* Reduce congestion window and ssthresh. */
            eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 800b14a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b14c:	2264      	movs	r2, #100	; 0x64
 800b14e:	5a99      	ldrh	r1, [r3, r2]
 800b150:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b152:	224c      	movs	r2, #76	; 0x4c
 800b154:	5a9b      	ldrh	r3, [r3, r2]
 800b156:	2212      	movs	r2, #18
 800b158:	18ba      	adds	r2, r7, r2
 800b15a:	1c1c      	adds	r4, r3, #0
 800b15c:	1c0b      	adds	r3, r1, #0
 800b15e:	b298      	uxth	r0, r3
 800b160:	b2a1      	uxth	r1, r4
 800b162:	4288      	cmp	r0, r1
 800b164:	d900      	bls.n	800b168 <tcp_slowtmr+0x2f4>
 800b166:	1c23      	adds	r3, r4, #0
 800b168:	8013      	strh	r3, [r2, #0]
            pcb->ssthresh = eff_wnd >> 1;
 800b16a:	2312      	movs	r3, #18
 800b16c:	18fb      	adds	r3, r7, r3
 800b16e:	881b      	ldrh	r3, [r3, #0]
 800b170:	085b      	lsrs	r3, r3, #1
 800b172:	b299      	uxth	r1, r3
 800b174:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b176:	224e      	movs	r2, #78	; 0x4e
 800b178:	5299      	strh	r1, [r3, r2]
            if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
 800b17a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b17c:	224e      	movs	r2, #78	; 0x4e
 800b17e:	5a9a      	ldrh	r2, [r3, r2]
 800b180:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b182:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800b184:	18db      	adds	r3, r3, r3
 800b186:	b29b      	uxth	r3, r3
 800b188:	429a      	cmp	r2, r3
 800b18a:	d206      	bcs.n	800b19a <tcp_slowtmr+0x326>
              pcb->ssthresh = (tcpwnd_size_t)(pcb->mss << 1);
 800b18c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b18e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800b190:	18db      	adds	r3, r3, r3
 800b192:	b299      	uxth	r1, r3
 800b194:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b196:	224e      	movs	r2, #78	; 0x4e
 800b198:	5299      	strh	r1, [r3, r2]
            }
            pcb->cwnd = pcb->mss;
 800b19a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b19c:	8ed9      	ldrh	r1, [r3, #54]	; 0x36
 800b19e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b1a0:	224c      	movs	r2, #76	; 0x4c
 800b1a2:	5299      	strh	r1, [r3, r2]
            LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %"TCPWNDSIZE_F
                                         " ssthresh %"TCPWNDSIZE_F"\n",
                                         pcb->cwnd, pcb->ssthresh));
            pcb->bytes_acked = 0;
 800b1a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b1a6:	226e      	movs	r2, #110	; 0x6e
 800b1a8:	2100      	movs	r1, #0
 800b1aa:	5299      	strh	r1, [r3, r2]

            /* The following needs to be called AFTER cwnd is set to one
               mss - STJ */
            tcp_rexmit_rto_commit(pcb);
 800b1ac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b1ae:	0018      	movs	r0, r3
 800b1b0:	f005 fec8 	bl	8010f44 <tcp_rexmit_rto_commit>
          }
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
 800b1b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b1b6:	7e1b      	ldrb	r3, [r3, #24]
 800b1b8:	2b06      	cmp	r3, #6
 800b1ba:	d112      	bne.n	800b1e2 <tcp_slowtmr+0x36e>
      /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
      if (pcb->flags & TF_RXCLOSED) {
 800b1bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b1be:	8bdb      	ldrh	r3, [r3, #30]
 800b1c0:	001a      	movs	r2, r3
 800b1c2:	2310      	movs	r3, #16
 800b1c4:	4013      	ands	r3, r2
 800b1c6:	d00c      	beq.n	800b1e2 <tcp_slowtmr+0x36e>
        /* PCB was fully closed (either through close() or SHUT_RDWR):
           normal FIN-WAIT timeout handling. */
        if ((u32_t)(tcp_ticks - pcb->tmr) >
 800b1c8:	4bae      	ldr	r3, [pc, #696]	; (800b484 <tcp_slowtmr+0x610>)
 800b1ca:	681a      	ldr	r2, [r3, #0]
 800b1cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b1ce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b1d0:	1ad3      	subs	r3, r2, r3
 800b1d2:	2b14      	cmp	r3, #20
 800b1d4:	d905      	bls.n	800b1e2 <tcp_slowtmr+0x36e>
            TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
          ++pcb_remove;
 800b1d6:	2227      	movs	r2, #39	; 0x27
 800b1d8:	18bb      	adds	r3, r7, r2
 800b1da:	18ba      	adds	r2, r7, r2
 800b1dc:	7812      	ldrb	r2, [r2, #0]
 800b1de:	3201      	adds	r2, #1
 800b1e0:	701a      	strb	r2, [r3, #0]
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
 800b1e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b1e4:	7a5b      	ldrb	r3, [r3, #9]
 800b1e6:	001a      	movs	r2, r3
 800b1e8:	2308      	movs	r3, #8
 800b1ea:	4013      	ands	r3, r2
 800b1ec:	d05a      	beq.n	800b2a4 <tcp_slowtmr+0x430>
        ((pcb->state == ESTABLISHED) ||
 800b1ee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b1f0:	7e1b      	ldrb	r3, [r3, #24]
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
 800b1f2:	2b04      	cmp	r3, #4
 800b1f4:	d003      	beq.n	800b1fe <tcp_slowtmr+0x38a>
         (pcb->state == CLOSE_WAIT))) {
 800b1f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b1f8:	7e1b      	ldrb	r3, [r3, #24]
        ((pcb->state == ESTABLISHED) ||
 800b1fa:	2b07      	cmp	r3, #7
 800b1fc:	d152      	bne.n	800b2a4 <tcp_slowtmr+0x430>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800b1fe:	4ba1      	ldr	r3, [pc, #644]	; (800b484 <tcp_slowtmr+0x610>)
 800b200:	681a      	ldr	r2, [r3, #0]
 800b202:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b204:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b206:	1ad4      	subs	r4, r2, r3
          (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL) {
 800b208:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b20a:	2298      	movs	r2, #152	; 0x98
 800b20c:	589a      	ldr	r2, [r3, r2]
 800b20e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b210:	21a0      	movs	r1, #160	; 0xa0
 800b212:	585b      	ldr	r3, [r3, r1]
 800b214:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800b216:	209c      	movs	r0, #156	; 0x9c
 800b218:	5809      	ldr	r1, [r1, r0]
 800b21a:	434b      	muls	r3, r1
 800b21c:	18d3      	adds	r3, r2, r3
 800b21e:	22fa      	movs	r2, #250	; 0xfa
 800b220:	0091      	lsls	r1, r2, #2
 800b222:	0018      	movs	r0, r3
 800b224:	f7f4 ff82 	bl	800012c <__udivsi3>
 800b228:	0003      	movs	r3, r0
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800b22a:	429c      	cmp	r4, r3
 800b22c:	d90c      	bls.n	800b248 <tcp_slowtmr+0x3d4>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to "));
        ip_addr_debug_print_val(TCP_DEBUG, pcb->remote_ip);
        LWIP_DEBUGF(TCP_DEBUG, ("\n"));

        ++pcb_remove;
 800b22e:	2227      	movs	r2, #39	; 0x27
 800b230:	18bb      	adds	r3, r7, r2
 800b232:	18ba      	adds	r2, r7, r2
 800b234:	7812      	ldrb	r2, [r2, #0]
 800b236:	3201      	adds	r2, #1
 800b238:	701a      	strb	r2, [r3, #0]
        ++pcb_reset;
 800b23a:	2226      	movs	r2, #38	; 0x26
 800b23c:	18bb      	adds	r3, r7, r2
 800b23e:	18ba      	adds	r2, r7, r2
 800b240:	7812      	ldrb	r2, [r2, #0]
 800b242:	3201      	adds	r2, #1
 800b244:	701a      	strb	r2, [r3, #0]
 800b246:	e02d      	b.n	800b2a4 <tcp_slowtmr+0x430>
      } else if ((u32_t)(tcp_ticks - pcb->tmr) >
 800b248:	4b8e      	ldr	r3, [pc, #568]	; (800b484 <tcp_slowtmr+0x610>)
 800b24a:	681a      	ldr	r2, [r3, #0]
 800b24c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b24e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b250:	1ad4      	subs	r4, r2, r3
                 (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
 800b252:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b254:	2298      	movs	r2, #152	; 0x98
 800b256:	589a      	ldr	r2, [r3, r2]
 800b258:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b25a:	21a7      	movs	r1, #167	; 0xa7
 800b25c:	5c5b      	ldrb	r3, [r3, r1]
 800b25e:	0018      	movs	r0, r3
 800b260:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b262:	219c      	movs	r1, #156	; 0x9c
 800b264:	585b      	ldr	r3, [r3, r1]
 800b266:	4343      	muls	r3, r0
 800b268:	18d3      	adds	r3, r2, r3
                 / TCP_SLOW_INTERVAL) {
 800b26a:	22fa      	movs	r2, #250	; 0xfa
 800b26c:	0091      	lsls	r1, r2, #2
 800b26e:	0018      	movs	r0, r3
 800b270:	f7f4 ff5c 	bl	800012c <__udivsi3>
 800b274:	0003      	movs	r3, r0
      } else if ((u32_t)(tcp_ticks - pcb->tmr) >
 800b276:	429c      	cmp	r4, r3
 800b278:	d914      	bls.n	800b2a4 <tcp_slowtmr+0x430>
        err = tcp_keepalive(pcb);
 800b27a:	2525      	movs	r5, #37	; 0x25
 800b27c:	197c      	adds	r4, r7, r5
 800b27e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b280:	0018      	movs	r0, r3
 800b282:	f006 faa7 	bl	80117d4 <tcp_keepalive>
 800b286:	0003      	movs	r3, r0
 800b288:	7023      	strb	r3, [r4, #0]
        if (err == ERR_OK) {
 800b28a:	197b      	adds	r3, r7, r5
 800b28c:	781b      	ldrb	r3, [r3, #0]
 800b28e:	b25b      	sxtb	r3, r3
 800b290:	2b00      	cmp	r3, #0
 800b292:	d107      	bne.n	800b2a4 <tcp_slowtmr+0x430>
          pcb->keep_cnt_sent++;
 800b294:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b296:	22a7      	movs	r2, #167	; 0xa7
 800b298:	5c9b      	ldrb	r3, [r3, r2]
 800b29a:	3301      	adds	r3, #1
 800b29c:	b2d9      	uxtb	r1, r3
 800b29e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b2a0:	22a7      	movs	r2, #167	; 0xa7
 800b2a2:	5499      	strb	r1, [r3, r2]

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
 800b2a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b2a6:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800b2a8:	2b00      	cmp	r3, #0
 800b2aa:	d012      	beq.n	800b2d2 <tcp_slowtmr+0x45e>
        (tcp_ticks - pcb->tmr >= (u32_t)pcb->rto * TCP_OOSEQ_TIMEOUT)) {
 800b2ac:	4b75      	ldr	r3, [pc, #468]	; (800b484 <tcp_slowtmr+0x610>)
 800b2ae:	681a      	ldr	r2, [r3, #0]
 800b2b0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b2b2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b2b4:	1ad2      	subs	r2, r2, r3
 800b2b6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b2b8:	2144      	movs	r1, #68	; 0x44
 800b2ba:	5e5b      	ldrsh	r3, [r3, r1]
 800b2bc:	0019      	movs	r1, r3
 800b2be:	000b      	movs	r3, r1
 800b2c0:	005b      	lsls	r3, r3, #1
 800b2c2:	185b      	adds	r3, r3, r1
 800b2c4:	005b      	lsls	r3, r3, #1
    if (pcb->ooseq != NULL &&
 800b2c6:	429a      	cmp	r2, r3
 800b2c8:	d303      	bcc.n	800b2d2 <tcp_slowtmr+0x45e>
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
      tcp_free_ooseq(pcb);
 800b2ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b2cc:	0018      	movs	r0, r3
 800b2ce:	f000 fefb 	bl	800c0c8 <tcp_free_ooseq>
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
 800b2d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b2d4:	7e1b      	ldrb	r3, [r3, #24]
 800b2d6:	2b03      	cmp	r3, #3
 800b2d8:	d10c      	bne.n	800b2f4 <tcp_slowtmr+0x480>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 800b2da:	4b6a      	ldr	r3, [pc, #424]	; (800b484 <tcp_slowtmr+0x610>)
 800b2dc:	681a      	ldr	r2, [r3, #0]
 800b2de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b2e0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b2e2:	1ad3      	subs	r3, r2, r3
 800b2e4:	2b14      	cmp	r3, #20
 800b2e6:	d905      	bls.n	800b2f4 <tcp_slowtmr+0x480>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
 800b2e8:	2227      	movs	r2, #39	; 0x27
 800b2ea:	18bb      	adds	r3, r7, r2
 800b2ec:	18ba      	adds	r2, r7, r2
 800b2ee:	7812      	ldrb	r2, [r2, #0]
 800b2f0:	3201      	adds	r2, #1
 800b2f2:	701a      	strb	r2, [r3, #0]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
 800b2f4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b2f6:	7e1b      	ldrb	r3, [r3, #24]
 800b2f8:	2b09      	cmp	r3, #9
 800b2fa:	d10c      	bne.n	800b316 <tcp_slowtmr+0x4a2>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 800b2fc:	4b61      	ldr	r3, [pc, #388]	; (800b484 <tcp_slowtmr+0x610>)
 800b2fe:	681a      	ldr	r2, [r3, #0]
 800b300:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b302:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b304:	1ad3      	subs	r3, r2, r3
 800b306:	2b78      	cmp	r3, #120	; 0x78
 800b308:	d905      	bls.n	800b316 <tcp_slowtmr+0x4a2>
        ++pcb_remove;
 800b30a:	2227      	movs	r2, #39	; 0x27
 800b30c:	18bb      	adds	r3, r7, r2
 800b30e:	18ba      	adds	r2, r7, r2
 800b310:	7812      	ldrb	r2, [r2, #0]
 800b312:	3201      	adds	r2, #1
 800b314:	701a      	strb	r2, [r3, #0]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 800b316:	2327      	movs	r3, #39	; 0x27
 800b318:	18fb      	adds	r3, r7, r3
 800b31a:	781b      	ldrb	r3, [r3, #0]
 800b31c:	2b00      	cmp	r3, #0
 800b31e:	d063      	beq.n	800b3e8 <tcp_slowtmr+0x574>
      struct tcp_pcb *pcb2;
#if LWIP_CALLBACK_API
      tcp_err_fn err_fn = pcb->errf;
 800b320:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b322:	2294      	movs	r2, #148	; 0x94
 800b324:	589b      	ldr	r3, [r3, r2]
 800b326:	60fb      	str	r3, [r7, #12]
#endif /* LWIP_CALLBACK_API */
      void *err_arg;
      enum tcp_state last_state;
      tcp_pcb_purge(pcb);
 800b328:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b32a:	0018      	movs	r0, r3
 800b32c:	f000 fcfc 	bl	800bd28 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
 800b330:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b332:	2b00      	cmp	r3, #0
 800b334:	d00f      	beq.n	800b356 <tcp_slowtmr+0x4e2>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
 800b336:	4b54      	ldr	r3, [pc, #336]	; (800b488 <tcp_slowtmr+0x614>)
 800b338:	681b      	ldr	r3, [r3, #0]
 800b33a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b33c:	429a      	cmp	r2, r3
 800b33e:	d105      	bne.n	800b34c <tcp_slowtmr+0x4d8>
 800b340:	4b52      	ldr	r3, [pc, #328]	; (800b48c <tcp_slowtmr+0x618>)
 800b342:	4a53      	ldr	r2, [pc, #332]	; (800b490 <tcp_slowtmr+0x61c>)
 800b344:	4953      	ldr	r1, [pc, #332]	; (800b494 <tcp_slowtmr+0x620>)
 800b346:	4854      	ldr	r0, [pc, #336]	; (800b498 <tcp_slowtmr+0x624>)
 800b348:	f7f6 ff40 	bl	80021cc <app_debug_rtt_raw>
        prev->next = pcb->next;
 800b34c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b34e:	691a      	ldr	r2, [r3, #16]
 800b350:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b352:	611a      	str	r2, [r3, #16]
 800b354:	e00e      	b.n	800b374 <tcp_slowtmr+0x500>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
 800b356:	4b4c      	ldr	r3, [pc, #304]	; (800b488 <tcp_slowtmr+0x614>)
 800b358:	681b      	ldr	r3, [r3, #0]
 800b35a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b35c:	429a      	cmp	r2, r3
 800b35e:	d005      	beq.n	800b36c <tcp_slowtmr+0x4f8>
 800b360:	4b4a      	ldr	r3, [pc, #296]	; (800b48c <tcp_slowtmr+0x618>)
 800b362:	4a4e      	ldr	r2, [pc, #312]	; (800b49c <tcp_slowtmr+0x628>)
 800b364:	494e      	ldr	r1, [pc, #312]	; (800b4a0 <tcp_slowtmr+0x62c>)
 800b366:	484c      	ldr	r0, [pc, #304]	; (800b498 <tcp_slowtmr+0x624>)
 800b368:	f7f6 ff30 	bl	80021cc <app_debug_rtt_raw>
        tcp_active_pcbs = pcb->next;
 800b36c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b36e:	691a      	ldr	r2, [r3, #16]
 800b370:	4b45      	ldr	r3, [pc, #276]	; (800b488 <tcp_slowtmr+0x614>)
 800b372:	601a      	str	r2, [r3, #0]
      }

      if (pcb_reset) {
 800b374:	2326      	movs	r3, #38	; 0x26
 800b376:	18fb      	adds	r3, r7, r3
 800b378:	781b      	ldrb	r3, [r3, #0]
 800b37a:	2b00      	cmp	r3, #0
 800b37c:	d013      	beq.n	800b3a6 <tcp_slowtmr+0x532>
        tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 800b37e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b380:	6d5c      	ldr	r4, [r3, #84]	; 0x54
 800b382:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b384:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 800b386:	6afe      	ldr	r6, [r7, #44]	; 0x2c
 800b388:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b38a:	3304      	adds	r3, #4
 800b38c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b38e:	8b52      	ldrh	r2, [r2, #26]
 800b390:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800b392:	8b89      	ldrh	r1, [r1, #28]
 800b394:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800b396:	9102      	str	r1, [sp, #8]
 800b398:	9201      	str	r2, [sp, #4]
 800b39a:	9300      	str	r3, [sp, #0]
 800b39c:	0033      	movs	r3, r6
 800b39e:	002a      	movs	r2, r5
 800b3a0:	0021      	movs	r1, r4
 800b3a2:	f006 f941 	bl	8011628 <tcp_rst>
                pcb->local_port, pcb->remote_port);
      }

      err_arg = pcb->callback_arg;
 800b3a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b3a8:	695b      	ldr	r3, [r3, #20]
 800b3aa:	60bb      	str	r3, [r7, #8]
      last_state = pcb->state;
 800b3ac:	1dfb      	adds	r3, r7, #7
 800b3ae:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b3b0:	7e12      	ldrb	r2, [r2, #24]
 800b3b2:	701a      	strb	r2, [r3, #0]
      pcb2 = pcb;
 800b3b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b3b6:	603b      	str	r3, [r7, #0]
      pcb = pcb->next;
 800b3b8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b3ba:	691b      	ldr	r3, [r3, #16]
 800b3bc:	62fb      	str	r3, [r7, #44]	; 0x2c
      tcp_free(pcb2);
 800b3be:	683b      	ldr	r3, [r7, #0]
 800b3c0:	0018      	movs	r0, r3
 800b3c2:	f7fe ffd3 	bl	800a36c <tcp_free>

      tcp_active_pcbs_changed = 0;
 800b3c6:	4b37      	ldr	r3, [pc, #220]	; (800b4a4 <tcp_slowtmr+0x630>)
 800b3c8:	2200      	movs	r2, #0
 800b3ca:	701a      	strb	r2, [r3, #0]
      TCP_EVENT_ERR(last_state, err_fn, err_arg, ERR_ABRT);
 800b3cc:	68fb      	ldr	r3, [r7, #12]
 800b3ce:	2b00      	cmp	r3, #0
 800b3d0:	d005      	beq.n	800b3de <tcp_slowtmr+0x56a>
 800b3d2:	230d      	movs	r3, #13
 800b3d4:	4259      	negs	r1, r3
 800b3d6:	68ba      	ldr	r2, [r7, #8]
 800b3d8:	68fb      	ldr	r3, [r7, #12]
 800b3da:	0010      	movs	r0, r2
 800b3dc:	4798      	blx	r3
      if (tcp_active_pcbs_changed) {
 800b3de:	4b31      	ldr	r3, [pc, #196]	; (800b4a4 <tcp_slowtmr+0x630>)
 800b3e0:	781b      	ldrb	r3, [r3, #0]
 800b3e2:	2b00      	cmp	r3, #0
 800b3e4:	d041      	beq.n	800b46a <tcp_slowtmr+0x5f6>
        goto tcp_slowtmr_start;
 800b3e6:	e557      	b.n	800ae98 <tcp_slowtmr+0x24>
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
 800b3e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b3ea:	62bb      	str	r3, [r7, #40]	; 0x28
      pcb = pcb->next;
 800b3ec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b3ee:	691b      	ldr	r3, [r3, #16]
 800b3f0:	62fb      	str	r3, [r7, #44]	; 0x2c

      /* We check if we should poll the connection. */
      ++prev->polltmr;
 800b3f2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b3f4:	2220      	movs	r2, #32
 800b3f6:	5c9b      	ldrb	r3, [r3, r2]
 800b3f8:	3301      	adds	r3, #1
 800b3fa:	b2d9      	uxtb	r1, r3
 800b3fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b3fe:	2220      	movs	r2, #32
 800b400:	5499      	strb	r1, [r3, r2]
      if (prev->polltmr >= prev->pollinterval) {
 800b402:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b404:	2220      	movs	r2, #32
 800b406:	5c9a      	ldrb	r2, [r3, r2]
 800b408:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b40a:	2121      	movs	r1, #33	; 0x21
 800b40c:	5c5b      	ldrb	r3, [r3, r1]
 800b40e:	429a      	cmp	r2, r3
 800b410:	d32b      	bcc.n	800b46a <tcp_slowtmr+0x5f6>
        prev->polltmr = 0;
 800b412:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b414:	2220      	movs	r2, #32
 800b416:	2100      	movs	r1, #0
 800b418:	5499      	strb	r1, [r3, r2]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
 800b41a:	4b22      	ldr	r3, [pc, #136]	; (800b4a4 <tcp_slowtmr+0x630>)
 800b41c:	2200      	movs	r2, #0
 800b41e:	701a      	strb	r2, [r3, #0]
        TCP_EVENT_POLL(prev, err);
 800b420:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b422:	2290      	movs	r2, #144	; 0x90
 800b424:	589b      	ldr	r3, [r3, r2]
 800b426:	2b00      	cmp	r3, #0
 800b428:	d00c      	beq.n	800b444 <tcp_slowtmr+0x5d0>
 800b42a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b42c:	2290      	movs	r2, #144	; 0x90
 800b42e:	589a      	ldr	r2, [r3, r2]
 800b430:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b432:	695b      	ldr	r3, [r3, #20]
 800b434:	2125      	movs	r1, #37	; 0x25
 800b436:	187c      	adds	r4, r7, r1
 800b438:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800b43a:	0018      	movs	r0, r3
 800b43c:	4790      	blx	r2
 800b43e:	0003      	movs	r3, r0
 800b440:	7023      	strb	r3, [r4, #0]
 800b442:	e003      	b.n	800b44c <tcp_slowtmr+0x5d8>
 800b444:	2325      	movs	r3, #37	; 0x25
 800b446:	18fb      	adds	r3, r7, r3
 800b448:	2200      	movs	r2, #0
 800b44a:	701a      	strb	r2, [r3, #0]
        if (tcp_active_pcbs_changed) {
 800b44c:	4b15      	ldr	r3, [pc, #84]	; (800b4a4 <tcp_slowtmr+0x630>)
 800b44e:	781b      	ldrb	r3, [r3, #0]
 800b450:	2b00      	cmp	r3, #0
 800b452:	d000      	beq.n	800b456 <tcp_slowtmr+0x5e2>
          goto tcp_slowtmr_start;
 800b454:	e520      	b.n	800ae98 <tcp_slowtmr+0x24>
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
 800b456:	2325      	movs	r3, #37	; 0x25
 800b458:	18fb      	adds	r3, r7, r3
 800b45a:	781b      	ldrb	r3, [r3, #0]
 800b45c:	b25b      	sxtb	r3, r3
 800b45e:	2b00      	cmp	r3, #0
 800b460:	d103      	bne.n	800b46a <tcp_slowtmr+0x5f6>
          tcp_output(prev);
 800b462:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b464:	0018      	movs	r0, r3
 800b466:	f005 f88b 	bl	8010580 <tcp_output>
  while (pcb != NULL) {
 800b46a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b46c:	2b00      	cmp	r3, #0
 800b46e:	d000      	beq.n	800b472 <tcp_slowtmr+0x5fe>
 800b470:	e518      	b.n	800aea4 <tcp_slowtmr+0x30>
    }
  }


  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
 800b472:	2300      	movs	r3, #0
 800b474:	62bb      	str	r3, [r7, #40]	; 0x28
  pcb = tcp_tw_pcbs;
 800b476:	4b0c      	ldr	r3, [pc, #48]	; (800b4a8 <tcp_slowtmr+0x634>)
 800b478:	681b      	ldr	r3, [r3, #0]
 800b47a:	62fb      	str	r3, [r7, #44]	; 0x2c
  while (pcb != NULL) {
 800b47c:	e06b      	b.n	800b556 <tcp_slowtmr+0x6e2>
 800b47e:	46c0      	nop			; (mov r8, r8)
 800b480:	00007fff 	.word	0x00007fff
 800b484:	20002b1c 	.word	0x20002b1c
 800b488:	20002b18 	.word	0x20002b18
 800b48c:	0801f238 	.word	0x0801f238
 800b490:	0000056e 	.word	0x0000056e
 800b494:	0801f66c 	.word	0x0801f66c
 800b498:	0801f274 	.word	0x0801f274
 800b49c:	00000572 	.word	0x00000572
 800b4a0:	0801f698 	.word	0x0801f698
 800b4a4:	20002b14 	.word	0x20002b14
 800b4a8:	20002b28 	.word	0x20002b28
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 800b4ac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b4ae:	7e1b      	ldrb	r3, [r3, #24]
 800b4b0:	2b0a      	cmp	r3, #10
 800b4b2:	d005      	beq.n	800b4c0 <tcp_slowtmr+0x64c>
 800b4b4:	4b2c      	ldr	r3, [pc, #176]	; (800b568 <tcp_slowtmr+0x6f4>)
 800b4b6:	4a2d      	ldr	r2, [pc, #180]	; (800b56c <tcp_slowtmr+0x6f8>)
 800b4b8:	492d      	ldr	r1, [pc, #180]	; (800b570 <tcp_slowtmr+0x6fc>)
 800b4ba:	482e      	ldr	r0, [pc, #184]	; (800b574 <tcp_slowtmr+0x700>)
 800b4bc:	f7f6 fe86 	bl	80021cc <app_debug_rtt_raw>
    pcb_remove = 0;
 800b4c0:	2127      	movs	r1, #39	; 0x27
 800b4c2:	187b      	adds	r3, r7, r1
 800b4c4:	2200      	movs	r2, #0
 800b4c6:	701a      	strb	r2, [r3, #0]

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 800b4c8:	4b2b      	ldr	r3, [pc, #172]	; (800b578 <tcp_slowtmr+0x704>)
 800b4ca:	681a      	ldr	r2, [r3, #0]
 800b4cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b4ce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b4d0:	1ad3      	subs	r3, r2, r3
 800b4d2:	2b78      	cmp	r3, #120	; 0x78
 800b4d4:	d904      	bls.n	800b4e0 <tcp_slowtmr+0x66c>
      ++pcb_remove;
 800b4d6:	187b      	adds	r3, r7, r1
 800b4d8:	187a      	adds	r2, r7, r1
 800b4da:	7812      	ldrb	r2, [r2, #0]
 800b4dc:	3201      	adds	r2, #1
 800b4de:	701a      	strb	r2, [r3, #0]
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 800b4e0:	2327      	movs	r3, #39	; 0x27
 800b4e2:	18fb      	adds	r3, r7, r3
 800b4e4:	781b      	ldrb	r3, [r3, #0]
 800b4e6:	2b00      	cmp	r3, #0
 800b4e8:	d030      	beq.n	800b54c <tcp_slowtmr+0x6d8>
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
 800b4ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b4ec:	0018      	movs	r0, r3
 800b4ee:	f000 fc1b 	bl	800bd28 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
 800b4f2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b4f4:	2b00      	cmp	r3, #0
 800b4f6:	d010      	beq.n	800b51a <tcp_slowtmr+0x6a6>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
 800b4f8:	4b20      	ldr	r3, [pc, #128]	; (800b57c <tcp_slowtmr+0x708>)
 800b4fa:	681b      	ldr	r3, [r3, #0]
 800b4fc:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b4fe:	429a      	cmp	r2, r3
 800b500:	d106      	bne.n	800b510 <tcp_slowtmr+0x69c>
 800b502:	4b19      	ldr	r3, [pc, #100]	; (800b568 <tcp_slowtmr+0x6f4>)
 800b504:	22b6      	movs	r2, #182	; 0xb6
 800b506:	00d2      	lsls	r2, r2, #3
 800b508:	491d      	ldr	r1, [pc, #116]	; (800b580 <tcp_slowtmr+0x70c>)
 800b50a:	481a      	ldr	r0, [pc, #104]	; (800b574 <tcp_slowtmr+0x700>)
 800b50c:	f7f6 fe5e 	bl	80021cc <app_debug_rtt_raw>
        prev->next = pcb->next;
 800b510:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b512:	691a      	ldr	r2, [r3, #16]
 800b514:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b516:	611a      	str	r2, [r3, #16]
 800b518:	e00e      	b.n	800b538 <tcp_slowtmr+0x6c4>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
 800b51a:	4b18      	ldr	r3, [pc, #96]	; (800b57c <tcp_slowtmr+0x708>)
 800b51c:	681b      	ldr	r3, [r3, #0]
 800b51e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b520:	429a      	cmp	r2, r3
 800b522:	d005      	beq.n	800b530 <tcp_slowtmr+0x6bc>
 800b524:	4b10      	ldr	r3, [pc, #64]	; (800b568 <tcp_slowtmr+0x6f4>)
 800b526:	4a17      	ldr	r2, [pc, #92]	; (800b584 <tcp_slowtmr+0x710>)
 800b528:	4917      	ldr	r1, [pc, #92]	; (800b588 <tcp_slowtmr+0x714>)
 800b52a:	4812      	ldr	r0, [pc, #72]	; (800b574 <tcp_slowtmr+0x700>)
 800b52c:	f7f6 fe4e 	bl	80021cc <app_debug_rtt_raw>
        tcp_tw_pcbs = pcb->next;
 800b530:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b532:	691a      	ldr	r2, [r3, #16]
 800b534:	4b11      	ldr	r3, [pc, #68]	; (800b57c <tcp_slowtmr+0x708>)
 800b536:	601a      	str	r2, [r3, #0]
      }
      pcb2 = pcb;
 800b538:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b53a:	61fb      	str	r3, [r7, #28]
      pcb = pcb->next;
 800b53c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b53e:	691b      	ldr	r3, [r3, #16]
 800b540:	62fb      	str	r3, [r7, #44]	; 0x2c
      tcp_free(pcb2);
 800b542:	69fb      	ldr	r3, [r7, #28]
 800b544:	0018      	movs	r0, r3
 800b546:	f7fe ff11 	bl	800a36c <tcp_free>
 800b54a:	e004      	b.n	800b556 <tcp_slowtmr+0x6e2>
    } else {
      prev = pcb;
 800b54c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b54e:	62bb      	str	r3, [r7, #40]	; 0x28
      pcb = pcb->next;
 800b550:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b552:	691b      	ldr	r3, [r3, #16]
 800b554:	62fb      	str	r3, [r7, #44]	; 0x2c
  while (pcb != NULL) {
 800b556:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b558:	2b00      	cmp	r3, #0
 800b55a:	d1a7      	bne.n	800b4ac <tcp_slowtmr+0x638>
    }
  }
}
 800b55c:	46c0      	nop			; (mov r8, r8)
 800b55e:	46c0      	nop			; (mov r8, r8)
 800b560:	46bd      	mov	sp, r7
 800b562:	b00d      	add	sp, #52	; 0x34
 800b564:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b566:	46c0      	nop			; (mov r8, r8)
 800b568:	0801f238 	.word	0x0801f238
 800b56c:	000005a2 	.word	0x000005a2
 800b570:	0801f6c4 	.word	0x0801f6c4
 800b574:	0801f274 	.word	0x0801f274
 800b578:	20002b1c 	.word	0x20002b1c
 800b57c:	20002b28 	.word	0x20002b28
 800b580:	0801f6f4 	.word	0x0801f6f4
 800b584:	000005b4 	.word	0x000005b4
 800b588:	0801f71c 	.word	0x0801f71c

0800b58c <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
 800b58c:	b580      	push	{r7, lr}
 800b58e:	b082      	sub	sp, #8
 800b590:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
 800b592:	4b30      	ldr	r3, [pc, #192]	; (800b654 <tcp_fasttmr+0xc8>)
 800b594:	781b      	ldrb	r3, [r3, #0]
 800b596:	3301      	adds	r3, #1
 800b598:	b2da      	uxtb	r2, r3
 800b59a:	4b2e      	ldr	r3, [pc, #184]	; (800b654 <tcp_fasttmr+0xc8>)
 800b59c:	701a      	strb	r2, [r3, #0]

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;
 800b59e:	4b2e      	ldr	r3, [pc, #184]	; (800b658 <tcp_fasttmr+0xcc>)
 800b5a0:	681b      	ldr	r3, [r3, #0]
 800b5a2:	607b      	str	r3, [r7, #4]

  while (pcb != NULL) {
 800b5a4:	e04d      	b.n	800b642 <tcp_fasttmr+0xb6>
    if (pcb->last_timer != tcp_timer_ctr) {
 800b5a6:	687b      	ldr	r3, [r7, #4]
 800b5a8:	2222      	movs	r2, #34	; 0x22
 800b5aa:	5c9a      	ldrb	r2, [r3, r2]
 800b5ac:	4b29      	ldr	r3, [pc, #164]	; (800b654 <tcp_fasttmr+0xc8>)
 800b5ae:	781b      	ldrb	r3, [r3, #0]
 800b5b0:	429a      	cmp	r2, r3
 800b5b2:	d043      	beq.n	800b63c <tcp_fasttmr+0xb0>
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
 800b5b4:	4b27      	ldr	r3, [pc, #156]	; (800b654 <tcp_fasttmr+0xc8>)
 800b5b6:	7819      	ldrb	r1, [r3, #0]
 800b5b8:	687b      	ldr	r3, [r7, #4]
 800b5ba:	2222      	movs	r2, #34	; 0x22
 800b5bc:	5499      	strb	r1, [r3, r2]
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
 800b5be:	687b      	ldr	r3, [r7, #4]
 800b5c0:	8bdb      	ldrh	r3, [r3, #30]
 800b5c2:	001a      	movs	r2, r3
 800b5c4:	2301      	movs	r3, #1
 800b5c6:	4013      	ands	r3, r2
 800b5c8:	d011      	beq.n	800b5ee <tcp_fasttmr+0x62>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
        tcp_ack_now(pcb);
 800b5ca:	687b      	ldr	r3, [r7, #4]
 800b5cc:	8bdb      	ldrh	r3, [r3, #30]
 800b5ce:	2202      	movs	r2, #2
 800b5d0:	4313      	orrs	r3, r2
 800b5d2:	b29a      	uxth	r2, r3
 800b5d4:	687b      	ldr	r3, [r7, #4]
 800b5d6:	83da      	strh	r2, [r3, #30]
        tcp_output(pcb);
 800b5d8:	687b      	ldr	r3, [r7, #4]
 800b5da:	0018      	movs	r0, r3
 800b5dc:	f004 ffd0 	bl	8010580 <tcp_output>
        tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 800b5e0:	687b      	ldr	r3, [r7, #4]
 800b5e2:	8bdb      	ldrh	r3, [r3, #30]
 800b5e4:	2203      	movs	r2, #3
 800b5e6:	4393      	bics	r3, r2
 800b5e8:	b29a      	uxth	r2, r3
 800b5ea:	687b      	ldr	r3, [r7, #4]
 800b5ec:	83da      	strh	r2, [r3, #30]
      }
      /* send pending FIN */
      if (pcb->flags & TF_CLOSEPEND) {
 800b5ee:	687b      	ldr	r3, [r7, #4]
 800b5f0:	8bdb      	ldrh	r3, [r3, #30]
 800b5f2:	001a      	movs	r2, r3
 800b5f4:	2308      	movs	r3, #8
 800b5f6:	4013      	ands	r3, r2
 800b5f8:	d00a      	beq.n	800b610 <tcp_fasttmr+0x84>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: pending FIN\n"));
        tcp_clear_flags(pcb, TF_CLOSEPEND);
 800b5fa:	687b      	ldr	r3, [r7, #4]
 800b5fc:	8bdb      	ldrh	r3, [r3, #30]
 800b5fe:	2208      	movs	r2, #8
 800b600:	4393      	bics	r3, r2
 800b602:	b29a      	uxth	r2, r3
 800b604:	687b      	ldr	r3, [r7, #4]
 800b606:	83da      	strh	r2, [r3, #30]
        tcp_close_shutdown_fin(pcb);
 800b608:	687b      	ldr	r3, [r7, #4]
 800b60a:	0018      	movs	r0, r3
 800b60c:	f7ff f85a 	bl	800a6c4 <tcp_close_shutdown_fin>
      }

      next = pcb->next;
 800b610:	687b      	ldr	r3, [r7, #4]
 800b612:	691b      	ldr	r3, [r3, #16]
 800b614:	603b      	str	r3, [r7, #0]

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
 800b616:	687b      	ldr	r3, [r7, #4]
 800b618:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800b61a:	2b00      	cmp	r3, #0
 800b61c:	d00b      	beq.n	800b636 <tcp_fasttmr+0xaa>
        tcp_active_pcbs_changed = 0;
 800b61e:	4b0f      	ldr	r3, [pc, #60]	; (800b65c <tcp_fasttmr+0xd0>)
 800b620:	2200      	movs	r2, #0
 800b622:	701a      	strb	r2, [r3, #0]
        tcp_process_refused_data(pcb);
 800b624:	687b      	ldr	r3, [r7, #4]
 800b626:	0018      	movs	r0, r3
 800b628:	f000 f81a 	bl	800b660 <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
 800b62c:	4b0b      	ldr	r3, [pc, #44]	; (800b65c <tcp_fasttmr+0xd0>)
 800b62e:	781b      	ldrb	r3, [r3, #0]
 800b630:	2b00      	cmp	r3, #0
 800b632:	d000      	beq.n	800b636 <tcp_fasttmr+0xaa>
          /* application callback has changed the pcb list: restart the loop */
          goto tcp_fasttmr_start;
 800b634:	e7b3      	b.n	800b59e <tcp_fasttmr+0x12>
        }
      }
      pcb = next;
 800b636:	683b      	ldr	r3, [r7, #0]
 800b638:	607b      	str	r3, [r7, #4]
 800b63a:	e002      	b.n	800b642 <tcp_fasttmr+0xb6>
    } else {
      pcb = pcb->next;
 800b63c:	687b      	ldr	r3, [r7, #4]
 800b63e:	691b      	ldr	r3, [r3, #16]
 800b640:	607b      	str	r3, [r7, #4]
  while (pcb != NULL) {
 800b642:	687b      	ldr	r3, [r7, #4]
 800b644:	2b00      	cmp	r3, #0
 800b646:	d1ae      	bne.n	800b5a6 <tcp_fasttmr+0x1a>
    }
  }
}
 800b648:	46c0      	nop			; (mov r8, r8)
 800b64a:	46c0      	nop			; (mov r8, r8)
 800b64c:	46bd      	mov	sp, r7
 800b64e:	b002      	add	sp, #8
 800b650:	bd80      	pop	{r7, pc}
 800b652:	46c0      	nop			; (mov r8, r8)
 800b654:	2000135a 	.word	0x2000135a
 800b658:	20002b18 	.word	0x20002b18
 800b65c:	20002b14 	.word	0x20002b14

0800b660 <tcp_process_refused_data>:
}

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
 800b660:	b5b0      	push	{r4, r5, r7, lr}
 800b662:	b084      	sub	sp, #16
 800b664:	af00      	add	r7, sp, #0
 800b666:	6078      	str	r0, [r7, #4]
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
  struct pbuf *rest;
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */

  LWIP_ERROR("tcp_process_refused_data: invalid pcb", pcb != NULL, return ERR_ARG);
 800b668:	687b      	ldr	r3, [r7, #4]
 800b66a:	2b00      	cmp	r3, #0
 800b66c:	d106      	bne.n	800b67c <tcp_process_refused_data+0x1c>
 800b66e:	4b3e      	ldr	r3, [pc, #248]	; (800b768 <tcp_process_refused_data+0x108>)
 800b670:	0018      	movs	r0, r3
 800b672:	f7f6 fdab 	bl	80021cc <app_debug_rtt_raw>
 800b676:	2310      	movs	r3, #16
 800b678:	425b      	negs	r3, r3
 800b67a:	e070      	b.n	800b75e <tcp_process_refused_data+0xfe>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
  while (pcb->refused_data != NULL)
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
  {
    err_t err;
    u8_t refused_flags = pcb->refused_data->flags;
 800b67c:	687b      	ldr	r3, [r7, #4]
 800b67e:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 800b680:	230e      	movs	r3, #14
 800b682:	18fb      	adds	r3, r7, r3
 800b684:	7b52      	ldrb	r2, [r2, #13]
 800b686:	701a      	strb	r2, [r3, #0]
    /* set pcb->refused_data to NULL in case the callback frees it and then
       closes the pcb */
    struct pbuf *refused_data = pcb->refused_data;
 800b688:	687b      	ldr	r3, [r7, #4]
 800b68a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800b68c:	60bb      	str	r3, [r7, #8]
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
    pbuf_split_64k(refused_data, &rest);
    pcb->refused_data = rest;
#else /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
    pcb->refused_data = NULL;
 800b68e:	687b      	ldr	r3, [r7, #4]
 800b690:	2200      	movs	r2, #0
 800b692:	67da      	str	r2, [r3, #124]	; 0x7c
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
    /* Notify again application with data previously received. */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 800b694:	687b      	ldr	r3, [r7, #4]
 800b696:	2288      	movs	r2, #136	; 0x88
 800b698:	589b      	ldr	r3, [r3, r2]
 800b69a:	2b00      	cmp	r3, #0
 800b69c:	d00d      	beq.n	800b6ba <tcp_process_refused_data+0x5a>
 800b69e:	687b      	ldr	r3, [r7, #4]
 800b6a0:	2288      	movs	r2, #136	; 0x88
 800b6a2:	589d      	ldr	r5, [r3, r2]
 800b6a4:	687b      	ldr	r3, [r7, #4]
 800b6a6:	6958      	ldr	r0, [r3, #20]
 800b6a8:	230f      	movs	r3, #15
 800b6aa:	18fc      	adds	r4, r7, r3
 800b6ac:	68ba      	ldr	r2, [r7, #8]
 800b6ae:	6879      	ldr	r1, [r7, #4]
 800b6b0:	2300      	movs	r3, #0
 800b6b2:	47a8      	blx	r5
 800b6b4:	0003      	movs	r3, r0
 800b6b6:	7023      	strb	r3, [r4, #0]
 800b6b8:	e009      	b.n	800b6ce <tcp_process_refused_data+0x6e>
 800b6ba:	230f      	movs	r3, #15
 800b6bc:	18fc      	adds	r4, r7, r3
 800b6be:	68ba      	ldr	r2, [r7, #8]
 800b6c0:	6879      	ldr	r1, [r7, #4]
 800b6c2:	2300      	movs	r3, #0
 800b6c4:	2000      	movs	r0, #0
 800b6c6:	f000 f8b1 	bl	800b82c <tcp_recv_null>
 800b6ca:	0003      	movs	r3, r0
 800b6cc:	7023      	strb	r3, [r4, #0]
    if (err == ERR_OK) {
 800b6ce:	230f      	movs	r3, #15
 800b6d0:	18fb      	adds	r3, r7, r3
 800b6d2:	781b      	ldrb	r3, [r3, #0]
 800b6d4:	b25b      	sxtb	r3, r3
 800b6d6:	2b00      	cmp	r3, #0
 800b6d8:	d131      	bne.n	800b73e <tcp_process_refused_data+0xde>
      /* did refused_data include a FIN? */
      if ((refused_flags & PBUF_FLAG_TCP_FIN)
 800b6da:	230e      	movs	r3, #14
 800b6dc:	18fb      	adds	r3, r7, r3
 800b6de:	781b      	ldrb	r3, [r3, #0]
 800b6e0:	2220      	movs	r2, #32
 800b6e2:	4013      	ands	r3, r2
 800b6e4:	d03a      	beq.n	800b75c <tcp_process_refused_data+0xfc>
          && (rest == NULL)
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
         ) {
        /* correct rcv_wnd as the application won't call tcp_recved()
           for the FIN's seqno */
        if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 800b6e6:	687b      	ldr	r3, [r7, #4]
 800b6e8:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800b6ea:	2386      	movs	r3, #134	; 0x86
 800b6ec:	00db      	lsls	r3, r3, #3
 800b6ee:	429a      	cmp	r2, r3
 800b6f0:	d005      	beq.n	800b6fe <tcp_process_refused_data+0x9e>
          pcb->rcv_wnd++;
 800b6f2:	687b      	ldr	r3, [r7, #4]
 800b6f4:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800b6f6:	3301      	adds	r3, #1
 800b6f8:	b29a      	uxth	r2, r3
 800b6fa:	687b      	ldr	r3, [r7, #4]
 800b6fc:	859a      	strh	r2, [r3, #44]	; 0x2c
        }
        TCP_EVENT_CLOSED(pcb, err);
 800b6fe:	687b      	ldr	r3, [r7, #4]
 800b700:	2288      	movs	r2, #136	; 0x88
 800b702:	589b      	ldr	r3, [r3, r2]
 800b704:	2b00      	cmp	r3, #0
 800b706:	d00d      	beq.n	800b724 <tcp_process_refused_data+0xc4>
 800b708:	687b      	ldr	r3, [r7, #4]
 800b70a:	2288      	movs	r2, #136	; 0x88
 800b70c:	589d      	ldr	r5, [r3, r2]
 800b70e:	687b      	ldr	r3, [r7, #4]
 800b710:	6958      	ldr	r0, [r3, #20]
 800b712:	230f      	movs	r3, #15
 800b714:	18fc      	adds	r4, r7, r3
 800b716:	6879      	ldr	r1, [r7, #4]
 800b718:	2300      	movs	r3, #0
 800b71a:	2200      	movs	r2, #0
 800b71c:	47a8      	blx	r5
 800b71e:	0003      	movs	r3, r0
 800b720:	7023      	strb	r3, [r4, #0]
 800b722:	e003      	b.n	800b72c <tcp_process_refused_data+0xcc>
 800b724:	230f      	movs	r3, #15
 800b726:	18fb      	adds	r3, r7, r3
 800b728:	2200      	movs	r2, #0
 800b72a:	701a      	strb	r2, [r3, #0]
        if (err == ERR_ABRT) {
 800b72c:	230f      	movs	r3, #15
 800b72e:	18fb      	adds	r3, r7, r3
 800b730:	781b      	ldrb	r3, [r3, #0]
 800b732:	b25b      	sxtb	r3, r3
 800b734:	330d      	adds	r3, #13
 800b736:	d111      	bne.n	800b75c <tcp_process_refused_data+0xfc>
          return ERR_ABRT;
 800b738:	230d      	movs	r3, #13
 800b73a:	425b      	negs	r3, r3
 800b73c:	e00f      	b.n	800b75e <tcp_process_refused_data+0xfe>
        }
      }
    } else if (err == ERR_ABRT) {
 800b73e:	230f      	movs	r3, #15
 800b740:	18fb      	adds	r3, r7, r3
 800b742:	781b      	ldrb	r3, [r3, #0]
 800b744:	b25b      	sxtb	r3, r3
 800b746:	330d      	adds	r3, #13
 800b748:	d102      	bne.n	800b750 <tcp_process_refused_data+0xf0>
      /* if err == ERR_ABRT, 'pcb' is already deallocated */
      /* Drop incoming packets because pcb is "full" (only if the incoming
         segment contains data). */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
      return ERR_ABRT;
 800b74a:	230d      	movs	r3, #13
 800b74c:	425b      	negs	r3, r3
 800b74e:	e006      	b.n	800b75e <tcp_process_refused_data+0xfe>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
      if (rest != NULL) {
        pbuf_cat(refused_data, rest);
      }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
      pcb->refused_data = refused_data;
 800b750:	687b      	ldr	r3, [r7, #4]
 800b752:	68ba      	ldr	r2, [r7, #8]
 800b754:	67da      	str	r2, [r3, #124]	; 0x7c
      return ERR_INPROGRESS;
 800b756:	2305      	movs	r3, #5
 800b758:	425b      	negs	r3, r3
 800b75a:	e000      	b.n	800b75e <tcp_process_refused_data+0xfe>
    }
  }
  return ERR_OK;
 800b75c:	2300      	movs	r3, #0
}
 800b75e:	0018      	movs	r0, r3
 800b760:	46bd      	mov	sp, r7
 800b762:	b004      	add	sp, #16
 800b764:	bdb0      	pop	{r4, r5, r7, pc}
 800b766:	46c0      	nop			; (mov r8, r8)
 800b768:	0801f744 	.word	0x0801f744

0800b76c <tcp_segs_free>:
 *
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
 800b76c:	b580      	push	{r7, lr}
 800b76e:	b084      	sub	sp, #16
 800b770:	af00      	add	r7, sp, #0
 800b772:	6078      	str	r0, [r7, #4]
  while (seg != NULL) {
 800b774:	e008      	b.n	800b788 <tcp_segs_free+0x1c>
    struct tcp_seg *next = seg->next;
 800b776:	687b      	ldr	r3, [r7, #4]
 800b778:	681b      	ldr	r3, [r3, #0]
 800b77a:	60fb      	str	r3, [r7, #12]
    tcp_seg_free(seg);
 800b77c:	687b      	ldr	r3, [r7, #4]
 800b77e:	0018      	movs	r0, r3
 800b780:	f000 f80a 	bl	800b798 <tcp_seg_free>
    seg = next;
 800b784:	68fb      	ldr	r3, [r7, #12]
 800b786:	607b      	str	r3, [r7, #4]
  while (seg != NULL) {
 800b788:	687b      	ldr	r3, [r7, #4]
 800b78a:	2b00      	cmp	r3, #0
 800b78c:	d1f3      	bne.n	800b776 <tcp_segs_free+0xa>
  }
}
 800b78e:	46c0      	nop			; (mov r8, r8)
 800b790:	46c0      	nop			; (mov r8, r8)
 800b792:	46bd      	mov	sp, r7
 800b794:	b004      	add	sp, #16
 800b796:	bd80      	pop	{r7, pc}

0800b798 <tcp_seg_free>:
 *
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
 800b798:	b580      	push	{r7, lr}
 800b79a:	b082      	sub	sp, #8
 800b79c:	af00      	add	r7, sp, #0
 800b79e:	6078      	str	r0, [r7, #4]
  if (seg != NULL) {
 800b7a0:	687b      	ldr	r3, [r7, #4]
 800b7a2:	2b00      	cmp	r3, #0
 800b7a4:	d00d      	beq.n	800b7c2 <tcp_seg_free+0x2a>
    if (seg->p != NULL) {
 800b7a6:	687b      	ldr	r3, [r7, #4]
 800b7a8:	685b      	ldr	r3, [r3, #4]
 800b7aa:	2b00      	cmp	r3, #0
 800b7ac:	d004      	beq.n	800b7b8 <tcp_seg_free+0x20>
      pbuf_free(seg->p);
 800b7ae:	687b      	ldr	r3, [r7, #4]
 800b7b0:	685b      	ldr	r3, [r3, #4]
 800b7b2:	0018      	movs	r0, r3
 800b7b4:	f7fd ff6e 	bl	8009694 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 800b7b8:	687b      	ldr	r3, [r7, #4]
 800b7ba:	0019      	movs	r1, r3
 800b7bc:	2003      	movs	r0, #3
 800b7be:	f7fd f873 	bl	80088a8 <memp_free>
  }
}
 800b7c2:	46c0      	nop			; (mov r8, r8)
 800b7c4:	46bd      	mov	sp, r7
 800b7c6:	b002      	add	sp, #8
 800b7c8:	bd80      	pop	{r7, pc}
	...

0800b7cc <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
 800b7cc:	b580      	push	{r7, lr}
 800b7ce:	b084      	sub	sp, #16
 800b7d0:	af00      	add	r7, sp, #0
 800b7d2:	6078      	str	r0, [r7, #4]
  struct tcp_seg *cseg;

  LWIP_ASSERT("tcp_seg_copy: invalid seg", seg != NULL);
 800b7d4:	687b      	ldr	r3, [r7, #4]
 800b7d6:	2b00      	cmp	r3, #0
 800b7d8:	d105      	bne.n	800b7e6 <tcp_seg_copy+0x1a>
 800b7da:	4b10      	ldr	r3, [pc, #64]	; (800b81c <tcp_seg_copy+0x50>)
 800b7dc:	4a10      	ldr	r2, [pc, #64]	; (800b820 <tcp_seg_copy+0x54>)
 800b7de:	4911      	ldr	r1, [pc, #68]	; (800b824 <tcp_seg_copy+0x58>)
 800b7e0:	4811      	ldr	r0, [pc, #68]	; (800b828 <tcp_seg_copy+0x5c>)
 800b7e2:	f7f6 fcf3 	bl	80021cc <app_debug_rtt_raw>

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
 800b7e6:	2003      	movs	r0, #3
 800b7e8:	f7fc ffee 	bl	80087c8 <memp_malloc>
 800b7ec:	0003      	movs	r3, r0
 800b7ee:	60fb      	str	r3, [r7, #12]
  if (cseg == NULL) {
 800b7f0:	68fb      	ldr	r3, [r7, #12]
 800b7f2:	2b00      	cmp	r3, #0
 800b7f4:	d101      	bne.n	800b7fa <tcp_seg_copy+0x2e>
    return NULL;
 800b7f6:	2300      	movs	r3, #0
 800b7f8:	e00b      	b.n	800b812 <tcp_seg_copy+0x46>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg));
 800b7fa:	6879      	ldr	r1, [r7, #4]
 800b7fc:	68fb      	ldr	r3, [r7, #12]
 800b7fe:	2214      	movs	r2, #20
 800b800:	0018      	movs	r0, r3
 800b802:	f010 fff7 	bl	801c7f4 <memcpy>
  pbuf_ref(cseg->p);
 800b806:	68fb      	ldr	r3, [r7, #12]
 800b808:	685b      	ldr	r3, [r3, #4]
 800b80a:	0018      	movs	r0, r3
 800b80c:	f7fd fffe 	bl	800980c <pbuf_ref>
  return cseg;
 800b810:	68fb      	ldr	r3, [r7, #12]
}
 800b812:	0018      	movs	r0, r3
 800b814:	46bd      	mov	sp, r7
 800b816:	b004      	add	sp, #16
 800b818:	bd80      	pop	{r7, pc}
 800b81a:	46c0      	nop			; (mov r8, r8)
 800b81c:	0801f238 	.word	0x0801f238
 800b820:	00000683 	.word	0x00000683
 800b824:	0801f788 	.word	0x0801f788
 800b828:	0801f274 	.word	0x0801f274

0800b82c <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
 800b82c:	b580      	push	{r7, lr}
 800b82e:	b084      	sub	sp, #16
 800b830:	af00      	add	r7, sp, #0
 800b832:	60f8      	str	r0, [r7, #12]
 800b834:	60b9      	str	r1, [r7, #8]
 800b836:	607a      	str	r2, [r7, #4]
 800b838:	001a      	movs	r2, r3
 800b83a:	1cfb      	adds	r3, r7, #3
 800b83c:	701a      	strb	r2, [r3, #0]
  LWIP_UNUSED_ARG(arg);

  LWIP_ERROR("tcp_recv_null: invalid pcb", pcb != NULL, return ERR_ARG);
 800b83e:	68bb      	ldr	r3, [r7, #8]
 800b840:	2b00      	cmp	r3, #0
 800b842:	d106      	bne.n	800b852 <tcp_recv_null+0x26>
 800b844:	4b12      	ldr	r3, [pc, #72]	; (800b890 <tcp_recv_null+0x64>)
 800b846:	0018      	movs	r0, r3
 800b848:	f7f6 fcc0 	bl	80021cc <app_debug_rtt_raw>
 800b84c:	2310      	movs	r3, #16
 800b84e:	425b      	negs	r3, r3
 800b850:	e01a      	b.n	800b888 <tcp_recv_null+0x5c>

  if (p != NULL) {
 800b852:	687b      	ldr	r3, [r7, #4]
 800b854:	2b00      	cmp	r3, #0
 800b856:	d00b      	beq.n	800b870 <tcp_recv_null+0x44>
    tcp_recved(pcb, p->tot_len);
 800b858:	687b      	ldr	r3, [r7, #4]
 800b85a:	891a      	ldrh	r2, [r3, #8]
 800b85c:	68bb      	ldr	r3, [r7, #8]
 800b85e:	0011      	movs	r1, r2
 800b860:	0018      	movs	r0, r3
 800b862:	f7ff f907 	bl	800aa74 <tcp_recved>
    pbuf_free(p);
 800b866:	687b      	ldr	r3, [r7, #4]
 800b868:	0018      	movs	r0, r3
 800b86a:	f7fd ff13 	bl	8009694 <pbuf_free>
 800b86e:	e00a      	b.n	800b886 <tcp_recv_null+0x5a>
  } else if (err == ERR_OK) {
 800b870:	1cfb      	adds	r3, r7, #3
 800b872:	781b      	ldrb	r3, [r3, #0]
 800b874:	b25b      	sxtb	r3, r3
 800b876:	2b00      	cmp	r3, #0
 800b878:	d105      	bne.n	800b886 <tcp_recv_null+0x5a>
    return tcp_close(pcb);
 800b87a:	68bb      	ldr	r3, [r7, #8]
 800b87c:	0018      	movs	r0, r3
 800b87e:	f7fe ff9b 	bl	800a7b8 <tcp_close>
 800b882:	0003      	movs	r3, r0
 800b884:	e000      	b.n	800b888 <tcp_recv_null+0x5c>
  }
  return ERR_OK;
 800b886:	2300      	movs	r3, #0
}
 800b888:	0018      	movs	r0, r3
 800b88a:	46bd      	mov	sp, r7
 800b88c:	b004      	add	sp, #16
 800b88e:	bd80      	pop	{r7, pc}
 800b890:	0801f7a4 	.word	0x0801f7a4

0800b894 <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
 800b894:	b580      	push	{r7, lr}
 800b896:	b086      	sub	sp, #24
 800b898:	af00      	add	r7, sp, #0
 800b89a:	0002      	movs	r2, r0
 800b89c:	1dfb      	adds	r3, r7, #7
 800b89e:	701a      	strb	r2, [r3, #0]
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;

  mprio = LWIP_MIN(TCP_PRIO_MAX, prio);
 800b8a0:	1dfb      	adds	r3, r7, #7
 800b8a2:	781b      	ldrb	r3, [r3, #0]
 800b8a4:	b25b      	sxtb	r3, r3
 800b8a6:	2b00      	cmp	r3, #0
 800b8a8:	db02      	blt.n	800b8b0 <tcp_kill_prio+0x1c>
 800b8aa:	1dfb      	adds	r3, r7, #7
 800b8ac:	781a      	ldrb	r2, [r3, #0]
 800b8ae:	e000      	b.n	800b8b2 <tcp_kill_prio+0x1e>
 800b8b0:	227f      	movs	r2, #127	; 0x7f
 800b8b2:	210b      	movs	r1, #11
 800b8b4:	187b      	adds	r3, r7, r1
 800b8b6:	701a      	strb	r2, [r3, #0]

  /* We want to kill connections with a lower prio, so bail out if 
   * supplied prio is 0 - there can never be a lower prio
   */
  if (mprio == 0) {
 800b8b8:	187b      	adds	r3, r7, r1
 800b8ba:	781b      	ldrb	r3, [r3, #0]
 800b8bc:	2b00      	cmp	r3, #0
 800b8be:	d03c      	beq.n	800b93a <tcp_kill_prio+0xa6>
  /* We only want kill connections with a lower prio, so decrement prio by one 
   * and start searching for oldest connection with same or lower priority than mprio.
   * We want to find the connections with the lowest possible prio, and among
   * these the one with the longest inactivity time.
   */
  mprio--;
 800b8c0:	187b      	adds	r3, r7, r1
 800b8c2:	781a      	ldrb	r2, [r3, #0]
 800b8c4:	187b      	adds	r3, r7, r1
 800b8c6:	3a01      	subs	r2, #1
 800b8c8:	701a      	strb	r2, [r3, #0]

  inactivity = 0;
 800b8ca:	2300      	movs	r3, #0
 800b8cc:	60fb      	str	r3, [r7, #12]
  inactive = NULL;
 800b8ce:	2300      	movs	r3, #0
 800b8d0:	613b      	str	r3, [r7, #16]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800b8d2:	4b1c      	ldr	r3, [pc, #112]	; (800b944 <tcp_kill_prio+0xb0>)
 800b8d4:	681b      	ldr	r3, [r3, #0]
 800b8d6:	617b      	str	r3, [r7, #20]
 800b8d8:	e024      	b.n	800b924 <tcp_kill_prio+0x90>
        /* lower prio is always a kill candidate */
    if ((pcb->prio < mprio) ||
 800b8da:	697b      	ldr	r3, [r7, #20]
 800b8dc:	7e5b      	ldrb	r3, [r3, #25]
 800b8de:	210b      	movs	r1, #11
 800b8e0:	187a      	adds	r2, r7, r1
 800b8e2:	7812      	ldrb	r2, [r2, #0]
 800b8e4:	429a      	cmp	r2, r3
 800b8e6:	d80d      	bhi.n	800b904 <tcp_kill_prio+0x70>
        /* longer inactivity is also a kill candidate */
        ((pcb->prio == mprio) && ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity))) {
 800b8e8:	697b      	ldr	r3, [r7, #20]
 800b8ea:	7e5b      	ldrb	r3, [r3, #25]
    if ((pcb->prio < mprio) ||
 800b8ec:	187a      	adds	r2, r7, r1
 800b8ee:	7812      	ldrb	r2, [r2, #0]
 800b8f0:	429a      	cmp	r2, r3
 800b8f2:	d114      	bne.n	800b91e <tcp_kill_prio+0x8a>
        ((pcb->prio == mprio) && ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity))) {
 800b8f4:	4b14      	ldr	r3, [pc, #80]	; (800b948 <tcp_kill_prio+0xb4>)
 800b8f6:	681a      	ldr	r2, [r3, #0]
 800b8f8:	697b      	ldr	r3, [r7, #20]
 800b8fa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b8fc:	1ad3      	subs	r3, r2, r3
 800b8fe:	68fa      	ldr	r2, [r7, #12]
 800b900:	429a      	cmp	r2, r3
 800b902:	d80c      	bhi.n	800b91e <tcp_kill_prio+0x8a>
      inactivity = tcp_ticks - pcb->tmr;
 800b904:	4b10      	ldr	r3, [pc, #64]	; (800b948 <tcp_kill_prio+0xb4>)
 800b906:	681a      	ldr	r2, [r3, #0]
 800b908:	697b      	ldr	r3, [r7, #20]
 800b90a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b90c:	1ad3      	subs	r3, r2, r3
 800b90e:	60fb      	str	r3, [r7, #12]
      inactive   = pcb;
 800b910:	697b      	ldr	r3, [r7, #20]
 800b912:	613b      	str	r3, [r7, #16]
      mprio      = pcb->prio;
 800b914:	230b      	movs	r3, #11
 800b916:	18fb      	adds	r3, r7, r3
 800b918:	697a      	ldr	r2, [r7, #20]
 800b91a:	7e52      	ldrb	r2, [r2, #25]
 800b91c:	701a      	strb	r2, [r3, #0]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800b91e:	697b      	ldr	r3, [r7, #20]
 800b920:	691b      	ldr	r3, [r3, #16]
 800b922:	617b      	str	r3, [r7, #20]
 800b924:	697b      	ldr	r3, [r7, #20]
 800b926:	2b00      	cmp	r3, #0
 800b928:	d1d7      	bne.n	800b8da <tcp_kill_prio+0x46>
    }
  }
  if (inactive != NULL) {
 800b92a:	693b      	ldr	r3, [r7, #16]
 800b92c:	2b00      	cmp	r3, #0
 800b92e:	d005      	beq.n	800b93c <tcp_kill_prio+0xa8>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
                            (void *)inactive, inactivity));
    tcp_abort(inactive);
 800b930:	693b      	ldr	r3, [r7, #16]
 800b932:	0018      	movs	r0, r3
 800b934:	f7ff f830 	bl	800a998 <tcp_abort>
 800b938:	e000      	b.n	800b93c <tcp_kill_prio+0xa8>
    return;
 800b93a:	46c0      	nop			; (mov r8, r8)
  }
}
 800b93c:	46bd      	mov	sp, r7
 800b93e:	b006      	add	sp, #24
 800b940:	bd80      	pop	{r7, pc}
 800b942:	46c0      	nop			; (mov r8, r8)
 800b944:	20002b18 	.word	0x20002b18
 800b948:	20002b1c 	.word	0x20002b1c

0800b94c <tcp_kill_state>:
 * Kills the oldest connection that is in specific state.
 * Called from tcp_alloc() for LAST_ACK and CLOSING if no more connections are available.
 */
static void
tcp_kill_state(enum tcp_state state)
{
 800b94c:	b580      	push	{r7, lr}
 800b94e:	b086      	sub	sp, #24
 800b950:	af00      	add	r7, sp, #0
 800b952:	0002      	movs	r2, r0
 800b954:	1dfb      	adds	r3, r7, #7
 800b956:	701a      	strb	r2, [r3, #0]
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  LWIP_ASSERT("invalid state", (state == CLOSING) || (state == LAST_ACK));
 800b958:	1dfb      	adds	r3, r7, #7
 800b95a:	781b      	ldrb	r3, [r3, #0]
 800b95c:	2b08      	cmp	r3, #8
 800b95e:	d009      	beq.n	800b974 <tcp_kill_state+0x28>
 800b960:	1dfb      	adds	r3, r7, #7
 800b962:	781b      	ldrb	r3, [r3, #0]
 800b964:	2b09      	cmp	r3, #9
 800b966:	d005      	beq.n	800b974 <tcp_kill_state+0x28>
 800b968:	4b1a      	ldr	r3, [pc, #104]	; (800b9d4 <tcp_kill_state+0x88>)
 800b96a:	4a1b      	ldr	r2, [pc, #108]	; (800b9d8 <tcp_kill_state+0x8c>)
 800b96c:	491b      	ldr	r1, [pc, #108]	; (800b9dc <tcp_kill_state+0x90>)
 800b96e:	481c      	ldr	r0, [pc, #112]	; (800b9e0 <tcp_kill_state+0x94>)
 800b970:	f7f6 fc2c 	bl	80021cc <app_debug_rtt_raw>

  inactivity = 0;
 800b974:	2300      	movs	r3, #0
 800b976:	60fb      	str	r3, [r7, #12]
  inactive = NULL;
 800b978:	2300      	movs	r3, #0
 800b97a:	613b      	str	r3, [r7, #16]
  /* Go through the list of active pcbs and get the oldest pcb that is in state
     CLOSING/LAST_ACK. */
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800b97c:	4b19      	ldr	r3, [pc, #100]	; (800b9e4 <tcp_kill_state+0x98>)
 800b97e:	681b      	ldr	r3, [r3, #0]
 800b980:	617b      	str	r3, [r7, #20]
 800b982:	e018      	b.n	800b9b6 <tcp_kill_state+0x6a>
    if (pcb->state == state) {
 800b984:	697b      	ldr	r3, [r7, #20]
 800b986:	7e1b      	ldrb	r3, [r3, #24]
 800b988:	1dfa      	adds	r2, r7, #7
 800b98a:	7812      	ldrb	r2, [r2, #0]
 800b98c:	429a      	cmp	r2, r3
 800b98e:	d10f      	bne.n	800b9b0 <tcp_kill_state+0x64>
      if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800b990:	4b15      	ldr	r3, [pc, #84]	; (800b9e8 <tcp_kill_state+0x9c>)
 800b992:	681a      	ldr	r2, [r3, #0]
 800b994:	697b      	ldr	r3, [r7, #20]
 800b996:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b998:	1ad3      	subs	r3, r2, r3
 800b99a:	68fa      	ldr	r2, [r7, #12]
 800b99c:	429a      	cmp	r2, r3
 800b99e:	d807      	bhi.n	800b9b0 <tcp_kill_state+0x64>
        inactivity = tcp_ticks - pcb->tmr;
 800b9a0:	4b11      	ldr	r3, [pc, #68]	; (800b9e8 <tcp_kill_state+0x9c>)
 800b9a2:	681a      	ldr	r2, [r3, #0]
 800b9a4:	697b      	ldr	r3, [r7, #20]
 800b9a6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b9a8:	1ad3      	subs	r3, r2, r3
 800b9aa:	60fb      	str	r3, [r7, #12]
        inactive = pcb;
 800b9ac:	697b      	ldr	r3, [r7, #20]
 800b9ae:	613b      	str	r3, [r7, #16]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800b9b0:	697b      	ldr	r3, [r7, #20]
 800b9b2:	691b      	ldr	r3, [r3, #16]
 800b9b4:	617b      	str	r3, [r7, #20]
 800b9b6:	697b      	ldr	r3, [r7, #20]
 800b9b8:	2b00      	cmp	r3, #0
 800b9ba:	d1e3      	bne.n	800b984 <tcp_kill_state+0x38>
      }
    }
  }
  if (inactive != NULL) {
 800b9bc:	693b      	ldr	r3, [r7, #16]
 800b9be:	2b00      	cmp	r3, #0
 800b9c0:	d004      	beq.n	800b9cc <tcp_kill_state+0x80>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_closing: killing oldest %s PCB %p (%"S32_F")\n",
                            tcp_state_str[state], (void *)inactive, inactivity));
    /* Don't send a RST, since no data is lost. */
    tcp_abandon(inactive, 0);
 800b9c2:	693b      	ldr	r3, [r7, #16]
 800b9c4:	2100      	movs	r1, #0
 800b9c6:	0018      	movs	r0, r3
 800b9c8:	f7fe ff1c 	bl	800a804 <tcp_abandon>
  }
}
 800b9cc:	46c0      	nop			; (mov r8, r8)
 800b9ce:	46bd      	mov	sp, r7
 800b9d0:	b006      	add	sp, #24
 800b9d2:	bd80      	pop	{r7, pc}
 800b9d4:	0801f238 	.word	0x0801f238
 800b9d8:	000006de 	.word	0x000006de
 800b9dc:	0801f7c0 	.word	0x0801f7c0
 800b9e0:	0801f274 	.word	0x0801f274
 800b9e4:	20002b18 	.word	0x20002b18
 800b9e8:	20002b1c 	.word	0x20002b1c

0800b9ec <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
 800b9ec:	b580      	push	{r7, lr}
 800b9ee:	b084      	sub	sp, #16
 800b9f0:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
 800b9f2:	2300      	movs	r3, #0
 800b9f4:	607b      	str	r3, [r7, #4]
  inactive = NULL;
 800b9f6:	2300      	movs	r3, #0
 800b9f8:	60bb      	str	r3, [r7, #8]
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800b9fa:	4b12      	ldr	r3, [pc, #72]	; (800ba44 <tcp_kill_timewait+0x58>)
 800b9fc:	681b      	ldr	r3, [r3, #0]
 800b9fe:	60fb      	str	r3, [r7, #12]
 800ba00:	e012      	b.n	800ba28 <tcp_kill_timewait+0x3c>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800ba02:	4b11      	ldr	r3, [pc, #68]	; (800ba48 <tcp_kill_timewait+0x5c>)
 800ba04:	681a      	ldr	r2, [r3, #0]
 800ba06:	68fb      	ldr	r3, [r7, #12]
 800ba08:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ba0a:	1ad3      	subs	r3, r2, r3
 800ba0c:	687a      	ldr	r2, [r7, #4]
 800ba0e:	429a      	cmp	r2, r3
 800ba10:	d807      	bhi.n	800ba22 <tcp_kill_timewait+0x36>
      inactivity = tcp_ticks - pcb->tmr;
 800ba12:	4b0d      	ldr	r3, [pc, #52]	; (800ba48 <tcp_kill_timewait+0x5c>)
 800ba14:	681a      	ldr	r2, [r3, #0]
 800ba16:	68fb      	ldr	r3, [r7, #12]
 800ba18:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ba1a:	1ad3      	subs	r3, r2, r3
 800ba1c:	607b      	str	r3, [r7, #4]
      inactive = pcb;
 800ba1e:	68fb      	ldr	r3, [r7, #12]
 800ba20:	60bb      	str	r3, [r7, #8]
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800ba22:	68fb      	ldr	r3, [r7, #12]
 800ba24:	691b      	ldr	r3, [r3, #16]
 800ba26:	60fb      	str	r3, [r7, #12]
 800ba28:	68fb      	ldr	r3, [r7, #12]
 800ba2a:	2b00      	cmp	r3, #0
 800ba2c:	d1e9      	bne.n	800ba02 <tcp_kill_timewait+0x16>
    }
  }
  if (inactive != NULL) {
 800ba2e:	68bb      	ldr	r3, [r7, #8]
 800ba30:	2b00      	cmp	r3, #0
 800ba32:	d003      	beq.n	800ba3c <tcp_kill_timewait+0x50>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
                            (void *)inactive, inactivity));
    tcp_abort(inactive);
 800ba34:	68bb      	ldr	r3, [r7, #8]
 800ba36:	0018      	movs	r0, r3
 800ba38:	f7fe ffae 	bl	800a998 <tcp_abort>
  }
}
 800ba3c:	46c0      	nop			; (mov r8, r8)
 800ba3e:	46bd      	mov	sp, r7
 800ba40:	b004      	add	sp, #16
 800ba42:	bd80      	pop	{r7, pc}
 800ba44:	20002b28 	.word	0x20002b28
 800ba48:	20002b1c 	.word	0x20002b1c

0800ba4c <tcp_handle_closepend>:
 * now send the FIN (which failed before), the pcb might be in a state that is
 * OK for us to now free it.
 */
static void
tcp_handle_closepend(void)
{
 800ba4c:	b580      	push	{r7, lr}
 800ba4e:	b082      	sub	sp, #8
 800ba50:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb = tcp_active_pcbs;
 800ba52:	4b11      	ldr	r3, [pc, #68]	; (800ba98 <tcp_handle_closepend+0x4c>)
 800ba54:	681b      	ldr	r3, [r3, #0]
 800ba56:	607b      	str	r3, [r7, #4]

  while (pcb != NULL) {
 800ba58:	e015      	b.n	800ba86 <tcp_handle_closepend+0x3a>
    struct tcp_pcb *next = pcb->next;
 800ba5a:	687b      	ldr	r3, [r7, #4]
 800ba5c:	691b      	ldr	r3, [r3, #16]
 800ba5e:	603b      	str	r3, [r7, #0]
    /* send pending FIN */
    if (pcb->flags & TF_CLOSEPEND) {
 800ba60:	687b      	ldr	r3, [r7, #4]
 800ba62:	8bdb      	ldrh	r3, [r3, #30]
 800ba64:	001a      	movs	r2, r3
 800ba66:	2308      	movs	r3, #8
 800ba68:	4013      	ands	r3, r2
 800ba6a:	d00a      	beq.n	800ba82 <tcp_handle_closepend+0x36>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_handle_closepend: pending FIN\n"));
      tcp_clear_flags(pcb, TF_CLOSEPEND);
 800ba6c:	687b      	ldr	r3, [r7, #4]
 800ba6e:	8bdb      	ldrh	r3, [r3, #30]
 800ba70:	2208      	movs	r2, #8
 800ba72:	4393      	bics	r3, r2
 800ba74:	b29a      	uxth	r2, r3
 800ba76:	687b      	ldr	r3, [r7, #4]
 800ba78:	83da      	strh	r2, [r3, #30]
      tcp_close_shutdown_fin(pcb);
 800ba7a:	687b      	ldr	r3, [r7, #4]
 800ba7c:	0018      	movs	r0, r3
 800ba7e:	f7fe fe21 	bl	800a6c4 <tcp_close_shutdown_fin>
    }
    pcb = next;
 800ba82:	683b      	ldr	r3, [r7, #0]
 800ba84:	607b      	str	r3, [r7, #4]
  while (pcb != NULL) {
 800ba86:	687b      	ldr	r3, [r7, #4]
 800ba88:	2b00      	cmp	r3, #0
 800ba8a:	d1e6      	bne.n	800ba5a <tcp_handle_closepend+0xe>
  }
}
 800ba8c:	46c0      	nop			; (mov r8, r8)
 800ba8e:	46c0      	nop			; (mov r8, r8)
 800ba90:	46bd      	mov	sp, r7
 800ba92:	b002      	add	sp, #8
 800ba94:	bd80      	pop	{r7, pc}
 800ba96:	46c0      	nop			; (mov r8, r8)
 800ba98:	20002b18 	.word	0x20002b18

0800ba9c <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
 800ba9c:	b580      	push	{r7, lr}
 800ba9e:	b084      	sub	sp, #16
 800baa0:	af00      	add	r7, sp, #0
 800baa2:	0002      	movs	r2, r0
 800baa4:	1dfb      	adds	r3, r7, #7
 800baa6:	701a      	strb	r2, [r3, #0]
  struct tcp_pcb *pcb;

  LWIP_ASSERT_CORE_LOCKED();

  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800baa8:	2001      	movs	r0, #1
 800baaa:	f7fc fe8d 	bl	80087c8 <memp_malloc>
 800baae:	0003      	movs	r3, r0
 800bab0:	60fb      	str	r3, [r7, #12]
  if (pcb == NULL) {
 800bab2:	68fb      	ldr	r3, [r7, #12]
 800bab4:	2b00      	cmp	r3, #0
 800bab6:	d12b      	bne.n	800bb10 <tcp_alloc+0x74>
    /* Try to send FIN for all pcbs stuck in TF_CLOSEPEND first */
    tcp_handle_closepend();
 800bab8:	f7ff ffc8 	bl	800ba4c <tcp_handle_closepend>

    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
 800babc:	f7ff ff96 	bl	800b9ec <tcp_kill_timewait>
    /* Try to allocate a tcp_pcb again. */
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800bac0:	2001      	movs	r0, #1
 800bac2:	f7fc fe81 	bl	80087c8 <memp_malloc>
 800bac6:	0003      	movs	r3, r0
 800bac8:	60fb      	str	r3, [r7, #12]
    if (pcb == NULL) {
 800baca:	68fb      	ldr	r3, [r7, #12]
 800bacc:	2b00      	cmp	r3, #0
 800bace:	d11f      	bne.n	800bb10 <tcp_alloc+0x74>
      /* Try killing oldest connection in LAST-ACK (these wouldn't go to TIME-WAIT). */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest LAST-ACK connection\n"));
      tcp_kill_state(LAST_ACK);
 800bad0:	2009      	movs	r0, #9
 800bad2:	f7ff ff3b 	bl	800b94c <tcp_kill_state>
      /* Try to allocate a tcp_pcb again. */
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800bad6:	2001      	movs	r0, #1
 800bad8:	f7fc fe76 	bl	80087c8 <memp_malloc>
 800badc:	0003      	movs	r3, r0
 800bade:	60fb      	str	r3, [r7, #12]
      if (pcb == NULL) {
 800bae0:	68fb      	ldr	r3, [r7, #12]
 800bae2:	2b00      	cmp	r3, #0
 800bae4:	d114      	bne.n	800bb10 <tcp_alloc+0x74>
        /* Try killing oldest connection in CLOSING. */
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest CLOSING connection\n"));
        tcp_kill_state(CLOSING);
 800bae6:	2008      	movs	r0, #8
 800bae8:	f7ff ff30 	bl	800b94c <tcp_kill_state>
        /* Try to allocate a tcp_pcb again. */
        pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800baec:	2001      	movs	r0, #1
 800baee:	f7fc fe6b 	bl	80087c8 <memp_malloc>
 800baf2:	0003      	movs	r3, r0
 800baf4:	60fb      	str	r3, [r7, #12]
        if (pcb == NULL) {
 800baf6:	68fb      	ldr	r3, [r7, #12]
 800baf8:	2b00      	cmp	r3, #0
 800bafa:	d109      	bne.n	800bb10 <tcp_alloc+0x74>
          /* Try killing oldest active connection with lower priority than the new one. */
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing oldest connection with prio lower than %d\n", prio));
          tcp_kill_prio(prio);
 800bafc:	1dfb      	adds	r3, r7, #7
 800bafe:	781b      	ldrb	r3, [r3, #0]
 800bb00:	0018      	movs	r0, r3
 800bb02:	f7ff fec7 	bl	800b894 <tcp_kill_prio>
          /* Try to allocate a tcp_pcb again. */
          pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800bb06:	2001      	movs	r0, #1
 800bb08:	f7fc fe5e 	bl	80087c8 <memp_malloc>
 800bb0c:	0003      	movs	r3, r0
 800bb0e:	60fb      	str	r3, [r7, #12]
    if (pcb != NULL) {
      /* adjust err stats: memp_malloc failed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
 800bb10:	68fb      	ldr	r3, [r7, #12]
 800bb12:	2b00      	cmp	r3, #0
 800bb14:	d04c      	beq.n	800bbb0 <tcp_alloc+0x114>
    /* zero out the whole pcb, so there is no need to initialize members to zero */
    memset(pcb, 0, sizeof(struct tcp_pcb));
 800bb16:	68fb      	ldr	r3, [r7, #12]
 800bb18:	22a8      	movs	r2, #168	; 0xa8
 800bb1a:	2100      	movs	r1, #0
 800bb1c:	0018      	movs	r0, r3
 800bb1e:	f010 fe85 	bl	801c82c <memset>
    pcb->prio = prio;
 800bb22:	68fb      	ldr	r3, [r7, #12]
 800bb24:	1dfa      	adds	r2, r7, #7
 800bb26:	7812      	ldrb	r2, [r2, #0]
 800bb28:	765a      	strb	r2, [r3, #25]
    pcb->snd_buf = TCP_SND_BUF;
 800bb2a:	68fb      	ldr	r3, [r7, #12]
 800bb2c:	2268      	movs	r2, #104	; 0x68
 800bb2e:	2186      	movs	r1, #134	; 0x86
 800bb30:	00c9      	lsls	r1, r1, #3
 800bb32:	5299      	strh	r1, [r3, r2]
    /* Start with a window that does not need scaling. When window scaling is
       enabled and used, the window is enlarged when both sides agree on scaling. */
    pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 800bb34:	68fb      	ldr	r3, [r7, #12]
 800bb36:	2286      	movs	r2, #134	; 0x86
 800bb38:	00d2      	lsls	r2, r2, #3
 800bb3a:	85da      	strh	r2, [r3, #46]	; 0x2e
 800bb3c:	68fb      	ldr	r3, [r7, #12]
 800bb3e:	8dda      	ldrh	r2, [r3, #46]	; 0x2e
 800bb40:	68fb      	ldr	r3, [r7, #12]
 800bb42:	859a      	strh	r2, [r3, #44]	; 0x2c
    pcb->ttl = TCP_TTL;
 800bb44:	68fb      	ldr	r3, [r7, #12]
 800bb46:	22ff      	movs	r2, #255	; 0xff
 800bb48:	72da      	strb	r2, [r3, #11]
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = INITIAL_MSS;
 800bb4a:	68fb      	ldr	r3, [r7, #12]
 800bb4c:	2286      	movs	r2, #134	; 0x86
 800bb4e:	0092      	lsls	r2, r2, #2
 800bb50:	86da      	strh	r2, [r3, #54]	; 0x36
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 800bb52:	68fb      	ldr	r3, [r7, #12]
 800bb54:	2244      	movs	r2, #68	; 0x44
 800bb56:	2103      	movs	r1, #3
 800bb58:	5299      	strh	r1, [r3, r2]
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 800bb5a:	68fb      	ldr	r3, [r7, #12]
 800bb5c:	2242      	movs	r2, #66	; 0x42
 800bb5e:	2103      	movs	r1, #3
 800bb60:	5299      	strh	r1, [r3, r2]
    pcb->rtime = -1;
 800bb62:	68fb      	ldr	r3, [r7, #12]
 800bb64:	2201      	movs	r2, #1
 800bb66:	4252      	negs	r2, r2
 800bb68:	869a      	strh	r2, [r3, #52]	; 0x34
    pcb->cwnd = 1;
 800bb6a:	68fb      	ldr	r3, [r7, #12]
 800bb6c:	224c      	movs	r2, #76	; 0x4c
 800bb6e:	2101      	movs	r1, #1
 800bb70:	5299      	strh	r1, [r3, r2]
    pcb->tmr = tcp_ticks;
 800bb72:	4b12      	ldr	r3, [pc, #72]	; (800bbbc <tcp_alloc+0x120>)
 800bb74:	681a      	ldr	r2, [r3, #0]
 800bb76:	68fb      	ldr	r3, [r7, #12]
 800bb78:	625a      	str	r2, [r3, #36]	; 0x24
    pcb->last_timer = tcp_timer_ctr;
 800bb7a:	4b11      	ldr	r3, [pc, #68]	; (800bbc0 <tcp_alloc+0x124>)
 800bb7c:	7819      	ldrb	r1, [r3, #0]
 800bb7e:	68fb      	ldr	r3, [r7, #12]
 800bb80:	2222      	movs	r2, #34	; 0x22
 800bb82:	5499      	strb	r1, [r3, r2]
    of using the largest advertised receive window.  We've seen complications with
    receiving TCPs that use window scaling and/or window auto-tuning where the
    initial advertised window is very small and then grows rapidly once the
    connection is established. To avoid these complications, we set ssthresh to the
    largest effective cwnd (amount of in-flight data) that the sender can have. */
    pcb->ssthresh = TCP_SND_BUF;
 800bb84:	68fb      	ldr	r3, [r7, #12]
 800bb86:	224e      	movs	r2, #78	; 0x4e
 800bb88:	2186      	movs	r1, #134	; 0x86
 800bb8a:	00c9      	lsls	r1, r1, #3
 800bb8c:	5299      	strh	r1, [r3, r2]

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
 800bb8e:	68fb      	ldr	r3, [r7, #12]
 800bb90:	2188      	movs	r1, #136	; 0x88
 800bb92:	4a0c      	ldr	r2, [pc, #48]	; (800bbc4 <tcp_alloc+0x128>)
 800bb94:	505a      	str	r2, [r3, r1]
#endif /* LWIP_CALLBACK_API */

    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 800bb96:	68fb      	ldr	r3, [r7, #12]
 800bb98:	2298      	movs	r2, #152	; 0x98
 800bb9a:	490b      	ldr	r1, [pc, #44]	; (800bbc8 <tcp_alloc+0x12c>)
 800bb9c:	5099      	str	r1, [r3, r2]

#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
 800bb9e:	68fb      	ldr	r3, [r7, #12]
 800bba0:	219c      	movs	r1, #156	; 0x9c
 800bba2:	22fa      	movs	r2, #250	; 0xfa
 800bba4:	00d2      	lsls	r2, r2, #3
 800bba6:	505a      	str	r2, [r3, r1]
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
 800bba8:	68fb      	ldr	r3, [r7, #12]
 800bbaa:	22a0      	movs	r2, #160	; 0xa0
 800bbac:	2109      	movs	r1, #9
 800bbae:	5099      	str	r1, [r3, r2]
#endif /* LWIP_TCP_KEEPALIVE */
  }
  return pcb;
 800bbb0:	68fb      	ldr	r3, [r7, #12]
}
 800bbb2:	0018      	movs	r0, r3
 800bbb4:	46bd      	mov	sp, r7
 800bbb6:	b004      	add	sp, #16
 800bbb8:	bd80      	pop	{r7, pc}
 800bbba:	46c0      	nop			; (mov r8, r8)
 800bbbc:	20002b1c 	.word	0x20002b1c
 800bbc0:	2000135a 	.word	0x2000135a
 800bbc4:	0800b82d 	.word	0x0800b82d
 800bbc8:	00002710 	.word	0x00002710

0800bbcc <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
 800bbcc:	b580      	push	{r7, lr}
 800bbce:	af00      	add	r7, sp, #0
  return tcp_alloc(TCP_PRIO_NORMAL);
 800bbd0:	2040      	movs	r0, #64	; 0x40
 800bbd2:	f7ff ff63 	bl	800ba9c <tcp_alloc>
 800bbd6:	0003      	movs	r3, r0
}
 800bbd8:	0018      	movs	r0, r3
 800bbda:	46bd      	mov	sp, r7
 800bbdc:	bd80      	pop	{r7, pc}

0800bbde <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{
 800bbde:	b580      	push	{r7, lr}
 800bbe0:	b082      	sub	sp, #8
 800bbe2:	af00      	add	r7, sp, #0
 800bbe4:	6078      	str	r0, [r7, #4]
 800bbe6:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT_CORE_LOCKED();
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  if (pcb != NULL) {
 800bbe8:	687b      	ldr	r3, [r7, #4]
 800bbea:	2b00      	cmp	r3, #0
 800bbec:	d002      	beq.n	800bbf4 <tcp_arg+0x16>
    pcb->callback_arg = arg;
 800bbee:	687b      	ldr	r3, [r7, #4]
 800bbf0:	683a      	ldr	r2, [r7, #0]
 800bbf2:	615a      	str	r2, [r3, #20]
  }
}
 800bbf4:	46c0      	nop			; (mov r8, r8)
 800bbf6:	46bd      	mov	sp, r7
 800bbf8:	b002      	add	sp, #8
 800bbfa:	bd80      	pop	{r7, pc}

0800bbfc <tcp_recv>:
 * @param pcb tcp_pcb to set the recv callback
 * @param recv callback function to call for this pcb when data is received
 */
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
 800bbfc:	b580      	push	{r7, lr}
 800bbfe:	b082      	sub	sp, #8
 800bc00:	af00      	add	r7, sp, #0
 800bc02:	6078      	str	r0, [r7, #4]
 800bc04:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
 800bc06:	687b      	ldr	r3, [r7, #4]
 800bc08:	2b00      	cmp	r3, #0
 800bc0a:	d00d      	beq.n	800bc28 <tcp_recv+0x2c>
    LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
 800bc0c:	687b      	ldr	r3, [r7, #4]
 800bc0e:	7e1b      	ldrb	r3, [r3, #24]
 800bc10:	2b01      	cmp	r3, #1
 800bc12:	d105      	bne.n	800bc20 <tcp_recv+0x24>
 800bc14:	4b06      	ldr	r3, [pc, #24]	; (800bc30 <tcp_recv+0x34>)
 800bc16:	4a07      	ldr	r2, [pc, #28]	; (800bc34 <tcp_recv+0x38>)
 800bc18:	4907      	ldr	r1, [pc, #28]	; (800bc38 <tcp_recv+0x3c>)
 800bc1a:	4808      	ldr	r0, [pc, #32]	; (800bc3c <tcp_recv+0x40>)
 800bc1c:	f7f6 fad6 	bl	80021cc <app_debug_rtt_raw>
    pcb->recv = recv;
 800bc20:	687b      	ldr	r3, [r7, #4]
 800bc22:	2188      	movs	r1, #136	; 0x88
 800bc24:	683a      	ldr	r2, [r7, #0]
 800bc26:	505a      	str	r2, [r3, r1]
  }
}
 800bc28:	46c0      	nop			; (mov r8, r8)
 800bc2a:	46bd      	mov	sp, r7
 800bc2c:	b002      	add	sp, #8
 800bc2e:	bd80      	pop	{r7, pc}
 800bc30:	0801f238 	.word	0x0801f238
 800bc34:	000007e2 	.word	0x000007e2
 800bc38:	0801f7d0 	.word	0x0801f7d0
 800bc3c:	0801f274 	.word	0x0801f274

0800bc40 <tcp_sent>:
 * @param pcb tcp_pcb to set the sent callback
 * @param sent callback function to call for this pcb when data is successfully sent
 */
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
 800bc40:	b580      	push	{r7, lr}
 800bc42:	b082      	sub	sp, #8
 800bc44:	af00      	add	r7, sp, #0
 800bc46:	6078      	str	r0, [r7, #4]
 800bc48:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
 800bc4a:	687b      	ldr	r3, [r7, #4]
 800bc4c:	2b00      	cmp	r3, #0
 800bc4e:	d00d      	beq.n	800bc6c <tcp_sent+0x2c>
    LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
 800bc50:	687b      	ldr	r3, [r7, #4]
 800bc52:	7e1b      	ldrb	r3, [r3, #24]
 800bc54:	2b01      	cmp	r3, #1
 800bc56:	d105      	bne.n	800bc64 <tcp_sent+0x24>
 800bc58:	4b06      	ldr	r3, [pc, #24]	; (800bc74 <tcp_sent+0x34>)
 800bc5a:	4a07      	ldr	r2, [pc, #28]	; (800bc78 <tcp_sent+0x38>)
 800bc5c:	4907      	ldr	r1, [pc, #28]	; (800bc7c <tcp_sent+0x3c>)
 800bc5e:	4808      	ldr	r0, [pc, #32]	; (800bc80 <tcp_sent+0x40>)
 800bc60:	f7f6 fab4 	bl	80021cc <app_debug_rtt_raw>
    pcb->sent = sent;
 800bc64:	687b      	ldr	r3, [r7, #4]
 800bc66:	2184      	movs	r1, #132	; 0x84
 800bc68:	683a      	ldr	r2, [r7, #0]
 800bc6a:	505a      	str	r2, [r3, r1]
  }
}
 800bc6c:	46c0      	nop			; (mov r8, r8)
 800bc6e:	46bd      	mov	sp, r7
 800bc70:	b002      	add	sp, #8
 800bc72:	bd80      	pop	{r7, pc}
 800bc74:	0801f238 	.word	0x0801f238
 800bc78:	000007f6 	.word	0x000007f6
 800bc7c:	0801f7f8 	.word	0x0801f7f8
 800bc80:	0801f274 	.word	0x0801f274

0800bc84 <tcp_err>:
 * @param err callback function to call for this pcb when a fatal error
 *        has occurred on the connection
 */
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
 800bc84:	b580      	push	{r7, lr}
 800bc86:	b082      	sub	sp, #8
 800bc88:	af00      	add	r7, sp, #0
 800bc8a:	6078      	str	r0, [r7, #4]
 800bc8c:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
 800bc8e:	687b      	ldr	r3, [r7, #4]
 800bc90:	2b00      	cmp	r3, #0
 800bc92:	d00e      	beq.n	800bcb2 <tcp_err+0x2e>
    LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
 800bc94:	687b      	ldr	r3, [r7, #4]
 800bc96:	7e1b      	ldrb	r3, [r3, #24]
 800bc98:	2b01      	cmp	r3, #1
 800bc9a:	d106      	bne.n	800bcaa <tcp_err+0x26>
 800bc9c:	4b07      	ldr	r3, [pc, #28]	; (800bcbc <tcp_err+0x38>)
 800bc9e:	2281      	movs	r2, #129	; 0x81
 800bca0:	0112      	lsls	r2, r2, #4
 800bca2:	4907      	ldr	r1, [pc, #28]	; (800bcc0 <tcp_err+0x3c>)
 800bca4:	4807      	ldr	r0, [pc, #28]	; (800bcc4 <tcp_err+0x40>)
 800bca6:	f7f6 fa91 	bl	80021cc <app_debug_rtt_raw>
    pcb->errf = err;
 800bcaa:	687b      	ldr	r3, [r7, #4]
 800bcac:	2194      	movs	r1, #148	; 0x94
 800bcae:	683a      	ldr	r2, [r7, #0]
 800bcb0:	505a      	str	r2, [r3, r1]
  }
}
 800bcb2:	46c0      	nop			; (mov r8, r8)
 800bcb4:	46bd      	mov	sp, r7
 800bcb6:	b002      	add	sp, #8
 800bcb8:	bd80      	pop	{r7, pc}
 800bcba:	46c0      	nop			; (mov r8, r8)
 800bcbc:	0801f238 	.word	0x0801f238
 800bcc0:	0801f820 	.word	0x0801f820
 800bcc4:	0801f274 	.word	0x0801f274

0800bcc8 <tcp_poll>:
 * the application may use the polling functionality to call tcp_write()
 * again when the connection has been idle for a while.
 */
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
 800bcc8:	b580      	push	{r7, lr}
 800bcca:	b084      	sub	sp, #16
 800bccc:	af00      	add	r7, sp, #0
 800bcce:	60f8      	str	r0, [r7, #12]
 800bcd0:	60b9      	str	r1, [r7, #8]
 800bcd2:	1dfb      	adds	r3, r7, #7
 800bcd4:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_poll: invalid pcb", pcb != NULL, return);
 800bcd6:	68fb      	ldr	r3, [r7, #12]
 800bcd8:	2b00      	cmp	r3, #0
 800bcda:	d104      	bne.n	800bce6 <tcp_poll+0x1e>
 800bcdc:	4b0d      	ldr	r3, [pc, #52]	; (800bd14 <tcp_poll+0x4c>)
 800bcde:	0018      	movs	r0, r3
 800bce0:	f7f6 fa74 	bl	80021cc <app_debug_rtt_raw>
 800bce4:	e012      	b.n	800bd0c <tcp_poll+0x44>
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
 800bce6:	68fb      	ldr	r3, [r7, #12]
 800bce8:	7e1b      	ldrb	r3, [r3, #24]
 800bcea:	2b01      	cmp	r3, #1
 800bcec:	d105      	bne.n	800bcfa <tcp_poll+0x32>
 800bcee:	4b0a      	ldr	r3, [pc, #40]	; (800bd18 <tcp_poll+0x50>)
 800bcf0:	4a0a      	ldr	r2, [pc, #40]	; (800bd1c <tcp_poll+0x54>)
 800bcf2:	490b      	ldr	r1, [pc, #44]	; (800bd20 <tcp_poll+0x58>)
 800bcf4:	480b      	ldr	r0, [pc, #44]	; (800bd24 <tcp_poll+0x5c>)
 800bcf6:	f7f6 fa69 	bl	80021cc <app_debug_rtt_raw>

#if LWIP_CALLBACK_API
  pcb->poll = poll;
 800bcfa:	68fb      	ldr	r3, [r7, #12]
 800bcfc:	2190      	movs	r1, #144	; 0x90
 800bcfe:	68ba      	ldr	r2, [r7, #8]
 800bd00:	505a      	str	r2, [r3, r1]
#else /* LWIP_CALLBACK_API */
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */
  pcb->pollinterval = interval;
 800bd02:	68fb      	ldr	r3, [r7, #12]
 800bd04:	1dfa      	adds	r2, r7, #7
 800bd06:	2121      	movs	r1, #33	; 0x21
 800bd08:	7812      	ldrb	r2, [r2, #0]
 800bd0a:	545a      	strb	r2, [r3, r1]
}
 800bd0c:	46bd      	mov	sp, r7
 800bd0e:	b004      	add	sp, #16
 800bd10:	bd80      	pop	{r7, pc}
 800bd12:	46c0      	nop			; (mov r8, r8)
 800bd14:	0801f848 	.word	0x0801f848
 800bd18:	0801f238 	.word	0x0801f238
 800bd1c:	00000842 	.word	0x00000842
 800bd20:	0801f860 	.word	0x0801f860
 800bd24:	0801f274 	.word	0x0801f274

0800bd28 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
 800bd28:	b580      	push	{r7, lr}
 800bd2a:	b082      	sub	sp, #8
 800bd2c:	af00      	add	r7, sp, #0
 800bd2e:	6078      	str	r0, [r7, #4]
  LWIP_ERROR("tcp_pcb_purge: invalid pcb", pcb != NULL, return);
 800bd30:	687b      	ldr	r3, [r7, #4]
 800bd32:	2b00      	cmp	r3, #0
 800bd34:	d104      	bne.n	800bd40 <tcp_pcb_purge+0x18>
 800bd36:	4b20      	ldr	r3, [pc, #128]	; (800bdb8 <tcp_pcb_purge+0x90>)
 800bd38:	0018      	movs	r0, r3
 800bd3a:	f7f6 fa47 	bl	80021cc <app_debug_rtt_raw>
 800bd3e:	e038      	b.n	800bdb2 <tcp_pcb_purge+0x8a>

  if (pcb->state != CLOSED &&
 800bd40:	687b      	ldr	r3, [r7, #4]
 800bd42:	7e1b      	ldrb	r3, [r3, #24]
 800bd44:	2b00      	cmp	r3, #0
 800bd46:	d034      	beq.n	800bdb2 <tcp_pcb_purge+0x8a>
      pcb->state != TIME_WAIT &&
 800bd48:	687b      	ldr	r3, [r7, #4]
 800bd4a:	7e1b      	ldrb	r3, [r3, #24]
  if (pcb->state != CLOSED &&
 800bd4c:	2b0a      	cmp	r3, #10
 800bd4e:	d030      	beq.n	800bdb2 <tcp_pcb_purge+0x8a>
      pcb->state != LISTEN) {
 800bd50:	687b      	ldr	r3, [r7, #4]
 800bd52:	7e1b      	ldrb	r3, [r3, #24]
      pcb->state != TIME_WAIT &&
 800bd54:	2b01      	cmp	r3, #1
 800bd56:	d02c      	beq.n	800bdb2 <tcp_pcb_purge+0x8a>

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    tcp_backlog_accepted(pcb);

    if (pcb->refused_data != NULL) {
 800bd58:	687b      	ldr	r3, [r7, #4]
 800bd5a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800bd5c:	2b00      	cmp	r3, #0
 800bd5e:	d007      	beq.n	800bd70 <tcp_pcb_purge+0x48>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 800bd60:	687b      	ldr	r3, [r7, #4]
 800bd62:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800bd64:	0018      	movs	r0, r3
 800bd66:	f7fd fc95 	bl	8009694 <pbuf_free>
      pcb->refused_data = NULL;
 800bd6a:	687b      	ldr	r3, [r7, #4]
 800bd6c:	2200      	movs	r2, #0
 800bd6e:	67da      	str	r2, [r3, #124]	; 0x7c
    }
    if (pcb->unacked != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
 800bd70:	687b      	ldr	r3, [r7, #4]
 800bd72:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800bd74:	2b00      	cmp	r3, #0
 800bd76:	d003      	beq.n	800bd80 <tcp_pcb_purge+0x58>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
      tcp_free_ooseq(pcb);
 800bd78:	687b      	ldr	r3, [r7, #4]
 800bd7a:	0018      	movs	r0, r3
 800bd7c:	f000 f9a4 	bl	800c0c8 <tcp_free_ooseq>
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 800bd80:	687b      	ldr	r3, [r7, #4]
 800bd82:	2201      	movs	r2, #1
 800bd84:	4252      	negs	r2, r2
 800bd86:	869a      	strh	r2, [r3, #52]	; 0x34

    tcp_segs_free(pcb->unsent);
 800bd88:	687b      	ldr	r3, [r7, #4]
 800bd8a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800bd8c:	0018      	movs	r0, r3
 800bd8e:	f7ff fced 	bl	800b76c <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
 800bd92:	687b      	ldr	r3, [r7, #4]
 800bd94:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800bd96:	0018      	movs	r0, r3
 800bd98:	f7ff fce8 	bl	800b76c <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
 800bd9c:	687b      	ldr	r3, [r7, #4]
 800bd9e:	2200      	movs	r2, #0
 800bda0:	671a      	str	r2, [r3, #112]	; 0x70
 800bda2:	687b      	ldr	r3, [r7, #4]
 800bda4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800bda6:	687b      	ldr	r3, [r7, #4]
 800bda8:	675a      	str	r2, [r3, #116]	; 0x74
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 800bdaa:	687b      	ldr	r3, [r7, #4]
 800bdac:	226c      	movs	r2, #108	; 0x6c
 800bdae:	2100      	movs	r1, #0
 800bdb0:	5299      	strh	r1, [r3, r2]
#endif /* TCP_OVERSIZE */
  }
}
 800bdb2:	46bd      	mov	sp, r7
 800bdb4:	b002      	add	sp, #8
 800bdb6:	bd80      	pop	{r7, pc}
 800bdb8:	0801f880 	.word	0x0801f880

0800bdbc <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
 800bdbc:	b580      	push	{r7, lr}
 800bdbe:	b084      	sub	sp, #16
 800bdc0:	af00      	add	r7, sp, #0
 800bdc2:	6078      	str	r0, [r7, #4]
 800bdc4:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT("tcp_pcb_remove: invalid pcb", pcb != NULL);
 800bdc6:	683b      	ldr	r3, [r7, #0]
 800bdc8:	2b00      	cmp	r3, #0
 800bdca:	d105      	bne.n	800bdd8 <tcp_pcb_remove+0x1c>
 800bdcc:	4b3c      	ldr	r3, [pc, #240]	; (800bec0 <tcp_pcb_remove+0x104>)
 800bdce:	4a3d      	ldr	r2, [pc, #244]	; (800bec4 <tcp_pcb_remove+0x108>)
 800bdd0:	493d      	ldr	r1, [pc, #244]	; (800bec8 <tcp_pcb_remove+0x10c>)
 800bdd2:	483e      	ldr	r0, [pc, #248]	; (800becc <tcp_pcb_remove+0x110>)
 800bdd4:	f7f6 f9fa 	bl	80021cc <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_pcb_remove: invalid pcblist", pcblist != NULL);
 800bdd8:	687b      	ldr	r3, [r7, #4]
 800bdda:	2b00      	cmp	r3, #0
 800bddc:	d105      	bne.n	800bdea <tcp_pcb_remove+0x2e>
 800bdde:	4b38      	ldr	r3, [pc, #224]	; (800bec0 <tcp_pcb_remove+0x104>)
 800bde0:	4a3b      	ldr	r2, [pc, #236]	; (800bed0 <tcp_pcb_remove+0x114>)
 800bde2:	493c      	ldr	r1, [pc, #240]	; (800bed4 <tcp_pcb_remove+0x118>)
 800bde4:	4839      	ldr	r0, [pc, #228]	; (800becc <tcp_pcb_remove+0x110>)
 800bde6:	f7f6 f9f1 	bl	80021cc <app_debug_rtt_raw>

  TCP_RMV(pcblist, pcb);
 800bdea:	687b      	ldr	r3, [r7, #4]
 800bdec:	681b      	ldr	r3, [r3, #0]
 800bdee:	683a      	ldr	r2, [r7, #0]
 800bdf0:	429a      	cmp	r2, r3
 800bdf2:	d105      	bne.n	800be00 <tcp_pcb_remove+0x44>
 800bdf4:	687b      	ldr	r3, [r7, #4]
 800bdf6:	681b      	ldr	r3, [r3, #0]
 800bdf8:	691a      	ldr	r2, [r3, #16]
 800bdfa:	687b      	ldr	r3, [r7, #4]
 800bdfc:	601a      	str	r2, [r3, #0]
 800bdfe:	e013      	b.n	800be28 <tcp_pcb_remove+0x6c>
 800be00:	687b      	ldr	r3, [r7, #4]
 800be02:	681b      	ldr	r3, [r3, #0]
 800be04:	60fb      	str	r3, [r7, #12]
 800be06:	e00c      	b.n	800be22 <tcp_pcb_remove+0x66>
 800be08:	68fb      	ldr	r3, [r7, #12]
 800be0a:	691b      	ldr	r3, [r3, #16]
 800be0c:	683a      	ldr	r2, [r7, #0]
 800be0e:	429a      	cmp	r2, r3
 800be10:	d104      	bne.n	800be1c <tcp_pcb_remove+0x60>
 800be12:	683b      	ldr	r3, [r7, #0]
 800be14:	691a      	ldr	r2, [r3, #16]
 800be16:	68fb      	ldr	r3, [r7, #12]
 800be18:	611a      	str	r2, [r3, #16]
 800be1a:	e005      	b.n	800be28 <tcp_pcb_remove+0x6c>
 800be1c:	68fb      	ldr	r3, [r7, #12]
 800be1e:	691b      	ldr	r3, [r3, #16]
 800be20:	60fb      	str	r3, [r7, #12]
 800be22:	68fb      	ldr	r3, [r7, #12]
 800be24:	2b00      	cmp	r3, #0
 800be26:	d1ef      	bne.n	800be08 <tcp_pcb_remove+0x4c>
 800be28:	683b      	ldr	r3, [r7, #0]
 800be2a:	2200      	movs	r2, #0
 800be2c:	611a      	str	r2, [r3, #16]

  tcp_pcb_purge(pcb);
 800be2e:	683b      	ldr	r3, [r7, #0]
 800be30:	0018      	movs	r0, r3
 800be32:	f7ff ff79 	bl	800bd28 <tcp_pcb_purge>

  /* if there is an outstanding delayed ACKs, send it */
  if ((pcb->state != TIME_WAIT) &&
 800be36:	683b      	ldr	r3, [r7, #0]
 800be38:	7e1b      	ldrb	r3, [r3, #24]
 800be3a:	2b0a      	cmp	r3, #10
 800be3c:	d014      	beq.n	800be68 <tcp_pcb_remove+0xac>
      (pcb->state != LISTEN) &&
 800be3e:	683b      	ldr	r3, [r7, #0]
 800be40:	7e1b      	ldrb	r3, [r3, #24]
  if ((pcb->state != TIME_WAIT) &&
 800be42:	2b01      	cmp	r3, #1
 800be44:	d010      	beq.n	800be68 <tcp_pcb_remove+0xac>
      (pcb->flags & TF_ACK_DELAY)) {
 800be46:	683b      	ldr	r3, [r7, #0]
 800be48:	8bdb      	ldrh	r3, [r3, #30]
 800be4a:	001a      	movs	r2, r3
 800be4c:	2301      	movs	r3, #1
 800be4e:	4013      	ands	r3, r2
      (pcb->state != LISTEN) &&
 800be50:	d00a      	beq.n	800be68 <tcp_pcb_remove+0xac>
    tcp_ack_now(pcb);
 800be52:	683b      	ldr	r3, [r7, #0]
 800be54:	8bdb      	ldrh	r3, [r3, #30]
 800be56:	2202      	movs	r2, #2
 800be58:	4313      	orrs	r3, r2
 800be5a:	b29a      	uxth	r2, r3
 800be5c:	683b      	ldr	r3, [r7, #0]
 800be5e:	83da      	strh	r2, [r3, #30]
    tcp_output(pcb);
 800be60:	683b      	ldr	r3, [r7, #0]
 800be62:	0018      	movs	r0, r3
 800be64:	f004 fb8c 	bl	8010580 <tcp_output>
  }

  if (pcb->state != LISTEN) {
 800be68:	683b      	ldr	r3, [r7, #0]
 800be6a:	7e1b      	ldrb	r3, [r3, #24]
 800be6c:	2b01      	cmp	r3, #1
 800be6e:	d01d      	beq.n	800beac <tcp_pcb_remove+0xf0>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
 800be70:	683b      	ldr	r3, [r7, #0]
 800be72:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800be74:	2b00      	cmp	r3, #0
 800be76:	d005      	beq.n	800be84 <tcp_pcb_remove+0xc8>
 800be78:	4b11      	ldr	r3, [pc, #68]	; (800bec0 <tcp_pcb_remove+0x104>)
 800be7a:	4a17      	ldr	r2, [pc, #92]	; (800bed8 <tcp_pcb_remove+0x11c>)
 800be7c:	4917      	ldr	r1, [pc, #92]	; (800bedc <tcp_pcb_remove+0x120>)
 800be7e:	4813      	ldr	r0, [pc, #76]	; (800becc <tcp_pcb_remove+0x110>)
 800be80:	f7f6 f9a4 	bl	80021cc <app_debug_rtt_raw>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
 800be84:	683b      	ldr	r3, [r7, #0]
 800be86:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800be88:	2b00      	cmp	r3, #0
 800be8a:	d005      	beq.n	800be98 <tcp_pcb_remove+0xdc>
 800be8c:	4b0c      	ldr	r3, [pc, #48]	; (800bec0 <tcp_pcb_remove+0x104>)
 800be8e:	4a14      	ldr	r2, [pc, #80]	; (800bee0 <tcp_pcb_remove+0x124>)
 800be90:	4914      	ldr	r1, [pc, #80]	; (800bee4 <tcp_pcb_remove+0x128>)
 800be92:	480e      	ldr	r0, [pc, #56]	; (800becc <tcp_pcb_remove+0x110>)
 800be94:	f7f6 f99a 	bl	80021cc <app_debug_rtt_raw>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
 800be98:	683b      	ldr	r3, [r7, #0]
 800be9a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800be9c:	2b00      	cmp	r3, #0
 800be9e:	d005      	beq.n	800beac <tcp_pcb_remove+0xf0>
 800bea0:	4b07      	ldr	r3, [pc, #28]	; (800bec0 <tcp_pcb_remove+0x104>)
 800bea2:	4a11      	ldr	r2, [pc, #68]	; (800bee8 <tcp_pcb_remove+0x12c>)
 800bea4:	4911      	ldr	r1, [pc, #68]	; (800beec <tcp_pcb_remove+0x130>)
 800bea6:	4809      	ldr	r0, [pc, #36]	; (800becc <tcp_pcb_remove+0x110>)
 800bea8:	f7f6 f990 	bl	80021cc <app_debug_rtt_raw>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
 800beac:	683b      	ldr	r3, [r7, #0]
 800beae:	2200      	movs	r2, #0
 800beb0:	761a      	strb	r2, [r3, #24]
  /* reset the local port to prevent the pcb from being 'bound' */
  pcb->local_port = 0;
 800beb2:	683b      	ldr	r3, [r7, #0]
 800beb4:	2200      	movs	r2, #0
 800beb6:	835a      	strh	r2, [r3, #26]

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
 800beb8:	46c0      	nop			; (mov r8, r8)
 800beba:	46bd      	mov	sp, r7
 800bebc:	b004      	add	sp, #16
 800bebe:	bd80      	pop	{r7, pc}
 800bec0:	0801f238 	.word	0x0801f238
 800bec4:	00000887 	.word	0x00000887
 800bec8:	0801f89c 	.word	0x0801f89c
 800becc:	0801f274 	.word	0x0801f274
 800bed0:	00000888 	.word	0x00000888
 800bed4:	0801f8b8 	.word	0x0801f8b8
 800bed8:	00000897 	.word	0x00000897
 800bedc:	0801f8d8 	.word	0x0801f8d8
 800bee0:	00000898 	.word	0x00000898
 800bee4:	0801f8f0 	.word	0x0801f8f0
 800bee8:	0000089a 	.word	0x0000089a
 800beec:	0801f90c 	.word	0x0801f90c

0800bef0 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(struct tcp_pcb *pcb)
{
 800bef0:	b580      	push	{r7, lr}
 800bef2:	b082      	sub	sp, #8
 800bef4:	af00      	add	r7, sp, #0
 800bef6:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_next_iss: invalid pcb", pcb != NULL);
  return LWIP_HOOK_TCP_ISN(&pcb->local_ip, pcb->local_port, &pcb->remote_ip, pcb->remote_port);
#else /* LWIP_HOOK_TCP_ISN */
  static u32_t iss = 6510;

  LWIP_ASSERT("tcp_next_iss: invalid pcb", pcb != NULL);
 800bef8:	687b      	ldr	r3, [r7, #4]
 800befa:	2b00      	cmp	r3, #0
 800befc:	d105      	bne.n	800bf0a <tcp_next_iss+0x1a>
 800befe:	4b09      	ldr	r3, [pc, #36]	; (800bf24 <tcp_next_iss+0x34>)
 800bf00:	4a09      	ldr	r2, [pc, #36]	; (800bf28 <tcp_next_iss+0x38>)
 800bf02:	490a      	ldr	r1, [pc, #40]	; (800bf2c <tcp_next_iss+0x3c>)
 800bf04:	480a      	ldr	r0, [pc, #40]	; (800bf30 <tcp_next_iss+0x40>)
 800bf06:	f7f6 f961 	bl	80021cc <app_debug_rtt_raw>
  LWIP_UNUSED_ARG(pcb);

  iss += tcp_ticks;       /* XXX */
 800bf0a:	4b0a      	ldr	r3, [pc, #40]	; (800bf34 <tcp_next_iss+0x44>)
 800bf0c:	681a      	ldr	r2, [r3, #0]
 800bf0e:	4b0a      	ldr	r3, [pc, #40]	; (800bf38 <tcp_next_iss+0x48>)
 800bf10:	681b      	ldr	r3, [r3, #0]
 800bf12:	18d2      	adds	r2, r2, r3
 800bf14:	4b07      	ldr	r3, [pc, #28]	; (800bf34 <tcp_next_iss+0x44>)
 800bf16:	601a      	str	r2, [r3, #0]
  return iss;
 800bf18:	4b06      	ldr	r3, [pc, #24]	; (800bf34 <tcp_next_iss+0x44>)
 800bf1a:	681b      	ldr	r3, [r3, #0]
#endif /* LWIP_HOOK_TCP_ISN */
}
 800bf1c:	0018      	movs	r0, r3
 800bf1e:	46bd      	mov	sp, r7
 800bf20:	b002      	add	sp, #8
 800bf22:	bd80      	pop	{r7, pc}
 800bf24:	0801f238 	.word	0x0801f238
 800bf28:	000008b3 	.word	0x000008b3
 800bf2c:	0801f924 	.word	0x0801f924
 800bf30:	0801f274 	.word	0x0801f274
 800bf34:	20000210 	.word	0x20000210
 800bf38:	20002b1c 	.word	0x20002b1c

0800bf3c <tcp_eff_send_mss_netif>:
 * by calculating the minimum of TCP_MSS and the mtu (if set) of the target
 * netif (if not NULL).
 */
u16_t
tcp_eff_send_mss_netif(u16_t sendmss, struct netif *outif, const ip_addr_t *dest)
{
 800bf3c:	b590      	push	{r4, r7, lr}
 800bf3e:	b087      	sub	sp, #28
 800bf40:	af00      	add	r7, sp, #0
 800bf42:	60b9      	str	r1, [r7, #8]
 800bf44:	607a      	str	r2, [r7, #4]
 800bf46:	230e      	movs	r3, #14
 800bf48:	18fb      	adds	r3, r7, r3
 800bf4a:	1c02      	adds	r2, r0, #0
 800bf4c:	801a      	strh	r2, [r3, #0]
  u16_t mss_s;
  u16_t mtu;

  LWIP_UNUSED_ARG(dest); /* in case IPv6 is disabled */

  LWIP_ASSERT("tcp_eff_send_mss_netif: invalid dst_ip", dest != NULL);
 800bf4e:	687b      	ldr	r3, [r7, #4]
 800bf50:	2b00      	cmp	r3, #0
 800bf52:	d105      	bne.n	800bf60 <tcp_eff_send_mss_netif+0x24>
 800bf54:	4b1e      	ldr	r3, [pc, #120]	; (800bfd0 <tcp_eff_send_mss_netif+0x94>)
 800bf56:	4a1f      	ldr	r2, [pc, #124]	; (800bfd4 <tcp_eff_send_mss_netif+0x98>)
 800bf58:	491f      	ldr	r1, [pc, #124]	; (800bfd8 <tcp_eff_send_mss_netif+0x9c>)
 800bf5a:	4820      	ldr	r0, [pc, #128]	; (800bfdc <tcp_eff_send_mss_netif+0xa0>)
 800bf5c:	f7f6 f936 	bl	80021cc <app_debug_rtt_raw>
  else
#endif /* LWIP_IPV4 */
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
  {
    if (outif == NULL) {
 800bf60:	68bb      	ldr	r3, [r7, #8]
 800bf62:	2b00      	cmp	r3, #0
 800bf64:	d103      	bne.n	800bf6e <tcp_eff_send_mss_netif+0x32>
      return sendmss;
 800bf66:	230e      	movs	r3, #14
 800bf68:	18fb      	adds	r3, r7, r3
 800bf6a:	881b      	ldrh	r3, [r3, #0]
 800bf6c:	e02c      	b.n	800bfc8 <tcp_eff_send_mss_netif+0x8c>
    }
    mtu = outif->mtu;
 800bf6e:	2116      	movs	r1, #22
 800bf70:	187b      	adds	r3, r7, r1
 800bf72:	68ba      	ldr	r2, [r7, #8]
 800bf74:	8d12      	ldrh	r2, [r2, #40]	; 0x28
 800bf76:	801a      	strh	r2, [r3, #0]
  }
#endif /* LWIP_IPV4 */

  if (mtu != 0) {
 800bf78:	187b      	adds	r3, r7, r1
 800bf7a:	881b      	ldrh	r3, [r3, #0]
 800bf7c:	2b00      	cmp	r3, #0
 800bf7e:	d020      	beq.n	800bfc2 <tcp_eff_send_mss_netif+0x86>
    else
#endif /* LWIP_IPV4 */
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
    {
      offset = IP_HLEN + TCP_HLEN;
 800bf80:	2014      	movs	r0, #20
 800bf82:	183b      	adds	r3, r7, r0
 800bf84:	2228      	movs	r2, #40	; 0x28
 800bf86:	801a      	strh	r2, [r3, #0]
    }
#endif /* LWIP_IPV4 */
    mss_s = (mtu > offset) ? (u16_t)(mtu - offset) : 0;
 800bf88:	187a      	adds	r2, r7, r1
 800bf8a:	183b      	adds	r3, r7, r0
 800bf8c:	8812      	ldrh	r2, [r2, #0]
 800bf8e:	881b      	ldrh	r3, [r3, #0]
 800bf90:	429a      	cmp	r2, r3
 800bf92:	d906      	bls.n	800bfa2 <tcp_eff_send_mss_netif+0x66>
 800bf94:	187a      	adds	r2, r7, r1
 800bf96:	183b      	adds	r3, r7, r0
 800bf98:	8812      	ldrh	r2, [r2, #0]
 800bf9a:	881b      	ldrh	r3, [r3, #0]
 800bf9c:	1ad3      	subs	r3, r2, r3
 800bf9e:	b29a      	uxth	r2, r3
 800bfa0:	e000      	b.n	800bfa4 <tcp_eff_send_mss_netif+0x68>
 800bfa2:	2200      	movs	r2, #0
 800bfa4:	2112      	movs	r1, #18
 800bfa6:	187b      	adds	r3, r7, r1
 800bfa8:	801a      	strh	r2, [r3, #0]
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
 800bfaa:	200e      	movs	r0, #14
 800bfac:	183a      	adds	r2, r7, r0
 800bfae:	187b      	adds	r3, r7, r1
 800bfb0:	1839      	adds	r1, r7, r0
 800bfb2:	880c      	ldrh	r4, [r1, #0]
 800bfb4:	881b      	ldrh	r3, [r3, #0]
 800bfb6:	b298      	uxth	r0, r3
 800bfb8:	b2a1      	uxth	r1, r4
 800bfba:	4288      	cmp	r0, r1
 800bfbc:	d900      	bls.n	800bfc0 <tcp_eff_send_mss_netif+0x84>
 800bfbe:	1c23      	adds	r3, r4, #0
 800bfc0:	8013      	strh	r3, [r2, #0]
  }
  return sendmss;
 800bfc2:	230e      	movs	r3, #14
 800bfc4:	18fb      	adds	r3, r7, r3
 800bfc6:	881b      	ldrh	r3, [r3, #0]
}
 800bfc8:	0018      	movs	r0, r3
 800bfca:	46bd      	mov	sp, r7
 800bfcc:	b007      	add	sp, #28
 800bfce:	bd90      	pop	{r4, r7, pc}
 800bfd0:	0801f238 	.word	0x0801f238
 800bfd4:	000008c9 	.word	0x000008c9
 800bfd8:	0801f940 	.word	0x0801f940
 800bfdc:	0801f274 	.word	0x0801f274

0800bfe0 <tcp_netif_ip_addr_changed_pcblist>:
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

/** Helper function for tcp_netif_ip_addr_changed() that iterates a pcb list */
static void
tcp_netif_ip_addr_changed_pcblist(const ip_addr_t *old_addr, struct tcp_pcb *pcb_list)
{
 800bfe0:	b580      	push	{r7, lr}
 800bfe2:	b084      	sub	sp, #16
 800bfe4:	af00      	add	r7, sp, #0
 800bfe6:	6078      	str	r0, [r7, #4]
 800bfe8:	6039      	str	r1, [r7, #0]
  struct tcp_pcb *pcb;
  pcb = pcb_list;
 800bfea:	683b      	ldr	r3, [r7, #0]
 800bfec:	60fb      	str	r3, [r7, #12]

  LWIP_ASSERT("tcp_netif_ip_addr_changed_pcblist: invalid old_addr", old_addr != NULL);
 800bfee:	687b      	ldr	r3, [r7, #4]
 800bff0:	2b00      	cmp	r3, #0
 800bff2:	d119      	bne.n	800c028 <tcp_netif_ip_addr_changed_pcblist+0x48>
 800bff4:	4b10      	ldr	r3, [pc, #64]	; (800c038 <tcp_netif_ip_addr_changed_pcblist+0x58>)
 800bff6:	4a11      	ldr	r2, [pc, #68]	; (800c03c <tcp_netif_ip_addr_changed_pcblist+0x5c>)
 800bff8:	4911      	ldr	r1, [pc, #68]	; (800c040 <tcp_netif_ip_addr_changed_pcblist+0x60>)
 800bffa:	4812      	ldr	r0, [pc, #72]	; (800c044 <tcp_netif_ip_addr_changed_pcblist+0x64>)
 800bffc:	f7f6 f8e6 	bl	80021cc <app_debug_rtt_raw>

  while (pcb != NULL) {
 800c000:	e012      	b.n	800c028 <tcp_netif_ip_addr_changed_pcblist+0x48>
    /* PCB bound to current local interface address? */
    if (ip_addr_cmp(&pcb->local_ip, old_addr)
 800c002:	68fb      	ldr	r3, [r7, #12]
 800c004:	681a      	ldr	r2, [r3, #0]
 800c006:	687b      	ldr	r3, [r7, #4]
 800c008:	681b      	ldr	r3, [r3, #0]
 800c00a:	429a      	cmp	r2, r3
 800c00c:	d109      	bne.n	800c022 <tcp_netif_ip_addr_changed_pcblist+0x42>
        /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
        && (!IP_IS_V4_VAL(pcb->local_ip) || !ip4_addr_islinklocal(ip_2_ip4(&pcb->local_ip)))
#endif /* LWIP_AUTOIP */
       ) {
      /* this connection must be aborted */
      struct tcp_pcb *next = pcb->next;
 800c00e:	68fb      	ldr	r3, [r7, #12]
 800c010:	691b      	ldr	r3, [r3, #16]
 800c012:	60bb      	str	r3, [r7, #8]
      LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
      tcp_abort(pcb);
 800c014:	68fb      	ldr	r3, [r7, #12]
 800c016:	0018      	movs	r0, r3
 800c018:	f7fe fcbe 	bl	800a998 <tcp_abort>
      pcb = next;
 800c01c:	68bb      	ldr	r3, [r7, #8]
 800c01e:	60fb      	str	r3, [r7, #12]
 800c020:	e002      	b.n	800c028 <tcp_netif_ip_addr_changed_pcblist+0x48>
    } else {
      pcb = pcb->next;
 800c022:	68fb      	ldr	r3, [r7, #12]
 800c024:	691b      	ldr	r3, [r3, #16]
 800c026:	60fb      	str	r3, [r7, #12]
  while (pcb != NULL) {
 800c028:	68fb      	ldr	r3, [r7, #12]
 800c02a:	2b00      	cmp	r3, #0
 800c02c:	d1e9      	bne.n	800c002 <tcp_netif_ip_addr_changed_pcblist+0x22>
    }
  }
}
 800c02e:	46c0      	nop			; (mov r8, r8)
 800c030:	46c0      	nop			; (mov r8, r8)
 800c032:	46bd      	mov	sp, r7
 800c034:	b004      	add	sp, #16
 800c036:	bd80      	pop	{r7, pc}
 800c038:	0801f238 	.word	0x0801f238
 800c03c:	00000904 	.word	0x00000904
 800c040:	0801f968 	.word	0x0801f968
 800c044:	0801f274 	.word	0x0801f274

0800c048 <tcp_netif_ip_addr_changed>:
 * @param old_addr IP address of the netif before change
 * @param new_addr IP address of the netif after change or NULL if netif has been removed
 */
void
tcp_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
 800c048:	b580      	push	{r7, lr}
 800c04a:	b084      	sub	sp, #16
 800c04c:	af00      	add	r7, sp, #0
 800c04e:	6078      	str	r0, [r7, #4]
 800c050:	6039      	str	r1, [r7, #0]
  struct tcp_pcb_listen *lpcb;

  if (!ip_addr_isany(old_addr)) {
 800c052:	687b      	ldr	r3, [r7, #4]
 800c054:	2b00      	cmp	r3, #0
 800c056:	d02c      	beq.n	800c0b2 <tcp_netif_ip_addr_changed+0x6a>
 800c058:	687b      	ldr	r3, [r7, #4]
 800c05a:	681b      	ldr	r3, [r3, #0]
 800c05c:	2b00      	cmp	r3, #0
 800c05e:	d028      	beq.n	800c0b2 <tcp_netif_ip_addr_changed+0x6a>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_active_pcbs);
 800c060:	4b16      	ldr	r3, [pc, #88]	; (800c0bc <tcp_netif_ip_addr_changed+0x74>)
 800c062:	681a      	ldr	r2, [r3, #0]
 800c064:	687b      	ldr	r3, [r7, #4]
 800c066:	0011      	movs	r1, r2
 800c068:	0018      	movs	r0, r3
 800c06a:	f7ff ffb9 	bl	800bfe0 <tcp_netif_ip_addr_changed_pcblist>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_bound_pcbs);
 800c06e:	4b14      	ldr	r3, [pc, #80]	; (800c0c0 <tcp_netif_ip_addr_changed+0x78>)
 800c070:	681a      	ldr	r2, [r3, #0]
 800c072:	687b      	ldr	r3, [r7, #4]
 800c074:	0011      	movs	r1, r2
 800c076:	0018      	movs	r0, r3
 800c078:	f7ff ffb2 	bl	800bfe0 <tcp_netif_ip_addr_changed_pcblist>

    if (!ip_addr_isany(new_addr)) {
 800c07c:	683b      	ldr	r3, [r7, #0]
 800c07e:	2b00      	cmp	r3, #0
 800c080:	d017      	beq.n	800c0b2 <tcp_netif_ip_addr_changed+0x6a>
 800c082:	683b      	ldr	r3, [r7, #0]
 800c084:	681b      	ldr	r3, [r3, #0]
 800c086:	2b00      	cmp	r3, #0
 800c088:	d013      	beq.n	800c0b2 <tcp_netif_ip_addr_changed+0x6a>
      /* PCB bound to current local interface address? */
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800c08a:	4b0e      	ldr	r3, [pc, #56]	; (800c0c4 <tcp_netif_ip_addr_changed+0x7c>)
 800c08c:	681b      	ldr	r3, [r3, #0]
 800c08e:	60fb      	str	r3, [r7, #12]
 800c090:	e00c      	b.n	800c0ac <tcp_netif_ip_addr_changed+0x64>
        /* PCB bound to current local interface address? */
        if (ip_addr_cmp(&lpcb->local_ip, old_addr)) {
 800c092:	68fb      	ldr	r3, [r7, #12]
 800c094:	681a      	ldr	r2, [r3, #0]
 800c096:	687b      	ldr	r3, [r7, #4]
 800c098:	681b      	ldr	r3, [r3, #0]
 800c09a:	429a      	cmp	r2, r3
 800c09c:	d103      	bne.n	800c0a6 <tcp_netif_ip_addr_changed+0x5e>
          /* The PCB is listening to the old ipaddr and
            * is set to listen to the new one instead */
          ip_addr_copy(lpcb->local_ip, *new_addr);
 800c09e:	683b      	ldr	r3, [r7, #0]
 800c0a0:	681a      	ldr	r2, [r3, #0]
 800c0a2:	68fb      	ldr	r3, [r7, #12]
 800c0a4:	601a      	str	r2, [r3, #0]
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800c0a6:	68fb      	ldr	r3, [r7, #12]
 800c0a8:	691b      	ldr	r3, [r3, #16]
 800c0aa:	60fb      	str	r3, [r7, #12]
 800c0ac:	68fb      	ldr	r3, [r7, #12]
 800c0ae:	2b00      	cmp	r3, #0
 800c0b0:	d1ef      	bne.n	800c092 <tcp_netif_ip_addr_changed+0x4a>
        }
      }
    }
  }
}
 800c0b2:	46c0      	nop			; (mov r8, r8)
 800c0b4:	46bd      	mov	sp, r7
 800c0b6:	b004      	add	sp, #16
 800c0b8:	bd80      	pop	{r7, pc}
 800c0ba:	46c0      	nop			; (mov r8, r8)
 800c0bc:	20002b18 	.word	0x20002b18
 800c0c0:	20002b24 	.word	0x20002b24
 800c0c4:	20002b20 	.word	0x20002b20

0800c0c8 <tcp_free_ooseq>:

#if TCP_QUEUE_OOSEQ
/* Free all ooseq pbufs (and possibly reset SACK state) */
void
tcp_free_ooseq(struct tcp_pcb *pcb)
{
 800c0c8:	b580      	push	{r7, lr}
 800c0ca:	b082      	sub	sp, #8
 800c0cc:	af00      	add	r7, sp, #0
 800c0ce:	6078      	str	r0, [r7, #4]
  if (pcb->ooseq) {
 800c0d0:	687b      	ldr	r3, [r7, #4]
 800c0d2:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800c0d4:	2b00      	cmp	r3, #0
 800c0d6:	d007      	beq.n	800c0e8 <tcp_free_ooseq+0x20>
    tcp_segs_free(pcb->ooseq);
 800c0d8:	687b      	ldr	r3, [r7, #4]
 800c0da:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800c0dc:	0018      	movs	r0, r3
 800c0de:	f7ff fb45 	bl	800b76c <tcp_segs_free>
    pcb->ooseq = NULL;
 800c0e2:	687b      	ldr	r3, [r7, #4]
 800c0e4:	2200      	movs	r2, #0
 800c0e6:	679a      	str	r2, [r3, #120]	; 0x78
#if LWIP_TCP_SACK_OUT
    memset(pcb->rcv_sacks, 0, sizeof(pcb->rcv_sacks));
#endif /* LWIP_TCP_SACK_OUT */
  }
}
 800c0e8:	46c0      	nop			; (mov r8, r8)
 800c0ea:	46bd      	mov	sp, r7
 800c0ec:	b002      	add	sp, #8
 800c0ee:	bd80      	pop	{r7, pc}

0800c0f0 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the TCP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
 800c0f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c0f2:	b08f      	sub	sp, #60	; 0x3c
 800c0f4:	af04      	add	r7, sp, #16
 800c0f6:	6078      	str	r0, [r7, #4]
 800c0f8:	6039      	str	r1, [r7, #0]
  struct tcp_pcb *pcb, *prev;
  struct tcp_pcb_listen *lpcb;
#if SO_REUSE
  struct tcp_pcb *lpcb_prev = NULL;
 800c0fa:	2300      	movs	r3, #0
 800c0fc:	61bb      	str	r3, [r7, #24]
  struct tcp_pcb_listen *lpcb_any = NULL;
 800c0fe:	2300      	movs	r3, #0
 800c100:	617b      	str	r3, [r7, #20]
  u8_t hdrlen_bytes;
  err_t err;

  LWIP_UNUSED_ARG(inp);
  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("tcp_input: invalid pbuf", p != NULL);
 800c102:	687b      	ldr	r3, [r7, #4]
 800c104:	2b00      	cmp	r3, #0
 800c106:	d105      	bne.n	800c114 <tcp_input+0x24>
 800c108:	4b3a      	ldr	r3, [pc, #232]	; (800c1f4 <tcp_input+0x104>)
 800c10a:	493b      	ldr	r1, [pc, #236]	; (800c1f8 <tcp_input+0x108>)
 800c10c:	483b      	ldr	r0, [pc, #236]	; (800c1fc <tcp_input+0x10c>)
 800c10e:	2283      	movs	r2, #131	; 0x83
 800c110:	f7f6 f85c 	bl	80021cc <app_debug_rtt_raw>
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  MIB2_STATS_INC(mib2.tcpinsegs);

  tcphdr = (struct tcp_hdr *)p->payload;
 800c114:	687b      	ldr	r3, [r7, #4]
 800c116:	685a      	ldr	r2, [r3, #4]
 800c118:	4b39      	ldr	r3, [pc, #228]	; (800c200 <tcp_input+0x110>)
 800c11a:	601a      	str	r2, [r3, #0]
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* Check that TCP header fits in payload */
  if (p->len < TCP_HLEN) {
 800c11c:	687b      	ldr	r3, [r7, #4]
 800c11e:	895b      	ldrh	r3, [r3, #10]
 800c120:	2b13      	cmp	r3, #19
 800c122:	d801      	bhi.n	800c128 <tcp_input+0x38>
 800c124:	f000 fd03 	bl	800cb2e <tcp_input+0xa3e>
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
 800c128:	4b36      	ldr	r3, [pc, #216]	; (800c204 <tcp_input+0x114>)
 800c12a:	695a      	ldr	r2, [r3, #20]
 800c12c:	4b35      	ldr	r3, [pc, #212]	; (800c204 <tcp_input+0x114>)
 800c12e:	681b      	ldr	r3, [r3, #0]
 800c130:	0019      	movs	r1, r3
 800c132:	0010      	movs	r0, r2
 800c134:	f007 fae2 	bl	80136fc <ip4_addr_isbroadcast_u32>
 800c138:	1e03      	subs	r3, r0, #0
 800c13a:	d001      	beq.n	800c140 <tcp_input+0x50>
 800c13c:	f000 fcf9 	bl	800cb32 <tcp_input+0xa42>
      ip_addr_ismulticast(ip_current_dest_addr())) {
 800c140:	4b30      	ldr	r3, [pc, #192]	; (800c204 <tcp_input+0x114>)
 800c142:	695b      	ldr	r3, [r3, #20]
 800c144:	22f0      	movs	r2, #240	; 0xf0
 800c146:	4013      	ands	r3, r2
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
 800c148:	2be0      	cmp	r3, #224	; 0xe0
 800c14a:	d101      	bne.n	800c150 <tcp_input+0x60>
 800c14c:	f000 fcf1 	bl	800cb32 <tcp_input+0xa42>
  }

#if CHECKSUM_CHECK_TCP
  IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_TCP) {
    /* Verify TCP checksum. */
    u16_t chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
 800c150:	687b      	ldr	r3, [r7, #4]
 800c152:	891a      	ldrh	r2, [r3, #8]
 800c154:	2510      	movs	r5, #16
 800c156:	197c      	adds	r4, r7, r5
 800c158:	492b      	ldr	r1, [pc, #172]	; (800c208 <tcp_input+0x118>)
 800c15a:	6878      	ldr	r0, [r7, #4]
 800c15c:	4b2b      	ldr	r3, [pc, #172]	; (800c20c <tcp_input+0x11c>)
 800c15e:	9300      	str	r3, [sp, #0]
 800c160:	000b      	movs	r3, r1
 800c162:	2106      	movs	r1, #6
 800c164:	f7fb fc8f 	bl	8007a86 <ip_chksum_pseudo>
 800c168:	0003      	movs	r3, r0
 800c16a:	8023      	strh	r3, [r4, #0]
                                    ip_current_src_addr(), ip_current_dest_addr());
    if (chksum != 0) {
 800c16c:	197b      	adds	r3, r7, r5
 800c16e:	881b      	ldrh	r3, [r3, #0]
 800c170:	2b00      	cmp	r3, #0
 800c172:	d001      	beq.n	800c178 <tcp_input+0x88>
 800c174:	f000 fcdf 	bl	800cb36 <tcp_input+0xa46>
    }
  }
#endif /* CHECKSUM_CHECK_TCP */

  /* sanity-check header length */
  hdrlen_bytes = TCPH_HDRLEN_BYTES(tcphdr);
 800c178:	4b21      	ldr	r3, [pc, #132]	; (800c200 <tcp_input+0x110>)
 800c17a:	681b      	ldr	r3, [r3, #0]
 800c17c:	7b1a      	ldrb	r2, [r3, #12]
 800c17e:	7b5b      	ldrb	r3, [r3, #13]
 800c180:	021b      	lsls	r3, r3, #8
 800c182:	4313      	orrs	r3, r2
 800c184:	b29b      	uxth	r3, r3
 800c186:	0018      	movs	r0, r3
 800c188:	f7fa f9d4 	bl	8006534 <lwip_htons>
 800c18c:	0003      	movs	r3, r0
 800c18e:	0b1b      	lsrs	r3, r3, #12
 800c190:	b29b      	uxth	r3, r3
 800c192:	b2da      	uxtb	r2, r3
 800c194:	210f      	movs	r1, #15
 800c196:	187b      	adds	r3, r7, r1
 800c198:	0092      	lsls	r2, r2, #2
 800c19a:	701a      	strb	r2, [r3, #0]
  if ((hdrlen_bytes < TCP_HLEN) || (hdrlen_bytes > p->tot_len)) {
 800c19c:	187b      	adds	r3, r7, r1
 800c19e:	781b      	ldrb	r3, [r3, #0]
 800c1a0:	2b13      	cmp	r3, #19
 800c1a2:	d801      	bhi.n	800c1a8 <tcp_input+0xb8>
 800c1a4:	f000 fcc9 	bl	800cb3a <tcp_input+0xa4a>
 800c1a8:	187b      	adds	r3, r7, r1
 800c1aa:	781b      	ldrb	r3, [r3, #0]
 800c1ac:	b29a      	uxth	r2, r3
 800c1ae:	687b      	ldr	r3, [r7, #4]
 800c1b0:	891b      	ldrh	r3, [r3, #8]
 800c1b2:	429a      	cmp	r2, r3
 800c1b4:	d901      	bls.n	800c1ba <tcp_input+0xca>
 800c1b6:	f000 fcc0 	bl	800cb3a <tcp_input+0xa4a>
    goto dropped;
  }

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  tcphdr_optlen = (u16_t)(hdrlen_bytes - TCP_HLEN);
 800c1ba:	187b      	adds	r3, r7, r1
 800c1bc:	781b      	ldrb	r3, [r3, #0]
 800c1be:	b29b      	uxth	r3, r3
 800c1c0:	3b14      	subs	r3, #20
 800c1c2:	b29a      	uxth	r2, r3
 800c1c4:	4b12      	ldr	r3, [pc, #72]	; (800c210 <tcp_input+0x120>)
 800c1c6:	801a      	strh	r2, [r3, #0]
  tcphdr_opt2 = NULL;
 800c1c8:	4b12      	ldr	r3, [pc, #72]	; (800c214 <tcp_input+0x124>)
 800c1ca:	2200      	movs	r2, #0
 800c1cc:	601a      	str	r2, [r3, #0]
  if (p->len >= hdrlen_bytes) {
 800c1ce:	687b      	ldr	r3, [r7, #4]
 800c1d0:	895a      	ldrh	r2, [r3, #10]
 800c1d2:	187b      	adds	r3, r7, r1
 800c1d4:	781b      	ldrb	r3, [r3, #0]
 800c1d6:	b29b      	uxth	r3, r3
 800c1d8:	429a      	cmp	r2, r3
 800c1da:	d31f      	bcc.n	800c21c <tcp_input+0x12c>
    /* all options are in the first pbuf */
    tcphdr_opt1len = tcphdr_optlen;
 800c1dc:	4b0c      	ldr	r3, [pc, #48]	; (800c210 <tcp_input+0x120>)
 800c1de:	881a      	ldrh	r2, [r3, #0]
 800c1e0:	4b0d      	ldr	r3, [pc, #52]	; (800c218 <tcp_input+0x128>)
 800c1e2:	801a      	strh	r2, [r3, #0]
    pbuf_remove_header(p, hdrlen_bytes); /* cannot fail */
 800c1e4:	187b      	adds	r3, r7, r1
 800c1e6:	781a      	ldrb	r2, [r3, #0]
 800c1e8:	687b      	ldr	r3, [r7, #4]
 800c1ea:	0011      	movs	r1, r2
 800c1ec:	0018      	movs	r0, r3
 800c1ee:	f7fd f979 	bl	80094e4 <pbuf_remove_header>
 800c1f2:	e06b      	b.n	800c2cc <tcp_input+0x1dc>
 800c1f4:	0801f99c 	.word	0x0801f99c
 800c1f8:	0801f9c4 	.word	0x0801f9c4
 800c1fc:	0801f9dc 	.word	0x0801f9dc
 800c200:	20001370 	.word	0x20001370
 800c204:	200014c4 	.word	0x200014c4
 800c208:	200014d4 	.word	0x200014d4
 800c20c:	200014d8 	.word	0x200014d8
 800c210:	20001374 	.word	0x20001374
 800c214:	20001378 	.word	0x20001378
 800c218:	20001376 	.word	0x20001376
  } else {
    u16_t opt2len;
    /* TCP header fits into first pbuf, options don't - data is in the next pbuf */
    /* there must be a next pbuf, due to hdrlen_bytes sanity check above */
    LWIP_ASSERT("p->next != NULL", p->next != NULL);
 800c21c:	687b      	ldr	r3, [r7, #4]
 800c21e:	681b      	ldr	r3, [r3, #0]
 800c220:	2b00      	cmp	r3, #0
 800c222:	d105      	bne.n	800c230 <tcp_input+0x140>
 800c224:	4bd0      	ldr	r3, [pc, #832]	; (800c568 <tcp_input+0x478>)
 800c226:	49d1      	ldr	r1, [pc, #836]	; (800c56c <tcp_input+0x47c>)
 800c228:	48d1      	ldr	r0, [pc, #836]	; (800c570 <tcp_input+0x480>)
 800c22a:	22c2      	movs	r2, #194	; 0xc2
 800c22c:	f7f5 ffce 	bl	80021cc <app_debug_rtt_raw>

    /* advance over the TCP header (cannot fail) */
    pbuf_remove_header(p, TCP_HLEN);
 800c230:	687b      	ldr	r3, [r7, #4]
 800c232:	2114      	movs	r1, #20
 800c234:	0018      	movs	r0, r3
 800c236:	f7fd f955 	bl	80094e4 <pbuf_remove_header>

    /* determine how long the first and second parts of the options are */
    tcphdr_opt1len = p->len;
 800c23a:	687b      	ldr	r3, [r7, #4]
 800c23c:	895a      	ldrh	r2, [r3, #10]
 800c23e:	4bcd      	ldr	r3, [pc, #820]	; (800c574 <tcp_input+0x484>)
 800c240:	801a      	strh	r2, [r3, #0]
    opt2len = (u16_t)(tcphdr_optlen - tcphdr_opt1len);
 800c242:	4bcd      	ldr	r3, [pc, #820]	; (800c578 <tcp_input+0x488>)
 800c244:	8819      	ldrh	r1, [r3, #0]
 800c246:	4bcb      	ldr	r3, [pc, #812]	; (800c574 <tcp_input+0x484>)
 800c248:	881a      	ldrh	r2, [r3, #0]
 800c24a:	240c      	movs	r4, #12
 800c24c:	193b      	adds	r3, r7, r4
 800c24e:	1a8a      	subs	r2, r1, r2
 800c250:	801a      	strh	r2, [r3, #0]

    /* options continue in the next pbuf: set p to zero length and hide the
        options in the next pbuf (adjusting p->tot_len) */
    pbuf_remove_header(p, tcphdr_opt1len);
 800c252:	4bc8      	ldr	r3, [pc, #800]	; (800c574 <tcp_input+0x484>)
 800c254:	881b      	ldrh	r3, [r3, #0]
 800c256:	001a      	movs	r2, r3
 800c258:	687b      	ldr	r3, [r7, #4]
 800c25a:	0011      	movs	r1, r2
 800c25c:	0018      	movs	r0, r3
 800c25e:	f7fd f941 	bl	80094e4 <pbuf_remove_header>

    /* check that the options fit in the second pbuf */
    if (opt2len > p->next->len) {
 800c262:	687b      	ldr	r3, [r7, #4]
 800c264:	681b      	ldr	r3, [r3, #0]
 800c266:	895b      	ldrh	r3, [r3, #10]
 800c268:	193a      	adds	r2, r7, r4
 800c26a:	8812      	ldrh	r2, [r2, #0]
 800c26c:	429a      	cmp	r2, r3
 800c26e:	d901      	bls.n	800c274 <tcp_input+0x184>
 800c270:	f000 fc65 	bl	800cb3e <tcp_input+0xa4e>
      TCP_STATS_INC(tcp.lenerr);
      goto dropped;
    }

    /* remember the pointer to the second part of the options */
    tcphdr_opt2 = (u8_t *)p->next->payload;
 800c274:	687b      	ldr	r3, [r7, #4]
 800c276:	681b      	ldr	r3, [r3, #0]
 800c278:	685a      	ldr	r2, [r3, #4]
 800c27a:	4bc0      	ldr	r3, [pc, #768]	; (800c57c <tcp_input+0x48c>)
 800c27c:	601a      	str	r2, [r3, #0]

    /* advance p->next to point after the options, and manually
        adjust p->tot_len to keep it consistent with the changed p->next */
    pbuf_remove_header(p->next, opt2len);
 800c27e:	687b      	ldr	r3, [r7, #4]
 800c280:	681a      	ldr	r2, [r3, #0]
 800c282:	193b      	adds	r3, r7, r4
 800c284:	881b      	ldrh	r3, [r3, #0]
 800c286:	0019      	movs	r1, r3
 800c288:	0010      	movs	r0, r2
 800c28a:	f7fd f92b 	bl	80094e4 <pbuf_remove_header>
    p->tot_len = (u16_t)(p->tot_len - opt2len);
 800c28e:	687b      	ldr	r3, [r7, #4]
 800c290:	891a      	ldrh	r2, [r3, #8]
 800c292:	193b      	adds	r3, r7, r4
 800c294:	881b      	ldrh	r3, [r3, #0]
 800c296:	1ad3      	subs	r3, r2, r3
 800c298:	b29a      	uxth	r2, r3
 800c29a:	687b      	ldr	r3, [r7, #4]
 800c29c:	811a      	strh	r2, [r3, #8]

    LWIP_ASSERT("p->len == 0", p->len == 0);
 800c29e:	687b      	ldr	r3, [r7, #4]
 800c2a0:	895b      	ldrh	r3, [r3, #10]
 800c2a2:	2b00      	cmp	r3, #0
 800c2a4:	d005      	beq.n	800c2b2 <tcp_input+0x1c2>
 800c2a6:	4bb0      	ldr	r3, [pc, #704]	; (800c568 <tcp_input+0x478>)
 800c2a8:	49b5      	ldr	r1, [pc, #724]	; (800c580 <tcp_input+0x490>)
 800c2aa:	48b1      	ldr	r0, [pc, #708]	; (800c570 <tcp_input+0x480>)
 800c2ac:	22df      	movs	r2, #223	; 0xdf
 800c2ae:	f7f5 ff8d 	bl	80021cc <app_debug_rtt_raw>
    LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
 800c2b2:	687b      	ldr	r3, [r7, #4]
 800c2b4:	891a      	ldrh	r2, [r3, #8]
 800c2b6:	687b      	ldr	r3, [r7, #4]
 800c2b8:	681b      	ldr	r3, [r3, #0]
 800c2ba:	891b      	ldrh	r3, [r3, #8]
 800c2bc:	429a      	cmp	r2, r3
 800c2be:	d005      	beq.n	800c2cc <tcp_input+0x1dc>
 800c2c0:	4ba9      	ldr	r3, [pc, #676]	; (800c568 <tcp_input+0x478>)
 800c2c2:	49b0      	ldr	r1, [pc, #704]	; (800c584 <tcp_input+0x494>)
 800c2c4:	48aa      	ldr	r0, [pc, #680]	; (800c570 <tcp_input+0x480>)
 800c2c6:	22e0      	movs	r2, #224	; 0xe0
 800c2c8:	f7f5 ff80 	bl	80021cc <app_debug_rtt_raw>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = lwip_ntohs(tcphdr->src);
 800c2cc:	4bae      	ldr	r3, [pc, #696]	; (800c588 <tcp_input+0x498>)
 800c2ce:	681b      	ldr	r3, [r3, #0]
 800c2d0:	781a      	ldrb	r2, [r3, #0]
 800c2d2:	785b      	ldrb	r3, [r3, #1]
 800c2d4:	021b      	lsls	r3, r3, #8
 800c2d6:	4313      	orrs	r3, r2
 800c2d8:	b29a      	uxth	r2, r3
 800c2da:	4bab      	ldr	r3, [pc, #684]	; (800c588 <tcp_input+0x498>)
 800c2dc:	681c      	ldr	r4, [r3, #0]
 800c2de:	0010      	movs	r0, r2
 800c2e0:	f7fa f928 	bl	8006534 <lwip_htons>
 800c2e4:	0003      	movs	r3, r0
 800c2e6:	22ff      	movs	r2, #255	; 0xff
 800c2e8:	401a      	ands	r2, r3
 800c2ea:	0010      	movs	r0, r2
 800c2ec:	7822      	ldrb	r2, [r4, #0]
 800c2ee:	2100      	movs	r1, #0
 800c2f0:	400a      	ands	r2, r1
 800c2f2:	1c11      	adds	r1, r2, #0
 800c2f4:	1c02      	adds	r2, r0, #0
 800c2f6:	430a      	orrs	r2, r1
 800c2f8:	7022      	strb	r2, [r4, #0]
 800c2fa:	0a1b      	lsrs	r3, r3, #8
 800c2fc:	b299      	uxth	r1, r3
 800c2fe:	7863      	ldrb	r3, [r4, #1]
 800c300:	2200      	movs	r2, #0
 800c302:	4013      	ands	r3, r2
 800c304:	1c1a      	adds	r2, r3, #0
 800c306:	1c0b      	adds	r3, r1, #0
 800c308:	4313      	orrs	r3, r2
 800c30a:	7063      	strb	r3, [r4, #1]
  tcphdr->dest = lwip_ntohs(tcphdr->dest);
 800c30c:	4b9e      	ldr	r3, [pc, #632]	; (800c588 <tcp_input+0x498>)
 800c30e:	681b      	ldr	r3, [r3, #0]
 800c310:	789a      	ldrb	r2, [r3, #2]
 800c312:	78db      	ldrb	r3, [r3, #3]
 800c314:	021b      	lsls	r3, r3, #8
 800c316:	4313      	orrs	r3, r2
 800c318:	b29a      	uxth	r2, r3
 800c31a:	4b9b      	ldr	r3, [pc, #620]	; (800c588 <tcp_input+0x498>)
 800c31c:	681c      	ldr	r4, [r3, #0]
 800c31e:	0010      	movs	r0, r2
 800c320:	f7fa f908 	bl	8006534 <lwip_htons>
 800c324:	0003      	movs	r3, r0
 800c326:	22ff      	movs	r2, #255	; 0xff
 800c328:	401a      	ands	r2, r3
 800c32a:	0010      	movs	r0, r2
 800c32c:	78a2      	ldrb	r2, [r4, #2]
 800c32e:	2100      	movs	r1, #0
 800c330:	400a      	ands	r2, r1
 800c332:	1c11      	adds	r1, r2, #0
 800c334:	1c02      	adds	r2, r0, #0
 800c336:	430a      	orrs	r2, r1
 800c338:	70a2      	strb	r2, [r4, #2]
 800c33a:	0a1b      	lsrs	r3, r3, #8
 800c33c:	b299      	uxth	r1, r3
 800c33e:	78e3      	ldrb	r3, [r4, #3]
 800c340:	2200      	movs	r2, #0
 800c342:	4013      	ands	r3, r2
 800c344:	1c1a      	adds	r2, r3, #0
 800c346:	1c0b      	adds	r3, r1, #0
 800c348:	4313      	orrs	r3, r2
 800c34a:	70e3      	strb	r3, [r4, #3]
  seqno = tcphdr->seqno = lwip_ntohl(tcphdr->seqno);
 800c34c:	4b8e      	ldr	r3, [pc, #568]	; (800c588 <tcp_input+0x498>)
 800c34e:	681b      	ldr	r3, [r3, #0]
 800c350:	791a      	ldrb	r2, [r3, #4]
 800c352:	7959      	ldrb	r1, [r3, #5]
 800c354:	0209      	lsls	r1, r1, #8
 800c356:	430a      	orrs	r2, r1
 800c358:	7999      	ldrb	r1, [r3, #6]
 800c35a:	0409      	lsls	r1, r1, #16
 800c35c:	430a      	orrs	r2, r1
 800c35e:	79db      	ldrb	r3, [r3, #7]
 800c360:	061b      	lsls	r3, r3, #24
 800c362:	4313      	orrs	r3, r2
 800c364:	001a      	movs	r2, r3
 800c366:	4b88      	ldr	r3, [pc, #544]	; (800c588 <tcp_input+0x498>)
 800c368:	681c      	ldr	r4, [r3, #0]
 800c36a:	0010      	movs	r0, r2
 800c36c:	f7fa f8f8 	bl	8006560 <lwip_htonl>
 800c370:	0003      	movs	r3, r0
 800c372:	22ff      	movs	r2, #255	; 0xff
 800c374:	401a      	ands	r2, r3
 800c376:	0010      	movs	r0, r2
 800c378:	7922      	ldrb	r2, [r4, #4]
 800c37a:	2100      	movs	r1, #0
 800c37c:	400a      	ands	r2, r1
 800c37e:	1c11      	adds	r1, r2, #0
 800c380:	1c02      	adds	r2, r0, #0
 800c382:	430a      	orrs	r2, r1
 800c384:	7122      	strb	r2, [r4, #4]
 800c386:	0a1a      	lsrs	r2, r3, #8
 800c388:	21ff      	movs	r1, #255	; 0xff
 800c38a:	400a      	ands	r2, r1
 800c38c:	0010      	movs	r0, r2
 800c38e:	7962      	ldrb	r2, [r4, #5]
 800c390:	2100      	movs	r1, #0
 800c392:	400a      	ands	r2, r1
 800c394:	1c11      	adds	r1, r2, #0
 800c396:	1c02      	adds	r2, r0, #0
 800c398:	430a      	orrs	r2, r1
 800c39a:	7162      	strb	r2, [r4, #5]
 800c39c:	0c1a      	lsrs	r2, r3, #16
 800c39e:	21ff      	movs	r1, #255	; 0xff
 800c3a0:	400a      	ands	r2, r1
 800c3a2:	0010      	movs	r0, r2
 800c3a4:	79a2      	ldrb	r2, [r4, #6]
 800c3a6:	2100      	movs	r1, #0
 800c3a8:	400a      	ands	r2, r1
 800c3aa:	1c11      	adds	r1, r2, #0
 800c3ac:	1c02      	adds	r2, r0, #0
 800c3ae:	430a      	orrs	r2, r1
 800c3b0:	71a2      	strb	r2, [r4, #6]
 800c3b2:	0e19      	lsrs	r1, r3, #24
 800c3b4:	79e3      	ldrb	r3, [r4, #7]
 800c3b6:	2200      	movs	r2, #0
 800c3b8:	4013      	ands	r3, r2
 800c3ba:	1c1a      	adds	r2, r3, #0
 800c3bc:	1c0b      	adds	r3, r1, #0
 800c3be:	4313      	orrs	r3, r2
 800c3c0:	71e3      	strb	r3, [r4, #7]
 800c3c2:	7923      	ldrb	r3, [r4, #4]
 800c3c4:	7962      	ldrb	r2, [r4, #5]
 800c3c6:	0212      	lsls	r2, r2, #8
 800c3c8:	4313      	orrs	r3, r2
 800c3ca:	79a2      	ldrb	r2, [r4, #6]
 800c3cc:	0412      	lsls	r2, r2, #16
 800c3ce:	4313      	orrs	r3, r2
 800c3d0:	79e2      	ldrb	r2, [r4, #7]
 800c3d2:	0612      	lsls	r2, r2, #24
 800c3d4:	4313      	orrs	r3, r2
 800c3d6:	001a      	movs	r2, r3
 800c3d8:	4b6c      	ldr	r3, [pc, #432]	; (800c58c <tcp_input+0x49c>)
 800c3da:	601a      	str	r2, [r3, #0]
  ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
 800c3dc:	4b6a      	ldr	r3, [pc, #424]	; (800c588 <tcp_input+0x498>)
 800c3de:	681b      	ldr	r3, [r3, #0]
 800c3e0:	7a1a      	ldrb	r2, [r3, #8]
 800c3e2:	7a59      	ldrb	r1, [r3, #9]
 800c3e4:	0209      	lsls	r1, r1, #8
 800c3e6:	430a      	orrs	r2, r1
 800c3e8:	7a99      	ldrb	r1, [r3, #10]
 800c3ea:	0409      	lsls	r1, r1, #16
 800c3ec:	430a      	orrs	r2, r1
 800c3ee:	7adb      	ldrb	r3, [r3, #11]
 800c3f0:	061b      	lsls	r3, r3, #24
 800c3f2:	4313      	orrs	r3, r2
 800c3f4:	001a      	movs	r2, r3
 800c3f6:	4b64      	ldr	r3, [pc, #400]	; (800c588 <tcp_input+0x498>)
 800c3f8:	681c      	ldr	r4, [r3, #0]
 800c3fa:	0010      	movs	r0, r2
 800c3fc:	f7fa f8b0 	bl	8006560 <lwip_htonl>
 800c400:	0003      	movs	r3, r0
 800c402:	22ff      	movs	r2, #255	; 0xff
 800c404:	401a      	ands	r2, r3
 800c406:	0010      	movs	r0, r2
 800c408:	7a22      	ldrb	r2, [r4, #8]
 800c40a:	2100      	movs	r1, #0
 800c40c:	400a      	ands	r2, r1
 800c40e:	1c11      	adds	r1, r2, #0
 800c410:	1c02      	adds	r2, r0, #0
 800c412:	430a      	orrs	r2, r1
 800c414:	7222      	strb	r2, [r4, #8]
 800c416:	0a1a      	lsrs	r2, r3, #8
 800c418:	21ff      	movs	r1, #255	; 0xff
 800c41a:	400a      	ands	r2, r1
 800c41c:	0010      	movs	r0, r2
 800c41e:	7a62      	ldrb	r2, [r4, #9]
 800c420:	2100      	movs	r1, #0
 800c422:	400a      	ands	r2, r1
 800c424:	1c11      	adds	r1, r2, #0
 800c426:	1c02      	adds	r2, r0, #0
 800c428:	430a      	orrs	r2, r1
 800c42a:	7262      	strb	r2, [r4, #9]
 800c42c:	0c1a      	lsrs	r2, r3, #16
 800c42e:	21ff      	movs	r1, #255	; 0xff
 800c430:	400a      	ands	r2, r1
 800c432:	0010      	movs	r0, r2
 800c434:	7aa2      	ldrb	r2, [r4, #10]
 800c436:	2100      	movs	r1, #0
 800c438:	400a      	ands	r2, r1
 800c43a:	1c11      	adds	r1, r2, #0
 800c43c:	1c02      	adds	r2, r0, #0
 800c43e:	430a      	orrs	r2, r1
 800c440:	72a2      	strb	r2, [r4, #10]
 800c442:	0e19      	lsrs	r1, r3, #24
 800c444:	7ae3      	ldrb	r3, [r4, #11]
 800c446:	2200      	movs	r2, #0
 800c448:	4013      	ands	r3, r2
 800c44a:	1c1a      	adds	r2, r3, #0
 800c44c:	1c0b      	adds	r3, r1, #0
 800c44e:	4313      	orrs	r3, r2
 800c450:	72e3      	strb	r3, [r4, #11]
 800c452:	7a23      	ldrb	r3, [r4, #8]
 800c454:	7a62      	ldrb	r2, [r4, #9]
 800c456:	0212      	lsls	r2, r2, #8
 800c458:	4313      	orrs	r3, r2
 800c45a:	7aa2      	ldrb	r2, [r4, #10]
 800c45c:	0412      	lsls	r2, r2, #16
 800c45e:	4313      	orrs	r3, r2
 800c460:	7ae2      	ldrb	r2, [r4, #11]
 800c462:	0612      	lsls	r2, r2, #24
 800c464:	4313      	orrs	r3, r2
 800c466:	001a      	movs	r2, r3
 800c468:	4b49      	ldr	r3, [pc, #292]	; (800c590 <tcp_input+0x4a0>)
 800c46a:	601a      	str	r2, [r3, #0]
  tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
 800c46c:	4b46      	ldr	r3, [pc, #280]	; (800c588 <tcp_input+0x498>)
 800c46e:	681b      	ldr	r3, [r3, #0]
 800c470:	7b9a      	ldrb	r2, [r3, #14]
 800c472:	7bdb      	ldrb	r3, [r3, #15]
 800c474:	021b      	lsls	r3, r3, #8
 800c476:	4313      	orrs	r3, r2
 800c478:	b29a      	uxth	r2, r3
 800c47a:	4b43      	ldr	r3, [pc, #268]	; (800c588 <tcp_input+0x498>)
 800c47c:	681c      	ldr	r4, [r3, #0]
 800c47e:	0010      	movs	r0, r2
 800c480:	f7fa f858 	bl	8006534 <lwip_htons>
 800c484:	0003      	movs	r3, r0
 800c486:	22ff      	movs	r2, #255	; 0xff
 800c488:	401a      	ands	r2, r3
 800c48a:	0010      	movs	r0, r2
 800c48c:	7ba2      	ldrb	r2, [r4, #14]
 800c48e:	2100      	movs	r1, #0
 800c490:	400a      	ands	r2, r1
 800c492:	1c11      	adds	r1, r2, #0
 800c494:	1c02      	adds	r2, r0, #0
 800c496:	430a      	orrs	r2, r1
 800c498:	73a2      	strb	r2, [r4, #14]
 800c49a:	0a1b      	lsrs	r3, r3, #8
 800c49c:	b299      	uxth	r1, r3
 800c49e:	7be3      	ldrb	r3, [r4, #15]
 800c4a0:	2200      	movs	r2, #0
 800c4a2:	4013      	ands	r3, r2
 800c4a4:	1c1a      	adds	r2, r3, #0
 800c4a6:	1c0b      	adds	r3, r1, #0
 800c4a8:	4313      	orrs	r3, r2
 800c4aa:	73e3      	strb	r3, [r4, #15]

  flags = TCPH_FLAGS(tcphdr);
 800c4ac:	4b36      	ldr	r3, [pc, #216]	; (800c588 <tcp_input+0x498>)
 800c4ae:	681b      	ldr	r3, [r3, #0]
 800c4b0:	7b1a      	ldrb	r2, [r3, #12]
 800c4b2:	7b5b      	ldrb	r3, [r3, #13]
 800c4b4:	021b      	lsls	r3, r3, #8
 800c4b6:	4313      	orrs	r3, r2
 800c4b8:	b29b      	uxth	r3, r3
 800c4ba:	0018      	movs	r0, r3
 800c4bc:	f7fa f83a 	bl	8006534 <lwip_htons>
 800c4c0:	0003      	movs	r3, r0
 800c4c2:	b2db      	uxtb	r3, r3
 800c4c4:	223f      	movs	r2, #63	; 0x3f
 800c4c6:	4013      	ands	r3, r2
 800c4c8:	b2da      	uxtb	r2, r3
 800c4ca:	4b32      	ldr	r3, [pc, #200]	; (800c594 <tcp_input+0x4a4>)
 800c4cc:	701a      	strb	r2, [r3, #0]
  tcplen = p->tot_len;
 800c4ce:	687b      	ldr	r3, [r7, #4]
 800c4d0:	891a      	ldrh	r2, [r3, #8]
 800c4d2:	4b31      	ldr	r3, [pc, #196]	; (800c598 <tcp_input+0x4a8>)
 800c4d4:	801a      	strh	r2, [r3, #0]
  if (flags & (TCP_FIN | TCP_SYN)) {
 800c4d6:	4b2f      	ldr	r3, [pc, #188]	; (800c594 <tcp_input+0x4a4>)
 800c4d8:	781b      	ldrb	r3, [r3, #0]
 800c4da:	001a      	movs	r2, r3
 800c4dc:	2303      	movs	r3, #3
 800c4de:	4013      	ands	r3, r2
 800c4e0:	d00c      	beq.n	800c4fc <tcp_input+0x40c>
    tcplen++;
 800c4e2:	4b2d      	ldr	r3, [pc, #180]	; (800c598 <tcp_input+0x4a8>)
 800c4e4:	881b      	ldrh	r3, [r3, #0]
 800c4e6:	3301      	adds	r3, #1
 800c4e8:	b29a      	uxth	r2, r3
 800c4ea:	4b2b      	ldr	r3, [pc, #172]	; (800c598 <tcp_input+0x4a8>)
 800c4ec:	801a      	strh	r2, [r3, #0]
    if (tcplen < p->tot_len) {
 800c4ee:	687b      	ldr	r3, [r7, #4]
 800c4f0:	891a      	ldrh	r2, [r3, #8]
 800c4f2:	4b29      	ldr	r3, [pc, #164]	; (800c598 <tcp_input+0x4a8>)
 800c4f4:	881b      	ldrh	r3, [r3, #0]
 800c4f6:	429a      	cmp	r2, r3
 800c4f8:	d900      	bls.n	800c4fc <tcp_input+0x40c>
 800c4fa:	e322      	b.n	800cb42 <tcp_input+0xa52>
    }
  }

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
 800c4fc:	2300      	movs	r3, #0
 800c4fe:	627b      	str	r3, [r7, #36]	; 0x24

  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800c500:	4b26      	ldr	r3, [pc, #152]	; (800c59c <tcp_input+0x4ac>)
 800c502:	681b      	ldr	r3, [r3, #0]
 800c504:	623b      	str	r3, [r7, #32]
 800c506:	e0a1      	b.n	800c64c <tcp_input+0x55c>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 800c508:	6a3b      	ldr	r3, [r7, #32]
 800c50a:	7e1b      	ldrb	r3, [r3, #24]
 800c50c:	2b00      	cmp	r3, #0
 800c50e:	d105      	bne.n	800c51c <tcp_input+0x42c>
 800c510:	4b15      	ldr	r3, [pc, #84]	; (800c568 <tcp_input+0x478>)
 800c512:	4923      	ldr	r1, [pc, #140]	; (800c5a0 <tcp_input+0x4b0>)
 800c514:	4816      	ldr	r0, [pc, #88]	; (800c570 <tcp_input+0x480>)
 800c516:	22fb      	movs	r2, #251	; 0xfb
 800c518:	f7f5 fe58 	bl	80021cc <app_debug_rtt_raw>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 800c51c:	6a3b      	ldr	r3, [r7, #32]
 800c51e:	7e1b      	ldrb	r3, [r3, #24]
 800c520:	2b0a      	cmp	r3, #10
 800c522:	d105      	bne.n	800c530 <tcp_input+0x440>
 800c524:	4b10      	ldr	r3, [pc, #64]	; (800c568 <tcp_input+0x478>)
 800c526:	491f      	ldr	r1, [pc, #124]	; (800c5a4 <tcp_input+0x4b4>)
 800c528:	4811      	ldr	r0, [pc, #68]	; (800c570 <tcp_input+0x480>)
 800c52a:	22fc      	movs	r2, #252	; 0xfc
 800c52c:	f7f5 fe4e 	bl	80021cc <app_debug_rtt_raw>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 800c530:	6a3b      	ldr	r3, [r7, #32]
 800c532:	7e1b      	ldrb	r3, [r3, #24]
 800c534:	2b01      	cmp	r3, #1
 800c536:	d105      	bne.n	800c544 <tcp_input+0x454>
 800c538:	4b0b      	ldr	r3, [pc, #44]	; (800c568 <tcp_input+0x478>)
 800c53a:	491b      	ldr	r1, [pc, #108]	; (800c5a8 <tcp_input+0x4b8>)
 800c53c:	480c      	ldr	r0, [pc, #48]	; (800c570 <tcp_input+0x480>)
 800c53e:	22fd      	movs	r2, #253	; 0xfd
 800c540:	f7f5 fe44 	bl	80021cc <app_debug_rtt_raw>

    /* check if PCB is bound to specific netif */
    if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 800c544:	6a3b      	ldr	r3, [r7, #32]
 800c546:	7a1b      	ldrb	r3, [r3, #8]
 800c548:	2b00      	cmp	r3, #0
 800c54a:	d031      	beq.n	800c5b0 <tcp_input+0x4c0>
        (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 800c54c:	6a3b      	ldr	r3, [r7, #32]
 800c54e:	7a1a      	ldrb	r2, [r3, #8]
 800c550:	4b16      	ldr	r3, [pc, #88]	; (800c5ac <tcp_input+0x4bc>)
 800c552:	685b      	ldr	r3, [r3, #4]
 800c554:	2134      	movs	r1, #52	; 0x34
 800c556:	5c5b      	ldrb	r3, [r3, r1]
 800c558:	3301      	adds	r3, #1
 800c55a:	b2db      	uxtb	r3, r3
    if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 800c55c:	429a      	cmp	r2, r3
 800c55e:	d027      	beq.n	800c5b0 <tcp_input+0x4c0>
      prev = pcb;
 800c560:	6a3b      	ldr	r3, [r7, #32]
 800c562:	627b      	str	r3, [r7, #36]	; 0x24
      continue;
 800c564:	e06f      	b.n	800c646 <tcp_input+0x556>
 800c566:	46c0      	nop			; (mov r8, r8)
 800c568:	0801f99c 	.word	0x0801f99c
 800c56c:	0801fa08 	.word	0x0801fa08
 800c570:	0801f9dc 	.word	0x0801f9dc
 800c574:	20001376 	.word	0x20001376
 800c578:	20001374 	.word	0x20001374
 800c57c:	20001378 	.word	0x20001378
 800c580:	0801fa18 	.word	0x0801fa18
 800c584:	0801fa24 	.word	0x0801fa24
 800c588:	20001370 	.word	0x20001370
 800c58c:	20001380 	.word	0x20001380
 800c590:	20001384 	.word	0x20001384
 800c594:	2000138c 	.word	0x2000138c
 800c598:	2000138a 	.word	0x2000138a
 800c59c:	20002b18 	.word	0x20002b18
 800c5a0:	0801fa44 	.word	0x0801fa44
 800c5a4:	0801fa6c 	.word	0x0801fa6c
 800c5a8:	0801fa98 	.word	0x0801fa98
 800c5ac:	200014c4 	.word	0x200014c4
    }

    if (pcb->remote_port == tcphdr->src &&
 800c5b0:	6a3b      	ldr	r3, [r7, #32]
 800c5b2:	8b9a      	ldrh	r2, [r3, #28]
 800c5b4:	4bcb      	ldr	r3, [pc, #812]	; (800c8e4 <tcp_input+0x7f4>)
 800c5b6:	681b      	ldr	r3, [r3, #0]
 800c5b8:	7819      	ldrb	r1, [r3, #0]
 800c5ba:	785b      	ldrb	r3, [r3, #1]
 800c5bc:	021b      	lsls	r3, r3, #8
 800c5be:	430b      	orrs	r3, r1
 800c5c0:	b29b      	uxth	r3, r3
 800c5c2:	429a      	cmp	r2, r3
 800c5c4:	d13d      	bne.n	800c642 <tcp_input+0x552>
        pcb->local_port == tcphdr->dest &&
 800c5c6:	6a3b      	ldr	r3, [r7, #32]
 800c5c8:	8b5a      	ldrh	r2, [r3, #26]
 800c5ca:	4bc6      	ldr	r3, [pc, #792]	; (800c8e4 <tcp_input+0x7f4>)
 800c5cc:	681b      	ldr	r3, [r3, #0]
 800c5ce:	7899      	ldrb	r1, [r3, #2]
 800c5d0:	78db      	ldrb	r3, [r3, #3]
 800c5d2:	021b      	lsls	r3, r3, #8
 800c5d4:	430b      	orrs	r3, r1
 800c5d6:	b29b      	uxth	r3, r3
    if (pcb->remote_port == tcphdr->src &&
 800c5d8:	429a      	cmp	r2, r3
 800c5da:	d132      	bne.n	800c642 <tcp_input+0x552>
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 800c5dc:	6a3b      	ldr	r3, [r7, #32]
 800c5de:	685a      	ldr	r2, [r3, #4]
 800c5e0:	4bc1      	ldr	r3, [pc, #772]	; (800c8e8 <tcp_input+0x7f8>)
 800c5e2:	691b      	ldr	r3, [r3, #16]
        pcb->local_port == tcphdr->dest &&
 800c5e4:	429a      	cmp	r2, r3
 800c5e6:	d12c      	bne.n	800c642 <tcp_input+0x552>
        ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 800c5e8:	6a3b      	ldr	r3, [r7, #32]
 800c5ea:	681a      	ldr	r2, [r3, #0]
 800c5ec:	4bbe      	ldr	r3, [pc, #760]	; (800c8e8 <tcp_input+0x7f8>)
 800c5ee:	695b      	ldr	r3, [r3, #20]
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 800c5f0:	429a      	cmp	r2, r3
 800c5f2:	d126      	bne.n	800c642 <tcp_input+0x552>
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
 800c5f4:	6a3b      	ldr	r3, [r7, #32]
 800c5f6:	691b      	ldr	r3, [r3, #16]
 800c5f8:	6a3a      	ldr	r2, [r7, #32]
 800c5fa:	429a      	cmp	r2, r3
 800c5fc:	d106      	bne.n	800c60c <tcp_input+0x51c>
 800c5fe:	4bbb      	ldr	r3, [pc, #748]	; (800c8ec <tcp_input+0x7fc>)
 800c600:	220e      	movs	r2, #14
 800c602:	32ff      	adds	r2, #255	; 0xff
 800c604:	49ba      	ldr	r1, [pc, #744]	; (800c8f0 <tcp_input+0x800>)
 800c606:	48bb      	ldr	r0, [pc, #748]	; (800c8f4 <tcp_input+0x804>)
 800c608:	f7f5 fde0 	bl	80021cc <app_debug_rtt_raw>
      if (prev != NULL) {
 800c60c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c60e:	2b00      	cmp	r3, #0
 800c610:	d00a      	beq.n	800c628 <tcp_input+0x538>
        prev->next = pcb->next;
 800c612:	6a3b      	ldr	r3, [r7, #32]
 800c614:	691a      	ldr	r2, [r3, #16]
 800c616:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c618:	611a      	str	r2, [r3, #16]
        pcb->next = tcp_active_pcbs;
 800c61a:	4bb7      	ldr	r3, [pc, #732]	; (800c8f8 <tcp_input+0x808>)
 800c61c:	681a      	ldr	r2, [r3, #0]
 800c61e:	6a3b      	ldr	r3, [r7, #32]
 800c620:	611a      	str	r2, [r3, #16]
        tcp_active_pcbs = pcb;
 800c622:	4bb5      	ldr	r3, [pc, #724]	; (800c8f8 <tcp_input+0x808>)
 800c624:	6a3a      	ldr	r2, [r7, #32]
 800c626:	601a      	str	r2, [r3, #0]
      } else {
        TCP_STATS_INC(tcp.cachehit);
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
 800c628:	6a3b      	ldr	r3, [r7, #32]
 800c62a:	691b      	ldr	r3, [r3, #16]
 800c62c:	6a3a      	ldr	r2, [r7, #32]
 800c62e:	429a      	cmp	r2, r3
 800c630:	d111      	bne.n	800c656 <tcp_input+0x566>
 800c632:	4bae      	ldr	r3, [pc, #696]	; (800c8ec <tcp_input+0x7fc>)
 800c634:	2216      	movs	r2, #22
 800c636:	32ff      	adds	r2, #255	; 0xff
 800c638:	49b0      	ldr	r1, [pc, #704]	; (800c8fc <tcp_input+0x80c>)
 800c63a:	48ae      	ldr	r0, [pc, #696]	; (800c8f4 <tcp_input+0x804>)
 800c63c:	f7f5 fdc6 	bl	80021cc <app_debug_rtt_raw>
      break;
 800c640:	e009      	b.n	800c656 <tcp_input+0x566>
    }
    prev = pcb;
 800c642:	6a3b      	ldr	r3, [r7, #32]
 800c644:	627b      	str	r3, [r7, #36]	; 0x24
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800c646:	6a3b      	ldr	r3, [r7, #32]
 800c648:	691b      	ldr	r3, [r3, #16]
 800c64a:	623b      	str	r3, [r7, #32]
 800c64c:	6a3b      	ldr	r3, [r7, #32]
 800c64e:	2b00      	cmp	r3, #0
 800c650:	d000      	beq.n	800c654 <tcp_input+0x564>
 800c652:	e759      	b.n	800c508 <tcp_input+0x418>
 800c654:	e000      	b.n	800c658 <tcp_input+0x568>
      break;
 800c656:	46c0      	nop			; (mov r8, r8)
  }

  if (pcb == NULL) {
 800c658:	6a3b      	ldr	r3, [r7, #32]
 800c65a:	2b00      	cmp	r3, #0
 800c65c:	d000      	beq.n	800c660 <tcp_input+0x570>
 800c65e:	e0ac      	b.n	800c7ba <tcp_input+0x6ca>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800c660:	4ba7      	ldr	r3, [pc, #668]	; (800c900 <tcp_input+0x810>)
 800c662:	681b      	ldr	r3, [r3, #0]
 800c664:	623b      	str	r3, [r7, #32]
 800c666:	e047      	b.n	800c6f8 <tcp_input+0x608>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 800c668:	6a3b      	ldr	r3, [r7, #32]
 800c66a:	7e1b      	ldrb	r3, [r3, #24]
 800c66c:	2b0a      	cmp	r3, #10
 800c66e:	d006      	beq.n	800c67e <tcp_input+0x58e>
 800c670:	4b9e      	ldr	r3, [pc, #632]	; (800c8ec <tcp_input+0x7fc>)
 800c672:	2220      	movs	r2, #32
 800c674:	32ff      	adds	r2, #255	; 0xff
 800c676:	49a3      	ldr	r1, [pc, #652]	; (800c904 <tcp_input+0x814>)
 800c678:	489e      	ldr	r0, [pc, #632]	; (800c8f4 <tcp_input+0x804>)
 800c67a:	f7f5 fda7 	bl	80021cc <app_debug_rtt_raw>

      /* check if PCB is bound to specific netif */
      if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 800c67e:	6a3b      	ldr	r3, [r7, #32]
 800c680:	7a1b      	ldrb	r3, [r3, #8]
 800c682:	2b00      	cmp	r3, #0
 800c684:	d009      	beq.n	800c69a <tcp_input+0x5aa>
          (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 800c686:	6a3b      	ldr	r3, [r7, #32]
 800c688:	7a1a      	ldrb	r2, [r3, #8]
 800c68a:	4b97      	ldr	r3, [pc, #604]	; (800c8e8 <tcp_input+0x7f8>)
 800c68c:	685b      	ldr	r3, [r3, #4]
 800c68e:	2134      	movs	r1, #52	; 0x34
 800c690:	5c5b      	ldrb	r3, [r3, r1]
 800c692:	3301      	adds	r3, #1
 800c694:	b2db      	uxtb	r3, r3
      if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 800c696:	429a      	cmp	r2, r3
 800c698:	d12a      	bne.n	800c6f0 <tcp_input+0x600>
        continue;
      }

      if (pcb->remote_port == tcphdr->src &&
 800c69a:	6a3b      	ldr	r3, [r7, #32]
 800c69c:	8b9a      	ldrh	r2, [r3, #28]
 800c69e:	4b91      	ldr	r3, [pc, #580]	; (800c8e4 <tcp_input+0x7f4>)
 800c6a0:	681b      	ldr	r3, [r3, #0]
 800c6a2:	7819      	ldrb	r1, [r3, #0]
 800c6a4:	785b      	ldrb	r3, [r3, #1]
 800c6a6:	021b      	lsls	r3, r3, #8
 800c6a8:	430b      	orrs	r3, r1
 800c6aa:	b29b      	uxth	r3, r3
 800c6ac:	429a      	cmp	r2, r3
 800c6ae:	d120      	bne.n	800c6f2 <tcp_input+0x602>
          pcb->local_port == tcphdr->dest &&
 800c6b0:	6a3b      	ldr	r3, [r7, #32]
 800c6b2:	8b5a      	ldrh	r2, [r3, #26]
 800c6b4:	4b8b      	ldr	r3, [pc, #556]	; (800c8e4 <tcp_input+0x7f4>)
 800c6b6:	681b      	ldr	r3, [r3, #0]
 800c6b8:	7899      	ldrb	r1, [r3, #2]
 800c6ba:	78db      	ldrb	r3, [r3, #3]
 800c6bc:	021b      	lsls	r3, r3, #8
 800c6be:	430b      	orrs	r3, r1
 800c6c0:	b29b      	uxth	r3, r3
      if (pcb->remote_port == tcphdr->src &&
 800c6c2:	429a      	cmp	r2, r3
 800c6c4:	d115      	bne.n	800c6f2 <tcp_input+0x602>
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 800c6c6:	6a3b      	ldr	r3, [r7, #32]
 800c6c8:	685a      	ldr	r2, [r3, #4]
 800c6ca:	4b87      	ldr	r3, [pc, #540]	; (800c8e8 <tcp_input+0x7f8>)
 800c6cc:	691b      	ldr	r3, [r3, #16]
          pcb->local_port == tcphdr->dest &&
 800c6ce:	429a      	cmp	r2, r3
 800c6d0:	d10f      	bne.n	800c6f2 <tcp_input+0x602>
          ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 800c6d2:	6a3b      	ldr	r3, [r7, #32]
 800c6d4:	681a      	ldr	r2, [r3, #0]
 800c6d6:	4b84      	ldr	r3, [pc, #528]	; (800c8e8 <tcp_input+0x7f8>)
 800c6d8:	695b      	ldr	r3, [r3, #20]
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 800c6da:	429a      	cmp	r2, r3
 800c6dc:	d109      	bne.n	800c6f2 <tcp_input+0x602>
#ifdef LWIP_HOOK_TCP_INPACKET_PCB
        if (LWIP_HOOK_TCP_INPACKET_PCB(pcb, tcphdr, tcphdr_optlen, tcphdr_opt1len,
                                       tcphdr_opt2, p) == ERR_OK)
#endif
        {
          tcp_timewait_input(pcb);
 800c6de:	6a3b      	ldr	r3, [r7, #32]
 800c6e0:	0018      	movs	r0, r3
 800c6e2:	f000 fbb5 	bl	800ce50 <tcp_timewait_input>
        }
        pbuf_free(p);
 800c6e6:	687b      	ldr	r3, [r7, #4]
 800c6e8:	0018      	movs	r0, r3
 800c6ea:	f7fc ffd3 	bl	8009694 <pbuf_free>
        return;
 800c6ee:	e22f      	b.n	800cb50 <tcp_input+0xa60>
        continue;
 800c6f0:	46c0      	nop			; (mov r8, r8)
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800c6f2:	6a3b      	ldr	r3, [r7, #32]
 800c6f4:	691b      	ldr	r3, [r3, #16]
 800c6f6:	623b      	str	r3, [r7, #32]
 800c6f8:	6a3b      	ldr	r3, [r7, #32]
 800c6fa:	2b00      	cmp	r3, #0
 800c6fc:	d1b4      	bne.n	800c668 <tcp_input+0x578>
      }
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
 800c6fe:	2300      	movs	r3, #0
 800c700:	627b      	str	r3, [r7, #36]	; 0x24
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800c702:	4b81      	ldr	r3, [pc, #516]	; (800c908 <tcp_input+0x818>)
 800c704:	681b      	ldr	r3, [r3, #0]
 800c706:	61fb      	str	r3, [r7, #28]
 800c708:	e031      	b.n	800c76e <tcp_input+0x67e>
      /* check if PCB is bound to specific netif */
      if ((lpcb->netif_idx != NETIF_NO_INDEX) &&
 800c70a:	69fb      	ldr	r3, [r7, #28]
 800c70c:	7a1b      	ldrb	r3, [r3, #8]
 800c70e:	2b00      	cmp	r3, #0
 800c710:	d00c      	beq.n	800c72c <tcp_input+0x63c>
          (lpcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 800c712:	69fb      	ldr	r3, [r7, #28]
 800c714:	7a1a      	ldrb	r2, [r3, #8]
 800c716:	4b74      	ldr	r3, [pc, #464]	; (800c8e8 <tcp_input+0x7f8>)
 800c718:	685b      	ldr	r3, [r3, #4]
 800c71a:	2134      	movs	r1, #52	; 0x34
 800c71c:	5c5b      	ldrb	r3, [r3, r1]
 800c71e:	3301      	adds	r3, #1
 800c720:	b2db      	uxtb	r3, r3
      if ((lpcb->netif_idx != NETIF_NO_INDEX) &&
 800c722:	429a      	cmp	r2, r3
 800c724:	d002      	beq.n	800c72c <tcp_input+0x63c>
        prev = (struct tcp_pcb *)lpcb;
 800c726:	69fb      	ldr	r3, [r7, #28]
 800c728:	627b      	str	r3, [r7, #36]	; 0x24
        continue;
 800c72a:	e01d      	b.n	800c768 <tcp_input+0x678>
      }

      if (lpcb->local_port == tcphdr->dest) {
 800c72c:	69fb      	ldr	r3, [r7, #28]
 800c72e:	8b5a      	ldrh	r2, [r3, #26]
 800c730:	4b6c      	ldr	r3, [pc, #432]	; (800c8e4 <tcp_input+0x7f4>)
 800c732:	681b      	ldr	r3, [r3, #0]
 800c734:	7899      	ldrb	r1, [r3, #2]
 800c736:	78db      	ldrb	r3, [r3, #3]
 800c738:	021b      	lsls	r3, r3, #8
 800c73a:	430b      	orrs	r3, r1
 800c73c:	b29b      	uxth	r3, r3
 800c73e:	429a      	cmp	r2, r3
 800c740:	d110      	bne.n	800c764 <tcp_input+0x674>
          lpcb_prev = prev;
#else /* SO_REUSE */
          break;
#endif /* SO_REUSE */
        } else if (IP_ADDR_PCB_VERSION_MATCH_EXACT(lpcb, ip_current_dest_addr())) {
          if (ip_addr_cmp(&lpcb->local_ip, ip_current_dest_addr())) {
 800c742:	69fb      	ldr	r3, [r7, #28]
 800c744:	681a      	ldr	r2, [r3, #0]
 800c746:	4b68      	ldr	r3, [pc, #416]	; (800c8e8 <tcp_input+0x7f8>)
 800c748:	695b      	ldr	r3, [r3, #20]
 800c74a:	429a      	cmp	r2, r3
 800c74c:	d013      	beq.n	800c776 <tcp_input+0x686>
            /* found an exact match */
            break;
          } else if (ip_addr_isany(&lpcb->local_ip)) {
 800c74e:	69fb      	ldr	r3, [r7, #28]
 800c750:	2b00      	cmp	r3, #0
 800c752:	d003      	beq.n	800c75c <tcp_input+0x66c>
 800c754:	69fb      	ldr	r3, [r7, #28]
 800c756:	681b      	ldr	r3, [r3, #0]
 800c758:	2b00      	cmp	r3, #0
 800c75a:	d103      	bne.n	800c764 <tcp_input+0x674>
            /* found an ANY-match */
#if SO_REUSE
            lpcb_any = lpcb;
 800c75c:	69fb      	ldr	r3, [r7, #28]
 800c75e:	617b      	str	r3, [r7, #20]
            lpcb_prev = prev;
 800c760:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c762:	61bb      	str	r3, [r7, #24]
            break;
#endif /* SO_REUSE */
          }
        }
      }
      prev = (struct tcp_pcb *)lpcb;
 800c764:	69fb      	ldr	r3, [r7, #28]
 800c766:	627b      	str	r3, [r7, #36]	; 0x24
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 800c768:	69fb      	ldr	r3, [r7, #28]
 800c76a:	691b      	ldr	r3, [r3, #16]
 800c76c:	61fb      	str	r3, [r7, #28]
 800c76e:	69fb      	ldr	r3, [r7, #28]
 800c770:	2b00      	cmp	r3, #0
 800c772:	d1ca      	bne.n	800c70a <tcp_input+0x61a>
 800c774:	e000      	b.n	800c778 <tcp_input+0x688>
            break;
 800c776:	46c0      	nop			; (mov r8, r8)
    }
#if SO_REUSE
    /* first try specific local IP */
    if (lpcb == NULL) {
 800c778:	69fb      	ldr	r3, [r7, #28]
 800c77a:	2b00      	cmp	r3, #0
 800c77c:	d103      	bne.n	800c786 <tcp_input+0x696>
      /* only pass to ANY if no specific local IP has been found */
      lpcb = lpcb_any;
 800c77e:	697b      	ldr	r3, [r7, #20]
 800c780:	61fb      	str	r3, [r7, #28]
      prev = lpcb_prev;
 800c782:	69bb      	ldr	r3, [r7, #24]
 800c784:	627b      	str	r3, [r7, #36]	; 0x24
    }
#endif /* SO_REUSE */
    if (lpcb != NULL) {
 800c786:	69fb      	ldr	r3, [r7, #28]
 800c788:	2b00      	cmp	r3, #0
 800c78a:	d016      	beq.n	800c7ba <tcp_input+0x6ca>
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      if (prev != NULL) {
 800c78c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c78e:	2b00      	cmp	r3, #0
 800c790:	d00a      	beq.n	800c7a8 <tcp_input+0x6b8>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 800c792:	69fb      	ldr	r3, [r7, #28]
 800c794:	691a      	ldr	r2, [r3, #16]
 800c796:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c798:	611a      	str	r2, [r3, #16]
        /* our successor is the remainder of the listening list */
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
 800c79a:	4b5b      	ldr	r3, [pc, #364]	; (800c908 <tcp_input+0x818>)
 800c79c:	681a      	ldr	r2, [r3, #0]
 800c79e:	69fb      	ldr	r3, [r7, #28]
 800c7a0:	611a      	str	r2, [r3, #16]
        /* put this listening pcb at the head of the listening list */
        tcp_listen_pcbs.listen_pcbs = lpcb;
 800c7a2:	4b59      	ldr	r3, [pc, #356]	; (800c908 <tcp_input+0x818>)
 800c7a4:	69fa      	ldr	r2, [r7, #28]
 800c7a6:	601a      	str	r2, [r3, #0]
#ifdef LWIP_HOOK_TCP_INPACKET_PCB
      if (LWIP_HOOK_TCP_INPACKET_PCB((struct tcp_pcb *)lpcb, tcphdr, tcphdr_optlen,
                                     tcphdr_opt1len, tcphdr_opt2, p) == ERR_OK)
#endif
      {
        tcp_listen_input(lpcb);
 800c7a8:	69fb      	ldr	r3, [r7, #28]
 800c7aa:	0018      	movs	r0, r3
 800c7ac:	f000 fa34 	bl	800cc18 <tcp_listen_input>
      }
      pbuf_free(p);
 800c7b0:	687b      	ldr	r3, [r7, #4]
 800c7b2:	0018      	movs	r0, r3
 800c7b4:	f7fc ff6e 	bl	8009694 <pbuf_free>
      return;
 800c7b8:	e1ca      	b.n	800cb50 <tcp_input+0xa60>
      tcphdr_opt1len, tcphdr_opt2, p) != ERR_OK) {
    pbuf_free(p);
    return;
  }
#endif
  if (pcb != NULL) {
 800c7ba:	6a3b      	ldr	r3, [r7, #32]
 800c7bc:	2b00      	cmp	r3, #0
 800c7be:	d100      	bne.n	800c7c2 <tcp_input+0x6d2>
 800c7c0:	e17f      	b.n	800cac2 <tcp_input+0x9d2>
#if TCP_INPUT_DEBUG
    tcp_debug_print_state(pcb->state);
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
 800c7c2:	4b52      	ldr	r3, [pc, #328]	; (800c90c <tcp_input+0x81c>)
 800c7c4:	2200      	movs	r2, #0
 800c7c6:	601a      	str	r2, [r3, #0]
    inseg.len = p->tot_len;
 800c7c8:	687b      	ldr	r3, [r7, #4]
 800c7ca:	891a      	ldrh	r2, [r3, #8]
 800c7cc:	4b4f      	ldr	r3, [pc, #316]	; (800c90c <tcp_input+0x81c>)
 800c7ce:	811a      	strh	r2, [r3, #8]
    inseg.p = p;
 800c7d0:	4b4e      	ldr	r3, [pc, #312]	; (800c90c <tcp_input+0x81c>)
 800c7d2:	687a      	ldr	r2, [r7, #4]
 800c7d4:	605a      	str	r2, [r3, #4]
    inseg.tcphdr = tcphdr;
 800c7d6:	4b43      	ldr	r3, [pc, #268]	; (800c8e4 <tcp_input+0x7f4>)
 800c7d8:	681a      	ldr	r2, [r3, #0]
 800c7da:	4b4c      	ldr	r3, [pc, #304]	; (800c90c <tcp_input+0x81c>)
 800c7dc:	611a      	str	r2, [r3, #16]

    recv_data = NULL;
 800c7de:	4b4c      	ldr	r3, [pc, #304]	; (800c910 <tcp_input+0x820>)
 800c7e0:	2200      	movs	r2, #0
 800c7e2:	601a      	str	r2, [r3, #0]
    recv_flags = 0;
 800c7e4:	4b4b      	ldr	r3, [pc, #300]	; (800c914 <tcp_input+0x824>)
 800c7e6:	2200      	movs	r2, #0
 800c7e8:	701a      	strb	r2, [r3, #0]
    recv_acked = 0;
 800c7ea:	4b4b      	ldr	r3, [pc, #300]	; (800c918 <tcp_input+0x828>)
 800c7ec:	2200      	movs	r2, #0
 800c7ee:	801a      	strh	r2, [r3, #0]

    if (flags & TCP_PSH) {
 800c7f0:	4b4a      	ldr	r3, [pc, #296]	; (800c91c <tcp_input+0x82c>)
 800c7f2:	781b      	ldrb	r3, [r3, #0]
 800c7f4:	001a      	movs	r2, r3
 800c7f6:	2308      	movs	r3, #8
 800c7f8:	4013      	ands	r3, r2
 800c7fa:	d006      	beq.n	800c80a <tcp_input+0x71a>
      p->flags |= PBUF_FLAG_PUSH;
 800c7fc:	687b      	ldr	r3, [r7, #4]
 800c7fe:	7b5b      	ldrb	r3, [r3, #13]
 800c800:	2201      	movs	r2, #1
 800c802:	4313      	orrs	r3, r2
 800c804:	b2da      	uxtb	r2, r3
 800c806:	687b      	ldr	r3, [r7, #4]
 800c808:	735a      	strb	r2, [r3, #13]
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
 800c80a:	6a3b      	ldr	r3, [r7, #32]
 800c80c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800c80e:	2b00      	cmp	r3, #0
 800c810:	d018      	beq.n	800c844 <tcp_input+0x754>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 800c812:	6a3b      	ldr	r3, [r7, #32]
 800c814:	0018      	movs	r0, r3
 800c816:	f7fe ff23 	bl	800b660 <tcp_process_refused_data>
 800c81a:	0003      	movs	r3, r0
 800c81c:	330d      	adds	r3, #13
 800c81e:	d007      	beq.n	800c830 <tcp_input+0x740>
          ((pcb->refused_data != NULL) && (tcplen > 0))) {
 800c820:	6a3b      	ldr	r3, [r7, #32]
 800c822:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 800c824:	2b00      	cmp	r3, #0
 800c826:	d00d      	beq.n	800c844 <tcp_input+0x754>
          ((pcb->refused_data != NULL) && (tcplen > 0))) {
 800c828:	4b3d      	ldr	r3, [pc, #244]	; (800c920 <tcp_input+0x830>)
 800c82a:	881b      	ldrh	r3, [r3, #0]
 800c82c:	2b00      	cmp	r3, #0
 800c82e:	d009      	beq.n	800c844 <tcp_input+0x754>
        /* pcb has been aborted or refused data is still refused and the new
           segment contains data */
        if (pcb->rcv_ann_wnd == 0) {
 800c830:	6a3b      	ldr	r3, [r7, #32]
 800c832:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
 800c834:	2b00      	cmp	r3, #0
 800c836:	d000      	beq.n	800c83a <tcp_input+0x74a>
 800c838:	e123      	b.n	800ca82 <tcp_input+0x992>
          /* this is a zero-window probe, we respond to it with current RCV.NXT
          and drop the data segment */
          tcp_send_empty_ack(pcb);
 800c83a:	6a3b      	ldr	r3, [r7, #32]
 800c83c:	0018      	movs	r0, r3
 800c83e:	f004 ff53 	bl	80116e8 <tcp_send_empty_ack>
        }
        TCP_STATS_INC(tcp.drop);
        MIB2_STATS_INC(mib2.tcpinerrs);
        goto aborted;
 800c842:	e11e      	b.n	800ca82 <tcp_input+0x992>
      }
    }
    tcp_input_pcb = pcb;
 800c844:	4b37      	ldr	r3, [pc, #220]	; (800c924 <tcp_input+0x834>)
 800c846:	6a3a      	ldr	r2, [r7, #32]
 800c848:	601a      	str	r2, [r3, #0]
    err = tcp_process(pcb);
 800c84a:	2513      	movs	r5, #19
 800c84c:	197c      	adds	r4, r7, r5
 800c84e:	6a3b      	ldr	r3, [r7, #32]
 800c850:	0018      	movs	r0, r3
 800c852:	f000 fb81 	bl	800cf58 <tcp_process>
 800c856:	0003      	movs	r3, r0
 800c858:	7023      	strb	r3, [r4, #0]
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
 800c85a:	197b      	adds	r3, r7, r5
 800c85c:	781b      	ldrb	r3, [r3, #0]
 800c85e:	b25b      	sxtb	r3, r3
 800c860:	330d      	adds	r3, #13
 800c862:	d100      	bne.n	800c866 <tcp_input+0x776>
 800c864:	e10f      	b.n	800ca86 <tcp_input+0x996>
      if (recv_flags & TF_RESET) {
 800c866:	4b2b      	ldr	r3, [pc, #172]	; (800c914 <tcp_input+0x824>)
 800c868:	781b      	ldrb	r3, [r3, #0]
 800c86a:	001a      	movs	r2, r3
 800c86c:	2308      	movs	r3, #8
 800c86e:	4013      	ands	r3, r2
 800c870:	d018      	beq.n	800c8a4 <tcp_input+0x7b4>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_RST);
 800c872:	6a3b      	ldr	r3, [r7, #32]
 800c874:	2294      	movs	r2, #148	; 0x94
 800c876:	589b      	ldr	r3, [r3, r2]
 800c878:	2b00      	cmp	r3, #0
 800c87a:	d008      	beq.n	800c88e <tcp_input+0x79e>
 800c87c:	6a3b      	ldr	r3, [r7, #32]
 800c87e:	2294      	movs	r2, #148	; 0x94
 800c880:	589a      	ldr	r2, [r3, r2]
 800c882:	6a3b      	ldr	r3, [r7, #32]
 800c884:	695b      	ldr	r3, [r3, #20]
 800c886:	210e      	movs	r1, #14
 800c888:	4249      	negs	r1, r1
 800c88a:	0018      	movs	r0, r3
 800c88c:	4790      	blx	r2
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 800c88e:	6a3a      	ldr	r2, [r7, #32]
 800c890:	4b19      	ldr	r3, [pc, #100]	; (800c8f8 <tcp_input+0x808>)
 800c892:	0011      	movs	r1, r2
 800c894:	0018      	movs	r0, r3
 800c896:	f7ff fa91 	bl	800bdbc <tcp_pcb_remove>
        tcp_free(pcb);
 800c89a:	6a3b      	ldr	r3, [r7, #32]
 800c89c:	0018      	movs	r0, r3
 800c89e:	f7fd fd65 	bl	800a36c <tcp_free>
 800c8a2:	e0fb      	b.n	800ca9c <tcp_input+0x9ac>
      } else {
        err = ERR_OK;
 800c8a4:	2113      	movs	r1, #19
 800c8a6:	187b      	adds	r3, r7, r1
 800c8a8:	2200      	movs	r2, #0
 800c8aa:	701a      	strb	r2, [r3, #0]
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (recv_acked > 0) {
 800c8ac:	4b1a      	ldr	r3, [pc, #104]	; (800c918 <tcp_input+0x828>)
 800c8ae:	881b      	ldrh	r3, [r3, #0]
 800c8b0:	2b00      	cmp	r3, #0
 800c8b2:	d047      	beq.n	800c944 <tcp_input+0x854>
          while (acked > 0) {
            acked16 = (u16_t)LWIP_MIN(acked, 0xffffu);
            acked -= acked16;
#else
          {
            acked16 = recv_acked;
 800c8b4:	260a      	movs	r6, #10
 800c8b6:	19bb      	adds	r3, r7, r6
 800c8b8:	4a17      	ldr	r2, [pc, #92]	; (800c918 <tcp_input+0x828>)
 800c8ba:	8812      	ldrh	r2, [r2, #0]
 800c8bc:	801a      	strh	r2, [r3, #0]
#endif
            TCP_EVENT_SENT(pcb, (u16_t)acked16, err);
 800c8be:	6a3b      	ldr	r3, [r7, #32]
 800c8c0:	2284      	movs	r2, #132	; 0x84
 800c8c2:	589b      	ldr	r3, [r3, r2]
 800c8c4:	2b00      	cmp	r3, #0
 800c8c6:	d02f      	beq.n	800c928 <tcp_input+0x838>
 800c8c8:	6a3b      	ldr	r3, [r7, #32]
 800c8ca:	2284      	movs	r2, #132	; 0x84
 800c8cc:	589d      	ldr	r5, [r3, r2]
 800c8ce:	6a3b      	ldr	r3, [r7, #32]
 800c8d0:	6958      	ldr	r0, [r3, #20]
 800c8d2:	187c      	adds	r4, r7, r1
 800c8d4:	19bb      	adds	r3, r7, r6
 800c8d6:	881a      	ldrh	r2, [r3, #0]
 800c8d8:	6a3b      	ldr	r3, [r7, #32]
 800c8da:	0019      	movs	r1, r3
 800c8dc:	47a8      	blx	r5
 800c8de:	0003      	movs	r3, r0
 800c8e0:	7023      	strb	r3, [r4, #0]
 800c8e2:	e025      	b.n	800c930 <tcp_input+0x840>
 800c8e4:	20001370 	.word	0x20001370
 800c8e8:	200014c4 	.word	0x200014c4
 800c8ec:	0801f99c 	.word	0x0801f99c
 800c8f0:	0801fac0 	.word	0x0801fac0
 800c8f4:	0801f9dc 	.word	0x0801f9dc
 800c8f8:	20002b18 	.word	0x20002b18
 800c8fc:	0801faec 	.word	0x0801faec
 800c900:	20002b28 	.word	0x20002b28
 800c904:	0801fb18 	.word	0x0801fb18
 800c908:	20002b20 	.word	0x20002b20
 800c90c:	2000135c 	.word	0x2000135c
 800c910:	20001390 	.word	0x20001390
 800c914:	2000138d 	.word	0x2000138d
 800c918:	20001388 	.word	0x20001388
 800c91c:	2000138c 	.word	0x2000138c
 800c920:	2000138a 	.word	0x2000138a
 800c924:	20002b2c 	.word	0x20002b2c
 800c928:	2313      	movs	r3, #19
 800c92a:	18fb      	adds	r3, r7, r3
 800c92c:	2200      	movs	r2, #0
 800c92e:	701a      	strb	r2, [r3, #0]
            if (err == ERR_ABRT) {
 800c930:	2313      	movs	r3, #19
 800c932:	18fb      	adds	r3, r7, r3
 800c934:	781b      	ldrb	r3, [r3, #0]
 800c936:	b25b      	sxtb	r3, r3
 800c938:	330d      	adds	r3, #13
 800c93a:	d100      	bne.n	800c93e <tcp_input+0x84e>
 800c93c:	e0a5      	b.n	800ca8a <tcp_input+0x99a>
              goto aborted;
            }
          }
          recv_acked = 0;
 800c93e:	4b86      	ldr	r3, [pc, #536]	; (800cb58 <tcp_input+0xa68>)
 800c940:	2200      	movs	r2, #0
 800c942:	801a      	strh	r2, [r3, #0]
        }
        if (tcp_input_delayed_close(pcb)) {
 800c944:	6a3b      	ldr	r3, [r7, #32]
 800c946:	0018      	movs	r0, r3
 800c948:	f000 f922 	bl	800cb90 <tcp_input_delayed_close>
 800c94c:	1e03      	subs	r3, r0, #0
 800c94e:	d000      	beq.n	800c952 <tcp_input+0x862>
 800c950:	e09d      	b.n	800ca8e <tcp_input+0x99e>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
        while (recv_data != NULL) {
          struct pbuf *rest = NULL;
          pbuf_split_64k(recv_data, &rest);
#else /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
        if (recv_data != NULL) {
 800c952:	4b82      	ldr	r3, [pc, #520]	; (800cb5c <tcp_input+0xa6c>)
 800c954:	681b      	ldr	r3, [r3, #0]
 800c956:	2b00      	cmp	r3, #0
 800c958:	d048      	beq.n	800c9ec <tcp_input+0x8fc>
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */

          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
 800c95a:	6a3b      	ldr	r3, [r7, #32]
 800c95c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800c95e:	2b00      	cmp	r3, #0
 800c960:	d006      	beq.n	800c970 <tcp_input+0x880>
 800c962:	4b7f      	ldr	r3, [pc, #508]	; (800cb60 <tcp_input+0xa70>)
 800c964:	22f3      	movs	r2, #243	; 0xf3
 800c966:	0052      	lsls	r2, r2, #1
 800c968:	497e      	ldr	r1, [pc, #504]	; (800cb64 <tcp_input+0xa74>)
 800c96a:	487f      	ldr	r0, [pc, #508]	; (800cb68 <tcp_input+0xa78>)
 800c96c:	f7f5 fc2e 	bl	80021cc <app_debug_rtt_raw>
          if (pcb->flags & TF_RXCLOSED) {
 800c970:	6a3b      	ldr	r3, [r7, #32]
 800c972:	8bdb      	ldrh	r3, [r3, #30]
 800c974:	001a      	movs	r2, r3
 800c976:	2310      	movs	r3, #16
 800c978:	4013      	ands	r3, r2
 800c97a:	d009      	beq.n	800c990 <tcp_input+0x8a0>
            /* received data although already closed -> abort (send RST) to
               notify the remote host that not all data has been processed */
            pbuf_free(recv_data);
 800c97c:	4b77      	ldr	r3, [pc, #476]	; (800cb5c <tcp_input+0xa6c>)
 800c97e:	681b      	ldr	r3, [r3, #0]
 800c980:	0018      	movs	r0, r3
 800c982:	f7fc fe87 	bl	8009694 <pbuf_free>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
            if (rest != NULL) {
              pbuf_free(rest);
            }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            tcp_abort(pcb);
 800c986:	6a3b      	ldr	r3, [r7, #32]
 800c988:	0018      	movs	r0, r3
 800c98a:	f7fe f805 	bl	800a998 <tcp_abort>
            goto aborted;
 800c98e:	e085      	b.n	800ca9c <tcp_input+0x9ac>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 800c990:	6a3b      	ldr	r3, [r7, #32]
 800c992:	2288      	movs	r2, #136	; 0x88
 800c994:	589b      	ldr	r3, [r3, r2]
 800c996:	2b00      	cmp	r3, #0
 800c998:	d00e      	beq.n	800c9b8 <tcp_input+0x8c8>
 800c99a:	6a3b      	ldr	r3, [r7, #32]
 800c99c:	2288      	movs	r2, #136	; 0x88
 800c99e:	589d      	ldr	r5, [r3, r2]
 800c9a0:	6a3b      	ldr	r3, [r7, #32]
 800c9a2:	6958      	ldr	r0, [r3, #20]
 800c9a4:	4b6d      	ldr	r3, [pc, #436]	; (800cb5c <tcp_input+0xa6c>)
 800c9a6:	681a      	ldr	r2, [r3, #0]
 800c9a8:	2313      	movs	r3, #19
 800c9aa:	18fc      	adds	r4, r7, r3
 800c9ac:	6a39      	ldr	r1, [r7, #32]
 800c9ae:	2300      	movs	r3, #0
 800c9b0:	47a8      	blx	r5
 800c9b2:	0003      	movs	r3, r0
 800c9b4:	7023      	strb	r3, [r4, #0]
 800c9b6:	e00a      	b.n	800c9ce <tcp_input+0x8de>
 800c9b8:	4b68      	ldr	r3, [pc, #416]	; (800cb5c <tcp_input+0xa6c>)
 800c9ba:	681a      	ldr	r2, [r3, #0]
 800c9bc:	2313      	movs	r3, #19
 800c9be:	18fc      	adds	r4, r7, r3
 800c9c0:	6a39      	ldr	r1, [r7, #32]
 800c9c2:	2300      	movs	r3, #0
 800c9c4:	2000      	movs	r0, #0
 800c9c6:	f7fe ff31 	bl	800b82c <tcp_recv_null>
 800c9ca:	0003      	movs	r3, r0
 800c9cc:	7023      	strb	r3, [r4, #0]
          if (err == ERR_ABRT) {
 800c9ce:	2213      	movs	r2, #19
 800c9d0:	18bb      	adds	r3, r7, r2
 800c9d2:	781b      	ldrb	r3, [r3, #0]
 800c9d4:	b25b      	sxtb	r3, r3
 800c9d6:	330d      	adds	r3, #13
 800c9d8:	d05b      	beq.n	800ca92 <tcp_input+0x9a2>
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            goto aborted;
          }

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
 800c9da:	18bb      	adds	r3, r7, r2
 800c9dc:	781b      	ldrb	r3, [r3, #0]
 800c9de:	b25b      	sxtb	r3, r3
 800c9e0:	2b00      	cmp	r3, #0
 800c9e2:	d003      	beq.n	800c9ec <tcp_input+0x8fc>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
            if (rest != NULL) {
              pbuf_cat(recv_data, rest);
            }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            pcb->refused_data = recv_data;
 800c9e4:	4b5d      	ldr	r3, [pc, #372]	; (800cb5c <tcp_input+0xa6c>)
 800c9e6:	681a      	ldr	r2, [r3, #0]
 800c9e8:	6a3b      	ldr	r3, [r7, #32]
 800c9ea:	67da      	str	r2, [r3, #124]	; 0x7c
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
 800c9ec:	4b5f      	ldr	r3, [pc, #380]	; (800cb6c <tcp_input+0xa7c>)
 800c9ee:	781b      	ldrb	r3, [r3, #0]
 800c9f0:	001a      	movs	r2, r3
 800c9f2:	2320      	movs	r3, #32
 800c9f4:	4013      	ands	r3, r2
 800c9f6:	d036      	beq.n	800ca66 <tcp_input+0x976>
          if (pcb->refused_data != NULL) {
 800c9f8:	6a3b      	ldr	r3, [r7, #32]
 800c9fa:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800c9fc:	2b00      	cmp	r3, #0
 800c9fe:	d009      	beq.n	800ca14 <tcp_input+0x924>
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
 800ca00:	6a3b      	ldr	r3, [r7, #32]
 800ca02:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800ca04:	7b5a      	ldrb	r2, [r3, #13]
 800ca06:	6a3b      	ldr	r3, [r7, #32]
 800ca08:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800ca0a:	2120      	movs	r1, #32
 800ca0c:	430a      	orrs	r2, r1
 800ca0e:	b2d2      	uxtb	r2, r2
 800ca10:	735a      	strb	r2, [r3, #13]
 800ca12:	e028      	b.n	800ca66 <tcp_input+0x976>
          } else {
            /* correct rcv_wnd as the application won't call tcp_recved()
               for the FIN's seqno */
            if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 800ca14:	6a3b      	ldr	r3, [r7, #32]
 800ca16:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800ca18:	2386      	movs	r3, #134	; 0x86
 800ca1a:	00db      	lsls	r3, r3, #3
 800ca1c:	429a      	cmp	r2, r3
 800ca1e:	d005      	beq.n	800ca2c <tcp_input+0x93c>
              pcb->rcv_wnd++;
 800ca20:	6a3b      	ldr	r3, [r7, #32]
 800ca22:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800ca24:	3301      	adds	r3, #1
 800ca26:	b29a      	uxth	r2, r3
 800ca28:	6a3b      	ldr	r3, [r7, #32]
 800ca2a:	859a      	strh	r2, [r3, #44]	; 0x2c
            }
            TCP_EVENT_CLOSED(pcb, err);
 800ca2c:	6a3b      	ldr	r3, [r7, #32]
 800ca2e:	2288      	movs	r2, #136	; 0x88
 800ca30:	589b      	ldr	r3, [r3, r2]
 800ca32:	2b00      	cmp	r3, #0
 800ca34:	d00d      	beq.n	800ca52 <tcp_input+0x962>
 800ca36:	6a3b      	ldr	r3, [r7, #32]
 800ca38:	2288      	movs	r2, #136	; 0x88
 800ca3a:	589d      	ldr	r5, [r3, r2]
 800ca3c:	6a3b      	ldr	r3, [r7, #32]
 800ca3e:	6958      	ldr	r0, [r3, #20]
 800ca40:	2313      	movs	r3, #19
 800ca42:	18fc      	adds	r4, r7, r3
 800ca44:	6a39      	ldr	r1, [r7, #32]
 800ca46:	2300      	movs	r3, #0
 800ca48:	2200      	movs	r2, #0
 800ca4a:	47a8      	blx	r5
 800ca4c:	0003      	movs	r3, r0
 800ca4e:	7023      	strb	r3, [r4, #0]
 800ca50:	e003      	b.n	800ca5a <tcp_input+0x96a>
 800ca52:	2313      	movs	r3, #19
 800ca54:	18fb      	adds	r3, r7, r3
 800ca56:	2200      	movs	r2, #0
 800ca58:	701a      	strb	r2, [r3, #0]
            if (err == ERR_ABRT) {
 800ca5a:	2313      	movs	r3, #19
 800ca5c:	18fb      	adds	r3, r7, r3
 800ca5e:	781b      	ldrb	r3, [r3, #0]
 800ca60:	b25b      	sxtb	r3, r3
 800ca62:	330d      	adds	r3, #13
 800ca64:	d017      	beq.n	800ca96 <tcp_input+0x9a6>
              goto aborted;
            }
          }
        }

        tcp_input_pcb = NULL;
 800ca66:	4b42      	ldr	r3, [pc, #264]	; (800cb70 <tcp_input+0xa80>)
 800ca68:	2200      	movs	r2, #0
 800ca6a:	601a      	str	r2, [r3, #0]
        if (tcp_input_delayed_close(pcb)) {
 800ca6c:	6a3b      	ldr	r3, [r7, #32]
 800ca6e:	0018      	movs	r0, r3
 800ca70:	f000 f88e 	bl	800cb90 <tcp_input_delayed_close>
 800ca74:	1e03      	subs	r3, r0, #0
 800ca76:	d110      	bne.n	800ca9a <tcp_input+0x9aa>
          goto aborted;
        }
        /* Try to send something out. */
        tcp_output(pcb);
 800ca78:	6a3b      	ldr	r3, [r7, #32]
 800ca7a:	0018      	movs	r0, r3
 800ca7c:	f003 fd80 	bl	8010580 <tcp_output>
 800ca80:	e00c      	b.n	800ca9c <tcp_input+0x9ac>
        goto aborted;
 800ca82:	46c0      	nop			; (mov r8, r8)
 800ca84:	e00a      	b.n	800ca9c <tcp_input+0x9ac>
#endif /* TCP_INPUT_DEBUG */
      }
    }
    /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
       Below this line, 'pcb' may not be dereferenced! */
aborted:
 800ca86:	46c0      	nop			; (mov r8, r8)
 800ca88:	e008      	b.n	800ca9c <tcp_input+0x9ac>
              goto aborted;
 800ca8a:	46c0      	nop			; (mov r8, r8)
 800ca8c:	e006      	b.n	800ca9c <tcp_input+0x9ac>
          goto aborted;
 800ca8e:	46c0      	nop			; (mov r8, r8)
 800ca90:	e004      	b.n	800ca9c <tcp_input+0x9ac>
            goto aborted;
 800ca92:	46c0      	nop			; (mov r8, r8)
 800ca94:	e002      	b.n	800ca9c <tcp_input+0x9ac>
              goto aborted;
 800ca96:	46c0      	nop			; (mov r8, r8)
 800ca98:	e000      	b.n	800ca9c <tcp_input+0x9ac>
          goto aborted;
 800ca9a:	46c0      	nop			; (mov r8, r8)
    tcp_input_pcb = NULL;
 800ca9c:	4b34      	ldr	r3, [pc, #208]	; (800cb70 <tcp_input+0xa80>)
 800ca9e:	2200      	movs	r2, #0
 800caa0:	601a      	str	r2, [r3, #0]
    recv_data = NULL;
 800caa2:	4b2e      	ldr	r3, [pc, #184]	; (800cb5c <tcp_input+0xa6c>)
 800caa4:	2200      	movs	r2, #0
 800caa6:	601a      	str	r2, [r3, #0]

    /* give up our reference to inseg.p */
    if (inseg.p != NULL) {
 800caa8:	4b32      	ldr	r3, [pc, #200]	; (800cb74 <tcp_input+0xa84>)
 800caaa:	685b      	ldr	r3, [r3, #4]
 800caac:	2b00      	cmp	r3, #0
 800caae:	d04e      	beq.n	800cb4e <tcp_input+0xa5e>
      pbuf_free(inseg.p);
 800cab0:	4b30      	ldr	r3, [pc, #192]	; (800cb74 <tcp_input+0xa84>)
 800cab2:	685b      	ldr	r3, [r3, #4]
 800cab4:	0018      	movs	r0, r3
 800cab6:	f7fc fded 	bl	8009694 <pbuf_free>
      inseg.p = NULL;
 800caba:	4b2e      	ldr	r3, [pc, #184]	; (800cb74 <tcp_input+0xa84>)
 800cabc:	2200      	movs	r2, #0
 800cabe:	605a      	str	r2, [r3, #4]
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
 800cac0:	e045      	b.n	800cb4e <tcp_input+0xa5e>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 800cac2:	4b2d      	ldr	r3, [pc, #180]	; (800cb78 <tcp_input+0xa88>)
 800cac4:	681b      	ldr	r3, [r3, #0]
 800cac6:	7b1a      	ldrb	r2, [r3, #12]
 800cac8:	7b5b      	ldrb	r3, [r3, #13]
 800caca:	021b      	lsls	r3, r3, #8
 800cacc:	4313      	orrs	r3, r2
 800cace:	b29b      	uxth	r3, r3
 800cad0:	0018      	movs	r0, r3
 800cad2:	f7f9 fd2f 	bl	8006534 <lwip_htons>
 800cad6:	0003      	movs	r3, r0
 800cad8:	b2db      	uxtb	r3, r3
 800cada:	001a      	movs	r2, r3
 800cadc:	2304      	movs	r3, #4
 800cade:	4013      	ands	r3, r2
 800cae0:	d120      	bne.n	800cb24 <tcp_input+0xa34>
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
 800cae2:	4b26      	ldr	r3, [pc, #152]	; (800cb7c <tcp_input+0xa8c>)
 800cae4:	6818      	ldr	r0, [r3, #0]
 800cae6:	4b26      	ldr	r3, [pc, #152]	; (800cb80 <tcp_input+0xa90>)
 800cae8:	881b      	ldrh	r3, [r3, #0]
 800caea:	001a      	movs	r2, r3
 800caec:	4b25      	ldr	r3, [pc, #148]	; (800cb84 <tcp_input+0xa94>)
 800caee:	681b      	ldr	r3, [r3, #0]
 800caf0:	18d4      	adds	r4, r2, r3
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800caf2:	4b21      	ldr	r3, [pc, #132]	; (800cb78 <tcp_input+0xa88>)
 800caf4:	681b      	ldr	r3, [r3, #0]
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
 800caf6:	789a      	ldrb	r2, [r3, #2]
 800caf8:	78db      	ldrb	r3, [r3, #3]
 800cafa:	021b      	lsls	r3, r3, #8
 800cafc:	4313      	orrs	r3, r2
 800cafe:	b29a      	uxth	r2, r3
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800cb00:	4b1d      	ldr	r3, [pc, #116]	; (800cb78 <tcp_input+0xa88>)
 800cb02:	681b      	ldr	r3, [r3, #0]
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
 800cb04:	7819      	ldrb	r1, [r3, #0]
 800cb06:	785b      	ldrb	r3, [r3, #1]
 800cb08:	021b      	lsls	r3, r3, #8
 800cb0a:	430b      	orrs	r3, r1
 800cb0c:	b29b      	uxth	r3, r3
 800cb0e:	491e      	ldr	r1, [pc, #120]	; (800cb88 <tcp_input+0xa98>)
 800cb10:	9302      	str	r3, [sp, #8]
 800cb12:	9201      	str	r2, [sp, #4]
 800cb14:	4b1d      	ldr	r3, [pc, #116]	; (800cb8c <tcp_input+0xa9c>)
 800cb16:	9300      	str	r3, [sp, #0]
 800cb18:	000b      	movs	r3, r1
 800cb1a:	0022      	movs	r2, r4
 800cb1c:	0001      	movs	r1, r0
 800cb1e:	2000      	movs	r0, #0
 800cb20:	f004 fd82 	bl	8011628 <tcp_rst>
    pbuf_free(p);
 800cb24:	687b      	ldr	r3, [r7, #4]
 800cb26:	0018      	movs	r0, r3
 800cb28:	f7fc fdb4 	bl	8009694 <pbuf_free>
  return;
 800cb2c:	e00f      	b.n	800cb4e <tcp_input+0xa5e>
    goto dropped;
 800cb2e:	46c0      	nop			; (mov r8, r8)
 800cb30:	e008      	b.n	800cb44 <tcp_input+0xa54>
    goto dropped;
 800cb32:	46c0      	nop			; (mov r8, r8)
 800cb34:	e006      	b.n	800cb44 <tcp_input+0xa54>
      goto dropped;
 800cb36:	46c0      	nop			; (mov r8, r8)
 800cb38:	e004      	b.n	800cb44 <tcp_input+0xa54>
    goto dropped;
 800cb3a:	46c0      	nop			; (mov r8, r8)
 800cb3c:	e002      	b.n	800cb44 <tcp_input+0xa54>
      goto dropped;
 800cb3e:	46c0      	nop			; (mov r8, r8)
 800cb40:	e000      	b.n	800cb44 <tcp_input+0xa54>
      goto dropped;
 800cb42:	46c0      	nop			; (mov r8, r8)
dropped:
  TCP_STATS_INC(tcp.drop);
  MIB2_STATS_INC(mib2.tcpinerrs);
  pbuf_free(p);
 800cb44:	687b      	ldr	r3, [r7, #4]
 800cb46:	0018      	movs	r0, r3
 800cb48:	f7fc fda4 	bl	8009694 <pbuf_free>
 800cb4c:	e000      	b.n	800cb50 <tcp_input+0xa60>
  return;
 800cb4e:	46c0      	nop			; (mov r8, r8)
}
 800cb50:	46bd      	mov	sp, r7
 800cb52:	b00b      	add	sp, #44	; 0x2c
 800cb54:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800cb56:	46c0      	nop			; (mov r8, r8)
 800cb58:	20001388 	.word	0x20001388
 800cb5c:	20001390 	.word	0x20001390
 800cb60:	0801f99c 	.word	0x0801f99c
 800cb64:	0801fb48 	.word	0x0801fb48
 800cb68:	0801f9dc 	.word	0x0801f9dc
 800cb6c:	2000138d 	.word	0x2000138d
 800cb70:	20002b2c 	.word	0x20002b2c
 800cb74:	2000135c 	.word	0x2000135c
 800cb78:	20001370 	.word	0x20001370
 800cb7c:	20001384 	.word	0x20001384
 800cb80:	2000138a 	.word	0x2000138a
 800cb84:	20001380 	.word	0x20001380
 800cb88:	200014d8 	.word	0x200014d8
 800cb8c:	200014d4 	.word	0x200014d4

0800cb90 <tcp_input_delayed_close>:
 * any more.
 * @returns 1 if the pcb has been closed and deallocated, 0 otherwise
 */
static int
tcp_input_delayed_close(struct tcp_pcb *pcb)
{
 800cb90:	b580      	push	{r7, lr}
 800cb92:	b082      	sub	sp, #8
 800cb94:	af00      	add	r7, sp, #0
 800cb96:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_input_delayed_close: invalid pcb", pcb != NULL);
 800cb98:	687b      	ldr	r3, [r7, #4]
 800cb9a:	2b00      	cmp	r3, #0
 800cb9c:	d105      	bne.n	800cbaa <tcp_input_delayed_close+0x1a>
 800cb9e:	4b18      	ldr	r3, [pc, #96]	; (800cc00 <tcp_input_delayed_close+0x70>)
 800cba0:	4a18      	ldr	r2, [pc, #96]	; (800cc04 <tcp_input_delayed_close+0x74>)
 800cba2:	4919      	ldr	r1, [pc, #100]	; (800cc08 <tcp_input_delayed_close+0x78>)
 800cba4:	4819      	ldr	r0, [pc, #100]	; (800cc0c <tcp_input_delayed_close+0x7c>)
 800cba6:	f7f5 fb11 	bl	80021cc <app_debug_rtt_raw>

  if (recv_flags & TF_CLOSED) {
 800cbaa:	4b19      	ldr	r3, [pc, #100]	; (800cc10 <tcp_input_delayed_close+0x80>)
 800cbac:	781b      	ldrb	r3, [r3, #0]
 800cbae:	001a      	movs	r2, r3
 800cbb0:	2310      	movs	r3, #16
 800cbb2:	4013      	ands	r3, r2
 800cbb4:	d01f      	beq.n	800cbf6 <tcp_input_delayed_close+0x66>
    /* The connection has been closed and we will deallocate the
        PCB. */
    if (!(pcb->flags & TF_RXCLOSED)) {
 800cbb6:	687b      	ldr	r3, [r7, #4]
 800cbb8:	8bdb      	ldrh	r3, [r3, #30]
 800cbba:	001a      	movs	r2, r3
 800cbbc:	2310      	movs	r3, #16
 800cbbe:	4013      	ands	r3, r2
 800cbc0:	d10d      	bne.n	800cbde <tcp_input_delayed_close+0x4e>
      /* Connection closed although the application has only shut down the
          tx side: call the PCB's err callback and indicate the closure to
          ensure the application doesn't continue using the PCB. */
      TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_CLSD);
 800cbc2:	687b      	ldr	r3, [r7, #4]
 800cbc4:	2294      	movs	r2, #148	; 0x94
 800cbc6:	589b      	ldr	r3, [r3, r2]
 800cbc8:	2b00      	cmp	r3, #0
 800cbca:	d008      	beq.n	800cbde <tcp_input_delayed_close+0x4e>
 800cbcc:	687b      	ldr	r3, [r7, #4]
 800cbce:	2294      	movs	r2, #148	; 0x94
 800cbd0:	589a      	ldr	r2, [r3, r2]
 800cbd2:	687b      	ldr	r3, [r7, #4]
 800cbd4:	695b      	ldr	r3, [r3, #20]
 800cbd6:	210f      	movs	r1, #15
 800cbd8:	4249      	negs	r1, r1
 800cbda:	0018      	movs	r0, r3
 800cbdc:	4790      	blx	r2
    }
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
 800cbde:	687a      	ldr	r2, [r7, #4]
 800cbe0:	4b0c      	ldr	r3, [pc, #48]	; (800cc14 <tcp_input_delayed_close+0x84>)
 800cbe2:	0011      	movs	r1, r2
 800cbe4:	0018      	movs	r0, r3
 800cbe6:	f7ff f8e9 	bl	800bdbc <tcp_pcb_remove>
    tcp_free(pcb);
 800cbea:	687b      	ldr	r3, [r7, #4]
 800cbec:	0018      	movs	r0, r3
 800cbee:	f7fd fbbd 	bl	800a36c <tcp_free>
    return 1;
 800cbf2:	2301      	movs	r3, #1
 800cbf4:	e000      	b.n	800cbf8 <tcp_input_delayed_close+0x68>
  }
  return 0;
 800cbf6:	2300      	movs	r3, #0
}
 800cbf8:	0018      	movs	r0, r3
 800cbfa:	46bd      	mov	sp, r7
 800cbfc:	b002      	add	sp, #8
 800cbfe:	bd80      	pop	{r7, pc}
 800cc00:	0801f99c 	.word	0x0801f99c
 800cc04:	0000025a 	.word	0x0000025a
 800cc08:	0801fb64 	.word	0x0801fb64
 800cc0c:	0801f9dc 	.word	0x0801f9dc
 800cc10:	2000138d 	.word	0x2000138d
 800cc14:	20002b18 	.word	0x20002b18

0800cc18 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static void
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
 800cc18:	b5b0      	push	{r4, r5, r7, lr}
 800cc1a:	b08a      	sub	sp, #40	; 0x28
 800cc1c:	af04      	add	r7, sp, #16
 800cc1e:	6078      	str	r0, [r7, #4]
  struct tcp_pcb *npcb;
  u32_t iss;
  err_t rc;

  if (flags & TCP_RST) {
 800cc20:	4b7d      	ldr	r3, [pc, #500]	; (800ce18 <tcp_listen_input+0x200>)
 800cc22:	781b      	ldrb	r3, [r3, #0]
 800cc24:	001a      	movs	r2, r3
 800cc26:	2304      	movs	r3, #4
 800cc28:	4013      	ands	r3, r2
 800cc2a:	d000      	beq.n	800cc2e <tcp_listen_input+0x16>
 800cc2c:	e0ee      	b.n	800ce0c <tcp_listen_input+0x1f4>
    /* An incoming RST should be ignored. Return. */
    return;
  }

  LWIP_ASSERT("tcp_listen_input: invalid pcb", pcb != NULL);
 800cc2e:	687b      	ldr	r3, [r7, #4]
 800cc30:	2b00      	cmp	r3, #0
 800cc32:	d105      	bne.n	800cc40 <tcp_listen_input+0x28>
 800cc34:	4b79      	ldr	r3, [pc, #484]	; (800ce1c <tcp_listen_input+0x204>)
 800cc36:	4a7a      	ldr	r2, [pc, #488]	; (800ce20 <tcp_listen_input+0x208>)
 800cc38:	497a      	ldr	r1, [pc, #488]	; (800ce24 <tcp_listen_input+0x20c>)
 800cc3a:	487b      	ldr	r0, [pc, #492]	; (800ce28 <tcp_listen_input+0x210>)
 800cc3c:	f7f5 fac6 	bl	80021cc <app_debug_rtt_raw>

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
 800cc40:	4b75      	ldr	r3, [pc, #468]	; (800ce18 <tcp_listen_input+0x200>)
 800cc42:	781b      	ldrb	r3, [r3, #0]
 800cc44:	001a      	movs	r2, r3
 800cc46:	2310      	movs	r3, #16
 800cc48:	4013      	ands	r3, r2
 800cc4a:	d021      	beq.n	800cc90 <tcp_listen_input+0x78>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800cc4c:	4b77      	ldr	r3, [pc, #476]	; (800ce2c <tcp_listen_input+0x214>)
 800cc4e:	681c      	ldr	r4, [r3, #0]
 800cc50:	4b77      	ldr	r3, [pc, #476]	; (800ce30 <tcp_listen_input+0x218>)
 800cc52:	881b      	ldrh	r3, [r3, #0]
 800cc54:	001a      	movs	r2, r3
 800cc56:	4b77      	ldr	r3, [pc, #476]	; (800ce34 <tcp_listen_input+0x21c>)
 800cc58:	681b      	ldr	r3, [r3, #0]
 800cc5a:	18d5      	adds	r5, r2, r3
            ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800cc5c:	4b76      	ldr	r3, [pc, #472]	; (800ce38 <tcp_listen_input+0x220>)
 800cc5e:	681b      	ldr	r3, [r3, #0]
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800cc60:	789a      	ldrb	r2, [r3, #2]
 800cc62:	78db      	ldrb	r3, [r3, #3]
 800cc64:	021b      	lsls	r3, r3, #8
 800cc66:	4313      	orrs	r3, r2
 800cc68:	b29a      	uxth	r2, r3
            ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800cc6a:	4b73      	ldr	r3, [pc, #460]	; (800ce38 <tcp_listen_input+0x220>)
 800cc6c:	681b      	ldr	r3, [r3, #0]
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800cc6e:	7819      	ldrb	r1, [r3, #0]
 800cc70:	785b      	ldrb	r3, [r3, #1]
 800cc72:	021b      	lsls	r3, r3, #8
 800cc74:	430b      	orrs	r3, r1
 800cc76:	b29b      	uxth	r3, r3
 800cc78:	4970      	ldr	r1, [pc, #448]	; (800ce3c <tcp_listen_input+0x224>)
 800cc7a:	6878      	ldr	r0, [r7, #4]
 800cc7c:	9302      	str	r3, [sp, #8]
 800cc7e:	9201      	str	r2, [sp, #4]
 800cc80:	4b6f      	ldr	r3, [pc, #444]	; (800ce40 <tcp_listen_input+0x228>)
 800cc82:	9300      	str	r3, [sp, #0]
 800cc84:	000b      	movs	r3, r1
 800cc86:	002a      	movs	r2, r5
 800cc88:	0021      	movs	r1, r4
 800cc8a:	f004 fccd 	bl	8011628 <tcp_rst>
      tcp_abandon(npcb, 0);
      return;
    }
    tcp_output(npcb);
  }
  return;
 800cc8e:	e0bf      	b.n	800ce10 <tcp_listen_input+0x1f8>
  } else if (flags & TCP_SYN) {
 800cc90:	4b61      	ldr	r3, [pc, #388]	; (800ce18 <tcp_listen_input+0x200>)
 800cc92:	781b      	ldrb	r3, [r3, #0]
 800cc94:	001a      	movs	r2, r3
 800cc96:	2302      	movs	r3, #2
 800cc98:	4013      	ands	r3, r2
 800cc9a:	d100      	bne.n	800cc9e <tcp_listen_input+0x86>
 800cc9c:	e0b8      	b.n	800ce10 <tcp_listen_input+0x1f8>
    npcb = tcp_alloc(pcb->prio);
 800cc9e:	687b      	ldr	r3, [r7, #4]
 800cca0:	7e5b      	ldrb	r3, [r3, #25]
 800cca2:	0018      	movs	r0, r3
 800cca4:	f7fe fefa 	bl	800ba9c <tcp_alloc>
 800cca8:	0003      	movs	r3, r0
 800ccaa:	617b      	str	r3, [r7, #20]
    if (npcb == NULL) {
 800ccac:	697b      	ldr	r3, [r7, #20]
 800ccae:	2b00      	cmp	r3, #0
 800ccb0:	d116      	bne.n	800cce0 <tcp_listen_input+0xc8>
      TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
 800ccb2:	687b      	ldr	r3, [r7, #4]
 800ccb4:	69db      	ldr	r3, [r3, #28]
 800ccb6:	2b00      	cmp	r3, #0
 800ccb8:	d00d      	beq.n	800ccd6 <tcp_listen_input+0xbe>
 800ccba:	687b      	ldr	r3, [r7, #4]
 800ccbc:	69dd      	ldr	r5, [r3, #28]
 800ccbe:	687b      	ldr	r3, [r7, #4]
 800ccc0:	695b      	ldr	r3, [r3, #20]
 800ccc2:	220e      	movs	r2, #14
 800ccc4:	18bc      	adds	r4, r7, r2
 800ccc6:	2201      	movs	r2, #1
 800ccc8:	4252      	negs	r2, r2
 800ccca:	2100      	movs	r1, #0
 800cccc:	0018      	movs	r0, r3
 800ccce:	47a8      	blx	r5
 800ccd0:	0003      	movs	r3, r0
 800ccd2:	7023      	strb	r3, [r4, #0]
      return;
 800ccd4:	e09d      	b.n	800ce12 <tcp_listen_input+0x1fa>
      TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
 800ccd6:	230e      	movs	r3, #14
 800ccd8:	18fb      	adds	r3, r7, r3
 800ccda:	22f0      	movs	r2, #240	; 0xf0
 800ccdc:	701a      	strb	r2, [r3, #0]
      return;
 800ccde:	e098      	b.n	800ce12 <tcp_listen_input+0x1fa>
    ip_addr_copy(npcb->local_ip, *ip_current_dest_addr());
 800cce0:	4b58      	ldr	r3, [pc, #352]	; (800ce44 <tcp_listen_input+0x22c>)
 800cce2:	695a      	ldr	r2, [r3, #20]
 800cce4:	697b      	ldr	r3, [r7, #20]
 800cce6:	601a      	str	r2, [r3, #0]
    ip_addr_copy(npcb->remote_ip, *ip_current_src_addr());
 800cce8:	4b56      	ldr	r3, [pc, #344]	; (800ce44 <tcp_listen_input+0x22c>)
 800ccea:	691a      	ldr	r2, [r3, #16]
 800ccec:	697b      	ldr	r3, [r7, #20]
 800ccee:	605a      	str	r2, [r3, #4]
    npcb->local_port = pcb->local_port;
 800ccf0:	687b      	ldr	r3, [r7, #4]
 800ccf2:	8b5a      	ldrh	r2, [r3, #26]
 800ccf4:	697b      	ldr	r3, [r7, #20]
 800ccf6:	835a      	strh	r2, [r3, #26]
    npcb->remote_port = tcphdr->src;
 800ccf8:	4b4f      	ldr	r3, [pc, #316]	; (800ce38 <tcp_listen_input+0x220>)
 800ccfa:	681b      	ldr	r3, [r3, #0]
 800ccfc:	781a      	ldrb	r2, [r3, #0]
 800ccfe:	785b      	ldrb	r3, [r3, #1]
 800cd00:	021b      	lsls	r3, r3, #8
 800cd02:	4313      	orrs	r3, r2
 800cd04:	b29a      	uxth	r2, r3
 800cd06:	697b      	ldr	r3, [r7, #20]
 800cd08:	839a      	strh	r2, [r3, #28]
    npcb->state = SYN_RCVD;
 800cd0a:	697b      	ldr	r3, [r7, #20]
 800cd0c:	2203      	movs	r2, #3
 800cd0e:	761a      	strb	r2, [r3, #24]
    npcb->rcv_nxt = seqno + 1;
 800cd10:	4b48      	ldr	r3, [pc, #288]	; (800ce34 <tcp_listen_input+0x21c>)
 800cd12:	681b      	ldr	r3, [r3, #0]
 800cd14:	1c5a      	adds	r2, r3, #1
 800cd16:	697b      	ldr	r3, [r7, #20]
 800cd18:	629a      	str	r2, [r3, #40]	; 0x28
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 800cd1a:	697b      	ldr	r3, [r7, #20]
 800cd1c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800cd1e:	697b      	ldr	r3, [r7, #20]
 800cd20:	631a      	str	r2, [r3, #48]	; 0x30
    iss = tcp_next_iss(npcb);
 800cd22:	697b      	ldr	r3, [r7, #20]
 800cd24:	0018      	movs	r0, r3
 800cd26:	f7ff f8e3 	bl	800bef0 <tcp_next_iss>
 800cd2a:	0003      	movs	r3, r0
 800cd2c:	613b      	str	r3, [r7, #16]
    npcb->snd_wl2 = iss;
 800cd2e:	697b      	ldr	r3, [r7, #20]
 800cd30:	693a      	ldr	r2, [r7, #16]
 800cd32:	65da      	str	r2, [r3, #92]	; 0x5c
    npcb->snd_nxt = iss;
 800cd34:	697b      	ldr	r3, [r7, #20]
 800cd36:	693a      	ldr	r2, [r7, #16]
 800cd38:	655a      	str	r2, [r3, #84]	; 0x54
    npcb->lastack = iss;
 800cd3a:	697b      	ldr	r3, [r7, #20]
 800cd3c:	693a      	ldr	r2, [r7, #16]
 800cd3e:	649a      	str	r2, [r3, #72]	; 0x48
    npcb->snd_lbb = iss;
 800cd40:	697b      	ldr	r3, [r7, #20]
 800cd42:	693a      	ldr	r2, [r7, #16]
 800cd44:	661a      	str	r2, [r3, #96]	; 0x60
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 800cd46:	4b3b      	ldr	r3, [pc, #236]	; (800ce34 <tcp_listen_input+0x21c>)
 800cd48:	681b      	ldr	r3, [r3, #0]
 800cd4a:	1e5a      	subs	r2, r3, #1
 800cd4c:	697b      	ldr	r3, [r7, #20]
 800cd4e:	659a      	str	r2, [r3, #88]	; 0x58
    npcb->callback_arg = pcb->callback_arg;
 800cd50:	687b      	ldr	r3, [r7, #4]
 800cd52:	695a      	ldr	r2, [r3, #20]
 800cd54:	697b      	ldr	r3, [r7, #20]
 800cd56:	615a      	str	r2, [r3, #20]
    npcb->listener = pcb;
 800cd58:	697b      	ldr	r3, [r7, #20]
 800cd5a:	2180      	movs	r1, #128	; 0x80
 800cd5c:	687a      	ldr	r2, [r7, #4]
 800cd5e:	505a      	str	r2, [r3, r1]
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 800cd60:	687b      	ldr	r3, [r7, #4]
 800cd62:	7a5b      	ldrb	r3, [r3, #9]
 800cd64:	220c      	movs	r2, #12
 800cd66:	4013      	ands	r3, r2
 800cd68:	b2da      	uxtb	r2, r3
 800cd6a:	697b      	ldr	r3, [r7, #20]
 800cd6c:	725a      	strb	r2, [r3, #9]
    npcb->netif_idx = pcb->netif_idx;
 800cd6e:	687b      	ldr	r3, [r7, #4]
 800cd70:	7a1a      	ldrb	r2, [r3, #8]
 800cd72:	697b      	ldr	r3, [r7, #20]
 800cd74:	721a      	strb	r2, [r3, #8]
    TCP_REG_ACTIVE(npcb);
 800cd76:	4b34      	ldr	r3, [pc, #208]	; (800ce48 <tcp_listen_input+0x230>)
 800cd78:	681a      	ldr	r2, [r3, #0]
 800cd7a:	697b      	ldr	r3, [r7, #20]
 800cd7c:	611a      	str	r2, [r3, #16]
 800cd7e:	4b32      	ldr	r3, [pc, #200]	; (800ce48 <tcp_listen_input+0x230>)
 800cd80:	697a      	ldr	r2, [r7, #20]
 800cd82:	601a      	str	r2, [r3, #0]
 800cd84:	f004 fe7a 	bl	8011a7c <tcp_timer_needed>
 800cd88:	4b30      	ldr	r3, [pc, #192]	; (800ce4c <tcp_listen_input+0x234>)
 800cd8a:	2201      	movs	r2, #1
 800cd8c:	701a      	strb	r2, [r3, #0]
    tcp_parseopt(npcb);
 800cd8e:	697b      	ldr	r3, [r7, #20]
 800cd90:	0018      	movs	r0, r3
 800cd92:	f001 ffbf 	bl	800ed14 <tcp_parseopt>
    npcb->snd_wnd = tcphdr->wnd;
 800cd96:	4b28      	ldr	r3, [pc, #160]	; (800ce38 <tcp_listen_input+0x220>)
 800cd98:	681b      	ldr	r3, [r3, #0]
 800cd9a:	7b9a      	ldrb	r2, [r3, #14]
 800cd9c:	7bdb      	ldrb	r3, [r3, #15]
 800cd9e:	021b      	lsls	r3, r3, #8
 800cda0:	4313      	orrs	r3, r2
 800cda2:	b299      	uxth	r1, r3
 800cda4:	697b      	ldr	r3, [r7, #20]
 800cda6:	2264      	movs	r2, #100	; 0x64
 800cda8:	5299      	strh	r1, [r3, r2]
    npcb->snd_wnd_max = npcb->snd_wnd;
 800cdaa:	697b      	ldr	r3, [r7, #20]
 800cdac:	2264      	movs	r2, #100	; 0x64
 800cdae:	5a99      	ldrh	r1, [r3, r2]
 800cdb0:	697b      	ldr	r3, [r7, #20]
 800cdb2:	2266      	movs	r2, #102	; 0x66
 800cdb4:	5299      	strh	r1, [r3, r2]
    npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip, &npcb->remote_ip);
 800cdb6:	697b      	ldr	r3, [r7, #20]
 800cdb8:	8edc      	ldrh	r4, [r3, #54]	; 0x36
 800cdba:	697b      	ldr	r3, [r7, #20]
 800cdbc:	3304      	adds	r3, #4
 800cdbe:	0018      	movs	r0, r3
 800cdc0:	f006 f874 	bl	8012eac <ip4_route>
 800cdc4:	0001      	movs	r1, r0
 800cdc6:	697b      	ldr	r3, [r7, #20]
 800cdc8:	3304      	adds	r3, #4
 800cdca:	001a      	movs	r2, r3
 800cdcc:	0020      	movs	r0, r4
 800cdce:	f7ff f8b5 	bl	800bf3c <tcp_eff_send_mss_netif>
 800cdd2:	0003      	movs	r3, r0
 800cdd4:	001a      	movs	r2, r3
 800cdd6:	697b      	ldr	r3, [r7, #20]
 800cdd8:	86da      	strh	r2, [r3, #54]	; 0x36
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 800cdda:	250f      	movs	r5, #15
 800cddc:	197c      	adds	r4, r7, r5
 800cdde:	697b      	ldr	r3, [r7, #20]
 800cde0:	2112      	movs	r1, #18
 800cde2:	0018      	movs	r0, r3
 800cde4:	f003 fac6 	bl	8010374 <tcp_enqueue_flags>
 800cde8:	0003      	movs	r3, r0
 800cdea:	7023      	strb	r3, [r4, #0]
    if (rc != ERR_OK) {
 800cdec:	197b      	adds	r3, r7, r5
 800cdee:	781b      	ldrb	r3, [r3, #0]
 800cdf0:	b25b      	sxtb	r3, r3
 800cdf2:	2b00      	cmp	r3, #0
 800cdf4:	d005      	beq.n	800ce02 <tcp_listen_input+0x1ea>
      tcp_abandon(npcb, 0);
 800cdf6:	697b      	ldr	r3, [r7, #20]
 800cdf8:	2100      	movs	r1, #0
 800cdfa:	0018      	movs	r0, r3
 800cdfc:	f7fd fd02 	bl	800a804 <tcp_abandon>
      return;
 800ce00:	e007      	b.n	800ce12 <tcp_listen_input+0x1fa>
    tcp_output(npcb);
 800ce02:	697b      	ldr	r3, [r7, #20]
 800ce04:	0018      	movs	r0, r3
 800ce06:	f003 fbbb 	bl	8010580 <tcp_output>
  return;
 800ce0a:	e001      	b.n	800ce10 <tcp_listen_input+0x1f8>
    return;
 800ce0c:	46c0      	nop			; (mov r8, r8)
 800ce0e:	e000      	b.n	800ce12 <tcp_listen_input+0x1fa>
  return;
 800ce10:	46c0      	nop			; (mov r8, r8)
}
 800ce12:	46bd      	mov	sp, r7
 800ce14:	b006      	add	sp, #24
 800ce16:	bdb0      	pop	{r4, r5, r7, pc}
 800ce18:	2000138c 	.word	0x2000138c
 800ce1c:	0801f99c 	.word	0x0801f99c
 800ce20:	00000281 	.word	0x00000281
 800ce24:	0801fb8c 	.word	0x0801fb8c
 800ce28:	0801f9dc 	.word	0x0801f9dc
 800ce2c:	20001384 	.word	0x20001384
 800ce30:	2000138a 	.word	0x2000138a
 800ce34:	20001380 	.word	0x20001380
 800ce38:	20001370 	.word	0x20001370
 800ce3c:	200014d8 	.word	0x200014d8
 800ce40:	200014d4 	.word	0x200014d4
 800ce44:	200014c4 	.word	0x200014c4
 800ce48:	20002b18 	.word	0x20002b18
 800ce4c:	20002b14 	.word	0x20002b14

0800ce50 <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static void
tcp_timewait_input(struct tcp_pcb *pcb)
{
 800ce50:	b5b0      	push	{r4, r5, r7, lr}
 800ce52:	b086      	sub	sp, #24
 800ce54:	af04      	add	r7, sp, #16
 800ce56:	6078      	str	r0, [r7, #4]
  /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST) {
 800ce58:	4b33      	ldr	r3, [pc, #204]	; (800cf28 <tcp_timewait_input+0xd8>)
 800ce5a:	781b      	ldrb	r3, [r3, #0]
 800ce5c:	001a      	movs	r2, r3
 800ce5e:	2304      	movs	r3, #4
 800ce60:	4013      	ands	r3, r2
 800ce62:	d15a      	bne.n	800cf1a <tcp_timewait_input+0xca>
    return;
  }

  LWIP_ASSERT("tcp_timewait_input: invalid pcb", pcb != NULL);
 800ce64:	687b      	ldr	r3, [r7, #4]
 800ce66:	2b00      	cmp	r3, #0
 800ce68:	d105      	bne.n	800ce76 <tcp_timewait_input+0x26>
 800ce6a:	4b30      	ldr	r3, [pc, #192]	; (800cf2c <tcp_timewait_input+0xdc>)
 800ce6c:	4a30      	ldr	r2, [pc, #192]	; (800cf30 <tcp_timewait_input+0xe0>)
 800ce6e:	4931      	ldr	r1, [pc, #196]	; (800cf34 <tcp_timewait_input+0xe4>)
 800ce70:	4831      	ldr	r0, [pc, #196]	; (800cf38 <tcp_timewait_input+0xe8>)
 800ce72:	f7f5 f9ab 	bl	80021cc <app_debug_rtt_raw>

  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
 800ce76:	4b2c      	ldr	r3, [pc, #176]	; (800cf28 <tcp_timewait_input+0xd8>)
 800ce78:	781b      	ldrb	r3, [r3, #0]
 800ce7a:	001a      	movs	r2, r3
 800ce7c:	2302      	movs	r3, #2
 800ce7e:	4013      	ands	r3, r2
 800ce80:	d031      	beq.n	800cee6 <tcp_timewait_input+0x96>
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
 800ce82:	4b2e      	ldr	r3, [pc, #184]	; (800cf3c <tcp_timewait_input+0xec>)
 800ce84:	681a      	ldr	r2, [r3, #0]
 800ce86:	687b      	ldr	r3, [r7, #4]
 800ce88:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ce8a:	1ad3      	subs	r3, r2, r3
 800ce8c:	d435      	bmi.n	800cefa <tcp_timewait_input+0xaa>
 800ce8e:	4b2b      	ldr	r3, [pc, #172]	; (800cf3c <tcp_timewait_input+0xec>)
 800ce90:	681a      	ldr	r2, [r3, #0]
 800ce92:	687b      	ldr	r3, [r7, #4]
 800ce94:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ce96:	6879      	ldr	r1, [r7, #4]
 800ce98:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800ce9a:	185b      	adds	r3, r3, r1
 800ce9c:	1ad3      	subs	r3, r2, r3
 800ce9e:	2b00      	cmp	r3, #0
 800cea0:	dc2b      	bgt.n	800cefa <tcp_timewait_input+0xaa>
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800cea2:	4b27      	ldr	r3, [pc, #156]	; (800cf40 <tcp_timewait_input+0xf0>)
 800cea4:	681c      	ldr	r4, [r3, #0]
 800cea6:	4b27      	ldr	r3, [pc, #156]	; (800cf44 <tcp_timewait_input+0xf4>)
 800cea8:	881b      	ldrh	r3, [r3, #0]
 800ceaa:	001a      	movs	r2, r3
 800ceac:	4b23      	ldr	r3, [pc, #140]	; (800cf3c <tcp_timewait_input+0xec>)
 800ceae:	681b      	ldr	r3, [r3, #0]
 800ceb0:	18d5      	adds	r5, r2, r3
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800ceb2:	4b25      	ldr	r3, [pc, #148]	; (800cf48 <tcp_timewait_input+0xf8>)
 800ceb4:	681b      	ldr	r3, [r3, #0]
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800ceb6:	789a      	ldrb	r2, [r3, #2]
 800ceb8:	78db      	ldrb	r3, [r3, #3]
 800ceba:	021b      	lsls	r3, r3, #8
 800cebc:	4313      	orrs	r3, r2
 800cebe:	b29a      	uxth	r2, r3
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800cec0:	4b21      	ldr	r3, [pc, #132]	; (800cf48 <tcp_timewait_input+0xf8>)
 800cec2:	681b      	ldr	r3, [r3, #0]
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800cec4:	7819      	ldrb	r1, [r3, #0]
 800cec6:	785b      	ldrb	r3, [r3, #1]
 800cec8:	021b      	lsls	r3, r3, #8
 800ceca:	430b      	orrs	r3, r1
 800cecc:	b29b      	uxth	r3, r3
 800cece:	491f      	ldr	r1, [pc, #124]	; (800cf4c <tcp_timewait_input+0xfc>)
 800ced0:	6878      	ldr	r0, [r7, #4]
 800ced2:	9302      	str	r3, [sp, #8]
 800ced4:	9201      	str	r2, [sp, #4]
 800ced6:	4b1e      	ldr	r3, [pc, #120]	; (800cf50 <tcp_timewait_input+0x100>)
 800ced8:	9300      	str	r3, [sp, #0]
 800ceda:	000b      	movs	r3, r1
 800cedc:	002a      	movs	r2, r5
 800cede:	0021      	movs	r1, r4
 800cee0:	f004 fba2 	bl	8011628 <tcp_rst>
      return;
 800cee4:	e01c      	b.n	800cf20 <tcp_timewait_input+0xd0>
    }
  } else if (flags & TCP_FIN) {
 800cee6:	4b10      	ldr	r3, [pc, #64]	; (800cf28 <tcp_timewait_input+0xd8>)
 800cee8:	781b      	ldrb	r3, [r3, #0]
 800ceea:	001a      	movs	r2, r3
 800ceec:	2301      	movs	r3, #1
 800ceee:	4013      	ands	r3, r2
 800cef0:	d003      	beq.n	800cefa <tcp_timewait_input+0xaa>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
 800cef2:	4b18      	ldr	r3, [pc, #96]	; (800cf54 <tcp_timewait_input+0x104>)
 800cef4:	681a      	ldr	r2, [r3, #0]
 800cef6:	687b      	ldr	r3, [r7, #4]
 800cef8:	625a      	str	r2, [r3, #36]	; 0x24
  }

  if ((tcplen > 0)) {
 800cefa:	4b12      	ldr	r3, [pc, #72]	; (800cf44 <tcp_timewait_input+0xf4>)
 800cefc:	881b      	ldrh	r3, [r3, #0]
 800cefe:	2b00      	cmp	r3, #0
 800cf00:	d00d      	beq.n	800cf1e <tcp_timewait_input+0xce>
    /* Acknowledge data, FIN or out-of-window SYN */
    tcp_ack_now(pcb);
 800cf02:	687b      	ldr	r3, [r7, #4]
 800cf04:	8bdb      	ldrh	r3, [r3, #30]
 800cf06:	2202      	movs	r2, #2
 800cf08:	4313      	orrs	r3, r2
 800cf0a:	b29a      	uxth	r2, r3
 800cf0c:	687b      	ldr	r3, [r7, #4]
 800cf0e:	83da      	strh	r2, [r3, #30]
    tcp_output(pcb);
 800cf10:	687b      	ldr	r3, [r7, #4]
 800cf12:	0018      	movs	r0, r3
 800cf14:	f003 fb34 	bl	8010580 <tcp_output>
  }
  return;
 800cf18:	e001      	b.n	800cf1e <tcp_timewait_input+0xce>
    return;
 800cf1a:	46c0      	nop			; (mov r8, r8)
 800cf1c:	e000      	b.n	800cf20 <tcp_timewait_input+0xd0>
  return;
 800cf1e:	46c0      	nop			; (mov r8, r8)
}
 800cf20:	46bd      	mov	sp, r7
 800cf22:	b002      	add	sp, #8
 800cf24:	bdb0      	pop	{r4, r5, r7, pc}
 800cf26:	46c0      	nop			; (mov r8, r8)
 800cf28:	2000138c 	.word	0x2000138c
 800cf2c:	0801f99c 	.word	0x0801f99c
 800cf30:	000002ee 	.word	0x000002ee
 800cf34:	0801fbac 	.word	0x0801fbac
 800cf38:	0801f9dc 	.word	0x0801f9dc
 800cf3c:	20001380 	.word	0x20001380
 800cf40:	20001384 	.word	0x20001384
 800cf44:	2000138a 	.word	0x2000138a
 800cf48:	20001370 	.word	0x20001370
 800cf4c:	200014d8 	.word	0x200014d8
 800cf50:	200014d4 	.word	0x200014d4
 800cf54:	20002b1c 	.word	0x20002b1c

0800cf58 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
 800cf58:	b5b0      	push	{r4, r5, r7, lr}
 800cf5a:	b08c      	sub	sp, #48	; 0x30
 800cf5c:	af04      	add	r7, sp, #16
 800cf5e:	6078      	str	r0, [r7, #4]
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
 800cf60:	231f      	movs	r3, #31
 800cf62:	18fb      	adds	r3, r7, r3
 800cf64:	2200      	movs	r2, #0
 800cf66:	701a      	strb	r2, [r3, #0]
  err_t err;

  err = ERR_OK;
 800cf68:	231e      	movs	r3, #30
 800cf6a:	18fb      	adds	r3, r7, r3
 800cf6c:	2200      	movs	r2, #0
 800cf6e:	701a      	strb	r2, [r3, #0]

  LWIP_ASSERT("tcp_process: invalid pcb", pcb != NULL);
 800cf70:	687b      	ldr	r3, [r7, #4]
 800cf72:	2b00      	cmp	r3, #0
 800cf74:	d106      	bne.n	800cf84 <tcp_process+0x2c>
 800cf76:	4bd4      	ldr	r3, [pc, #848]	; (800d2c8 <tcp_process+0x370>)
 800cf78:	22c7      	movs	r2, #199	; 0xc7
 800cf7a:	0092      	lsls	r2, r2, #2
 800cf7c:	49d3      	ldr	r1, [pc, #844]	; (800d2cc <tcp_process+0x374>)
 800cf7e:	48d4      	ldr	r0, [pc, #848]	; (800d2d0 <tcp_process+0x378>)
 800cf80:	f7f5 f924 	bl	80021cc <app_debug_rtt_raw>

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
 800cf84:	4bd3      	ldr	r3, [pc, #844]	; (800d2d4 <tcp_process+0x37c>)
 800cf86:	781b      	ldrb	r3, [r3, #0]
 800cf88:	001a      	movs	r2, r3
 800cf8a:	2304      	movs	r3, #4
 800cf8c:	4013      	ands	r3, r2
 800cf8e:	d055      	beq.n	800d03c <tcp_process+0xe4>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
 800cf90:	687b      	ldr	r3, [r7, #4]
 800cf92:	7e1b      	ldrb	r3, [r3, #24]
 800cf94:	2b02      	cmp	r3, #2
 800cf96:	d10a      	bne.n	800cfae <tcp_process+0x56>
      /* "In the SYN-SENT state (a RST received in response to an initial SYN),
          the RST is acceptable if the ACK field acknowledges the SYN." */
      if (ackno == pcb->snd_nxt) {
 800cf98:	687b      	ldr	r3, [r7, #4]
 800cf9a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800cf9c:	4bce      	ldr	r3, [pc, #824]	; (800d2d8 <tcp_process+0x380>)
 800cf9e:	681b      	ldr	r3, [r3, #0]
 800cfa0:	429a      	cmp	r2, r3
 800cfa2:	d126      	bne.n	800cff2 <tcp_process+0x9a>
        acceptable = 1;
 800cfa4:	231f      	movs	r3, #31
 800cfa6:	18fb      	adds	r3, r7, r3
 800cfa8:	2201      	movs	r2, #1
 800cfaa:	701a      	strb	r2, [r3, #0]
 800cfac:	e021      	b.n	800cff2 <tcp_process+0x9a>
      }
    } else {
      /* "In all states except SYN-SENT, all reset (RST) segments are validated
          by checking their SEQ-fields." */
      if (seqno == pcb->rcv_nxt) {
 800cfae:	687b      	ldr	r3, [r7, #4]
 800cfb0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800cfb2:	4bca      	ldr	r3, [pc, #808]	; (800d2dc <tcp_process+0x384>)
 800cfb4:	681b      	ldr	r3, [r3, #0]
 800cfb6:	429a      	cmp	r2, r3
 800cfb8:	d104      	bne.n	800cfc4 <tcp_process+0x6c>
        acceptable = 1;
 800cfba:	231f      	movs	r3, #31
 800cfbc:	18fb      	adds	r3, r7, r3
 800cfbe:	2201      	movs	r2, #1
 800cfc0:	701a      	strb	r2, [r3, #0]
 800cfc2:	e016      	b.n	800cff2 <tcp_process+0x9a>
      } else  if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 800cfc4:	4bc5      	ldr	r3, [pc, #788]	; (800d2dc <tcp_process+0x384>)
 800cfc6:	681a      	ldr	r2, [r3, #0]
 800cfc8:	687b      	ldr	r3, [r7, #4]
 800cfca:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800cfcc:	1ad3      	subs	r3, r2, r3
 800cfce:	d410      	bmi.n	800cff2 <tcp_process+0x9a>
 800cfd0:	4bc2      	ldr	r3, [pc, #776]	; (800d2dc <tcp_process+0x384>)
 800cfd2:	681a      	ldr	r2, [r3, #0]
 800cfd4:	687b      	ldr	r3, [r7, #4]
 800cfd6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800cfd8:	6879      	ldr	r1, [r7, #4]
 800cfda:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800cfdc:	185b      	adds	r3, r3, r1
 800cfde:	1ad3      	subs	r3, r2, r3
 800cfe0:	2b00      	cmp	r3, #0
 800cfe2:	dc06      	bgt.n	800cff2 <tcp_process+0x9a>
                                  pcb->rcv_nxt + pcb->rcv_wnd)) {
        /* If the sequence number is inside the window, we send a challenge ACK
           and wait for a re-send with matching sequence number.
           This follows RFC 5961 section 3.2 and addresses CVE-2004-0230
           (RST spoofing attack), which is present in RFC 793 RST handling. */
        tcp_ack_now(pcb);
 800cfe4:	687b      	ldr	r3, [r7, #4]
 800cfe6:	8bdb      	ldrh	r3, [r3, #30]
 800cfe8:	2202      	movs	r2, #2
 800cfea:	4313      	orrs	r3, r2
 800cfec:	b29a      	uxth	r2, r3
 800cfee:	687b      	ldr	r3, [r7, #4]
 800cff0:	83da      	strh	r2, [r3, #30]
      }
    }

    if (acceptable) {
 800cff2:	231f      	movs	r3, #31
 800cff4:	18fb      	adds	r3, r7, r3
 800cff6:	781b      	ldrb	r3, [r3, #0]
 800cff8:	2b00      	cmp	r3, #0
 800cffa:	d01c      	beq.n	800d036 <tcp_process+0xde>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
 800cffc:	687b      	ldr	r3, [r7, #4]
 800cffe:	7e1b      	ldrb	r3, [r3, #24]
 800d000:	2b00      	cmp	r3, #0
 800d002:	d106      	bne.n	800d012 <tcp_process+0xba>
 800d004:	4bb0      	ldr	r3, [pc, #704]	; (800d2c8 <tcp_process+0x370>)
 800d006:	22ce      	movs	r2, #206	; 0xce
 800d008:	0092      	lsls	r2, r2, #2
 800d00a:	49b5      	ldr	r1, [pc, #724]	; (800d2e0 <tcp_process+0x388>)
 800d00c:	48b0      	ldr	r0, [pc, #704]	; (800d2d0 <tcp_process+0x378>)
 800d00e:	f7f5 f8dd 	bl	80021cc <app_debug_rtt_raw>
      recv_flags |= TF_RESET;
 800d012:	4bb4      	ldr	r3, [pc, #720]	; (800d2e4 <tcp_process+0x38c>)
 800d014:	781b      	ldrb	r3, [r3, #0]
 800d016:	2208      	movs	r2, #8
 800d018:	4313      	orrs	r3, r2
 800d01a:	b2da      	uxtb	r2, r3
 800d01c:	4bb1      	ldr	r3, [pc, #708]	; (800d2e4 <tcp_process+0x38c>)
 800d01e:	701a      	strb	r2, [r3, #0]
      tcp_clear_flags(pcb, TF_ACK_DELAY);
 800d020:	687b      	ldr	r3, [r7, #4]
 800d022:	8bdb      	ldrh	r3, [r3, #30]
 800d024:	2201      	movs	r2, #1
 800d026:	4393      	bics	r3, r2
 800d028:	b29a      	uxth	r2, r3
 800d02a:	687b      	ldr	r3, [r7, #4]
 800d02c:	83da      	strh	r2, [r3, #30]
      return ERR_RST;
 800d02e:	230e      	movs	r3, #14
 800d030:	425b      	negs	r3, r3
 800d032:	f000 fbb1 	bl	800d798 <tcp_process+0x840>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
                                    seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
                              seqno, pcb->rcv_nxt));
      return ERR_OK;
 800d036:	2300      	movs	r3, #0
 800d038:	f000 fbae 	bl	800d798 <tcp_process+0x840>
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
 800d03c:	4ba5      	ldr	r3, [pc, #660]	; (800d2d4 <tcp_process+0x37c>)
 800d03e:	781b      	ldrb	r3, [r3, #0]
 800d040:	001a      	movs	r2, r3
 800d042:	2302      	movs	r3, #2
 800d044:	4013      	ands	r3, r2
 800d046:	d011      	beq.n	800d06c <tcp_process+0x114>
 800d048:	687b      	ldr	r3, [r7, #4]
 800d04a:	7e1b      	ldrb	r3, [r3, #24]
 800d04c:	2b02      	cmp	r3, #2
 800d04e:	d00d      	beq.n	800d06c <tcp_process+0x114>
 800d050:	687b      	ldr	r3, [r7, #4]
 800d052:	7e1b      	ldrb	r3, [r3, #24]
 800d054:	2b03      	cmp	r3, #3
 800d056:	d009      	beq.n	800d06c <tcp_process+0x114>
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
 800d058:	687b      	ldr	r3, [r7, #4]
 800d05a:	8bdb      	ldrh	r3, [r3, #30]
 800d05c:	2202      	movs	r2, #2
 800d05e:	4313      	orrs	r3, r2
 800d060:	b29a      	uxth	r2, r3
 800d062:	687b      	ldr	r3, [r7, #4]
 800d064:	83da      	strh	r2, [r3, #30]
    return ERR_OK;
 800d066:	2300      	movs	r3, #0
 800d068:	f000 fb96 	bl	800d798 <tcp_process+0x840>
  }

  if ((pcb->flags & TF_RXCLOSED) == 0) {
 800d06c:	687b      	ldr	r3, [r7, #4]
 800d06e:	8bdb      	ldrh	r3, [r3, #30]
 800d070:	001a      	movs	r2, r3
 800d072:	2310      	movs	r3, #16
 800d074:	4013      	ands	r3, r2
 800d076:	d103      	bne.n	800d080 <tcp_process+0x128>
    /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
    pcb->tmr = tcp_ticks;
 800d078:	4b9b      	ldr	r3, [pc, #620]	; (800d2e8 <tcp_process+0x390>)
 800d07a:	681a      	ldr	r2, [r3, #0]
 800d07c:	687b      	ldr	r3, [r7, #4]
 800d07e:	625a      	str	r2, [r3, #36]	; 0x24
  }
  pcb->keep_cnt_sent = 0;
 800d080:	687b      	ldr	r3, [r7, #4]
 800d082:	22a7      	movs	r2, #167	; 0xa7
 800d084:	2100      	movs	r1, #0
 800d086:	5499      	strb	r1, [r3, r2]
  pcb->persist_probe = 0;
 800d088:	687b      	ldr	r3, [r7, #4]
 800d08a:	22a6      	movs	r2, #166	; 0xa6
 800d08c:	2100      	movs	r1, #0
 800d08e:	5499      	strb	r1, [r3, r2]

  tcp_parseopt(pcb);
 800d090:	687b      	ldr	r3, [r7, #4]
 800d092:	0018      	movs	r0, r3
 800d094:	f001 fe3e 	bl	800ed14 <tcp_parseopt>

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
 800d098:	687b      	ldr	r3, [r7, #4]
 800d09a:	7e1b      	ldrb	r3, [r3, #24]
 800d09c:	2b09      	cmp	r3, #9
 800d09e:	d901      	bls.n	800d0a4 <tcp_process+0x14c>
 800d0a0:	f000 fb6a 	bl	800d778 <tcp_process+0x820>
 800d0a4:	009a      	lsls	r2, r3, #2
 800d0a6:	4b91      	ldr	r3, [pc, #580]	; (800d2ec <tcp_process+0x394>)
 800d0a8:	18d3      	adds	r3, r2, r3
 800d0aa:	681b      	ldr	r3, [r3, #0]
 800d0ac:	469f      	mov	pc, r3
    case SYN_SENT:
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %s %"U32_F"\n",
                                    ackno, pcb->snd_nxt, pcb->unacked ? "" : " empty:",
                                    pcb->unacked ? lwip_ntohl(pcb->unacked->tcphdr->seqno) : 0));
      /* received SYN ACK with expected sequence number? */
      if ((flags & TCP_ACK) && (flags & TCP_SYN)
 800d0ae:	4b89      	ldr	r3, [pc, #548]	; (800d2d4 <tcp_process+0x37c>)
 800d0b0:	781b      	ldrb	r3, [r3, #0]
 800d0b2:	001a      	movs	r2, r3
 800d0b4:	2310      	movs	r3, #16
 800d0b6:	4013      	ands	r3, r2
 800d0b8:	d100      	bne.n	800d0bc <tcp_process+0x164>
 800d0ba:	e0cf      	b.n	800d25c <tcp_process+0x304>
 800d0bc:	4b85      	ldr	r3, [pc, #532]	; (800d2d4 <tcp_process+0x37c>)
 800d0be:	781b      	ldrb	r3, [r3, #0]
 800d0c0:	001a      	movs	r2, r3
 800d0c2:	2302      	movs	r3, #2
 800d0c4:	4013      	ands	r3, r2
 800d0c6:	d100      	bne.n	800d0ca <tcp_process+0x172>
 800d0c8:	e0c8      	b.n	800d25c <tcp_process+0x304>
          && (ackno == pcb->lastack + 1)) {
 800d0ca:	687b      	ldr	r3, [r7, #4]
 800d0cc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800d0ce:	1c5a      	adds	r2, r3, #1
 800d0d0:	4b81      	ldr	r3, [pc, #516]	; (800d2d8 <tcp_process+0x380>)
 800d0d2:	681b      	ldr	r3, [r3, #0]
 800d0d4:	429a      	cmp	r2, r3
 800d0d6:	d000      	beq.n	800d0da <tcp_process+0x182>
 800d0d8:	e0c0      	b.n	800d25c <tcp_process+0x304>
        pcb->rcv_nxt = seqno + 1;
 800d0da:	4b80      	ldr	r3, [pc, #512]	; (800d2dc <tcp_process+0x384>)
 800d0dc:	681b      	ldr	r3, [r3, #0]
 800d0de:	1c5a      	adds	r2, r3, #1
 800d0e0:	687b      	ldr	r3, [r7, #4]
 800d0e2:	629a      	str	r2, [r3, #40]	; 0x28
        pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 800d0e4:	687b      	ldr	r3, [r7, #4]
 800d0e6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800d0e8:	687b      	ldr	r3, [r7, #4]
 800d0ea:	631a      	str	r2, [r3, #48]	; 0x30
        pcb->lastack = ackno;
 800d0ec:	4b7a      	ldr	r3, [pc, #488]	; (800d2d8 <tcp_process+0x380>)
 800d0ee:	681a      	ldr	r2, [r3, #0]
 800d0f0:	687b      	ldr	r3, [r7, #4]
 800d0f2:	649a      	str	r2, [r3, #72]	; 0x48
        pcb->snd_wnd = tcphdr->wnd;
 800d0f4:	4b7e      	ldr	r3, [pc, #504]	; (800d2f0 <tcp_process+0x398>)
 800d0f6:	681b      	ldr	r3, [r3, #0]
 800d0f8:	7b9a      	ldrb	r2, [r3, #14]
 800d0fa:	7bdb      	ldrb	r3, [r3, #15]
 800d0fc:	021b      	lsls	r3, r3, #8
 800d0fe:	4313      	orrs	r3, r2
 800d100:	b299      	uxth	r1, r3
 800d102:	687b      	ldr	r3, [r7, #4]
 800d104:	2264      	movs	r2, #100	; 0x64
 800d106:	5299      	strh	r1, [r3, r2]
        pcb->snd_wnd_max = pcb->snd_wnd;
 800d108:	687b      	ldr	r3, [r7, #4]
 800d10a:	2264      	movs	r2, #100	; 0x64
 800d10c:	5a99      	ldrh	r1, [r3, r2]
 800d10e:	687b      	ldr	r3, [r7, #4]
 800d110:	2266      	movs	r2, #102	; 0x66
 800d112:	5299      	strh	r1, [r3, r2]
        pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 800d114:	4b71      	ldr	r3, [pc, #452]	; (800d2dc <tcp_process+0x384>)
 800d116:	681b      	ldr	r3, [r3, #0]
 800d118:	1e5a      	subs	r2, r3, #1
 800d11a:	687b      	ldr	r3, [r7, #4]
 800d11c:	659a      	str	r2, [r3, #88]	; 0x58
        pcb->state = ESTABLISHED;
 800d11e:	687b      	ldr	r3, [r7, #4]
 800d120:	2204      	movs	r2, #4
 800d122:	761a      	strb	r2, [r3, #24]

#if TCP_CALCULATE_EFF_SEND_MSS
        pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
 800d124:	687b      	ldr	r3, [r7, #4]
 800d126:	8edc      	ldrh	r4, [r3, #54]	; 0x36
 800d128:	687b      	ldr	r3, [r7, #4]
 800d12a:	3304      	adds	r3, #4
 800d12c:	0018      	movs	r0, r3
 800d12e:	f005 febd 	bl	8012eac <ip4_route>
 800d132:	0001      	movs	r1, r0
 800d134:	687b      	ldr	r3, [r7, #4]
 800d136:	3304      	adds	r3, #4
 800d138:	001a      	movs	r2, r3
 800d13a:	0020      	movs	r0, r4
 800d13c:	f7fe fefe 	bl	800bf3c <tcp_eff_send_mss_netif>
 800d140:	0003      	movs	r3, r0
 800d142:	001a      	movs	r2, r3
 800d144:	687b      	ldr	r3, [r7, #4]
 800d146:	86da      	strh	r2, [r3, #54]	; 0x36
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

        pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 800d148:	687b      	ldr	r3, [r7, #4]
 800d14a:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d14c:	009a      	lsls	r2, r3, #2
 800d14e:	687b      	ldr	r3, [r7, #4]
 800d150:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d152:	005b      	lsls	r3, r3, #1
 800d154:	4967      	ldr	r1, [pc, #412]	; (800d2f4 <tcp_process+0x39c>)
 800d156:	428b      	cmp	r3, r1
 800d158:	d200      	bcs.n	800d15c <tcp_process+0x204>
 800d15a:	4b66      	ldr	r3, [pc, #408]	; (800d2f4 <tcp_process+0x39c>)
 800d15c:	429a      	cmp	r2, r3
 800d15e:	d204      	bcs.n	800d16a <tcp_process+0x212>
 800d160:	687b      	ldr	r3, [r7, #4]
 800d162:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d164:	009b      	lsls	r3, r3, #2
 800d166:	b29b      	uxth	r3, r3
 800d168:	e00b      	b.n	800d182 <tcp_process+0x22a>
 800d16a:	687b      	ldr	r3, [r7, #4]
 800d16c:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d16e:	005b      	lsls	r3, r3, #1
 800d170:	4a60      	ldr	r2, [pc, #384]	; (800d2f4 <tcp_process+0x39c>)
 800d172:	4293      	cmp	r3, r2
 800d174:	d904      	bls.n	800d180 <tcp_process+0x228>
 800d176:	687b      	ldr	r3, [r7, #4]
 800d178:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d17a:	18db      	adds	r3, r3, r3
 800d17c:	b29b      	uxth	r3, r3
 800d17e:	e000      	b.n	800d182 <tcp_process+0x22a>
 800d180:	4b5c      	ldr	r3, [pc, #368]	; (800d2f4 <tcp_process+0x39c>)
 800d182:	687a      	ldr	r2, [r7, #4]
 800d184:	214c      	movs	r1, #76	; 0x4c
 800d186:	5253      	strh	r3, [r2, r1]
        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SENT): cwnd %"TCPWNDSIZE_F
                                     " ssthresh %"TCPWNDSIZE_F"\n",
                                     pcb->cwnd, pcb->ssthresh));
        LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
 800d188:	687b      	ldr	r3, [r7, #4]
 800d18a:	226a      	movs	r2, #106	; 0x6a
 800d18c:	5a9b      	ldrh	r3, [r3, r2]
 800d18e:	2b00      	cmp	r3, #0
 800d190:	d105      	bne.n	800d19e <tcp_process+0x246>
 800d192:	4b4d      	ldr	r3, [pc, #308]	; (800d2c8 <tcp_process+0x370>)
 800d194:	4a58      	ldr	r2, [pc, #352]	; (800d2f8 <tcp_process+0x3a0>)
 800d196:	4959      	ldr	r1, [pc, #356]	; (800d2fc <tcp_process+0x3a4>)
 800d198:	484d      	ldr	r0, [pc, #308]	; (800d2d0 <tcp_process+0x378>)
 800d19a:	f7f5 f817 	bl	80021cc <app_debug_rtt_raw>
        --pcb->snd_queuelen;
 800d19e:	687b      	ldr	r3, [r7, #4]
 800d1a0:	226a      	movs	r2, #106	; 0x6a
 800d1a2:	5a9b      	ldrh	r3, [r3, r2]
 800d1a4:	3b01      	subs	r3, #1
 800d1a6:	b299      	uxth	r1, r3
 800d1a8:	687b      	ldr	r3, [r7, #4]
 800d1aa:	226a      	movs	r2, #106	; 0x6a
 800d1ac:	5299      	strh	r1, [r3, r2]
        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));
        rseg = pcb->unacked;
 800d1ae:	687b      	ldr	r3, [r7, #4]
 800d1b0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800d1b2:	617b      	str	r3, [r7, #20]
        if (rseg == NULL) {
 800d1b4:	697b      	ldr	r3, [r7, #20]
 800d1b6:	2b00      	cmp	r3, #0
 800d1b8:	d110      	bne.n	800d1dc <tcp_process+0x284>
          /* might happen if tcp_output fails in tcp_rexmit_rto()
             in which case the segment is on the unsent list */
          rseg = pcb->unsent;
 800d1ba:	687b      	ldr	r3, [r7, #4]
 800d1bc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d1be:	617b      	str	r3, [r7, #20]
          LWIP_ASSERT("no segment to free", rseg != NULL);
 800d1c0:	697b      	ldr	r3, [r7, #20]
 800d1c2:	2b00      	cmp	r3, #0
 800d1c4:	d105      	bne.n	800d1d2 <tcp_process+0x27a>
 800d1c6:	4b40      	ldr	r3, [pc, #256]	; (800d2c8 <tcp_process+0x370>)
 800d1c8:	4a4d      	ldr	r2, [pc, #308]	; (800d300 <tcp_process+0x3a8>)
 800d1ca:	494e      	ldr	r1, [pc, #312]	; (800d304 <tcp_process+0x3ac>)
 800d1cc:	4840      	ldr	r0, [pc, #256]	; (800d2d0 <tcp_process+0x378>)
 800d1ce:	f7f4 fffd 	bl	80021cc <app_debug_rtt_raw>
          pcb->unsent = rseg->next;
 800d1d2:	697b      	ldr	r3, [r7, #20]
 800d1d4:	681a      	ldr	r2, [r3, #0]
 800d1d6:	687b      	ldr	r3, [r7, #4]
 800d1d8:	671a      	str	r2, [r3, #112]	; 0x70
 800d1da:	e003      	b.n	800d1e4 <tcp_process+0x28c>
        } else {
          pcb->unacked = rseg->next;
 800d1dc:	697b      	ldr	r3, [r7, #20]
 800d1de:	681a      	ldr	r2, [r3, #0]
 800d1e0:	687b      	ldr	r3, [r7, #4]
 800d1e2:	675a      	str	r2, [r3, #116]	; 0x74
        }
        tcp_seg_free(rseg);
 800d1e4:	697b      	ldr	r3, [r7, #20]
 800d1e6:	0018      	movs	r0, r3
 800d1e8:	f7fe fad6 	bl	800b798 <tcp_seg_free>

        /* If there's nothing left to acknowledge, stop the retransmit
           timer, otherwise reset it to start again */
        if (pcb->unacked == NULL) {
 800d1ec:	687b      	ldr	r3, [r7, #4]
 800d1ee:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800d1f0:	2b00      	cmp	r3, #0
 800d1f2:	d104      	bne.n	800d1fe <tcp_process+0x2a6>
          pcb->rtime = -1;
 800d1f4:	687b      	ldr	r3, [r7, #4]
 800d1f6:	2201      	movs	r2, #1
 800d1f8:	4252      	negs	r2, r2
 800d1fa:	869a      	strh	r2, [r3, #52]	; 0x34
 800d1fc:	e006      	b.n	800d20c <tcp_process+0x2b4>
        } else {
          pcb->rtime = 0;
 800d1fe:	687b      	ldr	r3, [r7, #4]
 800d200:	2200      	movs	r2, #0
 800d202:	869a      	strh	r2, [r3, #52]	; 0x34
          pcb->nrtx = 0;
 800d204:	687b      	ldr	r3, [r7, #4]
 800d206:	2246      	movs	r2, #70	; 0x46
 800d208:	2100      	movs	r1, #0
 800d20a:	5499      	strb	r1, [r3, r2]
        }

        /* Call the user specified function to call when successfully
         * connected. */
        TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 800d20c:	687b      	ldr	r3, [r7, #4]
 800d20e:	228c      	movs	r2, #140	; 0x8c
 800d210:	589b      	ldr	r3, [r3, r2]
 800d212:	2b00      	cmp	r3, #0
 800d214:	d00d      	beq.n	800d232 <tcp_process+0x2da>
 800d216:	687b      	ldr	r3, [r7, #4]
 800d218:	228c      	movs	r2, #140	; 0x8c
 800d21a:	589d      	ldr	r5, [r3, r2]
 800d21c:	687b      	ldr	r3, [r7, #4]
 800d21e:	695b      	ldr	r3, [r3, #20]
 800d220:	221e      	movs	r2, #30
 800d222:	18bc      	adds	r4, r7, r2
 800d224:	6879      	ldr	r1, [r7, #4]
 800d226:	2200      	movs	r2, #0
 800d228:	0018      	movs	r0, r3
 800d22a:	47a8      	blx	r5
 800d22c:	0003      	movs	r3, r0
 800d22e:	7023      	strb	r3, [r4, #0]
 800d230:	e003      	b.n	800d23a <tcp_process+0x2e2>
 800d232:	231e      	movs	r3, #30
 800d234:	18fb      	adds	r3, r7, r3
 800d236:	2200      	movs	r2, #0
 800d238:	701a      	strb	r2, [r3, #0]
        if (err == ERR_ABRT) {
 800d23a:	231e      	movs	r3, #30
 800d23c:	18fb      	adds	r3, r7, r3
 800d23e:	781b      	ldrb	r3, [r3, #0]
 800d240:	b25b      	sxtb	r3, r3
 800d242:	330d      	adds	r3, #13
 800d244:	d102      	bne.n	800d24c <tcp_process+0x2f4>
          return ERR_ABRT;
 800d246:	230d      	movs	r3, #13
 800d248:	425b      	negs	r3, r3
 800d24a:	e2a5      	b.n	800d798 <tcp_process+0x840>
        }
        tcp_ack_now(pcb);
 800d24c:	687b      	ldr	r3, [r7, #4]
 800d24e:	8bdb      	ldrh	r3, [r3, #30]
 800d250:	2202      	movs	r2, #2
 800d252:	4313      	orrs	r3, r2
 800d254:	b29a      	uxth	r2, r3
 800d256:	687b      	ldr	r3, [r7, #4]
 800d258:	83da      	strh	r2, [r3, #30]
        if (pcb->nrtx < TCP_SYNMAXRTX) {
          pcb->rtime = 0;
          tcp_rexmit_rto(pcb);
        }
      }
      break;
 800d25a:	e28f      	b.n	800d77c <tcp_process+0x824>
      else if (flags & TCP_ACK) {
 800d25c:	4b1d      	ldr	r3, [pc, #116]	; (800d2d4 <tcp_process+0x37c>)
 800d25e:	781b      	ldrb	r3, [r3, #0]
 800d260:	001a      	movs	r2, r3
 800d262:	2310      	movs	r3, #16
 800d264:	4013      	ands	r3, r2
 800d266:	d100      	bne.n	800d26a <tcp_process+0x312>
 800d268:	e288      	b.n	800d77c <tcp_process+0x824>
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d26a:	4b1b      	ldr	r3, [pc, #108]	; (800d2d8 <tcp_process+0x380>)
 800d26c:	681c      	ldr	r4, [r3, #0]
 800d26e:	4b26      	ldr	r3, [pc, #152]	; (800d308 <tcp_process+0x3b0>)
 800d270:	881b      	ldrh	r3, [r3, #0]
 800d272:	001a      	movs	r2, r3
 800d274:	4b19      	ldr	r3, [pc, #100]	; (800d2dc <tcp_process+0x384>)
 800d276:	681b      	ldr	r3, [r3, #0]
 800d278:	18d5      	adds	r5, r2, r3
                ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d27a:	4b1d      	ldr	r3, [pc, #116]	; (800d2f0 <tcp_process+0x398>)
 800d27c:	681b      	ldr	r3, [r3, #0]
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d27e:	789a      	ldrb	r2, [r3, #2]
 800d280:	78db      	ldrb	r3, [r3, #3]
 800d282:	021b      	lsls	r3, r3, #8
 800d284:	4313      	orrs	r3, r2
 800d286:	b29a      	uxth	r2, r3
                ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d288:	4b19      	ldr	r3, [pc, #100]	; (800d2f0 <tcp_process+0x398>)
 800d28a:	681b      	ldr	r3, [r3, #0]
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d28c:	7819      	ldrb	r1, [r3, #0]
 800d28e:	785b      	ldrb	r3, [r3, #1]
 800d290:	021b      	lsls	r3, r3, #8
 800d292:	430b      	orrs	r3, r1
 800d294:	b29b      	uxth	r3, r3
 800d296:	491d      	ldr	r1, [pc, #116]	; (800d30c <tcp_process+0x3b4>)
 800d298:	6878      	ldr	r0, [r7, #4]
 800d29a:	9302      	str	r3, [sp, #8]
 800d29c:	9201      	str	r2, [sp, #4]
 800d29e:	4b1c      	ldr	r3, [pc, #112]	; (800d310 <tcp_process+0x3b8>)
 800d2a0:	9300      	str	r3, [sp, #0]
 800d2a2:	000b      	movs	r3, r1
 800d2a4:	002a      	movs	r2, r5
 800d2a6:	0021      	movs	r1, r4
 800d2a8:	f004 f9be 	bl	8011628 <tcp_rst>
        if (pcb->nrtx < TCP_SYNMAXRTX) {
 800d2ac:	687b      	ldr	r3, [r7, #4]
 800d2ae:	2246      	movs	r2, #70	; 0x46
 800d2b0:	5c9b      	ldrb	r3, [r3, r2]
 800d2b2:	2b05      	cmp	r3, #5
 800d2b4:	d900      	bls.n	800d2b8 <tcp_process+0x360>
 800d2b6:	e261      	b.n	800d77c <tcp_process+0x824>
          pcb->rtime = 0;
 800d2b8:	687b      	ldr	r3, [r7, #4]
 800d2ba:	2200      	movs	r2, #0
 800d2bc:	869a      	strh	r2, [r3, #52]	; 0x34
          tcp_rexmit_rto(pcb);
 800d2be:	687b      	ldr	r3, [r7, #4]
 800d2c0:	0018      	movs	r0, r3
 800d2c2:	f003 fe69 	bl	8010f98 <tcp_rexmit_rto>
      break;
 800d2c6:	e259      	b.n	800d77c <tcp_process+0x824>
 800d2c8:	0801f99c 	.word	0x0801f99c
 800d2cc:	0801fbcc 	.word	0x0801fbcc
 800d2d0:	0801f9dc 	.word	0x0801f9dc
 800d2d4:	2000138c 	.word	0x2000138c
 800d2d8:	20001384 	.word	0x20001384
 800d2dc:	20001380 	.word	0x20001380
 800d2e0:	0801fbe8 	.word	0x0801fbe8
 800d2e4:	2000138d 	.word	0x2000138d
 800d2e8:	20002b1c 	.word	0x20002b1c
 800d2ec:	08021a18 	.word	0x08021a18
 800d2f0:	20001370 	.word	0x20001370
 800d2f4:	0000111c 	.word	0x0000111c
 800d2f8:	0000036d 	.word	0x0000036d
 800d2fc:	0801fc08 	.word	0x0801fc08
 800d300:	00000375 	.word	0x00000375
 800d304:	0801fc20 	.word	0x0801fc20
 800d308:	2000138a 	.word	0x2000138a
 800d30c:	200014d8 	.word	0x200014d8
 800d310:	200014d4 	.word	0x200014d4
    case SYN_RCVD:
      if (flags & TCP_ACK) {
 800d314:	4bc7      	ldr	r3, [pc, #796]	; (800d634 <tcp_process+0x6dc>)
 800d316:	781b      	ldrb	r3, [r3, #0]
 800d318:	001a      	movs	r2, r3
 800d31a:	2310      	movs	r3, #16
 800d31c:	4013      	ands	r3, r2
 800d31e:	d100      	bne.n	800d322 <tcp_process+0x3ca>
 800d320:	e0b5      	b.n	800d48e <tcp_process+0x536>
        /* expected ACK number? */
        if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 800d322:	4bc5      	ldr	r3, [pc, #788]	; (800d638 <tcp_process+0x6e0>)
 800d324:	681a      	ldr	r2, [r3, #0]
 800d326:	687b      	ldr	r3, [r7, #4]
 800d328:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800d32a:	1ad3      	subs	r3, r2, r3
 800d32c:	3b01      	subs	r3, #1
 800d32e:	2b00      	cmp	r3, #0
 800d330:	da00      	bge.n	800d334 <tcp_process+0x3dc>
 800d332:	e08a      	b.n	800d44a <tcp_process+0x4f2>
 800d334:	4bc0      	ldr	r3, [pc, #768]	; (800d638 <tcp_process+0x6e0>)
 800d336:	681a      	ldr	r2, [r3, #0]
 800d338:	687b      	ldr	r3, [r7, #4]
 800d33a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800d33c:	1ad3      	subs	r3, r2, r3
 800d33e:	2b00      	cmp	r3, #0
 800d340:	dd00      	ble.n	800d344 <tcp_process+0x3ec>
 800d342:	e082      	b.n	800d44a <tcp_process+0x4f2>
          pcb->state = ESTABLISHED;
 800d344:	687b      	ldr	r3, [r7, #4]
 800d346:	2204      	movs	r2, #4
 800d348:	761a      	strb	r2, [r3, #24]
          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
          if (pcb->listener == NULL) {
 800d34a:	687b      	ldr	r3, [r7, #4]
 800d34c:	2280      	movs	r2, #128	; 0x80
 800d34e:	589b      	ldr	r3, [r3, r2]
 800d350:	2b00      	cmp	r3, #0
 800d352:	d104      	bne.n	800d35e <tcp_process+0x406>
            /* listen pcb might be closed by now */
            err = ERR_VAL;
 800d354:	231e      	movs	r3, #30
 800d356:	18fb      	adds	r3, r7, r3
 800d358:	22fa      	movs	r2, #250	; 0xfa
 800d35a:	701a      	strb	r2, [r3, #0]
 800d35c:	e024      	b.n	800d3a8 <tcp_process+0x450>
          } else
#endif /* LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG */
          {
#if LWIP_CALLBACK_API
            LWIP_ASSERT("pcb->listener->accept != NULL", pcb->listener->accept != NULL);
 800d35e:	687b      	ldr	r3, [r7, #4]
 800d360:	2280      	movs	r2, #128	; 0x80
 800d362:	589b      	ldr	r3, [r3, r2]
 800d364:	69db      	ldr	r3, [r3, #28]
 800d366:	2b00      	cmp	r3, #0
 800d368:	d105      	bne.n	800d376 <tcp_process+0x41e>
 800d36a:	4bb4      	ldr	r3, [pc, #720]	; (800d63c <tcp_process+0x6e4>)
 800d36c:	4ab4      	ldr	r2, [pc, #720]	; (800d640 <tcp_process+0x6e8>)
 800d36e:	49b5      	ldr	r1, [pc, #724]	; (800d644 <tcp_process+0x6ec>)
 800d370:	48b5      	ldr	r0, [pc, #724]	; (800d648 <tcp_process+0x6f0>)
 800d372:	f7f4 ff2b 	bl	80021cc <app_debug_rtt_raw>
#endif
            tcp_backlog_accepted(pcb);
            /* Call the accept function. */
            TCP_EVENT_ACCEPT(pcb->listener, pcb, pcb->callback_arg, ERR_OK, err);
 800d376:	687b      	ldr	r3, [r7, #4]
 800d378:	2280      	movs	r2, #128	; 0x80
 800d37a:	589b      	ldr	r3, [r3, r2]
 800d37c:	69db      	ldr	r3, [r3, #28]
 800d37e:	2b00      	cmp	r3, #0
 800d380:	d00e      	beq.n	800d3a0 <tcp_process+0x448>
 800d382:	687b      	ldr	r3, [r7, #4]
 800d384:	2280      	movs	r2, #128	; 0x80
 800d386:	589b      	ldr	r3, [r3, r2]
 800d388:	69dd      	ldr	r5, [r3, #28]
 800d38a:	687b      	ldr	r3, [r7, #4]
 800d38c:	695b      	ldr	r3, [r3, #20]
 800d38e:	221e      	movs	r2, #30
 800d390:	18bc      	adds	r4, r7, r2
 800d392:	6879      	ldr	r1, [r7, #4]
 800d394:	2200      	movs	r2, #0
 800d396:	0018      	movs	r0, r3
 800d398:	47a8      	blx	r5
 800d39a:	0003      	movs	r3, r0
 800d39c:	7023      	strb	r3, [r4, #0]
 800d39e:	e003      	b.n	800d3a8 <tcp_process+0x450>
 800d3a0:	231e      	movs	r3, #30
 800d3a2:	18fb      	adds	r3, r7, r3
 800d3a4:	22f0      	movs	r2, #240	; 0xf0
 800d3a6:	701a      	strb	r2, [r3, #0]
          }
          if (err != ERR_OK) {
 800d3a8:	221e      	movs	r2, #30
 800d3aa:	18bb      	adds	r3, r7, r2
 800d3ac:	781b      	ldrb	r3, [r3, #0]
 800d3ae:	b25b      	sxtb	r3, r3
 800d3b0:	2b00      	cmp	r3, #0
 800d3b2:	d00b      	beq.n	800d3cc <tcp_process+0x474>
            /* If the accept function returns with an error, we abort
             * the connection. */
            /* Already aborted? */
            if (err != ERR_ABRT) {
 800d3b4:	18bb      	adds	r3, r7, r2
 800d3b6:	781b      	ldrb	r3, [r3, #0]
 800d3b8:	b25b      	sxtb	r3, r3
 800d3ba:	330d      	adds	r3, #13
 800d3bc:	d003      	beq.n	800d3c6 <tcp_process+0x46e>
              tcp_abort(pcb);
 800d3be:	687b      	ldr	r3, [r7, #4]
 800d3c0:	0018      	movs	r0, r3
 800d3c2:	f7fd fae9 	bl	800a998 <tcp_abort>
            }
            return ERR_ABRT;
 800d3c6:	230d      	movs	r3, #13
 800d3c8:	425b      	negs	r3, r3
 800d3ca:	e1e5      	b.n	800d798 <tcp_process+0x840>
          }
          /* If there was any data contained within this ACK,
           * we'd better pass it on to the application as well. */
          tcp_receive(pcb);
 800d3cc:	687b      	ldr	r3, [r7, #4]
 800d3ce:	0018      	movs	r0, r3
 800d3d0:	f000 fb42 	bl	800da58 <tcp_receive>

          /* Prevent ACK for SYN to generate a sent event */
          if (recv_acked != 0) {
 800d3d4:	4b9d      	ldr	r3, [pc, #628]	; (800d64c <tcp_process+0x6f4>)
 800d3d6:	881b      	ldrh	r3, [r3, #0]
 800d3d8:	2b00      	cmp	r3, #0
 800d3da:	d005      	beq.n	800d3e8 <tcp_process+0x490>
            recv_acked--;
 800d3dc:	4b9b      	ldr	r3, [pc, #620]	; (800d64c <tcp_process+0x6f4>)
 800d3de:	881b      	ldrh	r3, [r3, #0]
 800d3e0:	3b01      	subs	r3, #1
 800d3e2:	b29a      	uxth	r2, r3
 800d3e4:	4b99      	ldr	r3, [pc, #612]	; (800d64c <tcp_process+0x6f4>)
 800d3e6:	801a      	strh	r2, [r3, #0]
          }

          pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 800d3e8:	687b      	ldr	r3, [r7, #4]
 800d3ea:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d3ec:	009a      	lsls	r2, r3, #2
 800d3ee:	687b      	ldr	r3, [r7, #4]
 800d3f0:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d3f2:	005b      	lsls	r3, r3, #1
 800d3f4:	4996      	ldr	r1, [pc, #600]	; (800d650 <tcp_process+0x6f8>)
 800d3f6:	428b      	cmp	r3, r1
 800d3f8:	d200      	bcs.n	800d3fc <tcp_process+0x4a4>
 800d3fa:	4b95      	ldr	r3, [pc, #596]	; (800d650 <tcp_process+0x6f8>)
 800d3fc:	429a      	cmp	r2, r3
 800d3fe:	d204      	bcs.n	800d40a <tcp_process+0x4b2>
 800d400:	687b      	ldr	r3, [r7, #4]
 800d402:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d404:	009b      	lsls	r3, r3, #2
 800d406:	b29b      	uxth	r3, r3
 800d408:	e00b      	b.n	800d422 <tcp_process+0x4ca>
 800d40a:	687b      	ldr	r3, [r7, #4]
 800d40c:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d40e:	005b      	lsls	r3, r3, #1
 800d410:	4a8f      	ldr	r2, [pc, #572]	; (800d650 <tcp_process+0x6f8>)
 800d412:	4293      	cmp	r3, r2
 800d414:	d904      	bls.n	800d420 <tcp_process+0x4c8>
 800d416:	687b      	ldr	r3, [r7, #4]
 800d418:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800d41a:	18db      	adds	r3, r3, r3
 800d41c:	b29b      	uxth	r3, r3
 800d41e:	e000      	b.n	800d422 <tcp_process+0x4ca>
 800d420:	4b8b      	ldr	r3, [pc, #556]	; (800d650 <tcp_process+0x6f8>)
 800d422:	687a      	ldr	r2, [r7, #4]
 800d424:	214c      	movs	r1, #76	; 0x4c
 800d426:	5253      	strh	r3, [r2, r1]
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SYN_RCVD): cwnd %"TCPWNDSIZE_F
                                       " ssthresh %"TCPWNDSIZE_F"\n",
                                       pcb->cwnd, pcb->ssthresh));

          if (recv_flags & TF_GOT_FIN) {
 800d428:	4b8a      	ldr	r3, [pc, #552]	; (800d654 <tcp_process+0x6fc>)
 800d42a:	781b      	ldrb	r3, [r3, #0]
 800d42c:	001a      	movs	r2, r3
 800d42e:	2320      	movs	r3, #32
 800d430:	4013      	ands	r3, r2
 800d432:	d040      	beq.n	800d4b6 <tcp_process+0x55e>
            tcp_ack_now(pcb);
 800d434:	687b      	ldr	r3, [r7, #4]
 800d436:	8bdb      	ldrh	r3, [r3, #30]
 800d438:	2202      	movs	r2, #2
 800d43a:	4313      	orrs	r3, r2
 800d43c:	b29a      	uxth	r2, r3
 800d43e:	687b      	ldr	r3, [r7, #4]
 800d440:	83da      	strh	r2, [r3, #30]
            pcb->state = CLOSE_WAIT;
 800d442:	687b      	ldr	r3, [r7, #4]
 800d444:	2207      	movs	r2, #7
 800d446:	761a      	strb	r2, [r3, #24]
          if (recv_flags & TF_GOT_FIN) {
 800d448:	e035      	b.n	800d4b6 <tcp_process+0x55e>
          }
        } else {
          /* incorrect ACK number, send RST */
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d44a:	4b7b      	ldr	r3, [pc, #492]	; (800d638 <tcp_process+0x6e0>)
 800d44c:	681c      	ldr	r4, [r3, #0]
 800d44e:	4b82      	ldr	r3, [pc, #520]	; (800d658 <tcp_process+0x700>)
 800d450:	881b      	ldrh	r3, [r3, #0]
 800d452:	001a      	movs	r2, r3
 800d454:	4b81      	ldr	r3, [pc, #516]	; (800d65c <tcp_process+0x704>)
 800d456:	681b      	ldr	r3, [r3, #0]
 800d458:	18d5      	adds	r5, r2, r3
                  ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d45a:	4b81      	ldr	r3, [pc, #516]	; (800d660 <tcp_process+0x708>)
 800d45c:	681b      	ldr	r3, [r3, #0]
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d45e:	789a      	ldrb	r2, [r3, #2]
 800d460:	78db      	ldrb	r3, [r3, #3]
 800d462:	021b      	lsls	r3, r3, #8
 800d464:	4313      	orrs	r3, r2
 800d466:	b29a      	uxth	r2, r3
                  ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 800d468:	4b7d      	ldr	r3, [pc, #500]	; (800d660 <tcp_process+0x708>)
 800d46a:	681b      	ldr	r3, [r3, #0]
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
 800d46c:	7819      	ldrb	r1, [r3, #0]
 800d46e:	785b      	ldrb	r3, [r3, #1]
 800d470:	021b      	lsls	r3, r3, #8
 800d472:	430b      	orrs	r3, r1
 800d474:	b29b      	uxth	r3, r3
 800d476:	497b      	ldr	r1, [pc, #492]	; (800d664 <tcp_process+0x70c>)
 800d478:	6878      	ldr	r0, [r7, #4]
 800d47a:	9302      	str	r3, [sp, #8]
 800d47c:	9201      	str	r2, [sp, #4]
 800d47e:	4b7a      	ldr	r3, [pc, #488]	; (800d668 <tcp_process+0x710>)
 800d480:	9300      	str	r3, [sp, #0]
 800d482:	000b      	movs	r3, r1
 800d484:	002a      	movs	r2, r5
 800d486:	0021      	movs	r1, r4
 800d488:	f004 f8ce 	bl	8011628 <tcp_rst>
        }
      } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
        /* Looks like another copy of the SYN - retransmit our SYN-ACK */
        tcp_rexmit(pcb);
      }
      break;
 800d48c:	e178      	b.n	800d780 <tcp_process+0x828>
      } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
 800d48e:	4b69      	ldr	r3, [pc, #420]	; (800d634 <tcp_process+0x6dc>)
 800d490:	781b      	ldrb	r3, [r3, #0]
 800d492:	001a      	movs	r2, r3
 800d494:	2302      	movs	r3, #2
 800d496:	4013      	ands	r3, r2
 800d498:	d100      	bne.n	800d49c <tcp_process+0x544>
 800d49a:	e171      	b.n	800d780 <tcp_process+0x828>
 800d49c:	687b      	ldr	r3, [r7, #4]
 800d49e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d4a0:	1e5a      	subs	r2, r3, #1
 800d4a2:	4b6e      	ldr	r3, [pc, #440]	; (800d65c <tcp_process+0x704>)
 800d4a4:	681b      	ldr	r3, [r3, #0]
 800d4a6:	429a      	cmp	r2, r3
 800d4a8:	d000      	beq.n	800d4ac <tcp_process+0x554>
 800d4aa:	e169      	b.n	800d780 <tcp_process+0x828>
        tcp_rexmit(pcb);
 800d4ac:	687b      	ldr	r3, [r7, #4]
 800d4ae:	0018      	movs	r0, r3
 800d4b0:	f003 fd96 	bl	8010fe0 <tcp_rexmit>
      break;
 800d4b4:	e164      	b.n	800d780 <tcp_process+0x828>
 800d4b6:	e163      	b.n	800d780 <tcp_process+0x828>
    case CLOSE_WAIT:
    /* FALLTHROUGH */
    case ESTABLISHED:
      tcp_receive(pcb);
 800d4b8:	687b      	ldr	r3, [r7, #4]
 800d4ba:	0018      	movs	r0, r3
 800d4bc:	f000 facc 	bl	800da58 <tcp_receive>
      if (recv_flags & TF_GOT_FIN) { /* passive close */
 800d4c0:	4b64      	ldr	r3, [pc, #400]	; (800d654 <tcp_process+0x6fc>)
 800d4c2:	781b      	ldrb	r3, [r3, #0]
 800d4c4:	001a      	movs	r2, r3
 800d4c6:	2320      	movs	r3, #32
 800d4c8:	4013      	ands	r3, r2
 800d4ca:	d100      	bne.n	800d4ce <tcp_process+0x576>
 800d4cc:	e15a      	b.n	800d784 <tcp_process+0x82c>
        tcp_ack_now(pcb);
 800d4ce:	687b      	ldr	r3, [r7, #4]
 800d4d0:	8bdb      	ldrh	r3, [r3, #30]
 800d4d2:	2202      	movs	r2, #2
 800d4d4:	4313      	orrs	r3, r2
 800d4d6:	b29a      	uxth	r2, r3
 800d4d8:	687b      	ldr	r3, [r7, #4]
 800d4da:	83da      	strh	r2, [r3, #30]
        pcb->state = CLOSE_WAIT;
 800d4dc:	687b      	ldr	r3, [r7, #4]
 800d4de:	2207      	movs	r2, #7
 800d4e0:	761a      	strb	r2, [r3, #24]
      }
      break;
 800d4e2:	e14f      	b.n	800d784 <tcp_process+0x82c>
    case FIN_WAIT_1:
      tcp_receive(pcb);
 800d4e4:	687b      	ldr	r3, [r7, #4]
 800d4e6:	0018      	movs	r0, r3
 800d4e8:	f000 fab6 	bl	800da58 <tcp_receive>
      if (recv_flags & TF_GOT_FIN) {
 800d4ec:	4b59      	ldr	r3, [pc, #356]	; (800d654 <tcp_process+0x6fc>)
 800d4ee:	781b      	ldrb	r3, [r3, #0]
 800d4f0:	001a      	movs	r2, r3
 800d4f2:	2320      	movs	r3, #32
 800d4f4:	4013      	ands	r3, r2
 800d4f6:	d057      	beq.n	800d5a8 <tcp_process+0x650>
        if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800d4f8:	4b4e      	ldr	r3, [pc, #312]	; (800d634 <tcp_process+0x6dc>)
 800d4fa:	781b      	ldrb	r3, [r3, #0]
 800d4fc:	001a      	movs	r2, r3
 800d4fe:	2310      	movs	r3, #16
 800d500:	4013      	ands	r3, r2
 800d502:	d046      	beq.n	800d592 <tcp_process+0x63a>
 800d504:	687b      	ldr	r3, [r7, #4]
 800d506:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800d508:	4b4b      	ldr	r3, [pc, #300]	; (800d638 <tcp_process+0x6e0>)
 800d50a:	681b      	ldr	r3, [r3, #0]
 800d50c:	429a      	cmp	r2, r3
 800d50e:	d140      	bne.n	800d592 <tcp_process+0x63a>
            pcb->unsent == NULL) {
 800d510:	687b      	ldr	r3, [r7, #4]
 800d512:	6f1b      	ldr	r3, [r3, #112]	; 0x70
        if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800d514:	2b00      	cmp	r3, #0
 800d516:	d13c      	bne.n	800d592 <tcp_process+0x63a>
          LWIP_DEBUGF(TCP_DEBUG,
                      ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
          tcp_ack_now(pcb);
 800d518:	687b      	ldr	r3, [r7, #4]
 800d51a:	8bdb      	ldrh	r3, [r3, #30]
 800d51c:	2202      	movs	r2, #2
 800d51e:	4313      	orrs	r3, r2
 800d520:	b29a      	uxth	r2, r3
 800d522:	687b      	ldr	r3, [r7, #4]
 800d524:	83da      	strh	r2, [r3, #30]
          tcp_pcb_purge(pcb);
 800d526:	687b      	ldr	r3, [r7, #4]
 800d528:	0018      	movs	r0, r3
 800d52a:	f7fe fbfd 	bl	800bd28 <tcp_pcb_purge>
          TCP_RMV_ACTIVE(pcb);
 800d52e:	4b4f      	ldr	r3, [pc, #316]	; (800d66c <tcp_process+0x714>)
 800d530:	681b      	ldr	r3, [r3, #0]
 800d532:	687a      	ldr	r2, [r7, #4]
 800d534:	429a      	cmp	r2, r3
 800d536:	d105      	bne.n	800d544 <tcp_process+0x5ec>
 800d538:	4b4c      	ldr	r3, [pc, #304]	; (800d66c <tcp_process+0x714>)
 800d53a:	681b      	ldr	r3, [r3, #0]
 800d53c:	691a      	ldr	r2, [r3, #16]
 800d53e:	4b4b      	ldr	r3, [pc, #300]	; (800d66c <tcp_process+0x714>)
 800d540:	601a      	str	r2, [r3, #0]
 800d542:	e013      	b.n	800d56c <tcp_process+0x614>
 800d544:	4b49      	ldr	r3, [pc, #292]	; (800d66c <tcp_process+0x714>)
 800d546:	681b      	ldr	r3, [r3, #0]
 800d548:	613b      	str	r3, [r7, #16]
 800d54a:	e00c      	b.n	800d566 <tcp_process+0x60e>
 800d54c:	693b      	ldr	r3, [r7, #16]
 800d54e:	691b      	ldr	r3, [r3, #16]
 800d550:	687a      	ldr	r2, [r7, #4]
 800d552:	429a      	cmp	r2, r3
 800d554:	d104      	bne.n	800d560 <tcp_process+0x608>
 800d556:	687b      	ldr	r3, [r7, #4]
 800d558:	691a      	ldr	r2, [r3, #16]
 800d55a:	693b      	ldr	r3, [r7, #16]
 800d55c:	611a      	str	r2, [r3, #16]
 800d55e:	e005      	b.n	800d56c <tcp_process+0x614>
 800d560:	693b      	ldr	r3, [r7, #16]
 800d562:	691b      	ldr	r3, [r3, #16]
 800d564:	613b      	str	r3, [r7, #16]
 800d566:	693b      	ldr	r3, [r7, #16]
 800d568:	2b00      	cmp	r3, #0
 800d56a:	d1ef      	bne.n	800d54c <tcp_process+0x5f4>
 800d56c:	687b      	ldr	r3, [r7, #4]
 800d56e:	2200      	movs	r2, #0
 800d570:	611a      	str	r2, [r3, #16]
 800d572:	4b3f      	ldr	r3, [pc, #252]	; (800d670 <tcp_process+0x718>)
 800d574:	2201      	movs	r2, #1
 800d576:	701a      	strb	r2, [r3, #0]
          pcb->state = TIME_WAIT;
 800d578:	687b      	ldr	r3, [r7, #4]
 800d57a:	220a      	movs	r2, #10
 800d57c:	761a      	strb	r2, [r3, #24]
          TCP_REG(&tcp_tw_pcbs, pcb);
 800d57e:	4b3d      	ldr	r3, [pc, #244]	; (800d674 <tcp_process+0x71c>)
 800d580:	681a      	ldr	r2, [r3, #0]
 800d582:	687b      	ldr	r3, [r7, #4]
 800d584:	611a      	str	r2, [r3, #16]
 800d586:	4b3b      	ldr	r3, [pc, #236]	; (800d674 <tcp_process+0x71c>)
 800d588:	687a      	ldr	r2, [r7, #4]
 800d58a:	601a      	str	r2, [r3, #0]
 800d58c:	f004 fa76 	bl	8011a7c <tcp_timer_needed>
        }
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
                 pcb->unsent == NULL) {
        pcb->state = FIN_WAIT_2;
      }
      break;
 800d590:	e0fa      	b.n	800d788 <tcp_process+0x830>
          tcp_ack_now(pcb);
 800d592:	687b      	ldr	r3, [r7, #4]
 800d594:	8bdb      	ldrh	r3, [r3, #30]
 800d596:	2202      	movs	r2, #2
 800d598:	4313      	orrs	r3, r2
 800d59a:	b29a      	uxth	r2, r3
 800d59c:	687b      	ldr	r3, [r7, #4]
 800d59e:	83da      	strh	r2, [r3, #30]
          pcb->state = CLOSING;
 800d5a0:	687b      	ldr	r3, [r7, #4]
 800d5a2:	2208      	movs	r2, #8
 800d5a4:	761a      	strb	r2, [r3, #24]
      break;
 800d5a6:	e0ef      	b.n	800d788 <tcp_process+0x830>
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800d5a8:	4b22      	ldr	r3, [pc, #136]	; (800d634 <tcp_process+0x6dc>)
 800d5aa:	781b      	ldrb	r3, [r3, #0]
 800d5ac:	001a      	movs	r2, r3
 800d5ae:	2310      	movs	r3, #16
 800d5b0:	4013      	ands	r3, r2
 800d5b2:	d100      	bne.n	800d5b6 <tcp_process+0x65e>
 800d5b4:	e0e8      	b.n	800d788 <tcp_process+0x830>
 800d5b6:	687b      	ldr	r3, [r7, #4]
 800d5b8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800d5ba:	4b1f      	ldr	r3, [pc, #124]	; (800d638 <tcp_process+0x6e0>)
 800d5bc:	681b      	ldr	r3, [r3, #0]
 800d5be:	429a      	cmp	r2, r3
 800d5c0:	d000      	beq.n	800d5c4 <tcp_process+0x66c>
 800d5c2:	e0e1      	b.n	800d788 <tcp_process+0x830>
                 pcb->unsent == NULL) {
 800d5c4:	687b      	ldr	r3, [r7, #4]
 800d5c6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 800d5c8:	2b00      	cmp	r3, #0
 800d5ca:	d000      	beq.n	800d5ce <tcp_process+0x676>
 800d5cc:	e0dc      	b.n	800d788 <tcp_process+0x830>
        pcb->state = FIN_WAIT_2;
 800d5ce:	687b      	ldr	r3, [r7, #4]
 800d5d0:	2206      	movs	r2, #6
 800d5d2:	761a      	strb	r2, [r3, #24]
      break;
 800d5d4:	e0d8      	b.n	800d788 <tcp_process+0x830>
    case FIN_WAIT_2:
      tcp_receive(pcb);
 800d5d6:	687b      	ldr	r3, [r7, #4]
 800d5d8:	0018      	movs	r0, r3
 800d5da:	f000 fa3d 	bl	800da58 <tcp_receive>
      if (recv_flags & TF_GOT_FIN) {
 800d5de:	4b1d      	ldr	r3, [pc, #116]	; (800d654 <tcp_process+0x6fc>)
 800d5e0:	781b      	ldrb	r3, [r3, #0]
 800d5e2:	001a      	movs	r2, r3
 800d5e4:	2320      	movs	r3, #32
 800d5e6:	4013      	ands	r3, r2
 800d5e8:	d100      	bne.n	800d5ec <tcp_process+0x694>
 800d5ea:	e0cf      	b.n	800d78c <tcp_process+0x834>
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
 800d5ec:	687b      	ldr	r3, [r7, #4]
 800d5ee:	8bdb      	ldrh	r3, [r3, #30]
 800d5f0:	2202      	movs	r2, #2
 800d5f2:	4313      	orrs	r3, r2
 800d5f4:	b29a      	uxth	r2, r3
 800d5f6:	687b      	ldr	r3, [r7, #4]
 800d5f8:	83da      	strh	r2, [r3, #30]
        tcp_pcb_purge(pcb);
 800d5fa:	687b      	ldr	r3, [r7, #4]
 800d5fc:	0018      	movs	r0, r3
 800d5fe:	f7fe fb93 	bl	800bd28 <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 800d602:	4b1a      	ldr	r3, [pc, #104]	; (800d66c <tcp_process+0x714>)
 800d604:	681b      	ldr	r3, [r3, #0]
 800d606:	687a      	ldr	r2, [r7, #4]
 800d608:	429a      	cmp	r2, r3
 800d60a:	d105      	bne.n	800d618 <tcp_process+0x6c0>
 800d60c:	4b17      	ldr	r3, [pc, #92]	; (800d66c <tcp_process+0x714>)
 800d60e:	681b      	ldr	r3, [r3, #0]
 800d610:	691a      	ldr	r2, [r3, #16]
 800d612:	4b16      	ldr	r3, [pc, #88]	; (800d66c <tcp_process+0x714>)
 800d614:	601a      	str	r2, [r3, #0]
 800d616:	e035      	b.n	800d684 <tcp_process+0x72c>
 800d618:	4b14      	ldr	r3, [pc, #80]	; (800d66c <tcp_process+0x714>)
 800d61a:	681b      	ldr	r3, [r3, #0]
 800d61c:	60fb      	str	r3, [r7, #12]
 800d61e:	e02e      	b.n	800d67e <tcp_process+0x726>
 800d620:	68fb      	ldr	r3, [r7, #12]
 800d622:	691b      	ldr	r3, [r3, #16]
 800d624:	687a      	ldr	r2, [r7, #4]
 800d626:	429a      	cmp	r2, r3
 800d628:	d126      	bne.n	800d678 <tcp_process+0x720>
 800d62a:	687b      	ldr	r3, [r7, #4]
 800d62c:	691a      	ldr	r2, [r3, #16]
 800d62e:	68fb      	ldr	r3, [r7, #12]
 800d630:	611a      	str	r2, [r3, #16]
 800d632:	e027      	b.n	800d684 <tcp_process+0x72c>
 800d634:	2000138c 	.word	0x2000138c
 800d638:	20001384 	.word	0x20001384
 800d63c:	0801f99c 	.word	0x0801f99c
 800d640:	000003a9 	.word	0x000003a9
 800d644:	0801fc34 	.word	0x0801fc34
 800d648:	0801f9dc 	.word	0x0801f9dc
 800d64c:	20001388 	.word	0x20001388
 800d650:	0000111c 	.word	0x0000111c
 800d654:	2000138d 	.word	0x2000138d
 800d658:	2000138a 	.word	0x2000138a
 800d65c:	20001380 	.word	0x20001380
 800d660:	20001370 	.word	0x20001370
 800d664:	200014d8 	.word	0x200014d8
 800d668:	200014d4 	.word	0x200014d4
 800d66c:	20002b18 	.word	0x20002b18
 800d670:	20002b14 	.word	0x20002b14
 800d674:	20002b28 	.word	0x20002b28
 800d678:	68fb      	ldr	r3, [r7, #12]
 800d67a:	691b      	ldr	r3, [r3, #16]
 800d67c:	60fb      	str	r3, [r7, #12]
 800d67e:	68fb      	ldr	r3, [r7, #12]
 800d680:	2b00      	cmp	r3, #0
 800d682:	d1cd      	bne.n	800d620 <tcp_process+0x6c8>
 800d684:	687b      	ldr	r3, [r7, #4]
 800d686:	2200      	movs	r2, #0
 800d688:	611a      	str	r2, [r3, #16]
 800d68a:	4b45      	ldr	r3, [pc, #276]	; (800d7a0 <tcp_process+0x848>)
 800d68c:	2201      	movs	r2, #1
 800d68e:	701a      	strb	r2, [r3, #0]
        pcb->state = TIME_WAIT;
 800d690:	687b      	ldr	r3, [r7, #4]
 800d692:	220a      	movs	r2, #10
 800d694:	761a      	strb	r2, [r3, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
 800d696:	4b43      	ldr	r3, [pc, #268]	; (800d7a4 <tcp_process+0x84c>)
 800d698:	681a      	ldr	r2, [r3, #0]
 800d69a:	687b      	ldr	r3, [r7, #4]
 800d69c:	611a      	str	r2, [r3, #16]
 800d69e:	4b41      	ldr	r3, [pc, #260]	; (800d7a4 <tcp_process+0x84c>)
 800d6a0:	687a      	ldr	r2, [r7, #4]
 800d6a2:	601a      	str	r2, [r3, #0]
 800d6a4:	f004 f9ea 	bl	8011a7c <tcp_timer_needed>
      }
      break;
 800d6a8:	e070      	b.n	800d78c <tcp_process+0x834>
    case CLOSING:
      tcp_receive(pcb);
 800d6aa:	687b      	ldr	r3, [r7, #4]
 800d6ac:	0018      	movs	r0, r3
 800d6ae:	f000 f9d3 	bl	800da58 <tcp_receive>
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 800d6b2:	4b3d      	ldr	r3, [pc, #244]	; (800d7a8 <tcp_process+0x850>)
 800d6b4:	781b      	ldrb	r3, [r3, #0]
 800d6b6:	001a      	movs	r2, r3
 800d6b8:	2310      	movs	r3, #16
 800d6ba:	4013      	ands	r3, r2
 800d6bc:	d100      	bne.n	800d6c0 <tcp_process+0x768>
 800d6be:	e067      	b.n	800d790 <tcp_process+0x838>
 800d6c0:	687b      	ldr	r3, [r7, #4]
 800d6c2:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800d6c4:	4b39      	ldr	r3, [pc, #228]	; (800d7ac <tcp_process+0x854>)
 800d6c6:	681b      	ldr	r3, [r3, #0]
 800d6c8:	429a      	cmp	r2, r3
 800d6ca:	d161      	bne.n	800d790 <tcp_process+0x838>
 800d6cc:	687b      	ldr	r3, [r7, #4]
 800d6ce:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d6d0:	2b00      	cmp	r3, #0
 800d6d2:	d15d      	bne.n	800d790 <tcp_process+0x838>
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_pcb_purge(pcb);
 800d6d4:	687b      	ldr	r3, [r7, #4]
 800d6d6:	0018      	movs	r0, r3
 800d6d8:	f7fe fb26 	bl	800bd28 <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 800d6dc:	4b34      	ldr	r3, [pc, #208]	; (800d7b0 <tcp_process+0x858>)
 800d6de:	681b      	ldr	r3, [r3, #0]
 800d6e0:	687a      	ldr	r2, [r7, #4]
 800d6e2:	429a      	cmp	r2, r3
 800d6e4:	d105      	bne.n	800d6f2 <tcp_process+0x79a>
 800d6e6:	4b32      	ldr	r3, [pc, #200]	; (800d7b0 <tcp_process+0x858>)
 800d6e8:	681b      	ldr	r3, [r3, #0]
 800d6ea:	691a      	ldr	r2, [r3, #16]
 800d6ec:	4b30      	ldr	r3, [pc, #192]	; (800d7b0 <tcp_process+0x858>)
 800d6ee:	601a      	str	r2, [r3, #0]
 800d6f0:	e013      	b.n	800d71a <tcp_process+0x7c2>
 800d6f2:	4b2f      	ldr	r3, [pc, #188]	; (800d7b0 <tcp_process+0x858>)
 800d6f4:	681b      	ldr	r3, [r3, #0]
 800d6f6:	61bb      	str	r3, [r7, #24]
 800d6f8:	e00c      	b.n	800d714 <tcp_process+0x7bc>
 800d6fa:	69bb      	ldr	r3, [r7, #24]
 800d6fc:	691b      	ldr	r3, [r3, #16]
 800d6fe:	687a      	ldr	r2, [r7, #4]
 800d700:	429a      	cmp	r2, r3
 800d702:	d104      	bne.n	800d70e <tcp_process+0x7b6>
 800d704:	687b      	ldr	r3, [r7, #4]
 800d706:	691a      	ldr	r2, [r3, #16]
 800d708:	69bb      	ldr	r3, [r7, #24]
 800d70a:	611a      	str	r2, [r3, #16]
 800d70c:	e005      	b.n	800d71a <tcp_process+0x7c2>
 800d70e:	69bb      	ldr	r3, [r7, #24]
 800d710:	691b      	ldr	r3, [r3, #16]
 800d712:	61bb      	str	r3, [r7, #24]
 800d714:	69bb      	ldr	r3, [r7, #24]
 800d716:	2b00      	cmp	r3, #0
 800d718:	d1ef      	bne.n	800d6fa <tcp_process+0x7a2>
 800d71a:	687b      	ldr	r3, [r7, #4]
 800d71c:	2200      	movs	r2, #0
 800d71e:	611a      	str	r2, [r3, #16]
 800d720:	4b1f      	ldr	r3, [pc, #124]	; (800d7a0 <tcp_process+0x848>)
 800d722:	2201      	movs	r2, #1
 800d724:	701a      	strb	r2, [r3, #0]
        pcb->state = TIME_WAIT;
 800d726:	687b      	ldr	r3, [r7, #4]
 800d728:	220a      	movs	r2, #10
 800d72a:	761a      	strb	r2, [r3, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
 800d72c:	4b1d      	ldr	r3, [pc, #116]	; (800d7a4 <tcp_process+0x84c>)
 800d72e:	681a      	ldr	r2, [r3, #0]
 800d730:	687b      	ldr	r3, [r7, #4]
 800d732:	611a      	str	r2, [r3, #16]
 800d734:	4b1b      	ldr	r3, [pc, #108]	; (800d7a4 <tcp_process+0x84c>)
 800d736:	687a      	ldr	r2, [r7, #4]
 800d738:	601a      	str	r2, [r3, #0]
 800d73a:	f004 f99f 	bl	8011a7c <tcp_timer_needed>
      }
      break;
 800d73e:	e027      	b.n	800d790 <tcp_process+0x838>
    case LAST_ACK:
      tcp_receive(pcb);
 800d740:	687b      	ldr	r3, [r7, #4]
 800d742:	0018      	movs	r0, r3
 800d744:	f000 f988 	bl	800da58 <tcp_receive>
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 800d748:	4b17      	ldr	r3, [pc, #92]	; (800d7a8 <tcp_process+0x850>)
 800d74a:	781b      	ldrb	r3, [r3, #0]
 800d74c:	001a      	movs	r2, r3
 800d74e:	2310      	movs	r3, #16
 800d750:	4013      	ands	r3, r2
 800d752:	d01f      	beq.n	800d794 <tcp_process+0x83c>
 800d754:	687b      	ldr	r3, [r7, #4]
 800d756:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800d758:	4b14      	ldr	r3, [pc, #80]	; (800d7ac <tcp_process+0x854>)
 800d75a:	681b      	ldr	r3, [r3, #0]
 800d75c:	429a      	cmp	r2, r3
 800d75e:	d119      	bne.n	800d794 <tcp_process+0x83c>
 800d760:	687b      	ldr	r3, [r7, #4]
 800d762:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d764:	2b00      	cmp	r3, #0
 800d766:	d115      	bne.n	800d794 <tcp_process+0x83c>
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
        recv_flags |= TF_CLOSED;
 800d768:	4b12      	ldr	r3, [pc, #72]	; (800d7b4 <tcp_process+0x85c>)
 800d76a:	781b      	ldrb	r3, [r3, #0]
 800d76c:	2210      	movs	r2, #16
 800d76e:	4313      	orrs	r3, r2
 800d770:	b2da      	uxtb	r2, r3
 800d772:	4b10      	ldr	r3, [pc, #64]	; (800d7b4 <tcp_process+0x85c>)
 800d774:	701a      	strb	r2, [r3, #0]
      }
      break;
 800d776:	e00d      	b.n	800d794 <tcp_process+0x83c>
    default:
      break;
 800d778:	46c0      	nop			; (mov r8, r8)
 800d77a:	e00c      	b.n	800d796 <tcp_process+0x83e>
      break;
 800d77c:	46c0      	nop			; (mov r8, r8)
 800d77e:	e00a      	b.n	800d796 <tcp_process+0x83e>
      break;
 800d780:	46c0      	nop			; (mov r8, r8)
 800d782:	e008      	b.n	800d796 <tcp_process+0x83e>
      break;
 800d784:	46c0      	nop			; (mov r8, r8)
 800d786:	e006      	b.n	800d796 <tcp_process+0x83e>
      break;
 800d788:	46c0      	nop			; (mov r8, r8)
 800d78a:	e004      	b.n	800d796 <tcp_process+0x83e>
      break;
 800d78c:	46c0      	nop			; (mov r8, r8)
 800d78e:	e002      	b.n	800d796 <tcp_process+0x83e>
      break;
 800d790:	46c0      	nop			; (mov r8, r8)
 800d792:	e000      	b.n	800d796 <tcp_process+0x83e>
      break;
 800d794:	46c0      	nop			; (mov r8, r8)
  }
  return ERR_OK;
 800d796:	2300      	movs	r3, #0
}
 800d798:	0018      	movs	r0, r3
 800d79a:	46bd      	mov	sp, r7
 800d79c:	b008      	add	sp, #32
 800d79e:	bdb0      	pop	{r4, r5, r7, pc}
 800d7a0:	20002b14 	.word	0x20002b14
 800d7a4:	20002b28 	.word	0x20002b28
 800d7a8:	2000138c 	.word	0x2000138c
 800d7ac:	20001384 	.word	0x20001384
 800d7b0:	20002b18 	.word	0x20002b18
 800d7b4:	2000138d 	.word	0x2000138d

0800d7b8 <tcp_oos_insert_segment>:
 *
 * Called from tcp_receive()
 */
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
 800d7b8:	b590      	push	{r4, r7, lr}
 800d7ba:	b085      	sub	sp, #20
 800d7bc:	af00      	add	r7, sp, #0
 800d7be:	6078      	str	r0, [r7, #4]
 800d7c0:	6039      	str	r1, [r7, #0]
  struct tcp_seg *old_seg;

  LWIP_ASSERT("tcp_oos_insert_segment: invalid cseg", cseg != NULL);
 800d7c2:	687b      	ldr	r3, [r7, #4]
 800d7c4:	2b00      	cmp	r3, #0
 800d7c6:	d106      	bne.n	800d7d6 <tcp_oos_insert_segment+0x1e>
 800d7c8:	4b57      	ldr	r3, [pc, #348]	; (800d928 <tcp_oos_insert_segment+0x170>)
 800d7ca:	2284      	movs	r2, #132	; 0x84
 800d7cc:	00d2      	lsls	r2, r2, #3
 800d7ce:	4957      	ldr	r1, [pc, #348]	; (800d92c <tcp_oos_insert_segment+0x174>)
 800d7d0:	4857      	ldr	r0, [pc, #348]	; (800d930 <tcp_oos_insert_segment+0x178>)
 800d7d2:	f7f4 fcfb 	bl	80021cc <app_debug_rtt_raw>

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 800d7d6:	687b      	ldr	r3, [r7, #4]
 800d7d8:	691b      	ldr	r3, [r3, #16]
 800d7da:	7b1a      	ldrb	r2, [r3, #12]
 800d7dc:	7b5b      	ldrb	r3, [r3, #13]
 800d7de:	021b      	lsls	r3, r3, #8
 800d7e0:	4313      	orrs	r3, r2
 800d7e2:	b29b      	uxth	r3, r3
 800d7e4:	0018      	movs	r0, r3
 800d7e6:	f7f8 fea5 	bl	8006534 <lwip_htons>
 800d7ea:	0003      	movs	r3, r0
 800d7ec:	b2db      	uxtb	r3, r3
 800d7ee:	001a      	movs	r2, r3
 800d7f0:	2301      	movs	r3, #1
 800d7f2:	4013      	ands	r3, r2
 800d7f4:	d042      	beq.n	800d87c <tcp_oos_insert_segment+0xc4>
    /* received segment overlaps all following segments */
    tcp_segs_free(next);
 800d7f6:	683b      	ldr	r3, [r7, #0]
 800d7f8:	0018      	movs	r0, r3
 800d7fa:	f7fd ffb7 	bl	800b76c <tcp_segs_free>
    next = NULL;
 800d7fe:	2300      	movs	r3, #0
 800d800:	603b      	str	r3, [r7, #0]
 800d802:	e08a      	b.n	800d91a <tcp_oos_insert_segment+0x162>
       oos queue may have segments with FIN flag */
    while (next &&
           TCP_SEQ_GEQ((seqno + cseg->len),
                       (next->tcphdr->seqno + next->len))) {
      /* cseg with FIN already processed */
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 800d804:	683b      	ldr	r3, [r7, #0]
 800d806:	691b      	ldr	r3, [r3, #16]
 800d808:	7b1a      	ldrb	r2, [r3, #12]
 800d80a:	7b5b      	ldrb	r3, [r3, #13]
 800d80c:	021b      	lsls	r3, r3, #8
 800d80e:	4313      	orrs	r3, r2
 800d810:	b29b      	uxth	r3, r3
 800d812:	0018      	movs	r0, r3
 800d814:	f7f8 fe8e 	bl	8006534 <lwip_htons>
 800d818:	0003      	movs	r3, r0
 800d81a:	b2db      	uxtb	r3, r3
 800d81c:	001a      	movs	r2, r3
 800d81e:	2301      	movs	r3, #1
 800d820:	4013      	ands	r3, r2
 800d822:	d022      	beq.n	800d86a <tcp_oos_insert_segment+0xb2>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
 800d824:	687b      	ldr	r3, [r7, #4]
 800d826:	691b      	ldr	r3, [r3, #16]
 800d828:	7b1a      	ldrb	r2, [r3, #12]
 800d82a:	7b5b      	ldrb	r3, [r3, #13]
 800d82c:	021b      	lsls	r3, r3, #8
 800d82e:	4313      	orrs	r3, r2
 800d830:	b29c      	uxth	r4, r3
 800d832:	2001      	movs	r0, #1
 800d834:	f7f8 fe7e 	bl	8006534 <lwip_htons>
 800d838:	0003      	movs	r3, r0
 800d83a:	001a      	movs	r2, r3
 800d83c:	687b      	ldr	r3, [r7, #4]
 800d83e:	691b      	ldr	r3, [r3, #16]
 800d840:	4322      	orrs	r2, r4
 800d842:	b292      	uxth	r2, r2
 800d844:	21ff      	movs	r1, #255	; 0xff
 800d846:	4011      	ands	r1, r2
 800d848:	000c      	movs	r4, r1
 800d84a:	7b19      	ldrb	r1, [r3, #12]
 800d84c:	2000      	movs	r0, #0
 800d84e:	4001      	ands	r1, r0
 800d850:	1c08      	adds	r0, r1, #0
 800d852:	1c21      	adds	r1, r4, #0
 800d854:	4301      	orrs	r1, r0
 800d856:	7319      	strb	r1, [r3, #12]
 800d858:	0a12      	lsrs	r2, r2, #8
 800d85a:	b290      	uxth	r0, r2
 800d85c:	7b5a      	ldrb	r2, [r3, #13]
 800d85e:	2100      	movs	r1, #0
 800d860:	400a      	ands	r2, r1
 800d862:	1c11      	adds	r1, r2, #0
 800d864:	1c02      	adds	r2, r0, #0
 800d866:	430a      	orrs	r2, r1
 800d868:	735a      	strb	r2, [r3, #13]
      }
      old_seg = next;
 800d86a:	683b      	ldr	r3, [r7, #0]
 800d86c:	60fb      	str	r3, [r7, #12]
      next = next->next;
 800d86e:	683b      	ldr	r3, [r7, #0]
 800d870:	681b      	ldr	r3, [r3, #0]
 800d872:	603b      	str	r3, [r7, #0]
      tcp_seg_free(old_seg);
 800d874:	68fb      	ldr	r3, [r7, #12]
 800d876:	0018      	movs	r0, r3
 800d878:	f7fd ff8e 	bl	800b798 <tcp_seg_free>
    while (next &&
 800d87c:	683b      	ldr	r3, [r7, #0]
 800d87e:	2b00      	cmp	r3, #0
 800d880:	d017      	beq.n	800d8b2 <tcp_oos_insert_segment+0xfa>
           TCP_SEQ_GEQ((seqno + cseg->len),
 800d882:	687b      	ldr	r3, [r7, #4]
 800d884:	891b      	ldrh	r3, [r3, #8]
 800d886:	001a      	movs	r2, r3
 800d888:	4b2a      	ldr	r3, [pc, #168]	; (800d934 <tcp_oos_insert_segment+0x17c>)
 800d88a:	681b      	ldr	r3, [r3, #0]
 800d88c:	18d2      	adds	r2, r2, r3
 800d88e:	683b      	ldr	r3, [r7, #0]
 800d890:	691b      	ldr	r3, [r3, #16]
 800d892:	7919      	ldrb	r1, [r3, #4]
 800d894:	7958      	ldrb	r0, [r3, #5]
 800d896:	0200      	lsls	r0, r0, #8
 800d898:	4301      	orrs	r1, r0
 800d89a:	7998      	ldrb	r0, [r3, #6]
 800d89c:	0400      	lsls	r0, r0, #16
 800d89e:	4301      	orrs	r1, r0
 800d8a0:	79db      	ldrb	r3, [r3, #7]
 800d8a2:	061b      	lsls	r3, r3, #24
 800d8a4:	430b      	orrs	r3, r1
 800d8a6:	0019      	movs	r1, r3
 800d8a8:	683b      	ldr	r3, [r7, #0]
 800d8aa:	891b      	ldrh	r3, [r3, #8]
 800d8ac:	18cb      	adds	r3, r1, r3
 800d8ae:	1ad3      	subs	r3, r2, r3
    while (next &&
 800d8b0:	d5a8      	bpl.n	800d804 <tcp_oos_insert_segment+0x4c>
    }
    if (next &&
 800d8b2:	683b      	ldr	r3, [r7, #0]
 800d8b4:	2b00      	cmp	r3, #0
 800d8b6:	d030      	beq.n	800d91a <tcp_oos_insert_segment+0x162>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
 800d8b8:	687b      	ldr	r3, [r7, #4]
 800d8ba:	891b      	ldrh	r3, [r3, #8]
 800d8bc:	001a      	movs	r2, r3
 800d8be:	4b1d      	ldr	r3, [pc, #116]	; (800d934 <tcp_oos_insert_segment+0x17c>)
 800d8c0:	681b      	ldr	r3, [r3, #0]
 800d8c2:	18d2      	adds	r2, r2, r3
 800d8c4:	683b      	ldr	r3, [r7, #0]
 800d8c6:	691b      	ldr	r3, [r3, #16]
 800d8c8:	7919      	ldrb	r1, [r3, #4]
 800d8ca:	7958      	ldrb	r0, [r3, #5]
 800d8cc:	0200      	lsls	r0, r0, #8
 800d8ce:	4301      	orrs	r1, r0
 800d8d0:	7998      	ldrb	r0, [r3, #6]
 800d8d2:	0400      	lsls	r0, r0, #16
 800d8d4:	4301      	orrs	r1, r0
 800d8d6:	79db      	ldrb	r3, [r3, #7]
 800d8d8:	061b      	lsls	r3, r3, #24
 800d8da:	430b      	orrs	r3, r1
 800d8dc:	1ad3      	subs	r3, r2, r3
    if (next &&
 800d8de:	2b00      	cmp	r3, #0
 800d8e0:	dd1b      	ble.n	800d91a <tcp_oos_insert_segment+0x162>
      /* We need to trim the incoming segment. */
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
 800d8e2:	683b      	ldr	r3, [r7, #0]
 800d8e4:	691b      	ldr	r3, [r3, #16]
 800d8e6:	791a      	ldrb	r2, [r3, #4]
 800d8e8:	7959      	ldrb	r1, [r3, #5]
 800d8ea:	0209      	lsls	r1, r1, #8
 800d8ec:	430a      	orrs	r2, r1
 800d8ee:	7999      	ldrb	r1, [r3, #6]
 800d8f0:	0409      	lsls	r1, r1, #16
 800d8f2:	430a      	orrs	r2, r1
 800d8f4:	79db      	ldrb	r3, [r3, #7]
 800d8f6:	061b      	lsls	r3, r3, #24
 800d8f8:	4313      	orrs	r3, r2
 800d8fa:	b29a      	uxth	r2, r3
 800d8fc:	4b0d      	ldr	r3, [pc, #52]	; (800d934 <tcp_oos_insert_segment+0x17c>)
 800d8fe:	681b      	ldr	r3, [r3, #0]
 800d900:	b29b      	uxth	r3, r3
 800d902:	1ad3      	subs	r3, r2, r3
 800d904:	b29a      	uxth	r2, r3
 800d906:	687b      	ldr	r3, [r7, #4]
 800d908:	811a      	strh	r2, [r3, #8]
      pbuf_realloc(cseg->p, cseg->len);
 800d90a:	687b      	ldr	r3, [r7, #4]
 800d90c:	685a      	ldr	r2, [r3, #4]
 800d90e:	687b      	ldr	r3, [r7, #4]
 800d910:	891b      	ldrh	r3, [r3, #8]
 800d912:	0019      	movs	r1, r3
 800d914:	0010      	movs	r0, r2
 800d916:	f7fb fcc3 	bl	80092a0 <pbuf_realloc>
    }
  }
  cseg->next = next;
 800d91a:	687b      	ldr	r3, [r7, #4]
 800d91c:	683a      	ldr	r2, [r7, #0]
 800d91e:	601a      	str	r2, [r3, #0]
}
 800d920:	46c0      	nop			; (mov r8, r8)
 800d922:	46bd      	mov	sp, r7
 800d924:	b005      	add	sp, #20
 800d926:	bd90      	pop	{r4, r7, pc}
 800d928:	0801f99c 	.word	0x0801f99c
 800d92c:	0801fc54 	.word	0x0801fc54
 800d930:	0801f9dc 	.word	0x0801f9dc
 800d934:	20001380 	.word	0x20001380

0800d938 <tcp_free_acked_segments>:

/** Remove segments from a list if the incoming ACK acknowledges them */
static struct tcp_seg *
tcp_free_acked_segments(struct tcp_pcb *pcb, struct tcp_seg *seg_list, const char *dbg_list_name,
                        struct tcp_seg *dbg_other_seg_list)
{
 800d938:	b5b0      	push	{r4, r5, r7, lr}
 800d93a:	b086      	sub	sp, #24
 800d93c:	af00      	add	r7, sp, #0
 800d93e:	60f8      	str	r0, [r7, #12]
 800d940:	60b9      	str	r1, [r7, #8]
 800d942:	607a      	str	r2, [r7, #4]
 800d944:	603b      	str	r3, [r7, #0]
  u16_t clen;

  LWIP_UNUSED_ARG(dbg_list_name);
  LWIP_UNUSED_ARG(dbg_other_seg_list);

  while (seg_list != NULL &&
 800d946:	e043      	b.n	800d9d0 <tcp_free_acked_segments+0x98>
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->%s\n",
                                  lwip_ntohl(seg_list->tcphdr->seqno),
                                  lwip_ntohl(seg_list->tcphdr->seqno) + TCP_TCPLEN(seg_list),
                                  dbg_list_name));

    next = seg_list;
 800d948:	68bb      	ldr	r3, [r7, #8]
 800d94a:	617b      	str	r3, [r7, #20]
    seg_list = seg_list->next;
 800d94c:	68bb      	ldr	r3, [r7, #8]
 800d94e:	681b      	ldr	r3, [r3, #0]
 800d950:	60bb      	str	r3, [r7, #8]

    clen = pbuf_clen(next->p);
 800d952:	697b      	ldr	r3, [r7, #20]
 800d954:	685b      	ldr	r3, [r3, #4]
 800d956:	2512      	movs	r5, #18
 800d958:	197c      	adds	r4, r7, r5
 800d95a:	0018      	movs	r0, r3
 800d95c:	f7fb ff3a 	bl	80097d4 <pbuf_clen>
 800d960:	0003      	movs	r3, r0
 800d962:	8023      	strh	r3, [r4, #0]
    LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"TCPWNDSIZE_F" ... ",
                                 (tcpwnd_size_t)pcb->snd_queuelen));
    LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= clen));
 800d964:	68fb      	ldr	r3, [r7, #12]
 800d966:	226a      	movs	r2, #106	; 0x6a
 800d968:	5a9b      	ldrh	r3, [r3, r2]
 800d96a:	197a      	adds	r2, r7, r5
 800d96c:	8812      	ldrh	r2, [r2, #0]
 800d96e:	429a      	cmp	r2, r3
 800d970:	d906      	bls.n	800d980 <tcp_free_acked_segments+0x48>
 800d972:	4b32      	ldr	r3, [pc, #200]	; (800da3c <tcp_free_acked_segments+0x104>)
 800d974:	228b      	movs	r2, #139	; 0x8b
 800d976:	00d2      	lsls	r2, r2, #3
 800d978:	4931      	ldr	r1, [pc, #196]	; (800da40 <tcp_free_acked_segments+0x108>)
 800d97a:	4832      	ldr	r0, [pc, #200]	; (800da44 <tcp_free_acked_segments+0x10c>)
 800d97c:	f7f4 fc26 	bl	80021cc <app_debug_rtt_raw>

    pcb->snd_queuelen = (u16_t)(pcb->snd_queuelen - clen);
 800d980:	68fb      	ldr	r3, [r7, #12]
 800d982:	226a      	movs	r2, #106	; 0x6a
 800d984:	5a9a      	ldrh	r2, [r3, r2]
 800d986:	2312      	movs	r3, #18
 800d988:	18fb      	adds	r3, r7, r3
 800d98a:	881b      	ldrh	r3, [r3, #0]
 800d98c:	1ad3      	subs	r3, r2, r3
 800d98e:	b299      	uxth	r1, r3
 800d990:	68fb      	ldr	r3, [r7, #12]
 800d992:	226a      	movs	r2, #106	; 0x6a
 800d994:	5299      	strh	r1, [r3, r2]
    recv_acked = (tcpwnd_size_t)(recv_acked + next->len);
 800d996:	697b      	ldr	r3, [r7, #20]
 800d998:	891a      	ldrh	r2, [r3, #8]
 800d99a:	4b2b      	ldr	r3, [pc, #172]	; (800da48 <tcp_free_acked_segments+0x110>)
 800d99c:	881b      	ldrh	r3, [r3, #0]
 800d99e:	18d3      	adds	r3, r2, r3
 800d9a0:	b29a      	uxth	r2, r3
 800d9a2:	4b29      	ldr	r3, [pc, #164]	; (800da48 <tcp_free_acked_segments+0x110>)
 800d9a4:	801a      	strh	r2, [r3, #0]
    tcp_seg_free(next);
 800d9a6:	697b      	ldr	r3, [r7, #20]
 800d9a8:	0018      	movs	r0, r3
 800d9aa:	f7fd fef5 	bl	800b798 <tcp_seg_free>

    LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"TCPWNDSIZE_F" (after freeing %s)\n",
                                 (tcpwnd_size_t)pcb->snd_queuelen,
                                 dbg_list_name));
    if (pcb->snd_queuelen != 0) {
 800d9ae:	68fb      	ldr	r3, [r7, #12]
 800d9b0:	226a      	movs	r2, #106	; 0x6a
 800d9b2:	5a9b      	ldrh	r3, [r3, r2]
 800d9b4:	2b00      	cmp	r3, #0
 800d9b6:	d00b      	beq.n	800d9d0 <tcp_free_acked_segments+0x98>
      LWIP_ASSERT("tcp_receive: valid queue length",
 800d9b8:	68bb      	ldr	r3, [r7, #8]
 800d9ba:	2b00      	cmp	r3, #0
 800d9bc:	d108      	bne.n	800d9d0 <tcp_free_acked_segments+0x98>
 800d9be:	683b      	ldr	r3, [r7, #0]
 800d9c0:	2b00      	cmp	r3, #0
 800d9c2:	d105      	bne.n	800d9d0 <tcp_free_acked_segments+0x98>
 800d9c4:	4b1d      	ldr	r3, [pc, #116]	; (800da3c <tcp_free_acked_segments+0x104>)
 800d9c6:	4a21      	ldr	r2, [pc, #132]	; (800da4c <tcp_free_acked_segments+0x114>)
 800d9c8:	4921      	ldr	r1, [pc, #132]	; (800da50 <tcp_free_acked_segments+0x118>)
 800d9ca:	481e      	ldr	r0, [pc, #120]	; (800da44 <tcp_free_acked_segments+0x10c>)
 800d9cc:	f7f4 fbfe 	bl	80021cc <app_debug_rtt_raw>
  while (seg_list != NULL &&
 800d9d0:	68bb      	ldr	r3, [r7, #8]
 800d9d2:	2b00      	cmp	r3, #0
 800d9d4:	d02c      	beq.n	800da30 <tcp_free_acked_segments+0xf8>
         TCP_SEQ_LEQ(lwip_ntohl(seg_list->tcphdr->seqno) +
 800d9d6:	68bb      	ldr	r3, [r7, #8]
 800d9d8:	691b      	ldr	r3, [r3, #16]
 800d9da:	791a      	ldrb	r2, [r3, #4]
 800d9dc:	7959      	ldrb	r1, [r3, #5]
 800d9de:	0209      	lsls	r1, r1, #8
 800d9e0:	430a      	orrs	r2, r1
 800d9e2:	7999      	ldrb	r1, [r3, #6]
 800d9e4:	0409      	lsls	r1, r1, #16
 800d9e6:	430a      	orrs	r2, r1
 800d9e8:	79db      	ldrb	r3, [r3, #7]
 800d9ea:	061b      	lsls	r3, r3, #24
 800d9ec:	4313      	orrs	r3, r2
 800d9ee:	0018      	movs	r0, r3
 800d9f0:	f7f8 fdb6 	bl	8006560 <lwip_htonl>
 800d9f4:	0004      	movs	r4, r0
 800d9f6:	68bb      	ldr	r3, [r7, #8]
 800d9f8:	891b      	ldrh	r3, [r3, #8]
 800d9fa:	001d      	movs	r5, r3
 800d9fc:	68bb      	ldr	r3, [r7, #8]
 800d9fe:	691b      	ldr	r3, [r3, #16]
 800da00:	7b1a      	ldrb	r2, [r3, #12]
 800da02:	7b5b      	ldrb	r3, [r3, #13]
 800da04:	021b      	lsls	r3, r3, #8
 800da06:	4313      	orrs	r3, r2
 800da08:	b29b      	uxth	r3, r3
 800da0a:	0018      	movs	r0, r3
 800da0c:	f7f8 fd92 	bl	8006534 <lwip_htons>
 800da10:	0003      	movs	r3, r0
 800da12:	b2db      	uxtb	r3, r3
 800da14:	001a      	movs	r2, r3
 800da16:	2303      	movs	r3, #3
 800da18:	4013      	ands	r3, r2
 800da1a:	d001      	beq.n	800da20 <tcp_free_acked_segments+0xe8>
 800da1c:	2301      	movs	r3, #1
 800da1e:	e000      	b.n	800da22 <tcp_free_acked_segments+0xea>
 800da20:	2300      	movs	r3, #0
 800da22:	195b      	adds	r3, r3, r5
 800da24:	18e2      	adds	r2, r4, r3
 800da26:	4b0b      	ldr	r3, [pc, #44]	; (800da54 <tcp_free_acked_segments+0x11c>)
 800da28:	681b      	ldr	r3, [r3, #0]
 800da2a:	1ad3      	subs	r3, r2, r3
  while (seg_list != NULL &&
 800da2c:	2b00      	cmp	r3, #0
 800da2e:	dd8b      	ble.n	800d948 <tcp_free_acked_segments+0x10>
                  seg_list != NULL || dbg_other_seg_list != NULL);
    }
  }
  return seg_list;
 800da30:	68bb      	ldr	r3, [r7, #8]
}
 800da32:	0018      	movs	r0, r3
 800da34:	46bd      	mov	sp, r7
 800da36:	b006      	add	sp, #24
 800da38:	bdb0      	pop	{r4, r5, r7, pc}
 800da3a:	46c0      	nop			; (mov r8, r8)
 800da3c:	0801f99c 	.word	0x0801f99c
 800da40:	0801fc7c 	.word	0x0801fc7c
 800da44:	0801f9dc 	.word	0x0801f9dc
 800da48:	20001388 	.word	0x20001388
 800da4c:	00000462 	.word	0x00000462
 800da50:	0801fca4 	.word	0x0801fca4
 800da54:	20001384 	.word	0x20001384

0800da58 <tcp_receive>:
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
 800da58:	b5b0      	push	{r4, r5, r7, lr}
 800da5a:	b094      	sub	sp, #80	; 0x50
 800da5c:	af00      	add	r7, sp, #0
 800da5e:	6078      	str	r0, [r7, #4]
  s16_t m;
  u32_t right_wnd_edge;
  int found_dupack = 0;
 800da60:	2300      	movs	r3, #0
 800da62:	64bb      	str	r3, [r7, #72]	; 0x48

  LWIP_ASSERT("tcp_receive: invalid pcb", pcb != NULL);
 800da64:	687b      	ldr	r3, [r7, #4]
 800da66:	2b00      	cmp	r3, #0
 800da68:	d105      	bne.n	800da76 <tcp_receive+0x1e>
 800da6a:	4bba      	ldr	r3, [pc, #744]	; (800dd54 <tcp_receive+0x2fc>)
 800da6c:	4aba      	ldr	r2, [pc, #744]	; (800dd58 <tcp_receive+0x300>)
 800da6e:	49bb      	ldr	r1, [pc, #748]	; (800dd5c <tcp_receive+0x304>)
 800da70:	48bb      	ldr	r0, [pc, #748]	; (800dd60 <tcp_receive+0x308>)
 800da72:	f7f4 fbab 	bl	80021cc <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 800da76:	687b      	ldr	r3, [r7, #4]
 800da78:	7e1b      	ldrb	r3, [r3, #24]
 800da7a:	2b03      	cmp	r3, #3
 800da7c:	d805      	bhi.n	800da8a <tcp_receive+0x32>
 800da7e:	4bb5      	ldr	r3, [pc, #724]	; (800dd54 <tcp_receive+0x2fc>)
 800da80:	4ab8      	ldr	r2, [pc, #736]	; (800dd64 <tcp_receive+0x30c>)
 800da82:	49b9      	ldr	r1, [pc, #740]	; (800dd68 <tcp_receive+0x310>)
 800da84:	48b6      	ldr	r0, [pc, #728]	; (800dd60 <tcp_receive+0x308>)
 800da86:	f7f4 fba1 	bl	80021cc <app_debug_rtt_raw>

  if (flags & TCP_ACK) {
 800da8a:	4bb8      	ldr	r3, [pc, #736]	; (800dd6c <tcp_receive+0x314>)
 800da8c:	781b      	ldrb	r3, [r3, #0]
 800da8e:	001a      	movs	r2, r3
 800da90:	2310      	movs	r3, #16
 800da92:	4013      	ands	r3, r2
 800da94:	d100      	bne.n	800da98 <tcp_receive+0x40>
 800da96:	e294      	b.n	800dfc2 <tcp_receive+0x56a>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 800da98:	687b      	ldr	r3, [r7, #4]
 800da9a:	2264      	movs	r2, #100	; 0x64
 800da9c:	5a9b      	ldrh	r3, [r3, r2]
 800da9e:	001a      	movs	r2, r3
 800daa0:	687b      	ldr	r3, [r7, #4]
 800daa2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800daa4:	18d3      	adds	r3, r2, r3
 800daa6:	633b      	str	r3, [r7, #48]	; 0x30

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 800daa8:	687b      	ldr	r3, [r7, #4]
 800daaa:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800daac:	4bb0      	ldr	r3, [pc, #704]	; (800dd70 <tcp_receive+0x318>)
 800daae:	681b      	ldr	r3, [r3, #0]
 800dab0:	1ad3      	subs	r3, r2, r3
 800dab2:	d41d      	bmi.n	800daf0 <tcp_receive+0x98>
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800dab4:	687b      	ldr	r3, [r7, #4]
 800dab6:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800dab8:	4bad      	ldr	r3, [pc, #692]	; (800dd70 <tcp_receive+0x318>)
 800daba:	681b      	ldr	r3, [r3, #0]
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 800dabc:	429a      	cmp	r2, r3
 800dabe:	d105      	bne.n	800dacc <tcp_receive+0x74>
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800dac0:	687b      	ldr	r3, [r7, #4]
 800dac2:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 800dac4:	4bab      	ldr	r3, [pc, #684]	; (800dd74 <tcp_receive+0x31c>)
 800dac6:	681b      	ldr	r3, [r3, #0]
 800dac8:	1ad3      	subs	r3, r2, r3
 800daca:	d411      	bmi.n	800daf0 <tcp_receive+0x98>
        (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 800dacc:	687b      	ldr	r3, [r7, #4]
 800dace:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 800dad0:	4ba8      	ldr	r3, [pc, #672]	; (800dd74 <tcp_receive+0x31c>)
 800dad2:	681b      	ldr	r3, [r3, #0]
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 800dad4:	429a      	cmp	r2, r3
 800dad6:	d12b      	bne.n	800db30 <tcp_receive+0xd8>
        (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 800dad8:	4ba7      	ldr	r3, [pc, #668]	; (800dd78 <tcp_receive+0x320>)
 800dada:	681b      	ldr	r3, [r3, #0]
 800dadc:	7b9a      	ldrb	r2, [r3, #14]
 800dade:	7bdb      	ldrb	r3, [r3, #15]
 800dae0:	021b      	lsls	r3, r3, #8
 800dae2:	4313      	orrs	r3, r2
 800dae4:	b29a      	uxth	r2, r3
 800dae6:	687b      	ldr	r3, [r7, #4]
 800dae8:	2164      	movs	r1, #100	; 0x64
 800daea:	5a5b      	ldrh	r3, [r3, r1]
 800daec:	429a      	cmp	r2, r3
 800daee:	d91f      	bls.n	800db30 <tcp_receive+0xd8>
      pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
 800daf0:	4ba1      	ldr	r3, [pc, #644]	; (800dd78 <tcp_receive+0x320>)
 800daf2:	681b      	ldr	r3, [r3, #0]
 800daf4:	7b9a      	ldrb	r2, [r3, #14]
 800daf6:	7bdb      	ldrb	r3, [r3, #15]
 800daf8:	021b      	lsls	r3, r3, #8
 800dafa:	4313      	orrs	r3, r2
 800dafc:	b299      	uxth	r1, r3
 800dafe:	687b      	ldr	r3, [r7, #4]
 800db00:	2264      	movs	r2, #100	; 0x64
 800db02:	5299      	strh	r1, [r3, r2]
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < pcb->snd_wnd) {
 800db04:	687b      	ldr	r3, [r7, #4]
 800db06:	2266      	movs	r2, #102	; 0x66
 800db08:	5a9a      	ldrh	r2, [r3, r2]
 800db0a:	687b      	ldr	r3, [r7, #4]
 800db0c:	2164      	movs	r1, #100	; 0x64
 800db0e:	5a5b      	ldrh	r3, [r3, r1]
 800db10:	429a      	cmp	r2, r3
 800db12:	d205      	bcs.n	800db20 <tcp_receive+0xc8>
        pcb->snd_wnd_max = pcb->snd_wnd;
 800db14:	687b      	ldr	r3, [r7, #4]
 800db16:	2264      	movs	r2, #100	; 0x64
 800db18:	5a99      	ldrh	r1, [r3, r2]
 800db1a:	687b      	ldr	r3, [r7, #4]
 800db1c:	2266      	movs	r2, #102	; 0x66
 800db1e:	5299      	strh	r1, [r3, r2]
      }
      pcb->snd_wl1 = seqno;
 800db20:	4b93      	ldr	r3, [pc, #588]	; (800dd70 <tcp_receive+0x318>)
 800db22:	681a      	ldr	r2, [r3, #0]
 800db24:	687b      	ldr	r3, [r7, #4]
 800db26:	659a      	str	r2, [r3, #88]	; 0x58
      pcb->snd_wl2 = ackno;
 800db28:	4b92      	ldr	r3, [pc, #584]	; (800dd74 <tcp_receive+0x31c>)
 800db2a:	681a      	ldr	r2, [r3, #0]
 800db2c:	687b      	ldr	r3, [r7, #4]
 800db2e:	65da      	str	r2, [r3, #92]	; 0x5c
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
 800db30:	4b90      	ldr	r3, [pc, #576]	; (800dd74 <tcp_receive+0x31c>)
 800db32:	681a      	ldr	r2, [r3, #0]
 800db34:	687b      	ldr	r3, [r7, #4]
 800db36:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800db38:	1ad3      	subs	r3, r2, r3
 800db3a:	2b00      	cmp	r3, #0
 800db3c:	dc59      	bgt.n	800dbf2 <tcp_receive+0x19a>
      /* Clause 2 */
      if (tcplen == 0) {
 800db3e:	4b8f      	ldr	r3, [pc, #572]	; (800dd7c <tcp_receive+0x324>)
 800db40:	881b      	ldrh	r3, [r3, #0]
 800db42:	2b00      	cmp	r3, #0
 800db44:	d14c      	bne.n	800dbe0 <tcp_receive+0x188>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
 800db46:	687b      	ldr	r3, [r7, #4]
 800db48:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800db4a:	687a      	ldr	r2, [r7, #4]
 800db4c:	2164      	movs	r1, #100	; 0x64
 800db4e:	5a52      	ldrh	r2, [r2, r1]
 800db50:	189b      	adds	r3, r3, r2
 800db52:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800db54:	429a      	cmp	r2, r3
 800db56:	d143      	bne.n	800dbe0 <tcp_receive+0x188>
          /* Clause 4 */
          if (pcb->rtime >= 0) {
 800db58:	687b      	ldr	r3, [r7, #4]
 800db5a:	2234      	movs	r2, #52	; 0x34
 800db5c:	5e9b      	ldrsh	r3, [r3, r2]
 800db5e:	2b00      	cmp	r3, #0
 800db60:	db3e      	blt.n	800dbe0 <tcp_receive+0x188>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
 800db62:	687b      	ldr	r3, [r7, #4]
 800db64:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800db66:	4b83      	ldr	r3, [pc, #524]	; (800dd74 <tcp_receive+0x31c>)
 800db68:	681b      	ldr	r3, [r3, #0]
 800db6a:	429a      	cmp	r2, r3
 800db6c:	d138      	bne.n	800dbe0 <tcp_receive+0x188>
              found_dupack = 1;
 800db6e:	2301      	movs	r3, #1
 800db70:	64bb      	str	r3, [r7, #72]	; 0x48
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
 800db72:	687b      	ldr	r3, [r7, #4]
 800db74:	2247      	movs	r2, #71	; 0x47
 800db76:	5c9b      	ldrb	r3, [r3, r2]
 800db78:	2bff      	cmp	r3, #255	; 0xff
 800db7a:	d007      	beq.n	800db8c <tcp_receive+0x134>
                ++pcb->dupacks;
 800db7c:	687b      	ldr	r3, [r7, #4]
 800db7e:	2247      	movs	r2, #71	; 0x47
 800db80:	5c9b      	ldrb	r3, [r3, r2]
 800db82:	3301      	adds	r3, #1
 800db84:	b2d9      	uxtb	r1, r3
 800db86:	687b      	ldr	r3, [r7, #4]
 800db88:	2247      	movs	r2, #71	; 0x47
 800db8a:	5499      	strb	r1, [r3, r2]
              }
              if (pcb->dupacks > 3) {
 800db8c:	687b      	ldr	r3, [r7, #4]
 800db8e:	2247      	movs	r2, #71	; 0x47
 800db90:	5c9b      	ldrb	r3, [r3, r2]
 800db92:	2b03      	cmp	r3, #3
 800db94:	d91b      	bls.n	800dbce <tcp_receive+0x176>
                /* Inflate the congestion window */
                TCP_WND_INC(pcb->cwnd, pcb->mss);
 800db96:	687b      	ldr	r3, [r7, #4]
 800db98:	224c      	movs	r2, #76	; 0x4c
 800db9a:	5a9a      	ldrh	r2, [r3, r2]
 800db9c:	687b      	ldr	r3, [r7, #4]
 800db9e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800dba0:	18d3      	adds	r3, r2, r3
 800dba2:	b29a      	uxth	r2, r3
 800dba4:	687b      	ldr	r3, [r7, #4]
 800dba6:	214c      	movs	r1, #76	; 0x4c
 800dba8:	5a5b      	ldrh	r3, [r3, r1]
 800dbaa:	429a      	cmp	r2, r3
 800dbac:	d30a      	bcc.n	800dbc4 <tcp_receive+0x16c>
 800dbae:	687b      	ldr	r3, [r7, #4]
 800dbb0:	224c      	movs	r2, #76	; 0x4c
 800dbb2:	5a9a      	ldrh	r2, [r3, r2]
 800dbb4:	687b      	ldr	r3, [r7, #4]
 800dbb6:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800dbb8:	18d3      	adds	r3, r2, r3
 800dbba:	b299      	uxth	r1, r3
 800dbbc:	687b      	ldr	r3, [r7, #4]
 800dbbe:	224c      	movs	r2, #76	; 0x4c
 800dbc0:	5299      	strh	r1, [r3, r2]
 800dbc2:	e004      	b.n	800dbce <tcp_receive+0x176>
 800dbc4:	687b      	ldr	r3, [r7, #4]
 800dbc6:	224c      	movs	r2, #76	; 0x4c
 800dbc8:	2101      	movs	r1, #1
 800dbca:	4249      	negs	r1, r1
 800dbcc:	5299      	strh	r1, [r3, r2]
              }
              if (pcb->dupacks >= 3) {
 800dbce:	687b      	ldr	r3, [r7, #4]
 800dbd0:	2247      	movs	r2, #71	; 0x47
 800dbd2:	5c9b      	ldrb	r3, [r3, r2]
 800dbd4:	2b02      	cmp	r3, #2
 800dbd6:	d903      	bls.n	800dbe0 <tcp_receive+0x188>
                /* Do fast retransmit (checked via TF_INFR, not via dupacks count) */
                tcp_rexmit_fast(pcb);
 800dbd8:	687b      	ldr	r3, [r7, #4]
 800dbda:	0018      	movs	r0, r3
 800dbdc:	f003 fa7e 	bl	80110dc <tcp_rexmit_fast>
          }
        }
      }
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
 800dbe0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800dbe2:	2b00      	cmp	r3, #0
 800dbe4:	d000      	beq.n	800dbe8 <tcp_receive+0x190>
 800dbe6:	e188      	b.n	800defa <tcp_receive+0x4a2>
        pcb->dupacks = 0;
 800dbe8:	687b      	ldr	r3, [r7, #4]
 800dbea:	2247      	movs	r2, #71	; 0x47
 800dbec:	2100      	movs	r1, #0
 800dbee:	5499      	strb	r1, [r3, r2]
 800dbf0:	e183      	b.n	800defa <tcp_receive+0x4a2>
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 800dbf2:	4b60      	ldr	r3, [pc, #384]	; (800dd74 <tcp_receive+0x31c>)
 800dbf4:	681a      	ldr	r2, [r3, #0]
 800dbf6:	687b      	ldr	r3, [r7, #4]
 800dbf8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800dbfa:	1ad3      	subs	r3, r2, r3
 800dbfc:	3b01      	subs	r3, #1
 800dbfe:	2b00      	cmp	r3, #0
 800dc00:	da00      	bge.n	800dc04 <tcp_receive+0x1ac>
 800dc02:	e174      	b.n	800deee <tcp_receive+0x496>
 800dc04:	4b5b      	ldr	r3, [pc, #364]	; (800dd74 <tcp_receive+0x31c>)
 800dc06:	681a      	ldr	r2, [r3, #0]
 800dc08:	687b      	ldr	r3, [r7, #4]
 800dc0a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800dc0c:	1ad3      	subs	r3, r2, r3
 800dc0e:	2b00      	cmp	r3, #0
 800dc10:	dd00      	ble.n	800dc14 <tcp_receive+0x1bc>
 800dc12:	e16c      	b.n	800deee <tcp_receive+0x496>
      tcpwnd_size_t acked;

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
 800dc14:	687b      	ldr	r3, [r7, #4]
 800dc16:	8bdb      	ldrh	r3, [r3, #30]
 800dc18:	001a      	movs	r2, r3
 800dc1a:	2304      	movs	r3, #4
 800dc1c:	4013      	ands	r3, r2
 800dc1e:	d010      	beq.n	800dc42 <tcp_receive+0x1ea>
        tcp_clear_flags(pcb, TF_INFR);
 800dc20:	687b      	ldr	r3, [r7, #4]
 800dc22:	8bdb      	ldrh	r3, [r3, #30]
 800dc24:	2204      	movs	r2, #4
 800dc26:	4393      	bics	r3, r2
 800dc28:	b29a      	uxth	r2, r3
 800dc2a:	687b      	ldr	r3, [r7, #4]
 800dc2c:	83da      	strh	r2, [r3, #30]
        pcb->cwnd = pcb->ssthresh;
 800dc2e:	687b      	ldr	r3, [r7, #4]
 800dc30:	224e      	movs	r2, #78	; 0x4e
 800dc32:	5a99      	ldrh	r1, [r3, r2]
 800dc34:	687b      	ldr	r3, [r7, #4]
 800dc36:	224c      	movs	r2, #76	; 0x4c
 800dc38:	5299      	strh	r1, [r3, r2]
        pcb->bytes_acked = 0;
 800dc3a:	687b      	ldr	r3, [r7, #4]
 800dc3c:	226e      	movs	r2, #110	; 0x6e
 800dc3e:	2100      	movs	r1, #0
 800dc40:	5299      	strh	r1, [r3, r2]
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
 800dc42:	687b      	ldr	r3, [r7, #4]
 800dc44:	2246      	movs	r2, #70	; 0x46
 800dc46:	2100      	movs	r1, #0
 800dc48:	5499      	strb	r1, [r3, r2]

      /* Reset the retransmission time-out. */
      pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
 800dc4a:	687b      	ldr	r3, [r7, #4]
 800dc4c:	2240      	movs	r2, #64	; 0x40
 800dc4e:	5e9b      	ldrsh	r3, [r3, r2]
 800dc50:	10db      	asrs	r3, r3, #3
 800dc52:	b21b      	sxth	r3, r3
 800dc54:	b29a      	uxth	r2, r3
 800dc56:	687b      	ldr	r3, [r7, #4]
 800dc58:	2142      	movs	r1, #66	; 0x42
 800dc5a:	5e5b      	ldrsh	r3, [r3, r1]
 800dc5c:	b29b      	uxth	r3, r3
 800dc5e:	18d3      	adds	r3, r2, r3
 800dc60:	b29b      	uxth	r3, r3
 800dc62:	b219      	sxth	r1, r3
 800dc64:	687b      	ldr	r3, [r7, #4]
 800dc66:	2244      	movs	r2, #68	; 0x44
 800dc68:	5299      	strh	r1, [r3, r2]

      /* Record how much data this ACK acks */
      acked = (tcpwnd_size_t)(ackno - pcb->lastack);
 800dc6a:	4b42      	ldr	r3, [pc, #264]	; (800dd74 <tcp_receive+0x31c>)
 800dc6c:	681b      	ldr	r3, [r3, #0]
 800dc6e:	b299      	uxth	r1, r3
 800dc70:	687b      	ldr	r3, [r7, #4]
 800dc72:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800dc74:	b29a      	uxth	r2, r3
 800dc76:	232e      	movs	r3, #46	; 0x2e
 800dc78:	18fb      	adds	r3, r7, r3
 800dc7a:	1a8a      	subs	r2, r1, r2
 800dc7c:	801a      	strh	r2, [r3, #0]

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
 800dc7e:	687b      	ldr	r3, [r7, #4]
 800dc80:	2247      	movs	r2, #71	; 0x47
 800dc82:	2100      	movs	r1, #0
 800dc84:	5499      	strb	r1, [r3, r2]
      pcb->lastack = ackno;
 800dc86:	4b3b      	ldr	r3, [pc, #236]	; (800dd74 <tcp_receive+0x31c>)
 800dc88:	681a      	ldr	r2, [r3, #0]
 800dc8a:	687b      	ldr	r3, [r7, #4]
 800dc8c:	649a      	str	r2, [r3, #72]	; 0x48

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
 800dc8e:	687b      	ldr	r3, [r7, #4]
 800dc90:	7e1b      	ldrb	r3, [r3, #24]
 800dc92:	2b03      	cmp	r3, #3
 800dc94:	d800      	bhi.n	800dc98 <tcp_receive+0x240>
 800dc96:	e0a7      	b.n	800dde8 <tcp_receive+0x390>
        if (pcb->cwnd < pcb->ssthresh) {
 800dc98:	687b      	ldr	r3, [r7, #4]
 800dc9a:	224c      	movs	r2, #76	; 0x4c
 800dc9c:	5a9a      	ldrh	r2, [r3, r2]
 800dc9e:	687b      	ldr	r3, [r7, #4]
 800dca0:	214e      	movs	r1, #78	; 0x4e
 800dca2:	5a5b      	ldrh	r3, [r3, r1]
 800dca4:	429a      	cmp	r2, r3
 800dca6:	d23d      	bcs.n	800dd24 <tcp_receive+0x2cc>
          tcpwnd_size_t increase;
          /* limit to 1 SMSS segment during period following RTO */
          u8_t num_seg = (pcb->flags & TF_RTO) ? 1 : 2;
 800dca8:	687b      	ldr	r3, [r7, #4]
 800dcaa:	8bdb      	ldrh	r3, [r3, #30]
 800dcac:	001a      	movs	r2, r3
 800dcae:	2380      	movs	r3, #128	; 0x80
 800dcb0:	011b      	lsls	r3, r3, #4
 800dcb2:	4013      	ands	r3, r2
 800dcb4:	d001      	beq.n	800dcba <tcp_receive+0x262>
 800dcb6:	2201      	movs	r2, #1
 800dcb8:	e000      	b.n	800dcbc <tcp_receive+0x264>
 800dcba:	2202      	movs	r2, #2
 800dcbc:	212d      	movs	r1, #45	; 0x2d
 800dcbe:	187b      	adds	r3, r7, r1
 800dcc0:	701a      	strb	r2, [r3, #0]
          /* RFC 3465, section 2.2 Slow Start */
          increase = LWIP_MIN(acked, (tcpwnd_size_t)(num_seg * pcb->mss));
 800dcc2:	187b      	adds	r3, r7, r1
 800dcc4:	781b      	ldrb	r3, [r3, #0]
 800dcc6:	b29b      	uxth	r3, r3
 800dcc8:	687a      	ldr	r2, [r7, #4]
 800dcca:	8ed2      	ldrh	r2, [r2, #54]	; 0x36
 800dccc:	4353      	muls	r3, r2
 800dcce:	b299      	uxth	r1, r3
 800dcd0:	232a      	movs	r3, #42	; 0x2a
 800dcd2:	18fa      	adds	r2, r7, r3
 800dcd4:	232e      	movs	r3, #46	; 0x2e
 800dcd6:	18fb      	adds	r3, r7, r3
 800dcd8:	1c0c      	adds	r4, r1, #0
 800dcda:	881b      	ldrh	r3, [r3, #0]
 800dcdc:	b298      	uxth	r0, r3
 800dcde:	b2a1      	uxth	r1, r4
 800dce0:	4288      	cmp	r0, r1
 800dce2:	d900      	bls.n	800dce6 <tcp_receive+0x28e>
 800dce4:	1c23      	adds	r3, r4, #0
 800dce6:	8013      	strh	r3, [r2, #0]
          TCP_WND_INC(pcb->cwnd, increase);
 800dce8:	687b      	ldr	r3, [r7, #4]
 800dcea:	224c      	movs	r2, #76	; 0x4c
 800dcec:	5a9a      	ldrh	r2, [r3, r2]
 800dcee:	202a      	movs	r0, #42	; 0x2a
 800dcf0:	183b      	adds	r3, r7, r0
 800dcf2:	881b      	ldrh	r3, [r3, #0]
 800dcf4:	18d3      	adds	r3, r2, r3
 800dcf6:	b29a      	uxth	r2, r3
 800dcf8:	687b      	ldr	r3, [r7, #4]
 800dcfa:	214c      	movs	r1, #76	; 0x4c
 800dcfc:	5a5b      	ldrh	r3, [r3, r1]
 800dcfe:	429a      	cmp	r2, r3
 800dd00:	d30a      	bcc.n	800dd18 <tcp_receive+0x2c0>
 800dd02:	687b      	ldr	r3, [r7, #4]
 800dd04:	224c      	movs	r2, #76	; 0x4c
 800dd06:	5a9a      	ldrh	r2, [r3, r2]
 800dd08:	183b      	adds	r3, r7, r0
 800dd0a:	881b      	ldrh	r3, [r3, #0]
 800dd0c:	18d3      	adds	r3, r2, r3
 800dd0e:	b299      	uxth	r1, r3
 800dd10:	687b      	ldr	r3, [r7, #4]
 800dd12:	224c      	movs	r2, #76	; 0x4c
 800dd14:	5299      	strh	r1, [r3, r2]
 800dd16:	e067      	b.n	800dde8 <tcp_receive+0x390>
 800dd18:	687b      	ldr	r3, [r7, #4]
 800dd1a:	224c      	movs	r2, #76	; 0x4c
 800dd1c:	2101      	movs	r1, #1
 800dd1e:	4249      	negs	r1, r1
 800dd20:	5299      	strh	r1, [r3, r2]
 800dd22:	e061      	b.n	800dde8 <tcp_receive+0x390>
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"TCPWNDSIZE_F"\n", pcb->cwnd));
        } else {
          /* RFC 3465, section 2.1 Congestion Avoidance */
          TCP_WND_INC(pcb->bytes_acked, acked);
 800dd24:	687b      	ldr	r3, [r7, #4]
 800dd26:	226e      	movs	r2, #110	; 0x6e
 800dd28:	5a9a      	ldrh	r2, [r3, r2]
 800dd2a:	202e      	movs	r0, #46	; 0x2e
 800dd2c:	183b      	adds	r3, r7, r0
 800dd2e:	881b      	ldrh	r3, [r3, #0]
 800dd30:	18d3      	adds	r3, r2, r3
 800dd32:	b29a      	uxth	r2, r3
 800dd34:	687b      	ldr	r3, [r7, #4]
 800dd36:	216e      	movs	r1, #110	; 0x6e
 800dd38:	5a5b      	ldrh	r3, [r3, r1]
 800dd3a:	429a      	cmp	r2, r3
 800dd3c:	d320      	bcc.n	800dd80 <tcp_receive+0x328>
 800dd3e:	687b      	ldr	r3, [r7, #4]
 800dd40:	226e      	movs	r2, #110	; 0x6e
 800dd42:	5a9a      	ldrh	r2, [r3, r2]
 800dd44:	183b      	adds	r3, r7, r0
 800dd46:	881b      	ldrh	r3, [r3, #0]
 800dd48:	18d3      	adds	r3, r2, r3
 800dd4a:	b299      	uxth	r1, r3
 800dd4c:	687b      	ldr	r3, [r7, #4]
 800dd4e:	226e      	movs	r2, #110	; 0x6e
 800dd50:	5299      	strh	r1, [r3, r2]
 800dd52:	e01a      	b.n	800dd8a <tcp_receive+0x332>
 800dd54:	0801f99c 	.word	0x0801f99c
 800dd58:	0000047c 	.word	0x0000047c
 800dd5c:	0801fcc4 	.word	0x0801fcc4
 800dd60:	0801f9dc 	.word	0x0801f9dc
 800dd64:	0000047d 	.word	0x0000047d
 800dd68:	0801fce0 	.word	0x0801fce0
 800dd6c:	2000138c 	.word	0x2000138c
 800dd70:	20001380 	.word	0x20001380
 800dd74:	20001384 	.word	0x20001384
 800dd78:	20001370 	.word	0x20001370
 800dd7c:	2000138a 	.word	0x2000138a
 800dd80:	687b      	ldr	r3, [r7, #4]
 800dd82:	226e      	movs	r2, #110	; 0x6e
 800dd84:	2101      	movs	r1, #1
 800dd86:	4249      	negs	r1, r1
 800dd88:	5299      	strh	r1, [r3, r2]
          if (pcb->bytes_acked >= pcb->cwnd) {
 800dd8a:	687b      	ldr	r3, [r7, #4]
 800dd8c:	226e      	movs	r2, #110	; 0x6e
 800dd8e:	5a9a      	ldrh	r2, [r3, r2]
 800dd90:	687b      	ldr	r3, [r7, #4]
 800dd92:	214c      	movs	r1, #76	; 0x4c
 800dd94:	5a5b      	ldrh	r3, [r3, r1]
 800dd96:	429a      	cmp	r2, r3
 800dd98:	d326      	bcc.n	800dde8 <tcp_receive+0x390>
            pcb->bytes_acked = (tcpwnd_size_t)(pcb->bytes_acked - pcb->cwnd);
 800dd9a:	687b      	ldr	r3, [r7, #4]
 800dd9c:	226e      	movs	r2, #110	; 0x6e
 800dd9e:	5a9a      	ldrh	r2, [r3, r2]
 800dda0:	687b      	ldr	r3, [r7, #4]
 800dda2:	214c      	movs	r1, #76	; 0x4c
 800dda4:	5a5b      	ldrh	r3, [r3, r1]
 800dda6:	1ad3      	subs	r3, r2, r3
 800dda8:	b299      	uxth	r1, r3
 800ddaa:	687b      	ldr	r3, [r7, #4]
 800ddac:	226e      	movs	r2, #110	; 0x6e
 800ddae:	5299      	strh	r1, [r3, r2]
            TCP_WND_INC(pcb->cwnd, pcb->mss);
 800ddb0:	687b      	ldr	r3, [r7, #4]
 800ddb2:	224c      	movs	r2, #76	; 0x4c
 800ddb4:	5a9a      	ldrh	r2, [r3, r2]
 800ddb6:	687b      	ldr	r3, [r7, #4]
 800ddb8:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800ddba:	18d3      	adds	r3, r2, r3
 800ddbc:	b29a      	uxth	r2, r3
 800ddbe:	687b      	ldr	r3, [r7, #4]
 800ddc0:	214c      	movs	r1, #76	; 0x4c
 800ddc2:	5a5b      	ldrh	r3, [r3, r1]
 800ddc4:	429a      	cmp	r2, r3
 800ddc6:	d30a      	bcc.n	800ddde <tcp_receive+0x386>
 800ddc8:	687b      	ldr	r3, [r7, #4]
 800ddca:	224c      	movs	r2, #76	; 0x4c
 800ddcc:	5a9a      	ldrh	r2, [r3, r2]
 800ddce:	687b      	ldr	r3, [r7, #4]
 800ddd0:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800ddd2:	18d3      	adds	r3, r2, r3
 800ddd4:	b299      	uxth	r1, r3
 800ddd6:	687b      	ldr	r3, [r7, #4]
 800ddd8:	224c      	movs	r2, #76	; 0x4c
 800ddda:	5299      	strh	r1, [r3, r2]
 800dddc:	e004      	b.n	800dde8 <tcp_receive+0x390>
 800ddde:	687b      	ldr	r3, [r7, #4]
 800dde0:	224c      	movs	r2, #76	; 0x4c
 800dde2:	2101      	movs	r1, #1
 800dde4:	4249      	negs	r1, r1
 800dde6:	5299      	strh	r1, [r3, r2]
                                    pcb->unacked != NULL ?
                                    lwip_ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked) : 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowledges them. */
      pcb->unacked = tcp_free_acked_segments(pcb, pcb->unacked, "unacked", pcb->unsent);
 800dde8:	687b      	ldr	r3, [r7, #4]
 800ddea:	6f59      	ldr	r1, [r3, #116]	; 0x74
 800ddec:	687b      	ldr	r3, [r7, #4]
 800ddee:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800ddf0:	4acf      	ldr	r2, [pc, #828]	; (800e130 <tcp_receive+0x6d8>)
 800ddf2:	6878      	ldr	r0, [r7, #4]
 800ddf4:	f7ff fda0 	bl	800d938 <tcp_free_acked_segments>
 800ddf8:	0002      	movs	r2, r0
 800ddfa:	687b      	ldr	r3, [r7, #4]
 800ddfc:	675a      	str	r2, [r3, #116]	; 0x74
         on the list are acknowledged by the ACK. This may seem
         strange since an "unsent" segment shouldn't be acked. The
         rationale is that lwIP puts all outstanding segments on the
         ->unsent list after a retransmission, so these segments may
         in fact have been sent once. */
      pcb->unsent = tcp_free_acked_segments(pcb, pcb->unsent, "unsent", pcb->unacked);
 800ddfe:	687b      	ldr	r3, [r7, #4]
 800de00:	6f19      	ldr	r1, [r3, #112]	; 0x70
 800de02:	687b      	ldr	r3, [r7, #4]
 800de04:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800de06:	4acb      	ldr	r2, [pc, #812]	; (800e134 <tcp_receive+0x6dc>)
 800de08:	6878      	ldr	r0, [r7, #4]
 800de0a:	f7ff fd95 	bl	800d938 <tcp_free_acked_segments>
 800de0e:	0002      	movs	r2, r0
 800de10:	687b      	ldr	r3, [r7, #4]
 800de12:	671a      	str	r2, [r3, #112]	; 0x70

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if (pcb->unacked == NULL) {
 800de14:	687b      	ldr	r3, [r7, #4]
 800de16:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800de18:	2b00      	cmp	r3, #0
 800de1a:	d104      	bne.n	800de26 <tcp_receive+0x3ce>
        pcb->rtime = -1;
 800de1c:	687b      	ldr	r3, [r7, #4]
 800de1e:	2201      	movs	r2, #1
 800de20:	4252      	negs	r2, r2
 800de22:	869a      	strh	r2, [r3, #52]	; 0x34
 800de24:	e002      	b.n	800de2c <tcp_receive+0x3d4>
      } else {
        pcb->rtime = 0;
 800de26:	687b      	ldr	r3, [r7, #4]
 800de28:	2200      	movs	r2, #0
 800de2a:	869a      	strh	r2, [r3, #52]	; 0x34
      }

      pcb->polltmr = 0;
 800de2c:	687b      	ldr	r3, [r7, #4]
 800de2e:	2220      	movs	r2, #32
 800de30:	2100      	movs	r1, #0
 800de32:	5499      	strb	r1, [r3, r2]

#if TCP_OVERSIZE
      if (pcb->unsent == NULL) {
 800de34:	687b      	ldr	r3, [r7, #4]
 800de36:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800de38:	2b00      	cmp	r3, #0
 800de3a:	d103      	bne.n	800de44 <tcp_receive+0x3ec>
        pcb->unsent_oversize = 0;
 800de3c:	687b      	ldr	r3, [r7, #4]
 800de3e:	226c      	movs	r2, #108	; 0x6c
 800de40:	2100      	movs	r1, #0
 800de42:	5299      	strh	r1, [r3, r2]
        /* Inform neighbor reachability of forward progress. */
        nd6_reachability_hint(ip6_current_src_addr());
      }
#endif /* LWIP_IPV6 && LWIP_ND6_TCP_REACHABILITY_HINTS*/

      pcb->snd_buf = (tcpwnd_size_t)(pcb->snd_buf + recv_acked);
 800de44:	687b      	ldr	r3, [r7, #4]
 800de46:	2268      	movs	r2, #104	; 0x68
 800de48:	5a9a      	ldrh	r2, [r3, r2]
 800de4a:	4bbb      	ldr	r3, [pc, #748]	; (800e138 <tcp_receive+0x6e0>)
 800de4c:	881b      	ldrh	r3, [r3, #0]
 800de4e:	18d3      	adds	r3, r2, r3
 800de50:	b299      	uxth	r1, r3
 800de52:	687b      	ldr	r3, [r7, #4]
 800de54:	2268      	movs	r2, #104	; 0x68
 800de56:	5299      	strh	r1, [r3, r2]
      /* check if this ACK ends our retransmission of in-flight data */
      if (pcb->flags & TF_RTO) {
 800de58:	687b      	ldr	r3, [r7, #4]
 800de5a:	8bdb      	ldrh	r3, [r3, #30]
 800de5c:	001a      	movs	r2, r3
 800de5e:	2380      	movs	r3, #128	; 0x80
 800de60:	011b      	lsls	r3, r3, #4
 800de62:	4013      	ands	r3, r2
 800de64:	d048      	beq.n	800def8 <tcp_receive+0x4a0>
        /* RTO is done if
            1) both queues are empty or
            2) unacked is empty and unsent head contains data not part of RTO or
            3) unacked head contains data not part of RTO */
        if (pcb->unacked == NULL) {
 800de66:	687b      	ldr	r3, [r7, #4]
 800de68:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800de6a:	2b00      	cmp	r3, #0
 800de6c:	d121      	bne.n	800deb2 <tcp_receive+0x45a>
          if ((pcb->unsent == NULL) ||
 800de6e:	687b      	ldr	r3, [r7, #4]
 800de70:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800de72:	2b00      	cmp	r3, #0
 800de74:	d015      	beq.n	800dea2 <tcp_receive+0x44a>
              (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unsent->tcphdr->seqno)))) {
 800de76:	687b      	ldr	r3, [r7, #4]
 800de78:	6d1c      	ldr	r4, [r3, #80]	; 0x50
 800de7a:	687b      	ldr	r3, [r7, #4]
 800de7c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800de7e:	691b      	ldr	r3, [r3, #16]
 800de80:	791a      	ldrb	r2, [r3, #4]
 800de82:	7959      	ldrb	r1, [r3, #5]
 800de84:	0209      	lsls	r1, r1, #8
 800de86:	430a      	orrs	r2, r1
 800de88:	7999      	ldrb	r1, [r3, #6]
 800de8a:	0409      	lsls	r1, r1, #16
 800de8c:	430a      	orrs	r2, r1
 800de8e:	79db      	ldrb	r3, [r3, #7]
 800de90:	061b      	lsls	r3, r3, #24
 800de92:	4313      	orrs	r3, r2
 800de94:	0018      	movs	r0, r3
 800de96:	f7f8 fb63 	bl	8006560 <lwip_htonl>
 800de9a:	0003      	movs	r3, r0
 800de9c:	1ae3      	subs	r3, r4, r3
          if ((pcb->unsent == NULL) ||
 800de9e:	2b00      	cmp	r3, #0
 800dea0:	dc2a      	bgt.n	800def8 <tcp_receive+0x4a0>
            tcp_clear_flags(pcb, TF_RTO);
 800dea2:	687b      	ldr	r3, [r7, #4]
 800dea4:	8bdb      	ldrh	r3, [r3, #30]
 800dea6:	4aa5      	ldr	r2, [pc, #660]	; (800e13c <tcp_receive+0x6e4>)
 800dea8:	4013      	ands	r3, r2
 800deaa:	b29a      	uxth	r2, r3
 800deac:	687b      	ldr	r3, [r7, #4]
 800deae:	83da      	strh	r2, [r3, #30]
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 800deb0:	e022      	b.n	800def8 <tcp_receive+0x4a0>
          }
        } else if (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unacked->tcphdr->seqno))) {
 800deb2:	687b      	ldr	r3, [r7, #4]
 800deb4:	6d1c      	ldr	r4, [r3, #80]	; 0x50
 800deb6:	687b      	ldr	r3, [r7, #4]
 800deb8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800deba:	691b      	ldr	r3, [r3, #16]
 800debc:	791a      	ldrb	r2, [r3, #4]
 800debe:	7959      	ldrb	r1, [r3, #5]
 800dec0:	0209      	lsls	r1, r1, #8
 800dec2:	430a      	orrs	r2, r1
 800dec4:	7999      	ldrb	r1, [r3, #6]
 800dec6:	0409      	lsls	r1, r1, #16
 800dec8:	430a      	orrs	r2, r1
 800deca:	79db      	ldrb	r3, [r3, #7]
 800decc:	061b      	lsls	r3, r3, #24
 800dece:	4313      	orrs	r3, r2
 800ded0:	0018      	movs	r0, r3
 800ded2:	f7f8 fb45 	bl	8006560 <lwip_htonl>
 800ded6:	0003      	movs	r3, r0
 800ded8:	1ae3      	subs	r3, r4, r3
 800deda:	2b00      	cmp	r3, #0
 800dedc:	dc0c      	bgt.n	800def8 <tcp_receive+0x4a0>
          tcp_clear_flags(pcb, TF_RTO);
 800dede:	687b      	ldr	r3, [r7, #4]
 800dee0:	8bdb      	ldrh	r3, [r3, #30]
 800dee2:	4a96      	ldr	r2, [pc, #600]	; (800e13c <tcp_receive+0x6e4>)
 800dee4:	4013      	ands	r3, r2
 800dee6:	b29a      	uxth	r2, r3
 800dee8:	687b      	ldr	r3, [r7, #4]
 800deea:	83da      	strh	r2, [r3, #30]
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 800deec:	e004      	b.n	800def8 <tcp_receive+0x4a0>
        }
      }
      /* End of ACK for new data processing. */
    } else {
      /* Out of sequence ACK, didn't really ack anything */
      tcp_send_empty_ack(pcb);
 800deee:	687b      	ldr	r3, [r7, #4]
 800def0:	0018      	movs	r0, r3
 800def2:	f003 fbf9 	bl	80116e8 <tcp_send_empty_ack>
 800def6:	e000      	b.n	800defa <tcp_receive+0x4a2>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
 800def8:	46c0      	nop			; (mov r8, r8)
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 800defa:	687b      	ldr	r3, [r7, #4]
 800defc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800defe:	2b00      	cmp	r3, #0
 800df00:	d05f      	beq.n	800dfc2 <tcp_receive+0x56a>
 800df02:	687b      	ldr	r3, [r7, #4]
 800df04:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800df06:	4b8e      	ldr	r3, [pc, #568]	; (800e140 <tcp_receive+0x6e8>)
 800df08:	681b      	ldr	r3, [r3, #0]
 800df0a:	1ad3      	subs	r3, r2, r3
 800df0c:	d559      	bpl.n	800dfc2 <tcp_receive+0x56a>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
 800df0e:	4b8d      	ldr	r3, [pc, #564]	; (800e144 <tcp_receive+0x6ec>)
 800df10:	681b      	ldr	r3, [r3, #0]
 800df12:	b29a      	uxth	r2, r3
 800df14:	687b      	ldr	r3, [r7, #4]
 800df16:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800df18:	b29b      	uxth	r3, r3
 800df1a:	1ad3      	subs	r3, r2, r3
 800df1c:	b29a      	uxth	r2, r3
 800df1e:	204e      	movs	r0, #78	; 0x4e
 800df20:	183b      	adds	r3, r7, r0
 800df22:	801a      	strh	r2, [r3, #0]

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, (u16_t)(m * TCP_SLOW_INTERVAL)));

      /* This is taken directly from VJs original code in his paper */
      m = (s16_t)(m - (pcb->sa >> 3));
 800df24:	183b      	adds	r3, r7, r0
 800df26:	881a      	ldrh	r2, [r3, #0]
 800df28:	687b      	ldr	r3, [r7, #4]
 800df2a:	2140      	movs	r1, #64	; 0x40
 800df2c:	5e5b      	ldrsh	r3, [r3, r1]
 800df2e:	10db      	asrs	r3, r3, #3
 800df30:	b21b      	sxth	r3, r3
 800df32:	b29b      	uxth	r3, r3
 800df34:	1ad3      	subs	r3, r2, r3
 800df36:	b29a      	uxth	r2, r3
 800df38:	183b      	adds	r3, r7, r0
 800df3a:	801a      	strh	r2, [r3, #0]
      pcb->sa = (s16_t)(pcb->sa + m);
 800df3c:	687b      	ldr	r3, [r7, #4]
 800df3e:	2240      	movs	r2, #64	; 0x40
 800df40:	5e9b      	ldrsh	r3, [r3, r2]
 800df42:	b29a      	uxth	r2, r3
 800df44:	183b      	adds	r3, r7, r0
 800df46:	881b      	ldrh	r3, [r3, #0]
 800df48:	18d3      	adds	r3, r2, r3
 800df4a:	b29b      	uxth	r3, r3
 800df4c:	b219      	sxth	r1, r3
 800df4e:	687b      	ldr	r3, [r7, #4]
 800df50:	2240      	movs	r2, #64	; 0x40
 800df52:	5299      	strh	r1, [r3, r2]
      if (m < 0) {
 800df54:	183b      	adds	r3, r7, r0
 800df56:	2200      	movs	r2, #0
 800df58:	5e9b      	ldrsh	r3, [r3, r2]
 800df5a:	2b00      	cmp	r3, #0
 800df5c:	da05      	bge.n	800df6a <tcp_receive+0x512>
        m = (s16_t) - m;
 800df5e:	183b      	adds	r3, r7, r0
 800df60:	881b      	ldrh	r3, [r3, #0]
 800df62:	425b      	negs	r3, r3
 800df64:	b29a      	uxth	r2, r3
 800df66:	183b      	adds	r3, r7, r0
 800df68:	801a      	strh	r2, [r3, #0]
      }
      m = (s16_t)(m - (pcb->sv >> 2));
 800df6a:	204e      	movs	r0, #78	; 0x4e
 800df6c:	183b      	adds	r3, r7, r0
 800df6e:	881a      	ldrh	r2, [r3, #0]
 800df70:	687b      	ldr	r3, [r7, #4]
 800df72:	2142      	movs	r1, #66	; 0x42
 800df74:	5e5b      	ldrsh	r3, [r3, r1]
 800df76:	109b      	asrs	r3, r3, #2
 800df78:	b21b      	sxth	r3, r3
 800df7a:	b29b      	uxth	r3, r3
 800df7c:	1ad3      	subs	r3, r2, r3
 800df7e:	b29a      	uxth	r2, r3
 800df80:	183b      	adds	r3, r7, r0
 800df82:	801a      	strh	r2, [r3, #0]
      pcb->sv = (s16_t)(pcb->sv + m);
 800df84:	687b      	ldr	r3, [r7, #4]
 800df86:	2242      	movs	r2, #66	; 0x42
 800df88:	5e9b      	ldrsh	r3, [r3, r2]
 800df8a:	b29a      	uxth	r2, r3
 800df8c:	183b      	adds	r3, r7, r0
 800df8e:	881b      	ldrh	r3, [r3, #0]
 800df90:	18d3      	adds	r3, r2, r3
 800df92:	b29b      	uxth	r3, r3
 800df94:	b219      	sxth	r1, r3
 800df96:	687b      	ldr	r3, [r7, #4]
 800df98:	2242      	movs	r2, #66	; 0x42
 800df9a:	5299      	strh	r1, [r3, r2]
      pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
 800df9c:	687b      	ldr	r3, [r7, #4]
 800df9e:	2240      	movs	r2, #64	; 0x40
 800dfa0:	5e9b      	ldrsh	r3, [r3, r2]
 800dfa2:	10db      	asrs	r3, r3, #3
 800dfa4:	b21b      	sxth	r3, r3
 800dfa6:	b29a      	uxth	r2, r3
 800dfa8:	687b      	ldr	r3, [r7, #4]
 800dfaa:	2142      	movs	r1, #66	; 0x42
 800dfac:	5e5b      	ldrsh	r3, [r3, r1]
 800dfae:	b29b      	uxth	r3, r3
 800dfb0:	18d3      	adds	r3, r2, r3
 800dfb2:	b29b      	uxth	r3, r3
 800dfb4:	b219      	sxth	r1, r3
 800dfb6:	687b      	ldr	r3, [r7, #4]
 800dfb8:	2244      	movs	r2, #68	; 0x44
 800dfba:	5299      	strh	r1, [r3, r2]

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, (u16_t)(pcb->rto * TCP_SLOW_INTERVAL)));

      pcb->rttest = 0;
 800dfbc:	687b      	ldr	r3, [r7, #4]
 800dfbe:	2200      	movs	r2, #0
 800dfc0:	639a      	str	r2, [r3, #56]	; 0x38

  /* If the incoming segment contains data, we must process it
     further unless the pcb already received a FIN.
     (RFC 793, chapter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
     LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
 800dfc2:	4b61      	ldr	r3, [pc, #388]	; (800e148 <tcp_receive+0x6f0>)
 800dfc4:	881b      	ldrh	r3, [r3, #0]
 800dfc6:	2b00      	cmp	r3, #0
 800dfc8:	d101      	bne.n	800dfce <tcp_receive+0x576>
 800dfca:	f000 fe3b 	bl	800ec44 <tcp_receive+0x11ec>
 800dfce:	687b      	ldr	r3, [r7, #4]
 800dfd0:	7e1b      	ldrb	r3, [r3, #24]
 800dfd2:	2b06      	cmp	r3, #6
 800dfd4:	d901      	bls.n	800dfda <tcp_receive+0x582>
 800dfd6:	f000 fe35 	bl	800ec44 <tcp_receive+0x11ec>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
 800dfda:	687b      	ldr	r3, [r7, #4]
 800dfdc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800dfde:	4b5b      	ldr	r3, [pc, #364]	; (800e14c <tcp_receive+0x6f4>)
 800dfe0:	681b      	ldr	r3, [r3, #0]
 800dfe2:	1ad3      	subs	r3, r2, r3
 800dfe4:	3b01      	subs	r3, #1
 800dfe6:	2b00      	cmp	r3, #0
 800dfe8:	da00      	bge.n	800dfec <tcp_receive+0x594>
 800dfea:	e0c3      	b.n	800e174 <tcp_receive+0x71c>
 800dfec:	687b      	ldr	r3, [r7, #4]
 800dfee:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800dff0:	4b55      	ldr	r3, [pc, #340]	; (800e148 <tcp_receive+0x6f0>)
 800dff2:	881b      	ldrh	r3, [r3, #0]
 800dff4:	0019      	movs	r1, r3
 800dff6:	4b55      	ldr	r3, [pc, #340]	; (800e14c <tcp_receive+0x6f4>)
 800dff8:	681b      	ldr	r3, [r3, #0]
 800dffa:	18cb      	adds	r3, r1, r3
 800dffc:	1ad3      	subs	r3, r2, r3
 800dffe:	3301      	adds	r3, #1
 800e000:	2b00      	cmp	r3, #0
 800e002:	dd00      	ble.n	800e006 <tcp_receive+0x5ae>
 800e004:	e0b6      	b.n	800e174 <tcp_receive+0x71c>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      struct pbuf *p = inseg.p;
 800e006:	4b52      	ldr	r3, [pc, #328]	; (800e150 <tcp_receive+0x6f8>)
 800e008:	685b      	ldr	r3, [r3, #4]
 800e00a:	647b      	str	r3, [r7, #68]	; 0x44
      u32_t off32 = pcb->rcv_nxt - seqno;
 800e00c:	687b      	ldr	r3, [r7, #4]
 800e00e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800e010:	4b4e      	ldr	r3, [pc, #312]	; (800e14c <tcp_receive+0x6f4>)
 800e012:	681b      	ldr	r3, [r3, #0]
 800e014:	1ad3      	subs	r3, r2, r3
 800e016:	627b      	str	r3, [r7, #36]	; 0x24
      u16_t new_tot_len, off;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
 800e018:	4b4d      	ldr	r3, [pc, #308]	; (800e150 <tcp_receive+0x6f8>)
 800e01a:	685b      	ldr	r3, [r3, #4]
 800e01c:	2b00      	cmp	r3, #0
 800e01e:	d105      	bne.n	800e02c <tcp_receive+0x5d4>
 800e020:	4b4c      	ldr	r3, [pc, #304]	; (800e154 <tcp_receive+0x6fc>)
 800e022:	4a4d      	ldr	r2, [pc, #308]	; (800e158 <tcp_receive+0x700>)
 800e024:	494d      	ldr	r1, [pc, #308]	; (800e15c <tcp_receive+0x704>)
 800e026:	484e      	ldr	r0, [pc, #312]	; (800e160 <tcp_receive+0x708>)
 800e028:	f7f4 f8d0 	bl	80021cc <app_debug_rtt_raw>
      LWIP_ASSERT("insane offset!", (off32 < 0xffff));
 800e02c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e02e:	4a4d      	ldr	r2, [pc, #308]	; (800e164 <tcp_receive+0x70c>)
 800e030:	4293      	cmp	r3, r2
 800e032:	d905      	bls.n	800e040 <tcp_receive+0x5e8>
 800e034:	4b47      	ldr	r3, [pc, #284]	; (800e154 <tcp_receive+0x6fc>)
 800e036:	4a4c      	ldr	r2, [pc, #304]	; (800e168 <tcp_receive+0x710>)
 800e038:	494c      	ldr	r1, [pc, #304]	; (800e16c <tcp_receive+0x714>)
 800e03a:	4849      	ldr	r0, [pc, #292]	; (800e160 <tcp_receive+0x708>)
 800e03c:	f7f4 f8c6 	bl	80021cc <app_debug_rtt_raw>
      off = (u16_t)off32;
 800e040:	2142      	movs	r1, #66	; 0x42
 800e042:	187b      	adds	r3, r7, r1
 800e044:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800e046:	801a      	strh	r2, [r3, #0]
      LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
 800e048:	4b41      	ldr	r3, [pc, #260]	; (800e150 <tcp_receive+0x6f8>)
 800e04a:	685b      	ldr	r3, [r3, #4]
 800e04c:	891b      	ldrh	r3, [r3, #8]
 800e04e:	187a      	adds	r2, r7, r1
 800e050:	8812      	ldrh	r2, [r2, #0]
 800e052:	429a      	cmp	r2, r3
 800e054:	d906      	bls.n	800e064 <tcp_receive+0x60c>
 800e056:	4b3f      	ldr	r3, [pc, #252]	; (800e154 <tcp_receive+0x6fc>)
 800e058:	22b3      	movs	r2, #179	; 0xb3
 800e05a:	00d2      	lsls	r2, r2, #3
 800e05c:	4944      	ldr	r1, [pc, #272]	; (800e170 <tcp_receive+0x718>)
 800e05e:	4840      	ldr	r0, [pc, #256]	; (800e160 <tcp_receive+0x708>)
 800e060:	f7f4 f8b4 	bl	80021cc <app_debug_rtt_raw>
      inseg.len -= off;
 800e064:	4b3a      	ldr	r3, [pc, #232]	; (800e150 <tcp_receive+0x6f8>)
 800e066:	891a      	ldrh	r2, [r3, #8]
 800e068:	2042      	movs	r0, #66	; 0x42
 800e06a:	183b      	adds	r3, r7, r0
 800e06c:	881b      	ldrh	r3, [r3, #0]
 800e06e:	1ad3      	subs	r3, r2, r3
 800e070:	b29a      	uxth	r2, r3
 800e072:	4b37      	ldr	r3, [pc, #220]	; (800e150 <tcp_receive+0x6f8>)
 800e074:	811a      	strh	r2, [r3, #8]
      new_tot_len = (u16_t)(inseg.p->tot_len - off);
 800e076:	4b36      	ldr	r3, [pc, #216]	; (800e150 <tcp_receive+0x6f8>)
 800e078:	685b      	ldr	r3, [r3, #4]
 800e07a:	8919      	ldrh	r1, [r3, #8]
 800e07c:	2322      	movs	r3, #34	; 0x22
 800e07e:	18fb      	adds	r3, r7, r3
 800e080:	183a      	adds	r2, r7, r0
 800e082:	8812      	ldrh	r2, [r2, #0]
 800e084:	1a8a      	subs	r2, r1, r2
 800e086:	801a      	strh	r2, [r3, #0]
      while (p->len < off) {
 800e088:	e012      	b.n	800e0b0 <tcp_receive+0x658>
        off -= p->len;
 800e08a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e08c:	895a      	ldrh	r2, [r3, #10]
 800e08e:	2142      	movs	r1, #66	; 0x42
 800e090:	187b      	adds	r3, r7, r1
 800e092:	1879      	adds	r1, r7, r1
 800e094:	8809      	ldrh	r1, [r1, #0]
 800e096:	1a8a      	subs	r2, r1, r2
 800e098:	801a      	strh	r2, [r3, #0]
        /* all pbufs up to and including this one have len==0, so tot_len is equal */
        p->tot_len = new_tot_len;
 800e09a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e09c:	2222      	movs	r2, #34	; 0x22
 800e09e:	18ba      	adds	r2, r7, r2
 800e0a0:	8812      	ldrh	r2, [r2, #0]
 800e0a2:	811a      	strh	r2, [r3, #8]
        p->len = 0;
 800e0a4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e0a6:	2200      	movs	r2, #0
 800e0a8:	815a      	strh	r2, [r3, #10]
        p = p->next;
 800e0aa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e0ac:	681b      	ldr	r3, [r3, #0]
 800e0ae:	647b      	str	r3, [r7, #68]	; 0x44
      while (p->len < off) {
 800e0b0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e0b2:	895b      	ldrh	r3, [r3, #10]
 800e0b4:	2142      	movs	r1, #66	; 0x42
 800e0b6:	187a      	adds	r2, r7, r1
 800e0b8:	8812      	ldrh	r2, [r2, #0]
 800e0ba:	429a      	cmp	r2, r3
 800e0bc:	d8e5      	bhi.n	800e08a <tcp_receive+0x632>
      }
      /* cannot fail... */
      pbuf_remove_header(p, off);
 800e0be:	187b      	adds	r3, r7, r1
 800e0c0:	881a      	ldrh	r2, [r3, #0]
 800e0c2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e0c4:	0011      	movs	r1, r2
 800e0c6:	0018      	movs	r0, r3
 800e0c8:	f7fb fa0c 	bl	80094e4 <pbuf_remove_header>
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 800e0cc:	687b      	ldr	r3, [r7, #4]
 800e0ce:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800e0d0:	4b1e      	ldr	r3, [pc, #120]	; (800e14c <tcp_receive+0x6f4>)
 800e0d2:	601a      	str	r2, [r3, #0]
 800e0d4:	4b1e      	ldr	r3, [pc, #120]	; (800e150 <tcp_receive+0x6f8>)
 800e0d6:	691b      	ldr	r3, [r3, #16]
 800e0d8:	4a1c      	ldr	r2, [pc, #112]	; (800e14c <tcp_receive+0x6f4>)
 800e0da:	6812      	ldr	r2, [r2, #0]
 800e0dc:	21ff      	movs	r1, #255	; 0xff
 800e0de:	4011      	ands	r1, r2
 800e0e0:	000c      	movs	r4, r1
 800e0e2:	7919      	ldrb	r1, [r3, #4]
 800e0e4:	2000      	movs	r0, #0
 800e0e6:	4001      	ands	r1, r0
 800e0e8:	1c08      	adds	r0, r1, #0
 800e0ea:	1c21      	adds	r1, r4, #0
 800e0ec:	4301      	orrs	r1, r0
 800e0ee:	7119      	strb	r1, [r3, #4]
 800e0f0:	0a11      	lsrs	r1, r2, #8
 800e0f2:	20ff      	movs	r0, #255	; 0xff
 800e0f4:	4001      	ands	r1, r0
 800e0f6:	000c      	movs	r4, r1
 800e0f8:	7959      	ldrb	r1, [r3, #5]
 800e0fa:	2000      	movs	r0, #0
 800e0fc:	4001      	ands	r1, r0
 800e0fe:	1c08      	adds	r0, r1, #0
 800e100:	1c21      	adds	r1, r4, #0
 800e102:	4301      	orrs	r1, r0
 800e104:	7159      	strb	r1, [r3, #5]
 800e106:	0c11      	lsrs	r1, r2, #16
 800e108:	20ff      	movs	r0, #255	; 0xff
 800e10a:	4001      	ands	r1, r0
 800e10c:	000c      	movs	r4, r1
 800e10e:	7999      	ldrb	r1, [r3, #6]
 800e110:	2000      	movs	r0, #0
 800e112:	4001      	ands	r1, r0
 800e114:	1c08      	adds	r0, r1, #0
 800e116:	1c21      	adds	r1, r4, #0
 800e118:	4301      	orrs	r1, r0
 800e11a:	7199      	strb	r1, [r3, #6]
 800e11c:	0e10      	lsrs	r0, r2, #24
 800e11e:	79da      	ldrb	r2, [r3, #7]
 800e120:	2100      	movs	r1, #0
 800e122:	400a      	ands	r2, r1
 800e124:	1c11      	adds	r1, r2, #0
 800e126:	1c02      	adds	r2, r0, #0
 800e128:	430a      	orrs	r2, r1
 800e12a:	71da      	strb	r2, [r3, #7]
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
 800e12c:	e02f      	b.n	800e18e <tcp_receive+0x736>
 800e12e:	46c0      	nop			; (mov r8, r8)
 800e130:	0801fcfc 	.word	0x0801fcfc
 800e134:	0801fd04 	.word	0x0801fd04
 800e138:	20001388 	.word	0x20001388
 800e13c:	fffff7ff 	.word	0xfffff7ff
 800e140:	20001384 	.word	0x20001384
 800e144:	20002b1c 	.word	0x20002b1c
 800e148:	2000138a 	.word	0x2000138a
 800e14c:	20001380 	.word	0x20001380
 800e150:	2000135c 	.word	0x2000135c
 800e154:	0801f99c 	.word	0x0801f99c
 800e158:	00000595 	.word	0x00000595
 800e15c:	0801fd0c 	.word	0x0801fd0c
 800e160:	0801f9dc 	.word	0x0801f9dc
 800e164:	0000fffe 	.word	0x0000fffe
 800e168:	00000596 	.word	0x00000596
 800e16c:	0801fd1c 	.word	0x0801fd1c
 800e170:	0801fd2c 	.word	0x0801fd2c
    } else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
 800e174:	4bb0      	ldr	r3, [pc, #704]	; (800e438 <tcp_receive+0x9e0>)
 800e176:	681a      	ldr	r2, [r3, #0]
 800e178:	687b      	ldr	r3, [r7, #4]
 800e17a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800e17c:	1ad3      	subs	r3, r2, r3
 800e17e:	d506      	bpl.n	800e18e <tcp_receive+0x736>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
 800e180:	687b      	ldr	r3, [r7, #4]
 800e182:	8bdb      	ldrh	r3, [r3, #30]
 800e184:	2202      	movs	r2, #2
 800e186:	4313      	orrs	r3, r2
 800e188:	b29a      	uxth	r2, r3
 800e18a:	687b      	ldr	r3, [r7, #4]
 800e18c:	83da      	strh	r2, [r3, #30]
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 800e18e:	4baa      	ldr	r3, [pc, #680]	; (800e438 <tcp_receive+0x9e0>)
 800e190:	681a      	ldr	r2, [r3, #0]
 800e192:	687b      	ldr	r3, [r7, #4]
 800e194:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800e196:	1ad3      	subs	r3, r2, r3
 800e198:	d501      	bpl.n	800e19e <tcp_receive+0x746>
 800e19a:	f000 fd4d 	bl	800ec38 <tcp_receive+0x11e0>
 800e19e:	4ba6      	ldr	r3, [pc, #664]	; (800e438 <tcp_receive+0x9e0>)
 800e1a0:	681a      	ldr	r2, [r3, #0]
 800e1a2:	687b      	ldr	r3, [r7, #4]
 800e1a4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800e1a6:	6879      	ldr	r1, [r7, #4]
 800e1a8:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800e1aa:	185b      	adds	r3, r3, r1
 800e1ac:	1ad3      	subs	r3, r2, r3
 800e1ae:	3301      	adds	r3, #1
 800e1b0:	2b00      	cmp	r3, #0
 800e1b2:	dd01      	ble.n	800e1b8 <tcp_receive+0x760>
 800e1b4:	f000 fd40 	bl	800ec38 <tcp_receive+0x11e0>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
      if (pcb->rcv_nxt == seqno) {
 800e1b8:	687b      	ldr	r3, [r7, #4]
 800e1ba:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800e1bc:	4b9e      	ldr	r3, [pc, #632]	; (800e438 <tcp_receive+0x9e0>)
 800e1be:	681b      	ldr	r3, [r3, #0]
 800e1c0:	429a      	cmp	r2, r3
 800e1c2:	d000      	beq.n	800e1c6 <tcp_receive+0x76e>
 800e1c4:	e337      	b.n	800e836 <tcp_receive+0xdde>
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
 800e1c6:	4b9d      	ldr	r3, [pc, #628]	; (800e43c <tcp_receive+0x9e4>)
 800e1c8:	891c      	ldrh	r4, [r3, #8]
 800e1ca:	4b9c      	ldr	r3, [pc, #624]	; (800e43c <tcp_receive+0x9e4>)
 800e1cc:	691b      	ldr	r3, [r3, #16]
 800e1ce:	7b1a      	ldrb	r2, [r3, #12]
 800e1d0:	7b5b      	ldrb	r3, [r3, #13]
 800e1d2:	021b      	lsls	r3, r3, #8
 800e1d4:	4313      	orrs	r3, r2
 800e1d6:	b29b      	uxth	r3, r3
 800e1d8:	0018      	movs	r0, r3
 800e1da:	f7f8 f9ab 	bl	8006534 <lwip_htons>
 800e1de:	0003      	movs	r3, r0
 800e1e0:	b2db      	uxtb	r3, r3
 800e1e2:	001a      	movs	r2, r3
 800e1e4:	2303      	movs	r3, #3
 800e1e6:	4013      	ands	r3, r2
 800e1e8:	d001      	beq.n	800e1ee <tcp_receive+0x796>
 800e1ea:	2301      	movs	r3, #1
 800e1ec:	e000      	b.n	800e1f0 <tcp_receive+0x798>
 800e1ee:	2300      	movs	r3, #0
 800e1f0:	191b      	adds	r3, r3, r4
 800e1f2:	b29a      	uxth	r2, r3
 800e1f4:	4b92      	ldr	r3, [pc, #584]	; (800e440 <tcp_receive+0x9e8>)
 800e1f6:	801a      	strh	r2, [r3, #0]

        if (tcplen > pcb->rcv_wnd) {
 800e1f8:	687b      	ldr	r3, [r7, #4]
 800e1fa:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800e1fc:	4b90      	ldr	r3, [pc, #576]	; (800e440 <tcp_receive+0x9e8>)
 800e1fe:	881b      	ldrh	r3, [r3, #0]
 800e200:	429a      	cmp	r2, r3
 800e202:	d300      	bcc.n	800e206 <tcp_receive+0x7ae>
 800e204:	e095      	b.n	800e332 <tcp_receive+0x8da>
          LWIP_DEBUGF(TCP_INPUT_DEBUG,
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800e206:	4b8d      	ldr	r3, [pc, #564]	; (800e43c <tcp_receive+0x9e4>)
 800e208:	691b      	ldr	r3, [r3, #16]
 800e20a:	7b1a      	ldrb	r2, [r3, #12]
 800e20c:	7b5b      	ldrb	r3, [r3, #13]
 800e20e:	021b      	lsls	r3, r3, #8
 800e210:	4313      	orrs	r3, r2
 800e212:	b29b      	uxth	r3, r3
 800e214:	0018      	movs	r0, r3
 800e216:	f7f8 f98d 	bl	8006534 <lwip_htons>
 800e21a:	0003      	movs	r3, r0
 800e21c:	b2db      	uxtb	r3, r3
 800e21e:	001a      	movs	r2, r3
 800e220:	2301      	movs	r3, #1
 800e222:	4013      	ands	r3, r2
 800e224:	d037      	beq.n	800e296 <tcp_receive+0x83e>
            /* Must remove the FIN from the header as we're trimming
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~(unsigned int)TCP_FIN);
 800e226:	4b85      	ldr	r3, [pc, #532]	; (800e43c <tcp_receive+0x9e4>)
 800e228:	691b      	ldr	r3, [r3, #16]
 800e22a:	7b1a      	ldrb	r2, [r3, #12]
 800e22c:	7b5b      	ldrb	r3, [r3, #13]
 800e22e:	021b      	lsls	r3, r3, #8
 800e230:	4313      	orrs	r3, r2
 800e232:	b29b      	uxth	r3, r3
 800e234:	b21b      	sxth	r3, r3
 800e236:	4a83      	ldr	r2, [pc, #524]	; (800e444 <tcp_receive+0x9ec>)
 800e238:	4013      	ands	r3, r2
 800e23a:	b21c      	sxth	r4, r3
 800e23c:	4b7f      	ldr	r3, [pc, #508]	; (800e43c <tcp_receive+0x9e4>)
 800e23e:	691b      	ldr	r3, [r3, #16]
 800e240:	7b1a      	ldrb	r2, [r3, #12]
 800e242:	7b5b      	ldrb	r3, [r3, #13]
 800e244:	021b      	lsls	r3, r3, #8
 800e246:	4313      	orrs	r3, r2
 800e248:	b29b      	uxth	r3, r3
 800e24a:	0018      	movs	r0, r3
 800e24c:	f7f8 f972 	bl	8006534 <lwip_htons>
 800e250:	0003      	movs	r3, r0
 800e252:	b2db      	uxtb	r3, r3
 800e254:	b29b      	uxth	r3, r3
 800e256:	223e      	movs	r2, #62	; 0x3e
 800e258:	4013      	ands	r3, r2
 800e25a:	b29b      	uxth	r3, r3
 800e25c:	0018      	movs	r0, r3
 800e25e:	f7f8 f969 	bl	8006534 <lwip_htons>
 800e262:	0003      	movs	r3, r0
 800e264:	b21b      	sxth	r3, r3
 800e266:	4323      	orrs	r3, r4
 800e268:	b21a      	sxth	r2, r3
 800e26a:	4b74      	ldr	r3, [pc, #464]	; (800e43c <tcp_receive+0x9e4>)
 800e26c:	691b      	ldr	r3, [r3, #16]
 800e26e:	b292      	uxth	r2, r2
 800e270:	21ff      	movs	r1, #255	; 0xff
 800e272:	4011      	ands	r1, r2
 800e274:	000c      	movs	r4, r1
 800e276:	7b19      	ldrb	r1, [r3, #12]
 800e278:	2000      	movs	r0, #0
 800e27a:	4001      	ands	r1, r0
 800e27c:	1c08      	adds	r0, r1, #0
 800e27e:	1c21      	adds	r1, r4, #0
 800e280:	4301      	orrs	r1, r0
 800e282:	7319      	strb	r1, [r3, #12]
 800e284:	0a12      	lsrs	r2, r2, #8
 800e286:	b290      	uxth	r0, r2
 800e288:	7b5a      	ldrb	r2, [r3, #13]
 800e28a:	2100      	movs	r1, #0
 800e28c:	400a      	ands	r2, r1
 800e28e:	1c11      	adds	r1, r2, #0
 800e290:	1c02      	adds	r2, r0, #0
 800e292:	430a      	orrs	r2, r1
 800e294:	735a      	strb	r2, [r3, #13]
          }
          /* Adjust length of segment to fit in the window. */
          TCPWND_CHECK16(pcb->rcv_wnd);
          inseg.len = (u16_t)pcb->rcv_wnd;
 800e296:	687b      	ldr	r3, [r7, #4]
 800e298:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800e29a:	4b68      	ldr	r3, [pc, #416]	; (800e43c <tcp_receive+0x9e4>)
 800e29c:	811a      	strh	r2, [r3, #8]
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 800e29e:	4b67      	ldr	r3, [pc, #412]	; (800e43c <tcp_receive+0x9e4>)
 800e2a0:	691b      	ldr	r3, [r3, #16]
 800e2a2:	7b1a      	ldrb	r2, [r3, #12]
 800e2a4:	7b5b      	ldrb	r3, [r3, #13]
 800e2a6:	021b      	lsls	r3, r3, #8
 800e2a8:	4313      	orrs	r3, r2
 800e2aa:	b29b      	uxth	r3, r3
 800e2ac:	0018      	movs	r0, r3
 800e2ae:	f7f8 f941 	bl	8006534 <lwip_htons>
 800e2b2:	0003      	movs	r3, r0
 800e2b4:	b2db      	uxtb	r3, r3
 800e2b6:	001a      	movs	r2, r3
 800e2b8:	2302      	movs	r3, #2
 800e2ba:	4013      	ands	r3, r2
 800e2bc:	d005      	beq.n	800e2ca <tcp_receive+0x872>
            inseg.len -= 1;
 800e2be:	4b5f      	ldr	r3, [pc, #380]	; (800e43c <tcp_receive+0x9e4>)
 800e2c0:	891b      	ldrh	r3, [r3, #8]
 800e2c2:	3b01      	subs	r3, #1
 800e2c4:	b29a      	uxth	r2, r3
 800e2c6:	4b5d      	ldr	r3, [pc, #372]	; (800e43c <tcp_receive+0x9e4>)
 800e2c8:	811a      	strh	r2, [r3, #8]
          }
          pbuf_realloc(inseg.p, inseg.len);
 800e2ca:	4b5c      	ldr	r3, [pc, #368]	; (800e43c <tcp_receive+0x9e4>)
 800e2cc:	685a      	ldr	r2, [r3, #4]
 800e2ce:	4b5b      	ldr	r3, [pc, #364]	; (800e43c <tcp_receive+0x9e4>)
 800e2d0:	891b      	ldrh	r3, [r3, #8]
 800e2d2:	0019      	movs	r1, r3
 800e2d4:	0010      	movs	r0, r2
 800e2d6:	f7fa ffe3 	bl	80092a0 <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
 800e2da:	4b58      	ldr	r3, [pc, #352]	; (800e43c <tcp_receive+0x9e4>)
 800e2dc:	891c      	ldrh	r4, [r3, #8]
 800e2de:	4b57      	ldr	r3, [pc, #348]	; (800e43c <tcp_receive+0x9e4>)
 800e2e0:	691b      	ldr	r3, [r3, #16]
 800e2e2:	7b1a      	ldrb	r2, [r3, #12]
 800e2e4:	7b5b      	ldrb	r3, [r3, #13]
 800e2e6:	021b      	lsls	r3, r3, #8
 800e2e8:	4313      	orrs	r3, r2
 800e2ea:	b29b      	uxth	r3, r3
 800e2ec:	0018      	movs	r0, r3
 800e2ee:	f7f8 f921 	bl	8006534 <lwip_htons>
 800e2f2:	0003      	movs	r3, r0
 800e2f4:	b2db      	uxtb	r3, r3
 800e2f6:	001a      	movs	r2, r3
 800e2f8:	2303      	movs	r3, #3
 800e2fa:	4013      	ands	r3, r2
 800e2fc:	d001      	beq.n	800e302 <tcp_receive+0x8aa>
 800e2fe:	2301      	movs	r3, #1
 800e300:	e000      	b.n	800e304 <tcp_receive+0x8ac>
 800e302:	2300      	movs	r3, #0
 800e304:	191b      	adds	r3, r3, r4
 800e306:	b29a      	uxth	r2, r3
 800e308:	4b4d      	ldr	r3, [pc, #308]	; (800e440 <tcp_receive+0x9e8>)
 800e30a:	801a      	strh	r2, [r3, #0]
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 800e30c:	4b4c      	ldr	r3, [pc, #304]	; (800e440 <tcp_receive+0x9e8>)
 800e30e:	881b      	ldrh	r3, [r3, #0]
 800e310:	001a      	movs	r2, r3
 800e312:	4b49      	ldr	r3, [pc, #292]	; (800e438 <tcp_receive+0x9e0>)
 800e314:	681b      	ldr	r3, [r3, #0]
 800e316:	18d2      	adds	r2, r2, r3
 800e318:	687b      	ldr	r3, [r7, #4]
 800e31a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800e31c:	6879      	ldr	r1, [r7, #4]
 800e31e:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800e320:	185b      	adds	r3, r3, r1
 800e322:	429a      	cmp	r2, r3
 800e324:	d005      	beq.n	800e332 <tcp_receive+0x8da>
 800e326:	4b48      	ldr	r3, [pc, #288]	; (800e448 <tcp_receive+0x9f0>)
 800e328:	4a48      	ldr	r2, [pc, #288]	; (800e44c <tcp_receive+0x9f4>)
 800e32a:	4949      	ldr	r1, [pc, #292]	; (800e450 <tcp_receive+0x9f8>)
 800e32c:	4849      	ldr	r0, [pc, #292]	; (800e454 <tcp_receive+0x9fc>)
 800e32e:	f7f3 ff4d 	bl	80021cc <app_debug_rtt_raw>
        }
#if TCP_QUEUE_OOSEQ
        /* Received in-sequence data, adjust ooseq data if:
           - FIN has been received or
           - inseq overlaps with ooseq */
        if (pcb->ooseq != NULL) {
 800e332:	687b      	ldr	r3, [r7, #4]
 800e334:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e336:	2b00      	cmp	r3, #0
 800e338:	d100      	bne.n	800e33c <tcp_receive+0x8e4>
 800e33a:	e138      	b.n	800e5ae <tcp_receive+0xb56>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800e33c:	4b3f      	ldr	r3, [pc, #252]	; (800e43c <tcp_receive+0x9e4>)
 800e33e:	691b      	ldr	r3, [r3, #16]
 800e340:	7b1a      	ldrb	r2, [r3, #12]
 800e342:	7b5b      	ldrb	r3, [r3, #13]
 800e344:	021b      	lsls	r3, r3, #8
 800e346:	4313      	orrs	r3, r2
 800e348:	b29b      	uxth	r3, r3
 800e34a:	0018      	movs	r0, r3
 800e34c:	f7f8 f8f2 	bl	8006534 <lwip_htons>
 800e350:	0003      	movs	r3, r0
 800e352:	b2db      	uxtb	r3, r3
 800e354:	001a      	movs	r2, r3
 800e356:	2301      	movs	r3, #1
 800e358:	4013      	ands	r3, r2
 800e35a:	d011      	beq.n	800e380 <tcp_receive+0x928>
            LWIP_DEBUGF(TCP_INPUT_DEBUG,
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
 800e35c:	e00b      	b.n	800e376 <tcp_receive+0x91e>
              struct tcp_seg *old_ooseq = pcb->ooseq;
 800e35e:	687b      	ldr	r3, [r7, #4]
 800e360:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e362:	60fb      	str	r3, [r7, #12]
              pcb->ooseq = pcb->ooseq->next;
 800e364:	687b      	ldr	r3, [r7, #4]
 800e366:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e368:	681a      	ldr	r2, [r3, #0]
 800e36a:	687b      	ldr	r3, [r7, #4]
 800e36c:	679a      	str	r2, [r3, #120]	; 0x78
              tcp_seg_free(old_ooseq);
 800e36e:	68fb      	ldr	r3, [r7, #12]
 800e370:	0018      	movs	r0, r3
 800e372:	f7fd fa11 	bl	800b798 <tcp_seg_free>
            while (pcb->ooseq != NULL) {
 800e376:	687b      	ldr	r3, [r7, #4]
 800e378:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e37a:	2b00      	cmp	r3, #0
 800e37c:	d1ef      	bne.n	800e35e <tcp_receive+0x906>
 800e37e:	e116      	b.n	800e5ae <tcp_receive+0xb56>
            }
          } else {
            struct tcp_seg *next = pcb->ooseq;
 800e380:	687b      	ldr	r3, [r7, #4]
 800e382:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e384:	63fb      	str	r3, [r7, #60]	; 0x3c
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
 800e386:	e075      	b.n	800e474 <tcp_receive+0xa1c>
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              struct tcp_seg *tmp;
              /* inseg cannot have FIN here (already processed above) */
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
 800e388:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e38a:	691b      	ldr	r3, [r3, #16]
 800e38c:	7b1a      	ldrb	r2, [r3, #12]
 800e38e:	7b5b      	ldrb	r3, [r3, #13]
 800e390:	021b      	lsls	r3, r3, #8
 800e392:	4313      	orrs	r3, r2
 800e394:	b29b      	uxth	r3, r3
 800e396:	0018      	movs	r0, r3
 800e398:	f7f8 f8cc 	bl	8006534 <lwip_htons>
 800e39c:	0003      	movs	r3, r0
 800e39e:	b2db      	uxtb	r3, r3
 800e3a0:	001a      	movs	r2, r3
 800e3a2:	2301      	movs	r3, #1
 800e3a4:	4013      	ands	r3, r2
 800e3a6:	d05c      	beq.n	800e462 <tcp_receive+0xa0a>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
 800e3a8:	4b24      	ldr	r3, [pc, #144]	; (800e43c <tcp_receive+0x9e4>)
 800e3aa:	691b      	ldr	r3, [r3, #16]
 800e3ac:	7b1a      	ldrb	r2, [r3, #12]
 800e3ae:	7b5b      	ldrb	r3, [r3, #13]
 800e3b0:	021b      	lsls	r3, r3, #8
 800e3b2:	4313      	orrs	r3, r2
 800e3b4:	b29b      	uxth	r3, r3
 800e3b6:	0018      	movs	r0, r3
 800e3b8:	f7f8 f8bc 	bl	8006534 <lwip_htons>
 800e3bc:	0003      	movs	r3, r0
 800e3be:	b2db      	uxtb	r3, r3
 800e3c0:	001a      	movs	r2, r3
 800e3c2:	2302      	movs	r3, #2
 800e3c4:	4013      	ands	r3, r2
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
 800e3c6:	d14c      	bne.n	800e462 <tcp_receive+0xa0a>
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
 800e3c8:	4b1c      	ldr	r3, [pc, #112]	; (800e43c <tcp_receive+0x9e4>)
 800e3ca:	691b      	ldr	r3, [r3, #16]
 800e3cc:	7b1a      	ldrb	r2, [r3, #12]
 800e3ce:	7b5b      	ldrb	r3, [r3, #13]
 800e3d0:	021b      	lsls	r3, r3, #8
 800e3d2:	4313      	orrs	r3, r2
 800e3d4:	b29c      	uxth	r4, r3
 800e3d6:	2001      	movs	r0, #1
 800e3d8:	f7f8 f8ac 	bl	8006534 <lwip_htons>
 800e3dc:	0003      	movs	r3, r0
 800e3de:	001a      	movs	r2, r3
 800e3e0:	4b16      	ldr	r3, [pc, #88]	; (800e43c <tcp_receive+0x9e4>)
 800e3e2:	691b      	ldr	r3, [r3, #16]
 800e3e4:	4322      	orrs	r2, r4
 800e3e6:	b292      	uxth	r2, r2
 800e3e8:	21ff      	movs	r1, #255	; 0xff
 800e3ea:	4011      	ands	r1, r2
 800e3ec:	000c      	movs	r4, r1
 800e3ee:	7b19      	ldrb	r1, [r3, #12]
 800e3f0:	2000      	movs	r0, #0
 800e3f2:	4001      	ands	r1, r0
 800e3f4:	1c08      	adds	r0, r1, #0
 800e3f6:	1c21      	adds	r1, r4, #0
 800e3f8:	4301      	orrs	r1, r0
 800e3fa:	7319      	strb	r1, [r3, #12]
 800e3fc:	0a12      	lsrs	r2, r2, #8
 800e3fe:	b290      	uxth	r0, r2
 800e400:	7b5a      	ldrb	r2, [r3, #13]
 800e402:	2100      	movs	r1, #0
 800e404:	400a      	ands	r2, r1
 800e406:	1c11      	adds	r1, r2, #0
 800e408:	1c02      	adds	r2, r0, #0
 800e40a:	430a      	orrs	r2, r1
 800e40c:	735a      	strb	r2, [r3, #13]
                tcplen = TCP_TCPLEN(&inseg);
 800e40e:	4b0b      	ldr	r3, [pc, #44]	; (800e43c <tcp_receive+0x9e4>)
 800e410:	891c      	ldrh	r4, [r3, #8]
 800e412:	4b0a      	ldr	r3, [pc, #40]	; (800e43c <tcp_receive+0x9e4>)
 800e414:	691b      	ldr	r3, [r3, #16]
 800e416:	7b1a      	ldrb	r2, [r3, #12]
 800e418:	7b5b      	ldrb	r3, [r3, #13]
 800e41a:	021b      	lsls	r3, r3, #8
 800e41c:	4313      	orrs	r3, r2
 800e41e:	b29b      	uxth	r3, r3
 800e420:	0018      	movs	r0, r3
 800e422:	f7f8 f887 	bl	8006534 <lwip_htons>
 800e426:	0003      	movs	r3, r0
 800e428:	b2db      	uxtb	r3, r3
 800e42a:	001a      	movs	r2, r3
 800e42c:	2303      	movs	r3, #3
 800e42e:	4013      	ands	r3, r2
 800e430:	d012      	beq.n	800e458 <tcp_receive+0xa00>
 800e432:	2301      	movs	r3, #1
 800e434:	e011      	b.n	800e45a <tcp_receive+0xa02>
 800e436:	46c0      	nop			; (mov r8, r8)
 800e438:	20001380 	.word	0x20001380
 800e43c:	2000135c 	.word	0x2000135c
 800e440:	2000138a 	.word	0x2000138a
 800e444:	ffffc0ff 	.word	0xffffc0ff
 800e448:	0801f99c 	.word	0x0801f99c
 800e44c:	000005cc 	.word	0x000005cc
 800e450:	0801fd3c 	.word	0x0801fd3c
 800e454:	0801f9dc 	.word	0x0801f9dc
 800e458:	2300      	movs	r3, #0
 800e45a:	191b      	adds	r3, r3, r4
 800e45c:	b29a      	uxth	r2, r3
 800e45e:	4bb9      	ldr	r3, [pc, #740]	; (800e744 <tcp_receive+0xcec>)
 800e460:	801a      	strh	r2, [r3, #0]
              }
              tmp = next;
 800e462:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e464:	613b      	str	r3, [r7, #16]
              next = next->next;
 800e466:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e468:	681b      	ldr	r3, [r3, #0]
 800e46a:	63fb      	str	r3, [r7, #60]	; 0x3c
              tcp_seg_free(tmp);
 800e46c:	693b      	ldr	r3, [r7, #16]
 800e46e:	0018      	movs	r0, r3
 800e470:	f7fd f992 	bl	800b798 <tcp_seg_free>
            while (next &&
 800e474:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e476:	2b00      	cmp	r3, #0
 800e478:	d018      	beq.n	800e4ac <tcp_receive+0xa54>
                   TCP_SEQ_GEQ(seqno + tcplen,
 800e47a:	4bb2      	ldr	r3, [pc, #712]	; (800e744 <tcp_receive+0xcec>)
 800e47c:	881b      	ldrh	r3, [r3, #0]
 800e47e:	001a      	movs	r2, r3
 800e480:	4bb1      	ldr	r3, [pc, #708]	; (800e748 <tcp_receive+0xcf0>)
 800e482:	681b      	ldr	r3, [r3, #0]
 800e484:	18d2      	adds	r2, r2, r3
 800e486:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e488:	691b      	ldr	r3, [r3, #16]
 800e48a:	7919      	ldrb	r1, [r3, #4]
 800e48c:	7958      	ldrb	r0, [r3, #5]
 800e48e:	0200      	lsls	r0, r0, #8
 800e490:	4301      	orrs	r1, r0
 800e492:	7998      	ldrb	r0, [r3, #6]
 800e494:	0400      	lsls	r0, r0, #16
 800e496:	4301      	orrs	r1, r0
 800e498:	79db      	ldrb	r3, [r3, #7]
 800e49a:	061b      	lsls	r3, r3, #24
 800e49c:	430b      	orrs	r3, r1
 800e49e:	0019      	movs	r1, r3
 800e4a0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e4a2:	891b      	ldrh	r3, [r3, #8]
 800e4a4:	18cb      	adds	r3, r1, r3
 800e4a6:	1ad3      	subs	r3, r2, r3
            while (next &&
 800e4a8:	d400      	bmi.n	800e4ac <tcp_receive+0xa54>
 800e4aa:	e76d      	b.n	800e388 <tcp_receive+0x930>
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
 800e4ac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e4ae:	2b00      	cmp	r3, #0
 800e4b0:	d100      	bne.n	800e4b4 <tcp_receive+0xa5c>
 800e4b2:	e079      	b.n	800e5a8 <tcp_receive+0xb50>
                TCP_SEQ_GT(seqno + tcplen,
 800e4b4:	4ba3      	ldr	r3, [pc, #652]	; (800e744 <tcp_receive+0xcec>)
 800e4b6:	881b      	ldrh	r3, [r3, #0]
 800e4b8:	001a      	movs	r2, r3
 800e4ba:	4ba3      	ldr	r3, [pc, #652]	; (800e748 <tcp_receive+0xcf0>)
 800e4bc:	681b      	ldr	r3, [r3, #0]
 800e4be:	18d2      	adds	r2, r2, r3
 800e4c0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e4c2:	691b      	ldr	r3, [r3, #16]
 800e4c4:	7919      	ldrb	r1, [r3, #4]
 800e4c6:	7958      	ldrb	r0, [r3, #5]
 800e4c8:	0200      	lsls	r0, r0, #8
 800e4ca:	4301      	orrs	r1, r0
 800e4cc:	7998      	ldrb	r0, [r3, #6]
 800e4ce:	0400      	lsls	r0, r0, #16
 800e4d0:	4301      	orrs	r1, r0
 800e4d2:	79db      	ldrb	r3, [r3, #7]
 800e4d4:	061b      	lsls	r3, r3, #24
 800e4d6:	430b      	orrs	r3, r1
 800e4d8:	1ad3      	subs	r3, r2, r3
            if (next &&
 800e4da:	2b00      	cmp	r3, #0
 800e4dc:	dd64      	ble.n	800e5a8 <tcp_receive+0xb50>
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
 800e4de:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e4e0:	691b      	ldr	r3, [r3, #16]
 800e4e2:	791a      	ldrb	r2, [r3, #4]
 800e4e4:	7959      	ldrb	r1, [r3, #5]
 800e4e6:	0209      	lsls	r1, r1, #8
 800e4e8:	430a      	orrs	r2, r1
 800e4ea:	7999      	ldrb	r1, [r3, #6]
 800e4ec:	0409      	lsls	r1, r1, #16
 800e4ee:	430a      	orrs	r2, r1
 800e4f0:	79db      	ldrb	r3, [r3, #7]
 800e4f2:	061b      	lsls	r3, r3, #24
 800e4f4:	4313      	orrs	r3, r2
 800e4f6:	b29a      	uxth	r2, r3
 800e4f8:	4b93      	ldr	r3, [pc, #588]	; (800e748 <tcp_receive+0xcf0>)
 800e4fa:	681b      	ldr	r3, [r3, #0]
 800e4fc:	b29b      	uxth	r3, r3
 800e4fe:	1ad3      	subs	r3, r2, r3
 800e500:	b29a      	uxth	r2, r3
 800e502:	4b92      	ldr	r3, [pc, #584]	; (800e74c <tcp_receive+0xcf4>)
 800e504:	811a      	strh	r2, [r3, #8]
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 800e506:	4b91      	ldr	r3, [pc, #580]	; (800e74c <tcp_receive+0xcf4>)
 800e508:	691b      	ldr	r3, [r3, #16]
 800e50a:	7b1a      	ldrb	r2, [r3, #12]
 800e50c:	7b5b      	ldrb	r3, [r3, #13]
 800e50e:	021b      	lsls	r3, r3, #8
 800e510:	4313      	orrs	r3, r2
 800e512:	b29b      	uxth	r3, r3
 800e514:	0018      	movs	r0, r3
 800e516:	f7f8 f80d 	bl	8006534 <lwip_htons>
 800e51a:	0003      	movs	r3, r0
 800e51c:	b2db      	uxtb	r3, r3
 800e51e:	001a      	movs	r2, r3
 800e520:	2302      	movs	r3, #2
 800e522:	4013      	ands	r3, r2
 800e524:	d005      	beq.n	800e532 <tcp_receive+0xada>
                inseg.len -= 1;
 800e526:	4b89      	ldr	r3, [pc, #548]	; (800e74c <tcp_receive+0xcf4>)
 800e528:	891b      	ldrh	r3, [r3, #8]
 800e52a:	3b01      	subs	r3, #1
 800e52c:	b29a      	uxth	r2, r3
 800e52e:	4b87      	ldr	r3, [pc, #540]	; (800e74c <tcp_receive+0xcf4>)
 800e530:	811a      	strh	r2, [r3, #8]
              }
              pbuf_realloc(inseg.p, inseg.len);
 800e532:	4b86      	ldr	r3, [pc, #536]	; (800e74c <tcp_receive+0xcf4>)
 800e534:	685a      	ldr	r2, [r3, #4]
 800e536:	4b85      	ldr	r3, [pc, #532]	; (800e74c <tcp_receive+0xcf4>)
 800e538:	891b      	ldrh	r3, [r3, #8]
 800e53a:	0019      	movs	r1, r3
 800e53c:	0010      	movs	r0, r2
 800e53e:	f7fa feaf 	bl	80092a0 <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
 800e542:	4b82      	ldr	r3, [pc, #520]	; (800e74c <tcp_receive+0xcf4>)
 800e544:	891c      	ldrh	r4, [r3, #8]
 800e546:	4b81      	ldr	r3, [pc, #516]	; (800e74c <tcp_receive+0xcf4>)
 800e548:	691b      	ldr	r3, [r3, #16]
 800e54a:	7b1a      	ldrb	r2, [r3, #12]
 800e54c:	7b5b      	ldrb	r3, [r3, #13]
 800e54e:	021b      	lsls	r3, r3, #8
 800e550:	4313      	orrs	r3, r2
 800e552:	b29b      	uxth	r3, r3
 800e554:	0018      	movs	r0, r3
 800e556:	f7f7 ffed 	bl	8006534 <lwip_htons>
 800e55a:	0003      	movs	r3, r0
 800e55c:	b2db      	uxtb	r3, r3
 800e55e:	001a      	movs	r2, r3
 800e560:	2303      	movs	r3, #3
 800e562:	4013      	ands	r3, r2
 800e564:	d001      	beq.n	800e56a <tcp_receive+0xb12>
 800e566:	2301      	movs	r3, #1
 800e568:	e000      	b.n	800e56c <tcp_receive+0xb14>
 800e56a:	2300      	movs	r3, #0
 800e56c:	191b      	adds	r3, r3, r4
 800e56e:	b29a      	uxth	r2, r3
 800e570:	4b74      	ldr	r3, [pc, #464]	; (800e744 <tcp_receive+0xcec>)
 800e572:	801a      	strh	r2, [r3, #0]
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
 800e574:	4b73      	ldr	r3, [pc, #460]	; (800e744 <tcp_receive+0xcec>)
 800e576:	881b      	ldrh	r3, [r3, #0]
 800e578:	001a      	movs	r2, r3
 800e57a:	4b73      	ldr	r3, [pc, #460]	; (800e748 <tcp_receive+0xcf0>)
 800e57c:	681b      	ldr	r3, [r3, #0]
 800e57e:	18d2      	adds	r2, r2, r3
 800e580:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800e582:	691b      	ldr	r3, [r3, #16]
 800e584:	7919      	ldrb	r1, [r3, #4]
 800e586:	7958      	ldrb	r0, [r3, #5]
 800e588:	0200      	lsls	r0, r0, #8
 800e58a:	4301      	orrs	r1, r0
 800e58c:	7998      	ldrb	r0, [r3, #6]
 800e58e:	0400      	lsls	r0, r0, #16
 800e590:	4301      	orrs	r1, r0
 800e592:	79db      	ldrb	r3, [r3, #7]
 800e594:	061b      	lsls	r3, r3, #24
 800e596:	430b      	orrs	r3, r1
 800e598:	429a      	cmp	r2, r3
 800e59a:	d005      	beq.n	800e5a8 <tcp_receive+0xb50>
 800e59c:	4b6c      	ldr	r3, [pc, #432]	; (800e750 <tcp_receive+0xcf8>)
 800e59e:	4a6d      	ldr	r2, [pc, #436]	; (800e754 <tcp_receive+0xcfc>)
 800e5a0:	496d      	ldr	r1, [pc, #436]	; (800e758 <tcp_receive+0xd00>)
 800e5a2:	486e      	ldr	r0, [pc, #440]	; (800e75c <tcp_receive+0xd04>)
 800e5a4:	f7f3 fe12 	bl	80021cc <app_debug_rtt_raw>
                          (seqno + tcplen) == next->tcphdr->seqno);
            }
            pcb->ooseq = next;
 800e5a8:	687b      	ldr	r3, [r7, #4]
 800e5aa:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800e5ac:	679a      	str	r2, [r3, #120]	; 0x78
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
 800e5ae:	4b65      	ldr	r3, [pc, #404]	; (800e744 <tcp_receive+0xcec>)
 800e5b0:	881b      	ldrh	r3, [r3, #0]
 800e5b2:	001a      	movs	r2, r3
 800e5b4:	4b64      	ldr	r3, [pc, #400]	; (800e748 <tcp_receive+0xcf0>)
 800e5b6:	681b      	ldr	r3, [r3, #0]
 800e5b8:	18d2      	adds	r2, r2, r3
 800e5ba:	687b      	ldr	r3, [r7, #4]
 800e5bc:	629a      	str	r2, [r3, #40]	; 0x28

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
 800e5be:	687b      	ldr	r3, [r7, #4]
 800e5c0:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800e5c2:	4b60      	ldr	r3, [pc, #384]	; (800e744 <tcp_receive+0xcec>)
 800e5c4:	881b      	ldrh	r3, [r3, #0]
 800e5c6:	429a      	cmp	r2, r3
 800e5c8:	d206      	bcs.n	800e5d8 <tcp_receive+0xb80>
 800e5ca:	4b61      	ldr	r3, [pc, #388]	; (800e750 <tcp_receive+0xcf8>)
 800e5cc:	22c1      	movs	r2, #193	; 0xc1
 800e5ce:	00d2      	lsls	r2, r2, #3
 800e5d0:	4963      	ldr	r1, [pc, #396]	; (800e760 <tcp_receive+0xd08>)
 800e5d2:	4862      	ldr	r0, [pc, #392]	; (800e75c <tcp_receive+0xd04>)
 800e5d4:	f7f3 fdfa 	bl	80021cc <app_debug_rtt_raw>
        pcb->rcv_wnd -= tcplen;
 800e5d8:	687b      	ldr	r3, [r7, #4]
 800e5da:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800e5dc:	4b59      	ldr	r3, [pc, #356]	; (800e744 <tcp_receive+0xcec>)
 800e5de:	881b      	ldrh	r3, [r3, #0]
 800e5e0:	1ad3      	subs	r3, r2, r3
 800e5e2:	b29a      	uxth	r2, r3
 800e5e4:	687b      	ldr	r3, [r7, #4]
 800e5e6:	859a      	strh	r2, [r3, #44]	; 0x2c

        tcp_update_rcv_ann_wnd(pcb);
 800e5e8:	687b      	ldr	r3, [r7, #4]
 800e5ea:	0018      	movs	r0, r3
 800e5ec:	f7fc f9e2 	bl	800a9b4 <tcp_update_rcv_ann_wnd>
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
 800e5f0:	4b56      	ldr	r3, [pc, #344]	; (800e74c <tcp_receive+0xcf4>)
 800e5f2:	685b      	ldr	r3, [r3, #4]
 800e5f4:	891b      	ldrh	r3, [r3, #8]
 800e5f6:	2b00      	cmp	r3, #0
 800e5f8:	d006      	beq.n	800e608 <tcp_receive+0xbb0>
          recv_data = inseg.p;
 800e5fa:	4b54      	ldr	r3, [pc, #336]	; (800e74c <tcp_receive+0xcf4>)
 800e5fc:	685a      	ldr	r2, [r3, #4]
 800e5fe:	4b59      	ldr	r3, [pc, #356]	; (800e764 <tcp_receive+0xd0c>)
 800e600:	601a      	str	r2, [r3, #0]
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
 800e602:	4b52      	ldr	r3, [pc, #328]	; (800e74c <tcp_receive+0xcf4>)
 800e604:	2200      	movs	r2, #0
 800e606:	605a      	str	r2, [r3, #4]
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 800e608:	4b50      	ldr	r3, [pc, #320]	; (800e74c <tcp_receive+0xcf4>)
 800e60a:	691b      	ldr	r3, [r3, #16]
 800e60c:	7b1a      	ldrb	r2, [r3, #12]
 800e60e:	7b5b      	ldrb	r3, [r3, #13]
 800e610:	021b      	lsls	r3, r3, #8
 800e612:	4313      	orrs	r3, r2
 800e614:	b29b      	uxth	r3, r3
 800e616:	0018      	movs	r0, r3
 800e618:	f7f7 ff8c 	bl	8006534 <lwip_htons>
 800e61c:	0003      	movs	r3, r0
 800e61e:	b2db      	uxtb	r3, r3
 800e620:	001a      	movs	r2, r3
 800e622:	2301      	movs	r3, #1
 800e624:	4013      	ands	r3, r2
 800e626:	d100      	bne.n	800e62a <tcp_receive+0xbd2>
 800e628:	e0d1      	b.n	800e7ce <tcp_receive+0xd76>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
 800e62a:	4b4f      	ldr	r3, [pc, #316]	; (800e768 <tcp_receive+0xd10>)
 800e62c:	781b      	ldrb	r3, [r3, #0]
 800e62e:	2220      	movs	r2, #32
 800e630:	4313      	orrs	r3, r2
 800e632:	b2da      	uxtb	r2, r3
 800e634:	4b4c      	ldr	r3, [pc, #304]	; (800e768 <tcp_receive+0xd10>)
 800e636:	701a      	strb	r2, [r3, #0]
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
 800e638:	e0c9      	b.n	800e7ce <tcp_receive+0xd76>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          struct tcp_seg *cseg = pcb->ooseq;
 800e63a:	687b      	ldr	r3, [r7, #4]
 800e63c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e63e:	60bb      	str	r3, [r7, #8]
          seqno = pcb->ooseq->tcphdr->seqno;
 800e640:	687b      	ldr	r3, [r7, #4]
 800e642:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e644:	691b      	ldr	r3, [r3, #16]
 800e646:	791a      	ldrb	r2, [r3, #4]
 800e648:	7959      	ldrb	r1, [r3, #5]
 800e64a:	0209      	lsls	r1, r1, #8
 800e64c:	430a      	orrs	r2, r1
 800e64e:	7999      	ldrb	r1, [r3, #6]
 800e650:	0409      	lsls	r1, r1, #16
 800e652:	430a      	orrs	r2, r1
 800e654:	79db      	ldrb	r3, [r3, #7]
 800e656:	061b      	lsls	r3, r3, #24
 800e658:	4313      	orrs	r3, r2
 800e65a:	001a      	movs	r2, r3
 800e65c:	4b3a      	ldr	r3, [pc, #232]	; (800e748 <tcp_receive+0xcf0>)
 800e65e:	601a      	str	r2, [r3, #0]

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
 800e660:	68bb      	ldr	r3, [r7, #8]
 800e662:	891b      	ldrh	r3, [r3, #8]
 800e664:	001c      	movs	r4, r3
 800e666:	68bb      	ldr	r3, [r7, #8]
 800e668:	691b      	ldr	r3, [r3, #16]
 800e66a:	7b1a      	ldrb	r2, [r3, #12]
 800e66c:	7b5b      	ldrb	r3, [r3, #13]
 800e66e:	021b      	lsls	r3, r3, #8
 800e670:	4313      	orrs	r3, r2
 800e672:	b29b      	uxth	r3, r3
 800e674:	0018      	movs	r0, r3
 800e676:	f7f7 ff5d 	bl	8006534 <lwip_htons>
 800e67a:	0003      	movs	r3, r0
 800e67c:	b2db      	uxtb	r3, r3
 800e67e:	001a      	movs	r2, r3
 800e680:	2303      	movs	r3, #3
 800e682:	4013      	ands	r3, r2
 800e684:	d001      	beq.n	800e68a <tcp_receive+0xc32>
 800e686:	2301      	movs	r3, #1
 800e688:	e000      	b.n	800e68c <tcp_receive+0xc34>
 800e68a:	2300      	movs	r3, #0
 800e68c:	191a      	adds	r2, r3, r4
 800e68e:	687b      	ldr	r3, [r7, #4]
 800e690:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800e692:	18d2      	adds	r2, r2, r3
 800e694:	687b      	ldr	r3, [r7, #4]
 800e696:	629a      	str	r2, [r3, #40]	; 0x28
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
 800e698:	687b      	ldr	r3, [r7, #4]
 800e69a:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800e69c:	001c      	movs	r4, r3
 800e69e:	68bb      	ldr	r3, [r7, #8]
 800e6a0:	891b      	ldrh	r3, [r3, #8]
 800e6a2:	001d      	movs	r5, r3
 800e6a4:	68bb      	ldr	r3, [r7, #8]
 800e6a6:	691b      	ldr	r3, [r3, #16]
 800e6a8:	7b1a      	ldrb	r2, [r3, #12]
 800e6aa:	7b5b      	ldrb	r3, [r3, #13]
 800e6ac:	021b      	lsls	r3, r3, #8
 800e6ae:	4313      	orrs	r3, r2
 800e6b0:	b29b      	uxth	r3, r3
 800e6b2:	0018      	movs	r0, r3
 800e6b4:	f7f7 ff3e 	bl	8006534 <lwip_htons>
 800e6b8:	0003      	movs	r3, r0
 800e6ba:	b2db      	uxtb	r3, r3
 800e6bc:	001a      	movs	r2, r3
 800e6be:	2303      	movs	r3, #3
 800e6c0:	4013      	ands	r3, r2
 800e6c2:	d001      	beq.n	800e6c8 <tcp_receive+0xc70>
 800e6c4:	2301      	movs	r3, #1
 800e6c6:	e000      	b.n	800e6ca <tcp_receive+0xc72>
 800e6c8:	2300      	movs	r3, #0
 800e6ca:	195b      	adds	r3, r3, r5
 800e6cc:	429c      	cmp	r4, r3
 800e6ce:	d205      	bcs.n	800e6dc <tcp_receive+0xc84>
 800e6d0:	4b1f      	ldr	r3, [pc, #124]	; (800e750 <tcp_receive+0xcf8>)
 800e6d2:	4a26      	ldr	r2, [pc, #152]	; (800e76c <tcp_receive+0xd14>)
 800e6d4:	4926      	ldr	r1, [pc, #152]	; (800e770 <tcp_receive+0xd18>)
 800e6d6:	4821      	ldr	r0, [pc, #132]	; (800e75c <tcp_receive+0xd04>)
 800e6d8:	f7f3 fd78 	bl	80021cc <app_debug_rtt_raw>
                      pcb->rcv_wnd >= TCP_TCPLEN(cseg));
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
 800e6dc:	68bb      	ldr	r3, [r7, #8]
 800e6de:	891b      	ldrh	r3, [r3, #8]
 800e6e0:	001c      	movs	r4, r3
 800e6e2:	68bb      	ldr	r3, [r7, #8]
 800e6e4:	691b      	ldr	r3, [r3, #16]
 800e6e6:	7b1a      	ldrb	r2, [r3, #12]
 800e6e8:	7b5b      	ldrb	r3, [r3, #13]
 800e6ea:	021b      	lsls	r3, r3, #8
 800e6ec:	4313      	orrs	r3, r2
 800e6ee:	b29b      	uxth	r3, r3
 800e6f0:	0018      	movs	r0, r3
 800e6f2:	f7f7 ff1f 	bl	8006534 <lwip_htons>
 800e6f6:	0003      	movs	r3, r0
 800e6f8:	b2db      	uxtb	r3, r3
 800e6fa:	001a      	movs	r2, r3
 800e6fc:	2303      	movs	r3, #3
 800e6fe:	4013      	ands	r3, r2
 800e700:	d001      	beq.n	800e706 <tcp_receive+0xcae>
 800e702:	2301      	movs	r3, #1
 800e704:	e000      	b.n	800e708 <tcp_receive+0xcb0>
 800e706:	2300      	movs	r3, #0
 800e708:	1919      	adds	r1, r3, r4
 800e70a:	687b      	ldr	r3, [r7, #4]
 800e70c:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 800e70e:	b28b      	uxth	r3, r1
 800e710:	1ad3      	subs	r3, r2, r3
 800e712:	b29a      	uxth	r2, r3
 800e714:	687b      	ldr	r3, [r7, #4]
 800e716:	859a      	strh	r2, [r3, #44]	; 0x2c

          tcp_update_rcv_ann_wnd(pcb);
 800e718:	687b      	ldr	r3, [r7, #4]
 800e71a:	0018      	movs	r0, r3
 800e71c:	f7fc f94a 	bl	800a9b4 <tcp_update_rcv_ann_wnd>

          if (cseg->p->tot_len > 0) {
 800e720:	68bb      	ldr	r3, [r7, #8]
 800e722:	685b      	ldr	r3, [r3, #4]
 800e724:	891b      	ldrh	r3, [r3, #8]
 800e726:	2b00      	cmp	r3, #0
 800e728:	d02b      	beq.n	800e782 <tcp_receive+0xd2a>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            /* With window scaling, this can overflow recv_data->tot_len, but
               that's not a problem since we explicitly fix that before passing
               recv_data to the application. */
            if (recv_data) {
 800e72a:	4b0e      	ldr	r3, [pc, #56]	; (800e764 <tcp_receive+0xd0c>)
 800e72c:	681b      	ldr	r3, [r3, #0]
 800e72e:	2b00      	cmp	r3, #0
 800e730:	d020      	beq.n	800e774 <tcp_receive+0xd1c>
              pbuf_cat(recv_data, cseg->p);
 800e732:	4b0c      	ldr	r3, [pc, #48]	; (800e764 <tcp_receive+0xd0c>)
 800e734:	681a      	ldr	r2, [r3, #0]
 800e736:	68bb      	ldr	r3, [r7, #8]
 800e738:	685b      	ldr	r3, [r3, #4]
 800e73a:	0019      	movs	r1, r3
 800e73c:	0010      	movs	r0, r2
 800e73e:	f7fb f889 	bl	8009854 <pbuf_cat>
 800e742:	e01b      	b.n	800e77c <tcp_receive+0xd24>
 800e744:	2000138a 	.word	0x2000138a
 800e748:	20001380 	.word	0x20001380
 800e74c:	2000135c 	.word	0x2000135c
 800e750:	0801f99c 	.word	0x0801f99c
 800e754:	000005fd 	.word	0x000005fd
 800e758:	0801fd74 	.word	0x0801fd74
 800e75c:	0801f9dc 	.word	0x0801f9dc
 800e760:	0801fdb0 	.word	0x0801fdb0
 800e764:	20001390 	.word	0x20001390
 800e768:	2000138d 	.word	0x2000138d
 800e76c:	0000062c 	.word	0x0000062c
 800e770:	0801fdd0 	.word	0x0801fdd0
            } else {
              recv_data = cseg->p;
 800e774:	68bb      	ldr	r3, [r7, #8]
 800e776:	685a      	ldr	r2, [r3, #4]
 800e778:	4b9a      	ldr	r3, [pc, #616]	; (800e9e4 <tcp_receive+0xf8c>)
 800e77a:	601a      	str	r2, [r3, #0]
            }
            cseg->p = NULL;
 800e77c:	68bb      	ldr	r3, [r7, #8]
 800e77e:	2200      	movs	r2, #0
 800e780:	605a      	str	r2, [r3, #4]
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 800e782:	68bb      	ldr	r3, [r7, #8]
 800e784:	691b      	ldr	r3, [r3, #16]
 800e786:	7b1a      	ldrb	r2, [r3, #12]
 800e788:	7b5b      	ldrb	r3, [r3, #13]
 800e78a:	021b      	lsls	r3, r3, #8
 800e78c:	4313      	orrs	r3, r2
 800e78e:	b29b      	uxth	r3, r3
 800e790:	0018      	movs	r0, r3
 800e792:	f7f7 fecf 	bl	8006534 <lwip_htons>
 800e796:	0003      	movs	r3, r0
 800e798:	b2db      	uxtb	r3, r3
 800e79a:	001a      	movs	r2, r3
 800e79c:	2301      	movs	r3, #1
 800e79e:	4013      	ands	r3, r2
 800e7a0:	d00d      	beq.n	800e7be <tcp_receive+0xd66>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
 800e7a2:	4b91      	ldr	r3, [pc, #580]	; (800e9e8 <tcp_receive+0xf90>)
 800e7a4:	781b      	ldrb	r3, [r3, #0]
 800e7a6:	2220      	movs	r2, #32
 800e7a8:	4313      	orrs	r3, r2
 800e7aa:	b2da      	uxtb	r2, r3
 800e7ac:	4b8e      	ldr	r3, [pc, #568]	; (800e9e8 <tcp_receive+0xf90>)
 800e7ae:	701a      	strb	r2, [r3, #0]
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
 800e7b0:	687b      	ldr	r3, [r7, #4]
 800e7b2:	7e1b      	ldrb	r3, [r3, #24]
 800e7b4:	2b04      	cmp	r3, #4
 800e7b6:	d102      	bne.n	800e7be <tcp_receive+0xd66>
              pcb->state = CLOSE_WAIT;
 800e7b8:	687b      	ldr	r3, [r7, #4]
 800e7ba:	2207      	movs	r2, #7
 800e7bc:	761a      	strb	r2, [r3, #24]
            }
          }

          pcb->ooseq = cseg->next;
 800e7be:	68bb      	ldr	r3, [r7, #8]
 800e7c0:	681a      	ldr	r2, [r3, #0]
 800e7c2:	687b      	ldr	r3, [r7, #4]
 800e7c4:	679a      	str	r2, [r3, #120]	; 0x78
          tcp_seg_free(cseg);
 800e7c6:	68bb      	ldr	r3, [r7, #8]
 800e7c8:	0018      	movs	r0, r3
 800e7ca:	f7fc ffe5 	bl	800b798 <tcp_seg_free>
        while (pcb->ooseq != NULL &&
 800e7ce:	687b      	ldr	r3, [r7, #4]
 800e7d0:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e7d2:	2b00      	cmp	r3, #0
 800e7d4:	d012      	beq.n	800e7fc <tcp_receive+0xda4>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
 800e7d6:	687b      	ldr	r3, [r7, #4]
 800e7d8:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e7da:	691b      	ldr	r3, [r3, #16]
 800e7dc:	791a      	ldrb	r2, [r3, #4]
 800e7de:	7959      	ldrb	r1, [r3, #5]
 800e7e0:	0209      	lsls	r1, r1, #8
 800e7e2:	430a      	orrs	r2, r1
 800e7e4:	7999      	ldrb	r1, [r3, #6]
 800e7e6:	0409      	lsls	r1, r1, #16
 800e7e8:	430a      	orrs	r2, r1
 800e7ea:	79db      	ldrb	r3, [r3, #7]
 800e7ec:	061b      	lsls	r3, r3, #24
 800e7ee:	4313      	orrs	r3, r2
 800e7f0:	001a      	movs	r2, r3
 800e7f2:	687b      	ldr	r3, [r7, #4]
 800e7f4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
        while (pcb->ooseq != NULL &&
 800e7f6:	429a      	cmp	r2, r3
 800e7f8:	d100      	bne.n	800e7fc <tcp_receive+0xda4>
 800e7fa:	e71e      	b.n	800e63a <tcp_receive+0xbe2>
#endif /* LWIP_TCP_SACK_OUT */
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
 800e7fc:	687b      	ldr	r3, [r7, #4]
 800e7fe:	8bdb      	ldrh	r3, [r3, #30]
 800e800:	001a      	movs	r2, r3
 800e802:	2301      	movs	r3, #1
 800e804:	4013      	ands	r3, r2
 800e806:	d00e      	beq.n	800e826 <tcp_receive+0xdce>
 800e808:	687b      	ldr	r3, [r7, #4]
 800e80a:	8bdb      	ldrh	r3, [r3, #30]
 800e80c:	2201      	movs	r2, #1
 800e80e:	4393      	bics	r3, r2
 800e810:	b29a      	uxth	r2, r3
 800e812:	687b      	ldr	r3, [r7, #4]
 800e814:	83da      	strh	r2, [r3, #30]
 800e816:	687b      	ldr	r3, [r7, #4]
 800e818:	8bdb      	ldrh	r3, [r3, #30]
 800e81a:	2202      	movs	r2, #2
 800e81c:	4313      	orrs	r3, r2
 800e81e:	b29a      	uxth	r2, r3
 800e820:	687b      	ldr	r3, [r7, #4]
 800e822:	83da      	strh	r2, [r3, #30]
      if (pcb->rcv_nxt == seqno) {
 800e824:	e20d      	b.n	800ec42 <tcp_receive+0x11ea>
        tcp_ack(pcb);
 800e826:	687b      	ldr	r3, [r7, #4]
 800e828:	8bdb      	ldrh	r3, [r3, #30]
 800e82a:	2201      	movs	r2, #1
 800e82c:	4313      	orrs	r3, r2
 800e82e:	b29a      	uxth	r2, r3
 800e830:	687b      	ldr	r3, [r7, #4]
 800e832:	83da      	strh	r2, [r3, #30]
      if (pcb->rcv_nxt == seqno) {
 800e834:	e205      	b.n	800ec42 <tcp_receive+0x11ea>
      } else {
        /* We get here if the incoming segment is out-of-sequence. */

#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
 800e836:	687b      	ldr	r3, [r7, #4]
 800e838:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e83a:	2b00      	cmp	r3, #0
 800e83c:	d107      	bne.n	800e84e <tcp_receive+0xdf6>
          pcb->ooseq = tcp_seg_copy(&inseg);
 800e83e:	4b6b      	ldr	r3, [pc, #428]	; (800e9ec <tcp_receive+0xf94>)
 800e840:	0018      	movs	r0, r3
 800e842:	f7fc ffc3 	bl	800b7cc <tcp_seg_copy>
 800e846:	0002      	movs	r2, r0
 800e848:	687b      	ldr	r3, [r7, #4]
 800e84a:	679a      	str	r2, [r3, #120]	; 0x78
 800e84c:	e1ef      	b.n	800ec2e <tcp_receive+0x11d6>
#if LWIP_TCP_SACK_OUT
          /* This is the left edge of the lowest possible SACK range.
             It may start before the newly received segment (possibly adjusted below). */
          u32_t sackbeg = TCP_SEQ_LT(seqno, pcb->ooseq->tcphdr->seqno) ? seqno : pcb->ooseq->tcphdr->seqno;
#endif /* LWIP_TCP_SACK_OUT */
          struct tcp_seg *next, *prev = NULL;
 800e84e:	2300      	movs	r3, #0
 800e850:	637b      	str	r3, [r7, #52]	; 0x34
          for (next = pcb->ooseq; next != NULL; next = next->next) {
 800e852:	687b      	ldr	r3, [r7, #4]
 800e854:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800e856:	63bb      	str	r3, [r7, #56]	; 0x38
 800e858:	e1d9      	b.n	800ec0e <tcp_receive+0x11b6>
            if (seqno == next->tcphdr->seqno) {
 800e85a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e85c:	691b      	ldr	r3, [r3, #16]
 800e85e:	791a      	ldrb	r2, [r3, #4]
 800e860:	7959      	ldrb	r1, [r3, #5]
 800e862:	0209      	lsls	r1, r1, #8
 800e864:	430a      	orrs	r2, r1
 800e866:	7999      	ldrb	r1, [r3, #6]
 800e868:	0409      	lsls	r1, r1, #16
 800e86a:	430a      	orrs	r2, r1
 800e86c:	79db      	ldrb	r3, [r3, #7]
 800e86e:	061b      	lsls	r3, r3, #24
 800e870:	4313      	orrs	r3, r2
 800e872:	001a      	movs	r2, r3
 800e874:	4b5e      	ldr	r3, [pc, #376]	; (800e9f0 <tcp_receive+0xf98>)
 800e876:	681b      	ldr	r3, [r3, #0]
 800e878:	429a      	cmp	r2, r3
 800e87a:	d121      	bne.n	800e8c0 <tcp_receive+0xe68>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
 800e87c:	4b5b      	ldr	r3, [pc, #364]	; (800e9ec <tcp_receive+0xf94>)
 800e87e:	891a      	ldrh	r2, [r3, #8]
 800e880:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e882:	891b      	ldrh	r3, [r3, #8]
 800e884:	429a      	cmp	r2, r3
 800e886:	d800      	bhi.n	800e88a <tcp_receive+0xe32>
 800e888:	e1c6      	b.n	800ec18 <tcp_receive+0x11c0>
                /* The incoming segment is larger than the old
                   segment. We replace some segments with the new
                   one. */
                struct tcp_seg *cseg = tcp_seg_copy(&inseg);
 800e88a:	4b58      	ldr	r3, [pc, #352]	; (800e9ec <tcp_receive+0xf94>)
 800e88c:	0018      	movs	r0, r3
 800e88e:	f7fc ff9d 	bl	800b7cc <tcp_seg_copy>
 800e892:	0003      	movs	r3, r0
 800e894:	617b      	str	r3, [r7, #20]
                if (cseg != NULL) {
 800e896:	697b      	ldr	r3, [r7, #20]
 800e898:	2b00      	cmp	r3, #0
 800e89a:	d100      	bne.n	800e89e <tcp_receive+0xe46>
 800e89c:	e1be      	b.n	800ec1c <tcp_receive+0x11c4>
                  if (prev != NULL) {
 800e89e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e8a0:	2b00      	cmp	r3, #0
 800e8a2:	d003      	beq.n	800e8ac <tcp_receive+0xe54>
                    prev->next = cseg;
 800e8a4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e8a6:	697a      	ldr	r2, [r7, #20]
 800e8a8:	601a      	str	r2, [r3, #0]
 800e8aa:	e002      	b.n	800e8b2 <tcp_receive+0xe5a>
                  } else {
                    pcb->ooseq = cseg;
 800e8ac:	687b      	ldr	r3, [r7, #4]
 800e8ae:	697a      	ldr	r2, [r7, #20]
 800e8b0:	679a      	str	r2, [r3, #120]	; 0x78
                  }
                  tcp_oos_insert_segment(cseg, next);
 800e8b2:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800e8b4:	697b      	ldr	r3, [r7, #20]
 800e8b6:	0011      	movs	r1, r2
 800e8b8:	0018      	movs	r0, r3
 800e8ba:	f7fe ff7d 	bl	800d7b8 <tcp_oos_insert_segment>
                }
                break;
 800e8be:	e1ad      	b.n	800ec1c <tcp_receive+0x11c4>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
 800e8c0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e8c2:	2b00      	cmp	r3, #0
 800e8c4:	d124      	bne.n	800e910 <tcp_receive+0xeb8>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
 800e8c6:	4b4a      	ldr	r3, [pc, #296]	; (800e9f0 <tcp_receive+0xf98>)
 800e8c8:	681a      	ldr	r2, [r3, #0]
 800e8ca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e8cc:	691b      	ldr	r3, [r3, #16]
 800e8ce:	7919      	ldrb	r1, [r3, #4]
 800e8d0:	7958      	ldrb	r0, [r3, #5]
 800e8d2:	0200      	lsls	r0, r0, #8
 800e8d4:	4301      	orrs	r1, r0
 800e8d6:	7998      	ldrb	r0, [r3, #6]
 800e8d8:	0400      	lsls	r0, r0, #16
 800e8da:	4301      	orrs	r1, r0
 800e8dc:	79db      	ldrb	r3, [r3, #7]
 800e8de:	061b      	lsls	r3, r3, #24
 800e8e0:	430b      	orrs	r3, r1
 800e8e2:	1ad3      	subs	r3, r2, r3
 800e8e4:	d400      	bmi.n	800e8e8 <tcp_receive+0xe90>
 800e8e6:	e085      	b.n	800e9f4 <tcp_receive+0xf9c>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */
                  struct tcp_seg *cseg = tcp_seg_copy(&inseg);
 800e8e8:	4b40      	ldr	r3, [pc, #256]	; (800e9ec <tcp_receive+0xf94>)
 800e8ea:	0018      	movs	r0, r3
 800e8ec:	f7fc ff6e 	bl	800b7cc <tcp_seg_copy>
 800e8f0:	0003      	movs	r3, r0
 800e8f2:	61bb      	str	r3, [r7, #24]
                  if (cseg != NULL) {
 800e8f4:	69bb      	ldr	r3, [r7, #24]
 800e8f6:	2b00      	cmp	r3, #0
 800e8f8:	d100      	bne.n	800e8fc <tcp_receive+0xea4>
 800e8fa:	e191      	b.n	800ec20 <tcp_receive+0x11c8>
                    pcb->ooseq = cseg;
 800e8fc:	687b      	ldr	r3, [r7, #4]
 800e8fe:	69ba      	ldr	r2, [r7, #24]
 800e900:	679a      	str	r2, [r3, #120]	; 0x78
                    tcp_oos_insert_segment(cseg, next);
 800e902:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800e904:	69bb      	ldr	r3, [r7, #24]
 800e906:	0011      	movs	r1, r2
 800e908:	0018      	movs	r0, r3
 800e90a:	f7fe ff55 	bl	800d7b8 <tcp_oos_insert_segment>
                  }
                  break;
 800e90e:	e187      	b.n	800ec20 <tcp_receive+0x11c8>
                }
              } else {
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno + 1, next->tcphdr->seqno - 1)) {
 800e910:	4b37      	ldr	r3, [pc, #220]	; (800e9f0 <tcp_receive+0xf98>)
 800e912:	681a      	ldr	r2, [r3, #0]
 800e914:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e916:	691b      	ldr	r3, [r3, #16]
 800e918:	7919      	ldrb	r1, [r3, #4]
 800e91a:	7958      	ldrb	r0, [r3, #5]
 800e91c:	0200      	lsls	r0, r0, #8
 800e91e:	4301      	orrs	r1, r0
 800e920:	7998      	ldrb	r0, [r3, #6]
 800e922:	0400      	lsls	r0, r0, #16
 800e924:	4301      	orrs	r1, r0
 800e926:	79db      	ldrb	r3, [r3, #7]
 800e928:	061b      	lsls	r3, r3, #24
 800e92a:	430b      	orrs	r3, r1
 800e92c:	1ad3      	subs	r3, r2, r3
 800e92e:	3b01      	subs	r3, #1
 800e930:	2b00      	cmp	r3, #0
 800e932:	db5f      	blt.n	800e9f4 <tcp_receive+0xf9c>
 800e934:	4b2e      	ldr	r3, [pc, #184]	; (800e9f0 <tcp_receive+0xf98>)
 800e936:	681a      	ldr	r2, [r3, #0]
 800e938:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e93a:	691b      	ldr	r3, [r3, #16]
 800e93c:	7919      	ldrb	r1, [r3, #4]
 800e93e:	7958      	ldrb	r0, [r3, #5]
 800e940:	0200      	lsls	r0, r0, #8
 800e942:	4301      	orrs	r1, r0
 800e944:	7998      	ldrb	r0, [r3, #6]
 800e946:	0400      	lsls	r0, r0, #16
 800e948:	4301      	orrs	r1, r0
 800e94a:	79db      	ldrb	r3, [r3, #7]
 800e94c:	061b      	lsls	r3, r3, #24
 800e94e:	430b      	orrs	r3, r1
 800e950:	1ad3      	subs	r3, r2, r3
 800e952:	3301      	adds	r3, #1
 800e954:	2b00      	cmp	r3, #0
 800e956:	dc4d      	bgt.n	800e9f4 <tcp_receive+0xf9c>
                  /* The sequence number of the incoming segment is in
                     between the sequence numbers of the previous and
                     the next segment on ->ooseq. We trim trim the previous
                     segment, delete next segments that included in received segment
                     and trim received, if needed. */
                  struct tcp_seg *cseg = tcp_seg_copy(&inseg);
 800e958:	4b24      	ldr	r3, [pc, #144]	; (800e9ec <tcp_receive+0xf94>)
 800e95a:	0018      	movs	r0, r3
 800e95c:	f7fc ff36 	bl	800b7cc <tcp_seg_copy>
 800e960:	0003      	movs	r3, r0
 800e962:	61fb      	str	r3, [r7, #28]
                  if (cseg != NULL) {
 800e964:	69fb      	ldr	r3, [r7, #28]
 800e966:	2b00      	cmp	r3, #0
 800e968:	d100      	bne.n	800e96c <tcp_receive+0xf14>
 800e96a:	e15b      	b.n	800ec24 <tcp_receive+0x11cc>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
 800e96c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e96e:	691b      	ldr	r3, [r3, #16]
 800e970:	791a      	ldrb	r2, [r3, #4]
 800e972:	7959      	ldrb	r1, [r3, #5]
 800e974:	0209      	lsls	r1, r1, #8
 800e976:	430a      	orrs	r2, r1
 800e978:	7999      	ldrb	r1, [r3, #6]
 800e97a:	0409      	lsls	r1, r1, #16
 800e97c:	430a      	orrs	r2, r1
 800e97e:	79db      	ldrb	r3, [r3, #7]
 800e980:	061b      	lsls	r3, r3, #24
 800e982:	4313      	orrs	r3, r2
 800e984:	001a      	movs	r2, r3
 800e986:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e988:	891b      	ldrh	r3, [r3, #8]
 800e98a:	18d2      	adds	r2, r2, r3
 800e98c:	4b18      	ldr	r3, [pc, #96]	; (800e9f0 <tcp_receive+0xf98>)
 800e98e:	681b      	ldr	r3, [r3, #0]
 800e990:	1ad3      	subs	r3, r2, r3
 800e992:	2b00      	cmp	r3, #0
 800e994:	dd1b      	ble.n	800e9ce <tcp_receive+0xf76>
                      /* We need to trim the prev segment. */
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
 800e996:	4b16      	ldr	r3, [pc, #88]	; (800e9f0 <tcp_receive+0xf98>)
 800e998:	681b      	ldr	r3, [r3, #0]
 800e99a:	b29a      	uxth	r2, r3
 800e99c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e99e:	691b      	ldr	r3, [r3, #16]
 800e9a0:	7919      	ldrb	r1, [r3, #4]
 800e9a2:	7958      	ldrb	r0, [r3, #5]
 800e9a4:	0200      	lsls	r0, r0, #8
 800e9a6:	4301      	orrs	r1, r0
 800e9a8:	7998      	ldrb	r0, [r3, #6]
 800e9aa:	0400      	lsls	r0, r0, #16
 800e9ac:	4301      	orrs	r1, r0
 800e9ae:	79db      	ldrb	r3, [r3, #7]
 800e9b0:	061b      	lsls	r3, r3, #24
 800e9b2:	430b      	orrs	r3, r1
 800e9b4:	b29b      	uxth	r3, r3
 800e9b6:	1ad3      	subs	r3, r2, r3
 800e9b8:	b29a      	uxth	r2, r3
 800e9ba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e9bc:	811a      	strh	r2, [r3, #8]
                      pbuf_realloc(prev->p, prev->len);
 800e9be:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e9c0:	685a      	ldr	r2, [r3, #4]
 800e9c2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e9c4:	891b      	ldrh	r3, [r3, #8]
 800e9c6:	0019      	movs	r1, r3
 800e9c8:	0010      	movs	r0, r2
 800e9ca:	f7fa fc69 	bl	80092a0 <pbuf_realloc>
                    }
                    prev->next = cseg;
 800e9ce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e9d0:	69fa      	ldr	r2, [r7, #28]
 800e9d2:	601a      	str	r2, [r3, #0]
                    tcp_oos_insert_segment(cseg, next);
 800e9d4:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800e9d6:	69fb      	ldr	r3, [r7, #28]
 800e9d8:	0011      	movs	r1, r2
 800e9da:	0018      	movs	r0, r3
 800e9dc:	f7fe feec 	bl	800d7b8 <tcp_oos_insert_segment>
                  }
                  break;
 800e9e0:	e120      	b.n	800ec24 <tcp_receive+0x11cc>
 800e9e2:	46c0      	nop			; (mov r8, r8)
 800e9e4:	20001390 	.word	0x20001390
 800e9e8:	2000138d 	.word	0x2000138d
 800e9ec:	2000135c 	.word	0x2000135c
 800e9f0:	20001380 	.word	0x20001380
#endif /* LWIP_TCP_SACK_OUT */

              /* We don't use 'prev' below, so let's set it to current 'next'.
                 This way even if we break the loop below, 'prev' will be pointing
                 at the segment right in front of the newly added one. */
              prev = next;
 800e9f4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e9f6:	637b      	str	r3, [r7, #52]	; 0x34

              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
 800e9f8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e9fa:	681b      	ldr	r3, [r3, #0]
 800e9fc:	2b00      	cmp	r3, #0
 800e9fe:	d000      	beq.n	800ea02 <tcp_receive+0xfaa>
 800ea00:	e102      	b.n	800ec08 <tcp_receive+0x11b0>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
 800ea02:	4b9f      	ldr	r3, [pc, #636]	; (800ec80 <tcp_receive+0x1228>)
 800ea04:	681a      	ldr	r2, [r3, #0]
 800ea06:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ea08:	691b      	ldr	r3, [r3, #16]
 800ea0a:	7919      	ldrb	r1, [r3, #4]
 800ea0c:	7958      	ldrb	r0, [r3, #5]
 800ea0e:	0200      	lsls	r0, r0, #8
 800ea10:	4301      	orrs	r1, r0
 800ea12:	7998      	ldrb	r0, [r3, #6]
 800ea14:	0400      	lsls	r0, r0, #16
 800ea16:	4301      	orrs	r1, r0
 800ea18:	79db      	ldrb	r3, [r3, #7]
 800ea1a:	061b      	lsls	r3, r3, #24
 800ea1c:	430b      	orrs	r3, r1
 800ea1e:	1ad3      	subs	r3, r2, r3
              if (next->next == NULL &&
 800ea20:	2b00      	cmp	r3, #0
 800ea22:	dc00      	bgt.n	800ea26 <tcp_receive+0xfce>
 800ea24:	e0f0      	b.n	800ec08 <tcp_receive+0x11b0>
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 800ea26:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ea28:	691b      	ldr	r3, [r3, #16]
 800ea2a:	7b1a      	ldrb	r2, [r3, #12]
 800ea2c:	7b5b      	ldrb	r3, [r3, #13]
 800ea2e:	021b      	lsls	r3, r3, #8
 800ea30:	4313      	orrs	r3, r2
 800ea32:	b29b      	uxth	r3, r3
 800ea34:	0018      	movs	r0, r3
 800ea36:	f7f7 fd7d 	bl	8006534 <lwip_htons>
 800ea3a:	0003      	movs	r3, r0
 800ea3c:	b2db      	uxtb	r3, r3
 800ea3e:	001a      	movs	r2, r3
 800ea40:	2301      	movs	r3, #1
 800ea42:	4013      	ands	r3, r2
 800ea44:	d000      	beq.n	800ea48 <tcp_receive+0xff0>
 800ea46:	e0ef      	b.n	800ec28 <tcp_receive+0x11d0>
                  /* segment "next" already contains all data */
                  break;
                }
                next->next = tcp_seg_copy(&inseg);
 800ea48:	4b8e      	ldr	r3, [pc, #568]	; (800ec84 <tcp_receive+0x122c>)
 800ea4a:	0018      	movs	r0, r3
 800ea4c:	f7fc febe 	bl	800b7cc <tcp_seg_copy>
 800ea50:	0002      	movs	r2, r0
 800ea52:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ea54:	601a      	str	r2, [r3, #0]
                if (next->next != NULL) {
 800ea56:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ea58:	681b      	ldr	r3, [r3, #0]
 800ea5a:	2b00      	cmp	r3, #0
 800ea5c:	d100      	bne.n	800ea60 <tcp_receive+0x1008>
 800ea5e:	e0e5      	b.n	800ec2c <tcp_receive+0x11d4>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
 800ea60:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ea62:	691b      	ldr	r3, [r3, #16]
 800ea64:	791a      	ldrb	r2, [r3, #4]
 800ea66:	7959      	ldrb	r1, [r3, #5]
 800ea68:	0209      	lsls	r1, r1, #8
 800ea6a:	430a      	orrs	r2, r1
 800ea6c:	7999      	ldrb	r1, [r3, #6]
 800ea6e:	0409      	lsls	r1, r1, #16
 800ea70:	430a      	orrs	r2, r1
 800ea72:	79db      	ldrb	r3, [r3, #7]
 800ea74:	061b      	lsls	r3, r3, #24
 800ea76:	4313      	orrs	r3, r2
 800ea78:	001a      	movs	r2, r3
 800ea7a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ea7c:	891b      	ldrh	r3, [r3, #8]
 800ea7e:	18d2      	adds	r2, r2, r3
 800ea80:	4b7f      	ldr	r3, [pc, #508]	; (800ec80 <tcp_receive+0x1228>)
 800ea82:	681b      	ldr	r3, [r3, #0]
 800ea84:	1ad3      	subs	r3, r2, r3
 800ea86:	2b00      	cmp	r3, #0
 800ea88:	dd1b      	ble.n	800eac2 <tcp_receive+0x106a>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
 800ea8a:	4b7d      	ldr	r3, [pc, #500]	; (800ec80 <tcp_receive+0x1228>)
 800ea8c:	681b      	ldr	r3, [r3, #0]
 800ea8e:	b29a      	uxth	r2, r3
 800ea90:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ea92:	691b      	ldr	r3, [r3, #16]
 800ea94:	7919      	ldrb	r1, [r3, #4]
 800ea96:	7958      	ldrb	r0, [r3, #5]
 800ea98:	0200      	lsls	r0, r0, #8
 800ea9a:	4301      	orrs	r1, r0
 800ea9c:	7998      	ldrb	r0, [r3, #6]
 800ea9e:	0400      	lsls	r0, r0, #16
 800eaa0:	4301      	orrs	r1, r0
 800eaa2:	79db      	ldrb	r3, [r3, #7]
 800eaa4:	061b      	lsls	r3, r3, #24
 800eaa6:	430b      	orrs	r3, r1
 800eaa8:	b29b      	uxth	r3, r3
 800eaaa:	1ad3      	subs	r3, r2, r3
 800eaac:	b29a      	uxth	r2, r3
 800eaae:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800eab0:	811a      	strh	r2, [r3, #8]
                    pbuf_realloc(next->p, next->len);
 800eab2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800eab4:	685a      	ldr	r2, [r3, #4]
 800eab6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800eab8:	891b      	ldrh	r3, [r3, #8]
 800eaba:	0019      	movs	r1, r3
 800eabc:	0010      	movs	r0, r2
 800eabe:	f7fa fbef 	bl	80092a0 <pbuf_realloc>
                  }
                  /* check if the remote side overruns our receive window */
                  if (TCP_SEQ_GT((u32_t)tcplen + seqno, pcb->rcv_nxt + (u32_t)pcb->rcv_wnd)) {
 800eac2:	4b71      	ldr	r3, [pc, #452]	; (800ec88 <tcp_receive+0x1230>)
 800eac4:	881b      	ldrh	r3, [r3, #0]
 800eac6:	001a      	movs	r2, r3
 800eac8:	4b6d      	ldr	r3, [pc, #436]	; (800ec80 <tcp_receive+0x1228>)
 800eaca:	681b      	ldr	r3, [r3, #0]
 800eacc:	18d2      	adds	r2, r2, r3
 800eace:	687b      	ldr	r3, [r7, #4]
 800ead0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ead2:	6879      	ldr	r1, [r7, #4]
 800ead4:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800ead6:	185b      	adds	r3, r3, r1
 800ead8:	1ad3      	subs	r3, r2, r3
 800eada:	2b00      	cmp	r3, #0
 800eadc:	dc00      	bgt.n	800eae0 <tcp_receive+0x1088>
 800eade:	e0a5      	b.n	800ec2c <tcp_receive+0x11d4>
                    LWIP_DEBUGF(TCP_INPUT_DEBUG,
                                ("tcp_receive: other end overran receive window"
                                 "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                                 seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
 800eae0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800eae2:	681b      	ldr	r3, [r3, #0]
 800eae4:	691b      	ldr	r3, [r3, #16]
 800eae6:	7b1a      	ldrb	r2, [r3, #12]
 800eae8:	7b5b      	ldrb	r3, [r3, #13]
 800eaea:	021b      	lsls	r3, r3, #8
 800eaec:	4313      	orrs	r3, r2
 800eaee:	b29b      	uxth	r3, r3
 800eaf0:	0018      	movs	r0, r3
 800eaf2:	f7f7 fd1f 	bl	8006534 <lwip_htons>
 800eaf6:	0003      	movs	r3, r0
 800eaf8:	b2db      	uxtb	r3, r3
 800eafa:	001a      	movs	r2, r3
 800eafc:	2301      	movs	r3, #1
 800eafe:	4013      	ands	r3, r2
 800eb00:	d03a      	beq.n	800eb78 <tcp_receive+0x1120>
                      /* Must remove the FIN from the header as we're trimming
                       * that byte of sequence-space from the packet */
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) & ~TCP_FIN);
 800eb02:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800eb04:	681b      	ldr	r3, [r3, #0]
 800eb06:	691b      	ldr	r3, [r3, #16]
 800eb08:	7b1a      	ldrb	r2, [r3, #12]
 800eb0a:	7b5b      	ldrb	r3, [r3, #13]
 800eb0c:	021b      	lsls	r3, r3, #8
 800eb0e:	4313      	orrs	r3, r2
 800eb10:	b29b      	uxth	r3, r3
 800eb12:	b21b      	sxth	r3, r3
 800eb14:	4a5d      	ldr	r2, [pc, #372]	; (800ec8c <tcp_receive+0x1234>)
 800eb16:	4013      	ands	r3, r2
 800eb18:	b21c      	sxth	r4, r3
 800eb1a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800eb1c:	681b      	ldr	r3, [r3, #0]
 800eb1e:	691b      	ldr	r3, [r3, #16]
 800eb20:	7b1a      	ldrb	r2, [r3, #12]
 800eb22:	7b5b      	ldrb	r3, [r3, #13]
 800eb24:	021b      	lsls	r3, r3, #8
 800eb26:	4313      	orrs	r3, r2
 800eb28:	b29b      	uxth	r3, r3
 800eb2a:	0018      	movs	r0, r3
 800eb2c:	f7f7 fd02 	bl	8006534 <lwip_htons>
 800eb30:	0003      	movs	r3, r0
 800eb32:	b2db      	uxtb	r3, r3
 800eb34:	b29b      	uxth	r3, r3
 800eb36:	223e      	movs	r2, #62	; 0x3e
 800eb38:	4013      	ands	r3, r2
 800eb3a:	b29b      	uxth	r3, r3
 800eb3c:	0018      	movs	r0, r3
 800eb3e:	f7f7 fcf9 	bl	8006534 <lwip_htons>
 800eb42:	0003      	movs	r3, r0
 800eb44:	b21b      	sxth	r3, r3
 800eb46:	4323      	orrs	r3, r4
 800eb48:	b21a      	sxth	r2, r3
 800eb4a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800eb4c:	681b      	ldr	r3, [r3, #0]
 800eb4e:	691b      	ldr	r3, [r3, #16]
 800eb50:	b292      	uxth	r2, r2
 800eb52:	21ff      	movs	r1, #255	; 0xff
 800eb54:	4011      	ands	r1, r2
 800eb56:	000c      	movs	r4, r1
 800eb58:	7b19      	ldrb	r1, [r3, #12]
 800eb5a:	2000      	movs	r0, #0
 800eb5c:	4001      	ands	r1, r0
 800eb5e:	1c08      	adds	r0, r1, #0
 800eb60:	1c21      	adds	r1, r4, #0
 800eb62:	4301      	orrs	r1, r0
 800eb64:	7319      	strb	r1, [r3, #12]
 800eb66:	0a12      	lsrs	r2, r2, #8
 800eb68:	b290      	uxth	r0, r2
 800eb6a:	7b5a      	ldrb	r2, [r3, #13]
 800eb6c:	2100      	movs	r1, #0
 800eb6e:	400a      	ands	r2, r1
 800eb70:	1c11      	adds	r1, r2, #0
 800eb72:	1c02      	adds	r2, r0, #0
 800eb74:	430a      	orrs	r2, r1
 800eb76:	735a      	strb	r2, [r3, #13]
                    }
                    /* Adjust length of segment to fit in the window. */
                    next->next->len = (u16_t)(pcb->rcv_nxt + pcb->rcv_wnd - seqno);
 800eb78:	687b      	ldr	r3, [r7, #4]
 800eb7a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800eb7c:	b29a      	uxth	r2, r3
 800eb7e:	687b      	ldr	r3, [r7, #4]
 800eb80:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 800eb82:	18d3      	adds	r3, r2, r3
 800eb84:	b299      	uxth	r1, r3
 800eb86:	4b3e      	ldr	r3, [pc, #248]	; (800ec80 <tcp_receive+0x1228>)
 800eb88:	681b      	ldr	r3, [r3, #0]
 800eb8a:	b29a      	uxth	r2, r3
 800eb8c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800eb8e:	681b      	ldr	r3, [r3, #0]
 800eb90:	1a8a      	subs	r2, r1, r2
 800eb92:	b292      	uxth	r2, r2
 800eb94:	811a      	strh	r2, [r3, #8]
                    pbuf_realloc(next->next->p, next->next->len);
 800eb96:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800eb98:	681b      	ldr	r3, [r3, #0]
 800eb9a:	685a      	ldr	r2, [r3, #4]
 800eb9c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800eb9e:	681b      	ldr	r3, [r3, #0]
 800eba0:	891b      	ldrh	r3, [r3, #8]
 800eba2:	0019      	movs	r1, r3
 800eba4:	0010      	movs	r0, r2
 800eba6:	f7fa fb7b 	bl	80092a0 <pbuf_realloc>
                    tcplen = TCP_TCPLEN(next->next);
 800ebaa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ebac:	681b      	ldr	r3, [r3, #0]
 800ebae:	891c      	ldrh	r4, [r3, #8]
 800ebb0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ebb2:	681b      	ldr	r3, [r3, #0]
 800ebb4:	691b      	ldr	r3, [r3, #16]
 800ebb6:	7b1a      	ldrb	r2, [r3, #12]
 800ebb8:	7b5b      	ldrb	r3, [r3, #13]
 800ebba:	021b      	lsls	r3, r3, #8
 800ebbc:	4313      	orrs	r3, r2
 800ebbe:	b29b      	uxth	r3, r3
 800ebc0:	0018      	movs	r0, r3
 800ebc2:	f7f7 fcb7 	bl	8006534 <lwip_htons>
 800ebc6:	0003      	movs	r3, r0
 800ebc8:	b2db      	uxtb	r3, r3
 800ebca:	001a      	movs	r2, r3
 800ebcc:	2303      	movs	r3, #3
 800ebce:	4013      	ands	r3, r2
 800ebd0:	d001      	beq.n	800ebd6 <tcp_receive+0x117e>
 800ebd2:	2301      	movs	r3, #1
 800ebd4:	e000      	b.n	800ebd8 <tcp_receive+0x1180>
 800ebd6:	2300      	movs	r3, #0
 800ebd8:	191b      	adds	r3, r3, r4
 800ebda:	b29a      	uxth	r2, r3
 800ebdc:	4b2a      	ldr	r3, [pc, #168]	; (800ec88 <tcp_receive+0x1230>)
 800ebde:	801a      	strh	r2, [r3, #0]
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 800ebe0:	4b29      	ldr	r3, [pc, #164]	; (800ec88 <tcp_receive+0x1230>)
 800ebe2:	881b      	ldrh	r3, [r3, #0]
 800ebe4:	001a      	movs	r2, r3
 800ebe6:	4b26      	ldr	r3, [pc, #152]	; (800ec80 <tcp_receive+0x1228>)
 800ebe8:	681b      	ldr	r3, [r3, #0]
 800ebea:	18d2      	adds	r2, r2, r3
 800ebec:	687b      	ldr	r3, [r7, #4]
 800ebee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ebf0:	6879      	ldr	r1, [r7, #4]
 800ebf2:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800ebf4:	185b      	adds	r3, r3, r1
 800ebf6:	429a      	cmp	r2, r3
 800ebf8:	d018      	beq.n	800ec2c <tcp_receive+0x11d4>
 800ebfa:	4b25      	ldr	r3, [pc, #148]	; (800ec90 <tcp_receive+0x1238>)
 800ebfc:	4a25      	ldr	r2, [pc, #148]	; (800ec94 <tcp_receive+0x123c>)
 800ebfe:	4926      	ldr	r1, [pc, #152]	; (800ec98 <tcp_receive+0x1240>)
 800ec00:	4826      	ldr	r0, [pc, #152]	; (800ec9c <tcp_receive+0x1244>)
 800ec02:	f7f3 fae3 	bl	80021cc <app_debug_rtt_raw>
                                (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
                  }
                }
                break;
 800ec06:	e011      	b.n	800ec2c <tcp_receive+0x11d4>
          for (next = pcb->ooseq; next != NULL; next = next->next) {
 800ec08:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ec0a:	681b      	ldr	r3, [r3, #0]
 800ec0c:	63bb      	str	r3, [r7, #56]	; 0x38
 800ec0e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ec10:	2b00      	cmp	r3, #0
 800ec12:	d000      	beq.n	800ec16 <tcp_receive+0x11be>
 800ec14:	e621      	b.n	800e85a <tcp_receive+0xe02>
 800ec16:	e00a      	b.n	800ec2e <tcp_receive+0x11d6>
                break;
 800ec18:	46c0      	nop			; (mov r8, r8)
 800ec1a:	e008      	b.n	800ec2e <tcp_receive+0x11d6>
                break;
 800ec1c:	46c0      	nop			; (mov r8, r8)
 800ec1e:	e006      	b.n	800ec2e <tcp_receive+0x11d6>
                  break;
 800ec20:	46c0      	nop			; (mov r8, r8)
 800ec22:	e004      	b.n	800ec2e <tcp_receive+0x11d6>
                  break;
 800ec24:	46c0      	nop			; (mov r8, r8)
 800ec26:	e002      	b.n	800ec2e <tcp_receive+0x11d6>
                  break;
 800ec28:	46c0      	nop			; (mov r8, r8)
 800ec2a:	e000      	b.n	800ec2e <tcp_receive+0x11d6>
                break;
 800ec2c:	46c0      	nop			; (mov r8, r8)
#endif /* TCP_OOSEQ_BYTES_LIMIT || TCP_OOSEQ_PBUFS_LIMIT */
#endif /* TCP_QUEUE_OOSEQ */

        /* We send the ACK packet after we've (potentially) dealt with SACKs,
           so they can be included in the acknowledgment. */
        tcp_send_empty_ack(pcb);
 800ec2e:	687b      	ldr	r3, [r7, #4]
 800ec30:	0018      	movs	r0, r3
 800ec32:	f002 fd59 	bl	80116e8 <tcp_send_empty_ack>
      if (pcb->rcv_nxt == seqno) {
 800ec36:	e004      	b.n	800ec42 <tcp_receive+0x11ea>
      }
    } else {
      /* The incoming segment is not within the window. */
      tcp_send_empty_ack(pcb);
 800ec38:	687b      	ldr	r3, [r7, #4]
 800ec3a:	0018      	movs	r0, r3
 800ec3c:	f002 fd54 	bl	80116e8 <tcp_send_empty_ack>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 800ec40:	e019      	b.n	800ec76 <tcp_receive+0x121e>
 800ec42:	e018      	b.n	800ec76 <tcp_receive+0x121e>
    }
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
 800ec44:	4b0e      	ldr	r3, [pc, #56]	; (800ec80 <tcp_receive+0x1228>)
 800ec46:	681a      	ldr	r2, [r3, #0]
 800ec48:	687b      	ldr	r3, [r7, #4]
 800ec4a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ec4c:	1ad3      	subs	r3, r2, r3
 800ec4e:	d40a      	bmi.n	800ec66 <tcp_receive+0x120e>
 800ec50:	4b0b      	ldr	r3, [pc, #44]	; (800ec80 <tcp_receive+0x1228>)
 800ec52:	681a      	ldr	r2, [r3, #0]
 800ec54:	687b      	ldr	r3, [r7, #4]
 800ec56:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ec58:	6879      	ldr	r1, [r7, #4]
 800ec5a:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
 800ec5c:	185b      	adds	r3, r3, r1
 800ec5e:	1ad3      	subs	r3, r2, r3
 800ec60:	3301      	adds	r3, #1
 800ec62:	2b00      	cmp	r3, #0
 800ec64:	dd07      	ble.n	800ec76 <tcp_receive+0x121e>
      tcp_ack_now(pcb);
 800ec66:	687b      	ldr	r3, [r7, #4]
 800ec68:	8bdb      	ldrh	r3, [r3, #30]
 800ec6a:	2202      	movs	r2, #2
 800ec6c:	4313      	orrs	r3, r2
 800ec6e:	b29a      	uxth	r2, r3
 800ec70:	687b      	ldr	r3, [r7, #4]
 800ec72:	83da      	strh	r2, [r3, #30]
    }
  }
}
 800ec74:	e7ff      	b.n	800ec76 <tcp_receive+0x121e>
 800ec76:	46c0      	nop			; (mov r8, r8)
 800ec78:	46bd      	mov	sp, r7
 800ec7a:	b014      	add	sp, #80	; 0x50
 800ec7c:	bdb0      	pop	{r4, r5, r7, pc}
 800ec7e:	46c0      	nop			; (mov r8, r8)
 800ec80:	20001380 	.word	0x20001380
 800ec84:	2000135c 	.word	0x2000135c
 800ec88:	2000138a 	.word	0x2000138a
 800ec8c:	ffffc0ff 	.word	0xffffc0ff
 800ec90:	0801f99c 	.word	0x0801f99c
 800ec94:	000006f9 	.word	0x000006f9
 800ec98:	0801fd3c 	.word	0x0801fd3c
 800ec9c:	0801f9dc 	.word	0x0801f9dc

0800eca0 <tcp_get_next_optbyte>:

static u8_t
tcp_get_next_optbyte(void)
{
 800eca0:	b580      	push	{r7, lr}
 800eca2:	b082      	sub	sp, #8
 800eca4:	af00      	add	r7, sp, #0
  u16_t optidx = tcp_optidx++;
 800eca6:	4b17      	ldr	r3, [pc, #92]	; (800ed04 <tcp_get_next_optbyte+0x64>)
 800eca8:	881b      	ldrh	r3, [r3, #0]
 800ecaa:	1c5a      	adds	r2, r3, #1
 800ecac:	b291      	uxth	r1, r2
 800ecae:	4a15      	ldr	r2, [pc, #84]	; (800ed04 <tcp_get_next_optbyte+0x64>)
 800ecb0:	8011      	strh	r1, [r2, #0]
 800ecb2:	1dba      	adds	r2, r7, #6
 800ecb4:	8013      	strh	r3, [r2, #0]
  if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
 800ecb6:	4b14      	ldr	r3, [pc, #80]	; (800ed08 <tcp_get_next_optbyte+0x68>)
 800ecb8:	681b      	ldr	r3, [r3, #0]
 800ecba:	2b00      	cmp	r3, #0
 800ecbc:	d005      	beq.n	800ecca <tcp_get_next_optbyte+0x2a>
 800ecbe:	4b13      	ldr	r3, [pc, #76]	; (800ed0c <tcp_get_next_optbyte+0x6c>)
 800ecc0:	881b      	ldrh	r3, [r3, #0]
 800ecc2:	1dba      	adds	r2, r7, #6
 800ecc4:	8812      	ldrh	r2, [r2, #0]
 800ecc6:	429a      	cmp	r2, r3
 800ecc8:	d209      	bcs.n	800ecde <tcp_get_next_optbyte+0x3e>
    u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
 800ecca:	4b11      	ldr	r3, [pc, #68]	; (800ed10 <tcp_get_next_optbyte+0x70>)
 800eccc:	681b      	ldr	r3, [r3, #0]
 800ecce:	3314      	adds	r3, #20
 800ecd0:	603b      	str	r3, [r7, #0]
    return opts[optidx];
 800ecd2:	1dbb      	adds	r3, r7, #6
 800ecd4:	881b      	ldrh	r3, [r3, #0]
 800ecd6:	683a      	ldr	r2, [r7, #0]
 800ecd8:	18d3      	adds	r3, r2, r3
 800ecda:	781b      	ldrb	r3, [r3, #0]
 800ecdc:	e00e      	b.n	800ecfc <tcp_get_next_optbyte+0x5c>
  } else {
    u8_t idx = (u8_t)(optidx - tcphdr_opt1len);
 800ecde:	1dbb      	adds	r3, r7, #6
 800ece0:	881b      	ldrh	r3, [r3, #0]
 800ece2:	b2d9      	uxtb	r1, r3
 800ece4:	4b09      	ldr	r3, [pc, #36]	; (800ed0c <tcp_get_next_optbyte+0x6c>)
 800ece6:	881b      	ldrh	r3, [r3, #0]
 800ece8:	b2da      	uxtb	r2, r3
 800ecea:	1d7b      	adds	r3, r7, #5
 800ecec:	1a8a      	subs	r2, r1, r2
 800ecee:	701a      	strb	r2, [r3, #0]
    return tcphdr_opt2[idx];
 800ecf0:	4b05      	ldr	r3, [pc, #20]	; (800ed08 <tcp_get_next_optbyte+0x68>)
 800ecf2:	681a      	ldr	r2, [r3, #0]
 800ecf4:	1d7b      	adds	r3, r7, #5
 800ecf6:	781b      	ldrb	r3, [r3, #0]
 800ecf8:	18d3      	adds	r3, r2, r3
 800ecfa:	781b      	ldrb	r3, [r3, #0]
  }
}
 800ecfc:	0018      	movs	r0, r3
 800ecfe:	46bd      	mov	sp, r7
 800ed00:	b002      	add	sp, #8
 800ed02:	bd80      	pop	{r7, pc}
 800ed04:	2000137c 	.word	0x2000137c
 800ed08:	20001378 	.word	0x20001378
 800ed0c:	20001376 	.word	0x20001376
 800ed10:	20001370 	.word	0x20001370

0800ed14 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
 800ed14:	b5b0      	push	{r4, r5, r7, lr}
 800ed16:	b084      	sub	sp, #16
 800ed18:	af00      	add	r7, sp, #0
 800ed1a:	6078      	str	r0, [r7, #4]
  u16_t mss;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  LWIP_ASSERT("tcp_parseopt: invalid pcb", pcb != NULL);
 800ed1c:	687b      	ldr	r3, [r7, #4]
 800ed1e:	2b00      	cmp	r3, #0
 800ed20:	d105      	bne.n	800ed2e <tcp_parseopt+0x1a>
 800ed22:	4b39      	ldr	r3, [pc, #228]	; (800ee08 <tcp_parseopt+0xf4>)
 800ed24:	4a39      	ldr	r2, [pc, #228]	; (800ee0c <tcp_parseopt+0xf8>)
 800ed26:	493a      	ldr	r1, [pc, #232]	; (800ee10 <tcp_parseopt+0xfc>)
 800ed28:	483a      	ldr	r0, [pc, #232]	; (800ee14 <tcp_parseopt+0x100>)
 800ed2a:	f7f3 fa4f 	bl	80021cc <app_debug_rtt_raw>

  /* Parse the TCP MSS option, if present. */
  if (tcphdr_optlen != 0) {
 800ed2e:	4b3a      	ldr	r3, [pc, #232]	; (800ee18 <tcp_parseopt+0x104>)
 800ed30:	881b      	ldrh	r3, [r3, #0]
 800ed32:	2b00      	cmp	r3, #0
 800ed34:	d100      	bne.n	800ed38 <tcp_parseopt+0x24>
 800ed36:	e064      	b.n	800ee02 <tcp_parseopt+0xee>
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
 800ed38:	4b38      	ldr	r3, [pc, #224]	; (800ee1c <tcp_parseopt+0x108>)
 800ed3a:	2200      	movs	r2, #0
 800ed3c:	801a      	strh	r2, [r3, #0]
 800ed3e:	e054      	b.n	800edea <tcp_parseopt+0xd6>
      u8_t opt = tcp_get_next_optbyte();
 800ed40:	250f      	movs	r5, #15
 800ed42:	197c      	adds	r4, r7, r5
 800ed44:	f7ff ffac 	bl	800eca0 <tcp_get_next_optbyte>
 800ed48:	0003      	movs	r3, r0
 800ed4a:	7023      	strb	r3, [r4, #0]
      switch (opt) {
 800ed4c:	197b      	adds	r3, r7, r5
 800ed4e:	781b      	ldrb	r3, [r3, #0]
 800ed50:	2b02      	cmp	r3, #2
 800ed52:	d005      	beq.n	800ed60 <tcp_parseopt+0x4c>
 800ed54:	dc33      	bgt.n	800edbe <tcp_parseopt+0xaa>
 800ed56:	2b00      	cmp	r3, #0
 800ed58:	d04e      	beq.n	800edf8 <tcp_parseopt+0xe4>
 800ed5a:	2b01      	cmp	r3, #1
 800ed5c:	d12f      	bne.n	800edbe <tcp_parseopt+0xaa>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
          return;
        case LWIP_TCP_OPT_NOP:
          /* NOP option. */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
          break;
 800ed5e:	e044      	b.n	800edea <tcp_parseopt+0xd6>
        case LWIP_TCP_OPT_MSS:
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
          if (tcp_get_next_optbyte() != LWIP_TCP_OPT_LEN_MSS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_MSS) > tcphdr_optlen) {
 800ed60:	f7ff ff9e 	bl	800eca0 <tcp_get_next_optbyte>
 800ed64:	0003      	movs	r3, r0
 800ed66:	2b04      	cmp	r3, #4
 800ed68:	d148      	bne.n	800edfc <tcp_parseopt+0xe8>
 800ed6a:	4b2c      	ldr	r3, [pc, #176]	; (800ee1c <tcp_parseopt+0x108>)
 800ed6c:	881b      	ldrh	r3, [r3, #0]
 800ed6e:	3301      	adds	r3, #1
 800ed70:	4a29      	ldr	r2, [pc, #164]	; (800ee18 <tcp_parseopt+0x104>)
 800ed72:	8812      	ldrh	r2, [r2, #0]
 800ed74:	4293      	cmp	r3, r2
 800ed76:	da41      	bge.n	800edfc <tcp_parseopt+0xe8>
            /* Bad length */
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
            return;
          }
          /* An MSS option with the right option length. */
          mss = (u16_t)(tcp_get_next_optbyte() << 8);
 800ed78:	f7ff ff92 	bl	800eca0 <tcp_get_next_optbyte>
 800ed7c:	0003      	movs	r3, r0
 800ed7e:	b29a      	uxth	r2, r3
 800ed80:	240c      	movs	r4, #12
 800ed82:	193b      	adds	r3, r7, r4
 800ed84:	0212      	lsls	r2, r2, #8
 800ed86:	801a      	strh	r2, [r3, #0]
          mss |= tcp_get_next_optbyte();
 800ed88:	f7ff ff8a 	bl	800eca0 <tcp_get_next_optbyte>
 800ed8c:	0003      	movs	r3, r0
 800ed8e:	b299      	uxth	r1, r3
 800ed90:	193b      	adds	r3, r7, r4
 800ed92:	193a      	adds	r2, r7, r4
 800ed94:	8812      	ldrh	r2, [r2, #0]
 800ed96:	430a      	orrs	r2, r1
 800ed98:	801a      	strh	r2, [r3, #0]
          /* Limit the mss to the configured TCP_MSS and prevent division by zero */
          pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 800ed9a:	193b      	adds	r3, r7, r4
 800ed9c:	881a      	ldrh	r2, [r3, #0]
 800ed9e:	2386      	movs	r3, #134	; 0x86
 800eda0:	009b      	lsls	r3, r3, #2
 800eda2:	429a      	cmp	r2, r3
 800eda4:	d806      	bhi.n	800edb4 <tcp_parseopt+0xa0>
 800eda6:	193b      	adds	r3, r7, r4
 800eda8:	881b      	ldrh	r3, [r3, #0]
 800edaa:	2b00      	cmp	r3, #0
 800edac:	d002      	beq.n	800edb4 <tcp_parseopt+0xa0>
 800edae:	193b      	adds	r3, r7, r4
 800edb0:	881b      	ldrh	r3, [r3, #0]
 800edb2:	e001      	b.n	800edb8 <tcp_parseopt+0xa4>
 800edb4:	2386      	movs	r3, #134	; 0x86
 800edb6:	009b      	lsls	r3, r3, #2
 800edb8:	687a      	ldr	r2, [r7, #4]
 800edba:	86d3      	strh	r3, [r2, #54]	; 0x36
          break;
 800edbc:	e015      	b.n	800edea <tcp_parseopt+0xd6>
          }
          break;
#endif /* LWIP_TCP_SACK_OUT */
        default:
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
          data = tcp_get_next_optbyte();
 800edbe:	250b      	movs	r5, #11
 800edc0:	197c      	adds	r4, r7, r5
 800edc2:	f7ff ff6d 	bl	800eca0 <tcp_get_next_optbyte>
 800edc6:	0003      	movs	r3, r0
 800edc8:	7023      	strb	r3, [r4, #0]
          if (data < 2) {
 800edca:	002a      	movs	r2, r5
 800edcc:	18bb      	adds	r3, r7, r2
 800edce:	781b      	ldrb	r3, [r3, #0]
 800edd0:	2b01      	cmp	r3, #1
 800edd2:	d915      	bls.n	800ee00 <tcp_parseopt+0xec>
               and we don't process them further. */
            return;
          }
          /* All other options have a length field, so that we easily
             can skip past them. */
          tcp_optidx += data - 2;
 800edd4:	18bb      	adds	r3, r7, r2
 800edd6:	781b      	ldrb	r3, [r3, #0]
 800edd8:	b29a      	uxth	r2, r3
 800edda:	4b10      	ldr	r3, [pc, #64]	; (800ee1c <tcp_parseopt+0x108>)
 800eddc:	881b      	ldrh	r3, [r3, #0]
 800edde:	18d3      	adds	r3, r2, r3
 800ede0:	b29b      	uxth	r3, r3
 800ede2:	3b02      	subs	r3, #2
 800ede4:	b29a      	uxth	r2, r3
 800ede6:	4b0d      	ldr	r3, [pc, #52]	; (800ee1c <tcp_parseopt+0x108>)
 800ede8:	801a      	strh	r2, [r3, #0]
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
 800edea:	4b0c      	ldr	r3, [pc, #48]	; (800ee1c <tcp_parseopt+0x108>)
 800edec:	881a      	ldrh	r2, [r3, #0]
 800edee:	4b0a      	ldr	r3, [pc, #40]	; (800ee18 <tcp_parseopt+0x104>)
 800edf0:	881b      	ldrh	r3, [r3, #0]
 800edf2:	429a      	cmp	r2, r3
 800edf4:	d3a4      	bcc.n	800ed40 <tcp_parseopt+0x2c>
 800edf6:	e004      	b.n	800ee02 <tcp_parseopt+0xee>
          return;
 800edf8:	46c0      	nop			; (mov r8, r8)
 800edfa:	e002      	b.n	800ee02 <tcp_parseopt+0xee>
            return;
 800edfc:	46c0      	nop			; (mov r8, r8)
 800edfe:	e000      	b.n	800ee02 <tcp_parseopt+0xee>
            return;
 800ee00:	46c0      	nop			; (mov r8, r8)
      }
    }
  }
}
 800ee02:	46bd      	mov	sp, r7
 800ee04:	b004      	add	sp, #16
 800ee06:	bdb0      	pop	{r4, r5, r7, pc}
 800ee08:	0801f99c 	.word	0x0801f99c
 800ee0c:	0000077e 	.word	0x0000077e
 800ee10:	0801fdf8 	.word	0x0801fdf8
 800ee14:	0801f9dc 	.word	0x0801f9dc
 800ee18:	20001374 	.word	0x20001374
 800ee1c:	2000137c 	.word	0x2000137c

0800ee20 <tcp_trigger_input_pcb_close>:

void
tcp_trigger_input_pcb_close(void)
{
 800ee20:	b580      	push	{r7, lr}
 800ee22:	af00      	add	r7, sp, #0
  recv_flags |= TF_CLOSED;
 800ee24:	4b04      	ldr	r3, [pc, #16]	; (800ee38 <tcp_trigger_input_pcb_close+0x18>)
 800ee26:	781b      	ldrb	r3, [r3, #0]
 800ee28:	2210      	movs	r2, #16
 800ee2a:	4313      	orrs	r3, r2
 800ee2c:	b2da      	uxtb	r2, r3
 800ee2e:	4b02      	ldr	r3, [pc, #8]	; (800ee38 <tcp_trigger_input_pcb_close+0x18>)
 800ee30:	701a      	strb	r2, [r3, #0]
}
 800ee32:	46c0      	nop			; (mov r8, r8)
 800ee34:	46bd      	mov	sp, r7
 800ee36:	bd80      	pop	{r7, pc}
 800ee38:	2000138d 	.word	0x2000138d

0800ee3c <tcp_route>:
static err_t tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb, struct netif *netif);

/* tcp_route: common code that returns a fixed bound netif or calls ip_route */
static struct netif *
tcp_route(const struct tcp_pcb *pcb, const ip_addr_t *src, const ip_addr_t *dst)
{
 800ee3c:	b580      	push	{r7, lr}
 800ee3e:	b084      	sub	sp, #16
 800ee40:	af00      	add	r7, sp, #0
 800ee42:	60f8      	str	r0, [r7, #12]
 800ee44:	60b9      	str	r1, [r7, #8]
 800ee46:	607a      	str	r2, [r7, #4]
  LWIP_UNUSED_ARG(src); /* in case IPv4-only and source-based routing is disabled */

  if ((pcb != NULL) && (pcb->netif_idx != NETIF_NO_INDEX)) {
 800ee48:	68fb      	ldr	r3, [r7, #12]
 800ee4a:	2b00      	cmp	r3, #0
 800ee4c:	d00a      	beq.n	800ee64 <tcp_route+0x28>
 800ee4e:	68fb      	ldr	r3, [r7, #12]
 800ee50:	7a1b      	ldrb	r3, [r3, #8]
 800ee52:	2b00      	cmp	r3, #0
 800ee54:	d006      	beq.n	800ee64 <tcp_route+0x28>
    return netif_get_by_index(pcb->netif_idx);
 800ee56:	68fb      	ldr	r3, [r7, #12]
 800ee58:	7a1b      	ldrb	r3, [r3, #8]
 800ee5a:	0018      	movs	r0, r3
 800ee5c:	f7fa f824 	bl	8008ea8 <netif_get_by_index>
 800ee60:	0003      	movs	r3, r0
 800ee62:	e004      	b.n	800ee6e <tcp_route+0x32>
  } else {
    return ip_route(src, dst);
 800ee64:	687b      	ldr	r3, [r7, #4]
 800ee66:	0018      	movs	r0, r3
 800ee68:	f004 f820 	bl	8012eac <ip4_route>
 800ee6c:	0003      	movs	r3, r0
  }
}
 800ee6e:	0018      	movs	r0, r3
 800ee70:	46bd      	mov	sp, r7
 800ee72:	b004      	add	sp, #16
 800ee74:	bd80      	pop	{r7, pc}
	...

0800ee78 <tcp_create_segment>:
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(const struct tcp_pcb *pcb, struct pbuf *p, u8_t hdrflags, u32_t seqno, u8_t optflags)
{
 800ee78:	b590      	push	{r4, r7, lr}
 800ee7a:	b087      	sub	sp, #28
 800ee7c:	af00      	add	r7, sp, #0
 800ee7e:	60f8      	str	r0, [r7, #12]
 800ee80:	60b9      	str	r1, [r7, #8]
 800ee82:	603b      	str	r3, [r7, #0]
 800ee84:	1dfb      	adds	r3, r7, #7
 800ee86:	701a      	strb	r2, [r3, #0]
  struct tcp_seg *seg;
  u8_t optlen;

  LWIP_ASSERT("tcp_create_segment: invalid pcb", pcb != NULL);
 800ee88:	68fb      	ldr	r3, [r7, #12]
 800ee8a:	2b00      	cmp	r3, #0
 800ee8c:	d105      	bne.n	800ee9a <tcp_create_segment+0x22>
 800ee8e:	4b86      	ldr	r3, [pc, #536]	; (800f0a8 <tcp_create_segment+0x230>)
 800ee90:	4986      	ldr	r1, [pc, #536]	; (800f0ac <tcp_create_segment+0x234>)
 800ee92:	4887      	ldr	r0, [pc, #540]	; (800f0b0 <tcp_create_segment+0x238>)
 800ee94:	22a3      	movs	r2, #163	; 0xa3
 800ee96:	f7f3 f999 	bl	80021cc <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_create_segment: invalid pbuf", p != NULL);
 800ee9a:	68bb      	ldr	r3, [r7, #8]
 800ee9c:	2b00      	cmp	r3, #0
 800ee9e:	d105      	bne.n	800eeac <tcp_create_segment+0x34>
 800eea0:	4b81      	ldr	r3, [pc, #516]	; (800f0a8 <tcp_create_segment+0x230>)
 800eea2:	4984      	ldr	r1, [pc, #528]	; (800f0b4 <tcp_create_segment+0x23c>)
 800eea4:	4882      	ldr	r0, [pc, #520]	; (800f0b0 <tcp_create_segment+0x238>)
 800eea6:	22a4      	movs	r2, #164	; 0xa4
 800eea8:	f7f3 f990 	bl	80021cc <app_debug_rtt_raw>

  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 800eeac:	2328      	movs	r3, #40	; 0x28
 800eeae:	18fb      	adds	r3, r7, r3
 800eeb0:	781b      	ldrb	r3, [r3, #0]
 800eeb2:	009b      	lsls	r3, r3, #2
 800eeb4:	b2da      	uxtb	r2, r3
 800eeb6:	2317      	movs	r3, #23
 800eeb8:	18fb      	adds	r3, r7, r3
 800eeba:	2104      	movs	r1, #4
 800eebc:	400a      	ands	r2, r1
 800eebe:	701a      	strb	r2, [r3, #0]

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 800eec0:	2003      	movs	r0, #3
 800eec2:	f7f9 fc81 	bl	80087c8 <memp_malloc>
 800eec6:	0003      	movs	r3, r0
 800eec8:	613b      	str	r3, [r7, #16]
 800eeca:	693b      	ldr	r3, [r7, #16]
 800eecc:	2b00      	cmp	r3, #0
 800eece:	d105      	bne.n	800eedc <tcp_create_segment+0x64>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
 800eed0:	68bb      	ldr	r3, [r7, #8]
 800eed2:	0018      	movs	r0, r3
 800eed4:	f7fa fbde 	bl	8009694 <pbuf_free>
    return NULL;
 800eed8:	2300      	movs	r3, #0
 800eeda:	e0e1      	b.n	800f0a0 <tcp_create_segment+0x228>
  }
  seg->flags = optflags;
 800eedc:	693a      	ldr	r2, [r7, #16]
 800eede:	2328      	movs	r3, #40	; 0x28
 800eee0:	18fb      	adds	r3, r7, r3
 800eee2:	781b      	ldrb	r3, [r3, #0]
 800eee4:	73d3      	strb	r3, [r2, #15]
  seg->next = NULL;
 800eee6:	693b      	ldr	r3, [r7, #16]
 800eee8:	2200      	movs	r2, #0
 800eeea:	601a      	str	r2, [r3, #0]
  seg->p = p;
 800eeec:	693b      	ldr	r3, [r7, #16]
 800eeee:	68ba      	ldr	r2, [r7, #8]
 800eef0:	605a      	str	r2, [r3, #4]
  LWIP_ASSERT("p->tot_len >= optlen", p->tot_len >= optlen);
 800eef2:	68bb      	ldr	r3, [r7, #8]
 800eef4:	891a      	ldrh	r2, [r3, #8]
 800eef6:	2317      	movs	r3, #23
 800eef8:	18fb      	adds	r3, r7, r3
 800eefa:	781b      	ldrb	r3, [r3, #0]
 800eefc:	b29b      	uxth	r3, r3
 800eefe:	429a      	cmp	r2, r3
 800ef00:	d205      	bcs.n	800ef0e <tcp_create_segment+0x96>
 800ef02:	4b69      	ldr	r3, [pc, #420]	; (800f0a8 <tcp_create_segment+0x230>)
 800ef04:	496c      	ldr	r1, [pc, #432]	; (800f0b8 <tcp_create_segment+0x240>)
 800ef06:	486a      	ldr	r0, [pc, #424]	; (800f0b0 <tcp_create_segment+0x238>)
 800ef08:	22b0      	movs	r2, #176	; 0xb0
 800ef0a:	f7f3 f95f 	bl	80021cc <app_debug_rtt_raw>
  seg->len = p->tot_len - optlen;
 800ef0e:	68bb      	ldr	r3, [r7, #8]
 800ef10:	891a      	ldrh	r2, [r3, #8]
 800ef12:	2317      	movs	r3, #23
 800ef14:	18fb      	adds	r3, r7, r3
 800ef16:	781b      	ldrb	r3, [r3, #0]
 800ef18:	b29b      	uxth	r3, r3
 800ef1a:	1ad3      	subs	r3, r2, r3
 800ef1c:	b29a      	uxth	r2, r3
 800ef1e:	693b      	ldr	r3, [r7, #16]
 800ef20:	811a      	strh	r2, [r3, #8]
#if TCP_OVERSIZE_DBGCHECK
  seg->oversize_left = 0;
 800ef22:	693b      	ldr	r3, [r7, #16]
 800ef24:	2200      	movs	r2, #0
 800ef26:	815a      	strh	r2, [r3, #10]
#endif /* TCP_OVERSIZE_DBGCHECK */
#if TCP_CHECKSUM_ON_COPY
  seg->chksum = 0;
 800ef28:	693b      	ldr	r3, [r7, #16]
 800ef2a:	2200      	movs	r2, #0
 800ef2c:	819a      	strh	r2, [r3, #12]
  seg->chksum_swapped = 0;
 800ef2e:	693b      	ldr	r3, [r7, #16]
 800ef30:	2200      	movs	r2, #0
 800ef32:	739a      	strb	r2, [r3, #14]
  /* check optflags */
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
 800ef34:	2328      	movs	r3, #40	; 0x28
 800ef36:	18fb      	adds	r3, r7, r3
 800ef38:	781b      	ldrb	r3, [r3, #0]
 800ef3a:	2204      	movs	r2, #4
 800ef3c:	4013      	ands	r3, r2
 800ef3e:	d005      	beq.n	800ef4c <tcp_create_segment+0xd4>
 800ef40:	4b59      	ldr	r3, [pc, #356]	; (800f0a8 <tcp_create_segment+0x230>)
 800ef42:	495e      	ldr	r1, [pc, #376]	; (800f0bc <tcp_create_segment+0x244>)
 800ef44:	485a      	ldr	r0, [pc, #360]	; (800f0b0 <tcp_create_segment+0x238>)
 800ef46:	22b9      	movs	r2, #185	; 0xb9
 800ef48:	f7f3 f940 	bl	80021cc <app_debug_rtt_raw>
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_add_header(p, TCP_HLEN)) {
 800ef4c:	68bb      	ldr	r3, [r7, #8]
 800ef4e:	2114      	movs	r1, #20
 800ef50:	0018      	movs	r0, r3
 800ef52:	f7fa fab7 	bl	80094c4 <pbuf_add_header>
 800ef56:	1e03      	subs	r3, r0, #0
 800ef58:	d005      	beq.n	800ef66 <tcp_create_segment+0xee>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
 800ef5a:	693b      	ldr	r3, [r7, #16]
 800ef5c:	0018      	movs	r0, r3
 800ef5e:	f7fc fc1b 	bl	800b798 <tcp_seg_free>
    return NULL;
 800ef62:	2300      	movs	r3, #0
 800ef64:	e09c      	b.n	800f0a0 <tcp_create_segment+0x228>
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 800ef66:	693b      	ldr	r3, [r7, #16]
 800ef68:	685b      	ldr	r3, [r3, #4]
 800ef6a:	685a      	ldr	r2, [r3, #4]
 800ef6c:	693b      	ldr	r3, [r7, #16]
 800ef6e:	611a      	str	r2, [r3, #16]
  seg->tcphdr->src = lwip_htons(pcb->local_port);
 800ef70:	68fb      	ldr	r3, [r7, #12]
 800ef72:	8b5a      	ldrh	r2, [r3, #26]
 800ef74:	693b      	ldr	r3, [r7, #16]
 800ef76:	691c      	ldr	r4, [r3, #16]
 800ef78:	0010      	movs	r0, r2
 800ef7a:	f7f7 fadb 	bl	8006534 <lwip_htons>
 800ef7e:	0003      	movs	r3, r0
 800ef80:	22ff      	movs	r2, #255	; 0xff
 800ef82:	401a      	ands	r2, r3
 800ef84:	0010      	movs	r0, r2
 800ef86:	7822      	ldrb	r2, [r4, #0]
 800ef88:	2100      	movs	r1, #0
 800ef8a:	400a      	ands	r2, r1
 800ef8c:	1c11      	adds	r1, r2, #0
 800ef8e:	1c02      	adds	r2, r0, #0
 800ef90:	430a      	orrs	r2, r1
 800ef92:	7022      	strb	r2, [r4, #0]
 800ef94:	0a1b      	lsrs	r3, r3, #8
 800ef96:	b299      	uxth	r1, r3
 800ef98:	7863      	ldrb	r3, [r4, #1]
 800ef9a:	2200      	movs	r2, #0
 800ef9c:	4013      	ands	r3, r2
 800ef9e:	1c1a      	adds	r2, r3, #0
 800efa0:	1c0b      	adds	r3, r1, #0
 800efa2:	4313      	orrs	r3, r2
 800efa4:	7063      	strb	r3, [r4, #1]
  seg->tcphdr->dest = lwip_htons(pcb->remote_port);
 800efa6:	68fb      	ldr	r3, [r7, #12]
 800efa8:	8b9a      	ldrh	r2, [r3, #28]
 800efaa:	693b      	ldr	r3, [r7, #16]
 800efac:	691c      	ldr	r4, [r3, #16]
 800efae:	0010      	movs	r0, r2
 800efb0:	f7f7 fac0 	bl	8006534 <lwip_htons>
 800efb4:	0003      	movs	r3, r0
 800efb6:	22ff      	movs	r2, #255	; 0xff
 800efb8:	401a      	ands	r2, r3
 800efba:	0010      	movs	r0, r2
 800efbc:	78a2      	ldrb	r2, [r4, #2]
 800efbe:	2100      	movs	r1, #0
 800efc0:	400a      	ands	r2, r1
 800efc2:	1c11      	adds	r1, r2, #0
 800efc4:	1c02      	adds	r2, r0, #0
 800efc6:	430a      	orrs	r2, r1
 800efc8:	70a2      	strb	r2, [r4, #2]
 800efca:	0a1b      	lsrs	r3, r3, #8
 800efcc:	b299      	uxth	r1, r3
 800efce:	78e3      	ldrb	r3, [r4, #3]
 800efd0:	2200      	movs	r2, #0
 800efd2:	4013      	ands	r3, r2
 800efd4:	1c1a      	adds	r2, r3, #0
 800efd6:	1c0b      	adds	r3, r1, #0
 800efd8:	4313      	orrs	r3, r2
 800efda:	70e3      	strb	r3, [r4, #3]
  seg->tcphdr->seqno = lwip_htonl(seqno);
 800efdc:	693b      	ldr	r3, [r7, #16]
 800efde:	691c      	ldr	r4, [r3, #16]
 800efe0:	683b      	ldr	r3, [r7, #0]
 800efe2:	0018      	movs	r0, r3
 800efe4:	f7f7 fabc 	bl	8006560 <lwip_htonl>
 800efe8:	0003      	movs	r3, r0
 800efea:	22ff      	movs	r2, #255	; 0xff
 800efec:	401a      	ands	r2, r3
 800efee:	0010      	movs	r0, r2
 800eff0:	7922      	ldrb	r2, [r4, #4]
 800eff2:	2100      	movs	r1, #0
 800eff4:	400a      	ands	r2, r1
 800eff6:	1c11      	adds	r1, r2, #0
 800eff8:	1c02      	adds	r2, r0, #0
 800effa:	430a      	orrs	r2, r1
 800effc:	7122      	strb	r2, [r4, #4]
 800effe:	0a1a      	lsrs	r2, r3, #8
 800f000:	21ff      	movs	r1, #255	; 0xff
 800f002:	400a      	ands	r2, r1
 800f004:	0010      	movs	r0, r2
 800f006:	7962      	ldrb	r2, [r4, #5]
 800f008:	2100      	movs	r1, #0
 800f00a:	400a      	ands	r2, r1
 800f00c:	1c11      	adds	r1, r2, #0
 800f00e:	1c02      	adds	r2, r0, #0
 800f010:	430a      	orrs	r2, r1
 800f012:	7162      	strb	r2, [r4, #5]
 800f014:	0c1a      	lsrs	r2, r3, #16
 800f016:	21ff      	movs	r1, #255	; 0xff
 800f018:	400a      	ands	r2, r1
 800f01a:	0010      	movs	r0, r2
 800f01c:	79a2      	ldrb	r2, [r4, #6]
 800f01e:	2100      	movs	r1, #0
 800f020:	400a      	ands	r2, r1
 800f022:	1c11      	adds	r1, r2, #0
 800f024:	1c02      	adds	r2, r0, #0
 800f026:	430a      	orrs	r2, r1
 800f028:	71a2      	strb	r2, [r4, #6]
 800f02a:	0e19      	lsrs	r1, r3, #24
 800f02c:	79e3      	ldrb	r3, [r4, #7]
 800f02e:	2200      	movs	r2, #0
 800f030:	4013      	ands	r3, r2
 800f032:	1c1a      	adds	r2, r3, #0
 800f034:	1c0b      	adds	r3, r1, #0
 800f036:	4313      	orrs	r3, r2
 800f038:	71e3      	strb	r3, [r4, #7]
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), hdrflags);
 800f03a:	2317      	movs	r3, #23
 800f03c:	18fb      	adds	r3, r7, r3
 800f03e:	781b      	ldrb	r3, [r3, #0]
 800f040:	089b      	lsrs	r3, r3, #2
 800f042:	b2db      	uxtb	r3, r3
 800f044:	b29b      	uxth	r3, r3
 800f046:	3305      	adds	r3, #5
 800f048:	b29b      	uxth	r3, r3
 800f04a:	031b      	lsls	r3, r3, #12
 800f04c:	b29a      	uxth	r2, r3
 800f04e:	1dfb      	adds	r3, r7, #7
 800f050:	781b      	ldrb	r3, [r3, #0]
 800f052:	b29b      	uxth	r3, r3
 800f054:	4313      	orrs	r3, r2
 800f056:	b29a      	uxth	r2, r3
 800f058:	693b      	ldr	r3, [r7, #16]
 800f05a:	691c      	ldr	r4, [r3, #16]
 800f05c:	0010      	movs	r0, r2
 800f05e:	f7f7 fa69 	bl	8006534 <lwip_htons>
 800f062:	0003      	movs	r3, r0
 800f064:	22ff      	movs	r2, #255	; 0xff
 800f066:	401a      	ands	r2, r3
 800f068:	0010      	movs	r0, r2
 800f06a:	7b22      	ldrb	r2, [r4, #12]
 800f06c:	2100      	movs	r1, #0
 800f06e:	400a      	ands	r2, r1
 800f070:	1c11      	adds	r1, r2, #0
 800f072:	1c02      	adds	r2, r0, #0
 800f074:	430a      	orrs	r2, r1
 800f076:	7322      	strb	r2, [r4, #12]
 800f078:	0a1b      	lsrs	r3, r3, #8
 800f07a:	b299      	uxth	r1, r3
 800f07c:	7b63      	ldrb	r3, [r4, #13]
 800f07e:	2200      	movs	r2, #0
 800f080:	4013      	ands	r3, r2
 800f082:	1c1a      	adds	r2, r3, #0
 800f084:	1c0b      	adds	r3, r1, #0
 800f086:	4313      	orrs	r3, r2
 800f088:	7363      	strb	r3, [r4, #13]
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
 800f08a:	693b      	ldr	r3, [r7, #16]
 800f08c:	691b      	ldr	r3, [r3, #16]
 800f08e:	7c9a      	ldrb	r2, [r3, #18]
 800f090:	2100      	movs	r1, #0
 800f092:	400a      	ands	r2, r1
 800f094:	749a      	strb	r2, [r3, #18]
 800f096:	7cda      	ldrb	r2, [r3, #19]
 800f098:	2100      	movs	r1, #0
 800f09a:	400a      	ands	r2, r1
 800f09c:	74da      	strb	r2, [r3, #19]
  return seg;
 800f09e:	693b      	ldr	r3, [r7, #16]
}
 800f0a0:	0018      	movs	r0, r3
 800f0a2:	46bd      	mov	sp, r7
 800f0a4:	b007      	add	sp, #28
 800f0a6:	bd90      	pop	{r4, r7, pc}
 800f0a8:	0801fe14 	.word	0x0801fe14
 800f0ac:	0801fe40 	.word	0x0801fe40
 800f0b0:	0801fe60 	.word	0x0801fe60
 800f0b4:	0801fe8c 	.word	0x0801fe8c
 800f0b8:	0801feb0 	.word	0x0801feb0
 800f0bc:	0801fec8 	.word	0x0801fec8

0800f0c0 <tcp_pbuf_prealloc>:
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, const struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
 800f0c0:	b590      	push	{r4, r7, lr}
 800f0c2:	b087      	sub	sp, #28
 800f0c4:	af00      	add	r7, sp, #0
 800f0c6:	0004      	movs	r4, r0
 800f0c8:	0008      	movs	r0, r1
 800f0ca:	0011      	movs	r1, r2
 800f0cc:	607b      	str	r3, [r7, #4]
 800f0ce:	230f      	movs	r3, #15
 800f0d0:	18fb      	adds	r3, r7, r3
 800f0d2:	1c22      	adds	r2, r4, #0
 800f0d4:	701a      	strb	r2, [r3, #0]
 800f0d6:	240c      	movs	r4, #12
 800f0d8:	193b      	adds	r3, r7, r4
 800f0da:	1c02      	adds	r2, r0, #0
 800f0dc:	801a      	strh	r2, [r3, #0]
 800f0de:	230a      	movs	r3, #10
 800f0e0:	18fb      	adds	r3, r7, r3
 800f0e2:	1c0a      	adds	r2, r1, #0
 800f0e4:	801a      	strh	r2, [r3, #0]
  struct pbuf *p;
  u16_t alloc = length;
 800f0e6:	2316      	movs	r3, #22
 800f0e8:	18fb      	adds	r3, r7, r3
 800f0ea:	193a      	adds	r2, r7, r4
 800f0ec:	8812      	ldrh	r2, [r2, #0]
 800f0ee:	801a      	strh	r2, [r3, #0]

  LWIP_ASSERT("tcp_pbuf_prealloc: invalid oversize", oversize != NULL);
 800f0f0:	687b      	ldr	r3, [r7, #4]
 800f0f2:	2b00      	cmp	r3, #0
 800f0f4:	d105      	bne.n	800f102 <tcp_pbuf_prealloc+0x42>
 800f0f6:	4b3a      	ldr	r3, [pc, #232]	; (800f1e0 <tcp_pbuf_prealloc+0x120>)
 800f0f8:	493a      	ldr	r1, [pc, #232]	; (800f1e4 <tcp_pbuf_prealloc+0x124>)
 800f0fa:	483b      	ldr	r0, [pc, #236]	; (800f1e8 <tcp_pbuf_prealloc+0x128>)
 800f0fc:	22e8      	movs	r2, #232	; 0xe8
 800f0fe:	f7f3 f865 	bl	80021cc <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_pbuf_prealloc: invalid pcb", pcb != NULL);
 800f102:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f104:	2b00      	cmp	r3, #0
 800f106:	d105      	bne.n	800f114 <tcp_pbuf_prealloc+0x54>
 800f108:	4b35      	ldr	r3, [pc, #212]	; (800f1e0 <tcp_pbuf_prealloc+0x120>)
 800f10a:	4938      	ldr	r1, [pc, #224]	; (800f1ec <tcp_pbuf_prealloc+0x12c>)
 800f10c:	4836      	ldr	r0, [pc, #216]	; (800f1e8 <tcp_pbuf_prealloc+0x128>)
 800f10e:	22e9      	movs	r2, #233	; 0xe9
 800f110:	f7f3 f85c 	bl	80021cc <app_debug_rtt_raw>
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
 800f114:	230c      	movs	r3, #12
 800f116:	18fa      	adds	r2, r7, r3
 800f118:	230a      	movs	r3, #10
 800f11a:	18fb      	adds	r3, r7, r3
 800f11c:	8812      	ldrh	r2, [r2, #0]
 800f11e:	881b      	ldrh	r3, [r3, #0]
 800f120:	429a      	cmp	r2, r3
 800f122:	d22a      	bcs.n	800f17a <tcp_pbuf_prealloc+0xba>
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 800f124:	232c      	movs	r3, #44	; 0x2c
 800f126:	18fb      	adds	r3, r7, r3
 800f128:	781b      	ldrb	r3, [r3, #0]
 800f12a:	2202      	movs	r2, #2
 800f12c:	4013      	ands	r3, r2
 800f12e:	d112      	bne.n	800f156 <tcp_pbuf_prealloc+0x96>
        (!(pcb->flags & TF_NODELAY) &&
 800f130:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f132:	8bdb      	ldrh	r3, [r3, #30]
 800f134:	001a      	movs	r2, r3
 800f136:	2340      	movs	r3, #64	; 0x40
 800f138:	4013      	ands	r3, r2
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 800f13a:	d11e      	bne.n	800f17a <tcp_pbuf_prealloc+0xba>
        (!(pcb->flags & TF_NODELAY) &&
 800f13c:	2330      	movs	r3, #48	; 0x30
 800f13e:	18fb      	adds	r3, r7, r3
 800f140:	781b      	ldrb	r3, [r3, #0]
 800f142:	2b00      	cmp	r3, #0
 800f144:	d007      	beq.n	800f156 <tcp_pbuf_prealloc+0x96>
         (!first_seg ||
          pcb->unsent != NULL ||
 800f146:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f148:	6f1b      	ldr	r3, [r3, #112]	; 0x70
         (!first_seg ||
 800f14a:	2b00      	cmp	r3, #0
 800f14c:	d103      	bne.n	800f156 <tcp_pbuf_prealloc+0x96>
          pcb->unacked != NULL))) {
 800f14e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f150:	6f5b      	ldr	r3, [r3, #116]	; 0x74
          pcb->unsent != NULL ||
 800f152:	2b00      	cmp	r3, #0
 800f154:	d011      	beq.n	800f17a <tcp_pbuf_prealloc+0xba>
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(TCP_OVERSIZE_CALC_LENGTH(length)));
 800f156:	230c      	movs	r3, #12
 800f158:	18fb      	adds	r3, r7, r3
 800f15a:	881b      	ldrh	r3, [r3, #0]
 800f15c:	4a24      	ldr	r2, [pc, #144]	; (800f1f0 <tcp_pbuf_prealloc+0x130>)
 800f15e:	4694      	mov	ip, r2
 800f160:	4463      	add	r3, ip
 800f162:	2203      	movs	r2, #3
 800f164:	4393      	bics	r3, r2
 800f166:	001a      	movs	r2, r3
 800f168:	230a      	movs	r3, #10
 800f16a:	18fb      	adds	r3, r7, r3
 800f16c:	881b      	ldrh	r3, [r3, #0]
 800f16e:	429a      	cmp	r2, r3
 800f170:	d900      	bls.n	800f174 <tcp_pbuf_prealloc+0xb4>
 800f172:	001a      	movs	r2, r3
 800f174:	2316      	movs	r3, #22
 800f176:	18fb      	adds	r3, r7, r3
 800f178:	801a      	strh	r2, [r3, #0]
    }
  }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
 800f17a:	23a0      	movs	r3, #160	; 0xa0
 800f17c:	009a      	lsls	r2, r3, #2
 800f17e:	2316      	movs	r3, #22
 800f180:	18fb      	adds	r3, r7, r3
 800f182:	8819      	ldrh	r1, [r3, #0]
 800f184:	230f      	movs	r3, #15
 800f186:	18fb      	adds	r3, r7, r3
 800f188:	781b      	ldrb	r3, [r3, #0]
 800f18a:	0018      	movs	r0, r3
 800f18c:	f7f9 ff0a 	bl	8008fa4 <pbuf_alloc>
 800f190:	0003      	movs	r3, r0
 800f192:	613b      	str	r3, [r7, #16]
  if (p == NULL) {
 800f194:	693b      	ldr	r3, [r7, #16]
 800f196:	2b00      	cmp	r3, #0
 800f198:	d101      	bne.n	800f19e <tcp_pbuf_prealloc+0xde>
    return NULL;
 800f19a:	2300      	movs	r3, #0
 800f19c:	e01c      	b.n	800f1d8 <tcp_pbuf_prealloc+0x118>
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
 800f19e:	693b      	ldr	r3, [r7, #16]
 800f1a0:	681b      	ldr	r3, [r3, #0]
 800f1a2:	2b00      	cmp	r3, #0
 800f1a4:	d006      	beq.n	800f1b4 <tcp_pbuf_prealloc+0xf4>
 800f1a6:	4b0e      	ldr	r3, [pc, #56]	; (800f1e0 <tcp_pbuf_prealloc+0x120>)
 800f1a8:	220c      	movs	r2, #12
 800f1aa:	32ff      	adds	r2, #255	; 0xff
 800f1ac:	4911      	ldr	r1, [pc, #68]	; (800f1f4 <tcp_pbuf_prealloc+0x134>)
 800f1ae:	480e      	ldr	r0, [pc, #56]	; (800f1e8 <tcp_pbuf_prealloc+0x128>)
 800f1b0:	f7f3 f80c 	bl	80021cc <app_debug_rtt_raw>
  *oversize = p->len - length;
 800f1b4:	693b      	ldr	r3, [r7, #16]
 800f1b6:	895a      	ldrh	r2, [r3, #10]
 800f1b8:	210c      	movs	r1, #12
 800f1ba:	187b      	adds	r3, r7, r1
 800f1bc:	881b      	ldrh	r3, [r3, #0]
 800f1be:	1ad3      	subs	r3, r2, r3
 800f1c0:	b29a      	uxth	r2, r3
 800f1c2:	687b      	ldr	r3, [r7, #4]
 800f1c4:	801a      	strh	r2, [r3, #0]
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
 800f1c6:	693b      	ldr	r3, [r7, #16]
 800f1c8:	187a      	adds	r2, r7, r1
 800f1ca:	8812      	ldrh	r2, [r2, #0]
 800f1cc:	811a      	strh	r2, [r3, #8]
 800f1ce:	693b      	ldr	r3, [r7, #16]
 800f1d0:	891a      	ldrh	r2, [r3, #8]
 800f1d2:	693b      	ldr	r3, [r7, #16]
 800f1d4:	815a      	strh	r2, [r3, #10]
  return p;
 800f1d6:	693b      	ldr	r3, [r7, #16]
}
 800f1d8:	0018      	movs	r0, r3
 800f1da:	46bd      	mov	sp, r7
 800f1dc:	b007      	add	sp, #28
 800f1de:	bd90      	pop	{r4, r7, pc}
 800f1e0:	0801fe14 	.word	0x0801fe14
 800f1e4:	0801fefc 	.word	0x0801fefc
 800f1e8:	0801fe60 	.word	0x0801fe60
 800f1ec:	0801ff20 	.word	0x0801ff20
 800f1f0:	0000021b 	.word	0x0000021b
 800f1f4:	0801ff40 	.word	0x0801ff40

0800f1f8 <tcp_seg_add_chksum>:
 * Called by tcp_write and tcp_split_unsent_seg.
 */
static void
tcp_seg_add_chksum(u16_t chksum, u16_t len, u16_t *seg_chksum,
                   u8_t *seg_chksum_swapped)
{
 800f1f8:	b5b0      	push	{r4, r5, r7, lr}
 800f1fa:	b086      	sub	sp, #24
 800f1fc:	af00      	add	r7, sp, #0
 800f1fe:	60ba      	str	r2, [r7, #8]
 800f200:	607b      	str	r3, [r7, #4]
 800f202:	240e      	movs	r4, #14
 800f204:	193b      	adds	r3, r7, r4
 800f206:	1c02      	adds	r2, r0, #0
 800f208:	801a      	strh	r2, [r3, #0]
 800f20a:	250c      	movs	r5, #12
 800f20c:	197b      	adds	r3, r7, r5
 800f20e:	1c0a      	adds	r2, r1, #0
 800f210:	801a      	strh	r2, [r3, #0]
  u32_t helper;
  /* add chksum to old chksum and fold to u16_t */
  helper = chksum + *seg_chksum;
 800f212:	0020      	movs	r0, r4
 800f214:	183b      	adds	r3, r7, r0
 800f216:	881b      	ldrh	r3, [r3, #0]
 800f218:	68ba      	ldr	r2, [r7, #8]
 800f21a:	8812      	ldrh	r2, [r2, #0]
 800f21c:	189b      	adds	r3, r3, r2
 800f21e:	617b      	str	r3, [r7, #20]
  chksum = FOLD_U32T(helper);
 800f220:	697b      	ldr	r3, [r7, #20]
 800f222:	0c1b      	lsrs	r3, r3, #16
 800f224:	b299      	uxth	r1, r3
 800f226:	697b      	ldr	r3, [r7, #20]
 800f228:	b29a      	uxth	r2, r3
 800f22a:	183b      	adds	r3, r7, r0
 800f22c:	188a      	adds	r2, r1, r2
 800f22e:	801a      	strh	r2, [r3, #0]
  if ((len & 1) != 0) {
 800f230:	197b      	adds	r3, r7, r5
 800f232:	881b      	ldrh	r3, [r3, #0]
 800f234:	2201      	movs	r2, #1
 800f236:	4013      	ands	r3, r2
 800f238:	d013      	beq.n	800f262 <tcp_seg_add_chksum+0x6a>
    *seg_chksum_swapped = 1 - *seg_chksum_swapped;
 800f23a:	687b      	ldr	r3, [r7, #4]
 800f23c:	781b      	ldrb	r3, [r3, #0]
 800f23e:	2201      	movs	r2, #1
 800f240:	1ad3      	subs	r3, r2, r3
 800f242:	b2da      	uxtb	r2, r3
 800f244:	687b      	ldr	r3, [r7, #4]
 800f246:	701a      	strb	r2, [r3, #0]
    chksum = SWAP_BYTES_IN_WORD(chksum);
 800f248:	183b      	adds	r3, r7, r0
 800f24a:	881b      	ldrh	r3, [r3, #0]
 800f24c:	021b      	lsls	r3, r3, #8
 800f24e:	b21a      	sxth	r2, r3
 800f250:	183b      	adds	r3, r7, r0
 800f252:	881b      	ldrh	r3, [r3, #0]
 800f254:	0a1b      	lsrs	r3, r3, #8
 800f256:	b29b      	uxth	r3, r3
 800f258:	b21b      	sxth	r3, r3
 800f25a:	4313      	orrs	r3, r2
 800f25c:	b21a      	sxth	r2, r3
 800f25e:	183b      	adds	r3, r7, r0
 800f260:	801a      	strh	r2, [r3, #0]
  }
  *seg_chksum = chksum;
 800f262:	68bb      	ldr	r3, [r7, #8]
 800f264:	220e      	movs	r2, #14
 800f266:	18ba      	adds	r2, r7, r2
 800f268:	8812      	ldrh	r2, [r2, #0]
 800f26a:	801a      	strh	r2, [r3, #0]
}
 800f26c:	46c0      	nop			; (mov r8, r8)
 800f26e:	46bd      	mov	sp, r7
 800f270:	b006      	add	sp, #24
 800f272:	bdb0      	pop	{r4, r5, r7, pc}

0800f274 <tcp_write_checks>:
 * @param len length of data to send (checked agains snd_buf)
 * @return ERR_OK if tcp_write is allowed to proceed, another err_t otherwise
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
 800f274:	b580      	push	{r7, lr}
 800f276:	b082      	sub	sp, #8
 800f278:	af00      	add	r7, sp, #0
 800f27a:	6078      	str	r0, [r7, #4]
 800f27c:	000a      	movs	r2, r1
 800f27e:	1cbb      	adds	r3, r7, #2
 800f280:	801a      	strh	r2, [r3, #0]
  LWIP_ASSERT("tcp_write_checks: invalid pcb", pcb != NULL);
 800f282:	687b      	ldr	r3, [r7, #4]
 800f284:	2b00      	cmp	r3, #0
 800f286:	d106      	bne.n	800f296 <tcp_write_checks+0x22>
 800f288:	4b34      	ldr	r3, [pc, #208]	; (800f35c <tcp_write_checks+0xe8>)
 800f28a:	2234      	movs	r2, #52	; 0x34
 800f28c:	32ff      	adds	r2, #255	; 0xff
 800f28e:	4934      	ldr	r1, [pc, #208]	; (800f360 <tcp_write_checks+0xec>)
 800f290:	4834      	ldr	r0, [pc, #208]	; (800f364 <tcp_write_checks+0xf0>)
 800f292:	f7f2 ff9b 	bl	80021cc <app_debug_rtt_raw>

  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
 800f296:	687b      	ldr	r3, [r7, #4]
 800f298:	7e1b      	ldrb	r3, [r3, #24]
 800f29a:	2b04      	cmp	r3, #4
 800f29c:	d00e      	beq.n	800f2bc <tcp_write_checks+0x48>
      (pcb->state != CLOSE_WAIT) &&
 800f29e:	687b      	ldr	r3, [r7, #4]
 800f2a0:	7e1b      	ldrb	r3, [r3, #24]
  if ((pcb->state != ESTABLISHED) &&
 800f2a2:	2b07      	cmp	r3, #7
 800f2a4:	d00a      	beq.n	800f2bc <tcp_write_checks+0x48>
      (pcb->state != SYN_SENT) &&
 800f2a6:	687b      	ldr	r3, [r7, #4]
 800f2a8:	7e1b      	ldrb	r3, [r3, #24]
      (pcb->state != CLOSE_WAIT) &&
 800f2aa:	2b02      	cmp	r3, #2
 800f2ac:	d006      	beq.n	800f2bc <tcp_write_checks+0x48>
      (pcb->state != SYN_RCVD)) {
 800f2ae:	687b      	ldr	r3, [r7, #4]
 800f2b0:	7e1b      	ldrb	r3, [r3, #24]
      (pcb->state != SYN_SENT) &&
 800f2b2:	2b03      	cmp	r3, #3
 800f2b4:	d002      	beq.n	800f2bc <tcp_write_checks+0x48>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
 800f2b6:	230b      	movs	r3, #11
 800f2b8:	425b      	negs	r3, r3
 800f2ba:	e04a      	b.n	800f352 <tcp_write_checks+0xde>
  } else if (len == 0) {
 800f2bc:	1cbb      	adds	r3, r7, #2
 800f2be:	881b      	ldrh	r3, [r3, #0]
 800f2c0:	2b00      	cmp	r3, #0
 800f2c2:	d101      	bne.n	800f2c8 <tcp_write_checks+0x54>
    return ERR_OK;
 800f2c4:	2300      	movs	r3, #0
 800f2c6:	e044      	b.n	800f352 <tcp_write_checks+0xde>
  }

  /* fail on too much data */
  if (len > pcb->snd_buf) {
 800f2c8:	687b      	ldr	r3, [r7, #4]
 800f2ca:	2268      	movs	r2, #104	; 0x68
 800f2cc:	5a9b      	ldrh	r3, [r3, r2]
 800f2ce:	1cba      	adds	r2, r7, #2
 800f2d0:	8812      	ldrh	r2, [r2, #0]
 800f2d2:	429a      	cmp	r2, r3
 800f2d4:	d909      	bls.n	800f2ea <tcp_write_checks+0x76>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"TCPWNDSIZE_F")\n",
                len, pcb->snd_buf));
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 800f2d6:	687b      	ldr	r3, [r7, #4]
 800f2d8:	8bdb      	ldrh	r3, [r3, #30]
 800f2da:	2280      	movs	r2, #128	; 0x80
 800f2dc:	4313      	orrs	r3, r2
 800f2de:	b29a      	uxth	r2, r3
 800f2e0:	687b      	ldr	r3, [r7, #4]
 800f2e2:	83da      	strh	r2, [r3, #30]
    return ERR_MEM;
 800f2e4:	2301      	movs	r3, #1
 800f2e6:	425b      	negs	r3, r3
 800f2e8:	e033      	b.n	800f352 <tcp_write_checks+0xde>
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if (pcb->snd_queuelen >= LWIP_MIN(TCP_SND_QUEUELEN, (TCP_SNDQUEUELEN_OVERFLOW + 1))) {
 800f2ea:	687b      	ldr	r3, [r7, #4]
 800f2ec:	226a      	movs	r2, #106	; 0x6a
 800f2ee:	5a9b      	ldrh	r3, [r3, r2]
 800f2f0:	2b07      	cmp	r3, #7
 800f2f2:	d909      	bls.n	800f308 <tcp_write_checks+0x94>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
                pcb->snd_queuelen, (u16_t)TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 800f2f4:	687b      	ldr	r3, [r7, #4]
 800f2f6:	8bdb      	ldrh	r3, [r3, #30]
 800f2f8:	2280      	movs	r2, #128	; 0x80
 800f2fa:	4313      	orrs	r3, r2
 800f2fc:	b29a      	uxth	r2, r3
 800f2fe:	687b      	ldr	r3, [r7, #4]
 800f300:	83da      	strh	r2, [r3, #30]
    return ERR_MEM;
 800f302:	2301      	movs	r3, #1
 800f304:	425b      	negs	r3, r3
 800f306:	e024      	b.n	800f352 <tcp_write_checks+0xde>
  }
  if (pcb->snd_queuelen != 0) {
 800f308:	687b      	ldr	r3, [r7, #4]
 800f30a:	226a      	movs	r2, #106	; 0x6a
 800f30c:	5a9b      	ldrh	r3, [r3, r2]
 800f30e:	2b00      	cmp	r3, #0
 800f310:	d00f      	beq.n	800f332 <tcp_write_checks+0xbe>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
 800f312:	687b      	ldr	r3, [r7, #4]
 800f314:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800f316:	2b00      	cmp	r3, #0
 800f318:	d11a      	bne.n	800f350 <tcp_write_checks+0xdc>
 800f31a:	687b      	ldr	r3, [r7, #4]
 800f31c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800f31e:	2b00      	cmp	r3, #0
 800f320:	d116      	bne.n	800f350 <tcp_write_checks+0xdc>
 800f322:	4b0e      	ldr	r3, [pc, #56]	; (800f35c <tcp_write_checks+0xe8>)
 800f324:	2256      	movs	r2, #86	; 0x56
 800f326:	32ff      	adds	r2, #255	; 0xff
 800f328:	490f      	ldr	r1, [pc, #60]	; (800f368 <tcp_write_checks+0xf4>)
 800f32a:	480e      	ldr	r0, [pc, #56]	; (800f364 <tcp_write_checks+0xf0>)
 800f32c:	f7f2 ff4e 	bl	80021cc <app_debug_rtt_raw>
 800f330:	e00e      	b.n	800f350 <tcp_write_checks+0xdc>
                pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
 800f332:	687b      	ldr	r3, [r7, #4]
 800f334:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800f336:	2b00      	cmp	r3, #0
 800f338:	d103      	bne.n	800f342 <tcp_write_checks+0xce>
 800f33a:	687b      	ldr	r3, [r7, #4]
 800f33c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800f33e:	2b00      	cmp	r3, #0
 800f340:	d006      	beq.n	800f350 <tcp_write_checks+0xdc>
 800f342:	4b06      	ldr	r3, [pc, #24]	; (800f35c <tcp_write_checks+0xe8>)
 800f344:	22ac      	movs	r2, #172	; 0xac
 800f346:	0052      	lsls	r2, r2, #1
 800f348:	4908      	ldr	r1, [pc, #32]	; (800f36c <tcp_write_checks+0xf8>)
 800f34a:	4806      	ldr	r0, [pc, #24]	; (800f364 <tcp_write_checks+0xf0>)
 800f34c:	f7f2 ff3e 	bl	80021cc <app_debug_rtt_raw>
                pcb->unacked == NULL && pcb->unsent == NULL);
  }
  return ERR_OK;
 800f350:	2300      	movs	r3, #0
}
 800f352:	0018      	movs	r0, r3
 800f354:	46bd      	mov	sp, r7
 800f356:	b002      	add	sp, #8
 800f358:	bd80      	pop	{r7, pc}
 800f35a:	46c0      	nop			; (mov r8, r8)
 800f35c:	0801fe14 	.word	0x0801fe14
 800f360:	0801ff54 	.word	0x0801ff54
 800f364:	0801fe60 	.word	0x0801fe60
 800f368:	0801ff74 	.word	0x0801ff74
 800f36c:	0801ffb0 	.word	0x0801ffb0

0800f370 <tcp_write>:
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will not be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
 800f370:	b5b0      	push	{r4, r5, r7, lr}
 800f372:	b09e      	sub	sp, #120	; 0x78
 800f374:	af04      	add	r7, sp, #16
 800f376:	60f8      	str	r0, [r7, #12]
 800f378:	60b9      	str	r1, [r7, #8]
 800f37a:	0019      	movs	r1, r3
 800f37c:	1dbb      	adds	r3, r7, #6
 800f37e:	801a      	strh	r2, [r3, #0]
 800f380:	1d7b      	adds	r3, r7, #5
 800f382:	1c0a      	adds	r2, r1, #0
 800f384:	701a      	strb	r2, [r3, #0]
  struct pbuf *concat_p = NULL;
 800f386:	2300      	movs	r3, #0
 800f388:	64bb      	str	r3, [r7, #72]	; 0x48
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 800f38a:	2300      	movs	r3, #0
 800f38c:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f38e:	2300      	movs	r3, #0
 800f390:	65fb      	str	r3, [r7, #92]	; 0x5c
 800f392:	2300      	movs	r3, #0
 800f394:	65bb      	str	r3, [r7, #88]	; 0x58
 800f396:	2300      	movs	r3, #0
 800f398:	657b      	str	r3, [r7, #84]	; 0x54
  u16_t pos = 0; /* position in 'arg' data */
 800f39a:	2352      	movs	r3, #82	; 0x52
 800f39c:	18fb      	adds	r3, r7, r3
 800f39e:	2200      	movs	r2, #0
 800f3a0:	801a      	strh	r2, [r3, #0]
  u16_t queuelen;
  u8_t optlen;
  u8_t optflags = 0;
 800f3a2:	2333      	movs	r3, #51	; 0x33
 800f3a4:	18fb      	adds	r3, r7, r3
 800f3a6:	2200      	movs	r2, #0
 800f3a8:	701a      	strb	r2, [r3, #0]
#if TCP_OVERSIZE
  u16_t oversize = 0;
 800f3aa:	231e      	movs	r3, #30
 800f3ac:	18fb      	adds	r3, r7, r3
 800f3ae:	2200      	movs	r2, #0
 800f3b0:	801a      	strh	r2, [r3, #0]
  u16_t oversize_used = 0;
 800f3b2:	2362      	movs	r3, #98	; 0x62
 800f3b4:	18fb      	adds	r3, r7, r3
 800f3b6:	2200      	movs	r2, #0
 800f3b8:	801a      	strh	r2, [r3, #0]
#if TCP_OVERSIZE_DBGCHECK
  u16_t oversize_add = 0;
 800f3ba:	2366      	movs	r3, #102	; 0x66
 800f3bc:	18fb      	adds	r3, r7, r3
 800f3be:	2200      	movs	r2, #0
 800f3c0:	801a      	strh	r2, [r3, #0]
#endif /* TCP_OVERSIZE_DBGCHECK*/
#endif /* TCP_OVERSIZE */
  u16_t extendlen = 0;
 800f3c2:	2364      	movs	r3, #100	; 0x64
 800f3c4:	18fb      	adds	r3, r7, r3
 800f3c6:	2200      	movs	r2, #0
 800f3c8:	801a      	strh	r2, [r3, #0]
#if TCP_CHECKSUM_ON_COPY
  u16_t concat_chksum = 0;
 800f3ca:	231c      	movs	r3, #28
 800f3cc:	18fb      	adds	r3, r7, r3
 800f3ce:	2200      	movs	r2, #0
 800f3d0:	801a      	strh	r2, [r3, #0]
  u8_t concat_chksum_swapped = 0;
 800f3d2:	231b      	movs	r3, #27
 800f3d4:	18fb      	adds	r3, r7, r3
 800f3d6:	2200      	movs	r2, #0
 800f3d8:	701a      	strb	r2, [r3, #0]
  u16_t concat_chksummed = 0;
 800f3da:	2346      	movs	r3, #70	; 0x46
 800f3dc:	18fb      	adds	r3, r7, r3
 800f3de:	2200      	movs	r2, #0
 800f3e0:	801a      	strh	r2, [r3, #0]
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  u16_t mss_local;

  LWIP_ERROR("tcp_write: invalid pcb", pcb != NULL, return ERR_ARG);
 800f3e2:	68fb      	ldr	r3, [r7, #12]
 800f3e4:	2b00      	cmp	r3, #0
 800f3e6:	d107      	bne.n	800f3f8 <tcp_write+0x88>
 800f3e8:	4bca      	ldr	r3, [pc, #808]	; (800f714 <tcp_write+0x3a4>)
 800f3ea:	0018      	movs	r0, r3
 800f3ec:	f7f2 feee 	bl	80021cc <app_debug_rtt_raw>
 800f3f0:	2310      	movs	r3, #16
 800f3f2:	425b      	negs	r3, r3
 800f3f4:	f000 fcfb 	bl	800fdee <tcp_write+0xa7e>

  /* don't allocate segments bigger than half the maximum window we ever received */
  mss_local = LWIP_MIN(pcb->mss, TCPWND_MIN16(pcb->snd_wnd_max / 2));
 800f3f8:	68fb      	ldr	r3, [r7, #12]
 800f3fa:	2266      	movs	r2, #102	; 0x66
 800f3fc:	5a9b      	ldrh	r3, [r3, r2]
 800f3fe:	085b      	lsrs	r3, r3, #1
 800f400:	b299      	uxth	r1, r3
 800f402:	68fb      	ldr	r3, [r7, #12]
 800f404:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800f406:	2230      	movs	r2, #48	; 0x30
 800f408:	18ba      	adds	r2, r7, r2
 800f40a:	1c1c      	adds	r4, r3, #0
 800f40c:	1c0b      	adds	r3, r1, #0
 800f40e:	b298      	uxth	r0, r3
 800f410:	b2a1      	uxth	r1, r4
 800f412:	4288      	cmp	r0, r1
 800f414:	d900      	bls.n	800f418 <tcp_write+0xa8>
 800f416:	1c23      	adds	r3, r4, #0
 800f418:	8013      	strh	r3, [r2, #0]
  mss_local = mss_local ? mss_local : pcb->mss;
 800f41a:	2330      	movs	r3, #48	; 0x30
 800f41c:	18fb      	adds	r3, r7, r3
 800f41e:	881b      	ldrh	r3, [r3, #0]
 800f420:	2b00      	cmp	r3, #0
 800f422:	d102      	bne.n	800f42a <tcp_write+0xba>
 800f424:	68fb      	ldr	r3, [r7, #12]
 800f426:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800f428:	e002      	b.n	800f430 <tcp_write+0xc0>
 800f42a:	2330      	movs	r3, #48	; 0x30
 800f42c:	18fb      	adds	r3, r7, r3
 800f42e:	881b      	ldrh	r3, [r3, #0]
 800f430:	2230      	movs	r2, #48	; 0x30
 800f432:	18ba      	adds	r2, r7, r2
 800f434:	8013      	strh	r3, [r2, #0]
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
                                 (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
 800f436:	68bb      	ldr	r3, [r7, #8]
 800f438:	2b00      	cmp	r3, #0
 800f43a:	d107      	bne.n	800f44c <tcp_write+0xdc>
 800f43c:	4bb6      	ldr	r3, [pc, #728]	; (800f718 <tcp_write+0x3a8>)
 800f43e:	0018      	movs	r0, r3
 800f440:	f7f2 fec4 	bl	80021cc <app_debug_rtt_raw>
 800f444:	2310      	movs	r3, #16
 800f446:	425b      	negs	r3, r3
 800f448:	f000 fcd1 	bl	800fdee <tcp_write+0xa7e>
             arg != NULL, return ERR_ARG;);

  err = tcp_write_checks(pcb, len);
 800f44c:	252f      	movs	r5, #47	; 0x2f
 800f44e:	197c      	adds	r4, r7, r5
 800f450:	1dbb      	adds	r3, r7, #6
 800f452:	881a      	ldrh	r2, [r3, #0]
 800f454:	68fb      	ldr	r3, [r7, #12]
 800f456:	0011      	movs	r1, r2
 800f458:	0018      	movs	r0, r3
 800f45a:	f7ff ff0b 	bl	800f274 <tcp_write_checks>
 800f45e:	0003      	movs	r3, r0
 800f460:	7023      	strb	r3, [r4, #0]
  if (err != ERR_OK) {
 800f462:	197b      	adds	r3, r7, r5
 800f464:	781b      	ldrb	r3, [r3, #0]
 800f466:	b25b      	sxtb	r3, r3
 800f468:	2b00      	cmp	r3, #0
 800f46a:	d004      	beq.n	800f476 <tcp_write+0x106>
    return err;
 800f46c:	197b      	adds	r3, r7, r5
 800f46e:	781b      	ldrb	r3, [r3, #0]
 800f470:	b25b      	sxtb	r3, r3
 800f472:	f000 fcbc 	bl	800fdee <tcp_write+0xa7e>
  }
  queuelen = pcb->snd_queuelen;
 800f476:	2350      	movs	r3, #80	; 0x50
 800f478:	18fb      	adds	r3, r7, r3
 800f47a:	68fa      	ldr	r2, [r7, #12]
 800f47c:	216a      	movs	r1, #106	; 0x6a
 800f47e:	5a52      	ldrh	r2, [r2, r1]
 800f480:	801a      	strh	r2, [r3, #0]
    /* ensure that segments can hold at least one data byte... */
    mss_local = LWIP_MAX(mss_local, LWIP_TCP_OPT_LEN_TS + 1);
  } else
#endif /* LWIP_TCP_TIMESTAMPS */
  {
    optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 800f482:	232e      	movs	r3, #46	; 0x2e
 800f484:	18fb      	adds	r3, r7, r3
 800f486:	2200      	movs	r2, #0
 800f488:	701a      	strb	r2, [r3, #0]
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
 800f48a:	68fb      	ldr	r3, [r7, #12]
 800f48c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800f48e:	2b00      	cmp	r3, #0
 800f490:	d100      	bne.n	800f494 <tcp_write+0x124>
 800f492:	e19e      	b.n	800f7d2 <tcp_write+0x462>
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 800f494:	68fb      	ldr	r3, [r7, #12]
 800f496:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800f498:	64fb      	str	r3, [r7, #76]	; 0x4c
 800f49a:	e002      	b.n	800f4a2 <tcp_write+0x132>
         last_unsent = last_unsent->next);
 800f49c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f49e:	681b      	ldr	r3, [r3, #0]
 800f4a0:	64fb      	str	r3, [r7, #76]	; 0x4c
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 800f4a2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f4a4:	681b      	ldr	r3, [r3, #0]
 800f4a6:	2b00      	cmp	r3, #0
 800f4a8:	d1f8      	bne.n	800f49c <tcp_write+0x12c>

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(last_unsent->flags, pcb);
 800f4aa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f4ac:	7bdb      	ldrb	r3, [r3, #15]
 800f4ae:	009b      	lsls	r3, r3, #2
 800f4b0:	b29a      	uxth	r2, r3
 800f4b2:	202c      	movs	r0, #44	; 0x2c
 800f4b4:	183b      	adds	r3, r7, r0
 800f4b6:	2104      	movs	r1, #4
 800f4b8:	400a      	ands	r2, r1
 800f4ba:	801a      	strh	r2, [r3, #0]
    LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
 800f4bc:	2330      	movs	r3, #48	; 0x30
 800f4be:	18fb      	adds	r3, r7, r3
 800f4c0:	881a      	ldrh	r2, [r3, #0]
 800f4c2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f4c4:	891b      	ldrh	r3, [r3, #8]
 800f4c6:	0019      	movs	r1, r3
 800f4c8:	183b      	adds	r3, r7, r0
 800f4ca:	881b      	ldrh	r3, [r3, #0]
 800f4cc:	18cb      	adds	r3, r1, r3
 800f4ce:	429a      	cmp	r2, r3
 800f4d0:	da06      	bge.n	800f4e0 <tcp_write+0x170>
 800f4d2:	4b92      	ldr	r3, [pc, #584]	; (800f71c <tcp_write+0x3ac>)
 800f4d4:	22f3      	movs	r2, #243	; 0xf3
 800f4d6:	0052      	lsls	r2, r2, #1
 800f4d8:	4991      	ldr	r1, [pc, #580]	; (800f720 <tcp_write+0x3b0>)
 800f4da:	4892      	ldr	r0, [pc, #584]	; (800f724 <tcp_write+0x3b4>)
 800f4dc:	f7f2 fe76 	bl	80021cc <app_debug_rtt_raw>
    space = mss_local - (last_unsent->len + unsent_optlen);
 800f4e0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f4e2:	891a      	ldrh	r2, [r3, #8]
 800f4e4:	232c      	movs	r3, #44	; 0x2c
 800f4e6:	18fb      	adds	r3, r7, r3
 800f4e8:	881b      	ldrh	r3, [r3, #0]
 800f4ea:	18d3      	adds	r3, r2, r3
 800f4ec:	b29a      	uxth	r2, r3
 800f4ee:	2344      	movs	r3, #68	; 0x44
 800f4f0:	18fb      	adds	r3, r7, r3
 800f4f2:	2130      	movs	r1, #48	; 0x30
 800f4f4:	1879      	adds	r1, r7, r1
 800f4f6:	8809      	ldrh	r1, [r1, #0]
 800f4f8:	1a8a      	subs	r2, r1, r2
 800f4fa:	801a      	strh	r2, [r3, #0]
     * function.
     */
#if TCP_OVERSIZE
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->oversize_left */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
 800f4fc:	68fb      	ldr	r3, [r7, #12]
 800f4fe:	226c      	movs	r2, #108	; 0x6c
 800f500:	5a9a      	ldrh	r2, [r3, r2]
 800f502:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f504:	895b      	ldrh	r3, [r3, #10]
 800f506:	429a      	cmp	r2, r3
 800f508:	d006      	beq.n	800f518 <tcp_write+0x1a8>
 800f50a:	4b84      	ldr	r3, [pc, #528]	; (800f71c <tcp_write+0x3ac>)
 800f50c:	22f4      	movs	r2, #244	; 0xf4
 800f50e:	32ff      	adds	r2, #255	; 0xff
 800f510:	4985      	ldr	r1, [pc, #532]	; (800f728 <tcp_write+0x3b8>)
 800f512:	4884      	ldr	r0, [pc, #528]	; (800f724 <tcp_write+0x3b4>)
 800f514:	f7f2 fe5a 	bl	80021cc <app_debug_rtt_raw>
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
 800f518:	68fb      	ldr	r3, [r7, #12]
 800f51a:	226c      	movs	r2, #108	; 0x6c
 800f51c:	5a9a      	ldrh	r2, [r3, r2]
 800f51e:	211e      	movs	r1, #30
 800f520:	187b      	adds	r3, r7, r1
 800f522:	801a      	strh	r2, [r3, #0]
    if (oversize > 0) {
 800f524:	000a      	movs	r2, r1
 800f526:	18bb      	adds	r3, r7, r2
 800f528:	881b      	ldrh	r3, [r3, #0]
 800f52a:	2b00      	cmp	r3, #0
 800f52c:	d041      	beq.n	800f5b2 <tcp_write+0x242>
      LWIP_ASSERT("inconsistent oversize vs. space", oversize <= space);
 800f52e:	18bb      	adds	r3, r7, r2
 800f530:	881b      	ldrh	r3, [r3, #0]
 800f532:	2244      	movs	r2, #68	; 0x44
 800f534:	18ba      	adds	r2, r7, r2
 800f536:	8812      	ldrh	r2, [r2, #0]
 800f538:	429a      	cmp	r2, r3
 800f53a:	d206      	bcs.n	800f54a <tcp_write+0x1da>
 800f53c:	4b77      	ldr	r3, [pc, #476]	; (800f71c <tcp_write+0x3ac>)
 800f53e:	22fc      	movs	r2, #252	; 0xfc
 800f540:	0052      	lsls	r2, r2, #1
 800f542:	497a      	ldr	r1, [pc, #488]	; (800f72c <tcp_write+0x3bc>)
 800f544:	4877      	ldr	r0, [pc, #476]	; (800f724 <tcp_write+0x3b4>)
 800f546:	f7f2 fe41 	bl	80021cc <app_debug_rtt_raw>
      seg = last_unsent;
 800f54a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f54c:	65fb      	str	r3, [r7, #92]	; 0x5c
      oversize_used = LWIP_MIN(space, LWIP_MIN(oversize, len));
 800f54e:	231e      	movs	r3, #30
 800f550:	18fb      	adds	r3, r7, r3
 800f552:	881a      	ldrh	r2, [r3, #0]
 800f554:	1dbb      	adds	r3, r7, #6
 800f556:	1c10      	adds	r0, r2, #0
 800f558:	881b      	ldrh	r3, [r3, #0]
 800f55a:	b299      	uxth	r1, r3
 800f55c:	b282      	uxth	r2, r0
 800f55e:	4291      	cmp	r1, r2
 800f560:	d900      	bls.n	800f564 <tcp_write+0x1f4>
 800f562:	1c03      	adds	r3, r0, #0
 800f564:	b299      	uxth	r1, r3
 800f566:	2362      	movs	r3, #98	; 0x62
 800f568:	18fa      	adds	r2, r7, r3
 800f56a:	2344      	movs	r3, #68	; 0x44
 800f56c:	18fb      	adds	r3, r7, r3
 800f56e:	1c0c      	adds	r4, r1, #0
 800f570:	881b      	ldrh	r3, [r3, #0]
 800f572:	b298      	uxth	r0, r3
 800f574:	b2a1      	uxth	r1, r4
 800f576:	4288      	cmp	r0, r1
 800f578:	d900      	bls.n	800f57c <tcp_write+0x20c>
 800f57a:	1c23      	adds	r3, r4, #0
 800f57c:	8013      	strh	r3, [r2, #0]
      pos += oversize_used;
 800f57e:	2252      	movs	r2, #82	; 0x52
 800f580:	18bb      	adds	r3, r7, r2
 800f582:	18b9      	adds	r1, r7, r2
 800f584:	2062      	movs	r0, #98	; 0x62
 800f586:	183a      	adds	r2, r7, r0
 800f588:	8809      	ldrh	r1, [r1, #0]
 800f58a:	8812      	ldrh	r2, [r2, #0]
 800f58c:	188a      	adds	r2, r1, r2
 800f58e:	801a      	strh	r2, [r3, #0]
      oversize -= oversize_used;
 800f590:	211e      	movs	r1, #30
 800f592:	187b      	adds	r3, r7, r1
 800f594:	881a      	ldrh	r2, [r3, #0]
 800f596:	183b      	adds	r3, r7, r0
 800f598:	881b      	ldrh	r3, [r3, #0]
 800f59a:	1ad3      	subs	r3, r2, r3
 800f59c:	b29a      	uxth	r2, r3
 800f59e:	187b      	adds	r3, r7, r1
 800f5a0:	801a      	strh	r2, [r3, #0]
      space -= oversize_used;
 800f5a2:	2244      	movs	r2, #68	; 0x44
 800f5a4:	18bb      	adds	r3, r7, r2
 800f5a6:	18b9      	adds	r1, r7, r2
 800f5a8:	183a      	adds	r2, r7, r0
 800f5aa:	8809      	ldrh	r1, [r1, #0]
 800f5ac:	8812      	ldrh	r2, [r2, #0]
 800f5ae:	1a8a      	subs	r2, r1, r2
 800f5b0:	801a      	strh	r2, [r3, #0]
    }
    /* now we are either finished or oversize is zero */
    LWIP_ASSERT("inconsistent oversize vs. len", (oversize == 0) || (pos == len));
 800f5b2:	231e      	movs	r3, #30
 800f5b4:	18fb      	adds	r3, r7, r3
 800f5b6:	881b      	ldrh	r3, [r3, #0]
 800f5b8:	2b00      	cmp	r3, #0
 800f5ba:	d00d      	beq.n	800f5d8 <tcp_write+0x268>
 800f5bc:	2352      	movs	r3, #82	; 0x52
 800f5be:	18fa      	adds	r2, r7, r3
 800f5c0:	1dbb      	adds	r3, r7, #6
 800f5c2:	8812      	ldrh	r2, [r2, #0]
 800f5c4:	881b      	ldrh	r3, [r3, #0]
 800f5c6:	429a      	cmp	r2, r3
 800f5c8:	d006      	beq.n	800f5d8 <tcp_write+0x268>
 800f5ca:	4b54      	ldr	r3, [pc, #336]	; (800f71c <tcp_write+0x3ac>)
 800f5cc:	2280      	movs	r2, #128	; 0x80
 800f5ce:	0092      	lsls	r2, r2, #2
 800f5d0:	4957      	ldr	r1, [pc, #348]	; (800f730 <tcp_write+0x3c0>)
 800f5d2:	4854      	ldr	r0, [pc, #336]	; (800f724 <tcp_write+0x3b4>)
 800f5d4:	f7f2 fdfa 	bl	80021cc <app_debug_rtt_raw>
     *
     * This phase is skipped for LWIP_NETIF_TX_SINGLE_PBUF as we could only execute
     * it after rexmit puts a segment from unacked to unsent and at this point,
     * oversize info is lost.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 800f5d8:	2152      	movs	r1, #82	; 0x52
 800f5da:	187a      	adds	r2, r7, r1
 800f5dc:	1dbb      	adds	r3, r7, #6
 800f5de:	8812      	ldrh	r2, [r2, #0]
 800f5e0:	881b      	ldrh	r3, [r3, #0]
 800f5e2:	429a      	cmp	r2, r3
 800f5e4:	d300      	bcc.n	800f5e8 <tcp_write+0x278>
 800f5e6:	e23b      	b.n	800fa60 <tcp_write+0x6f0>
 800f5e8:	2044      	movs	r0, #68	; 0x44
 800f5ea:	183b      	adds	r3, r7, r0
 800f5ec:	881b      	ldrh	r3, [r3, #0]
 800f5ee:	2b00      	cmp	r3, #0
 800f5f0:	d100      	bne.n	800f5f4 <tcp_write+0x284>
 800f5f2:	e235      	b.n	800fa60 <tcp_write+0x6f0>
 800f5f4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f5f6:	891b      	ldrh	r3, [r3, #8]
 800f5f8:	2b00      	cmp	r3, #0
 800f5fa:	d100      	bne.n	800f5fe <tcp_write+0x28e>
 800f5fc:	e230      	b.n	800fa60 <tcp_write+0x6f0>
      u16_t seglen = LWIP_MIN(space, len - pos);
 800f5fe:	1dbb      	adds	r3, r7, #6
 800f600:	881a      	ldrh	r2, [r3, #0]
 800f602:	187b      	adds	r3, r7, r1
 800f604:	881b      	ldrh	r3, [r3, #0]
 800f606:	1ad2      	subs	r2, r2, r3
 800f608:	183b      	adds	r3, r7, r0
 800f60a:	881b      	ldrh	r3, [r3, #0]
 800f60c:	429a      	cmp	r2, r3
 800f60e:	dd00      	ble.n	800f612 <tcp_write+0x2a2>
 800f610:	001a      	movs	r2, r3
 800f612:	242a      	movs	r4, #42	; 0x2a
 800f614:	193b      	adds	r3, r7, r4
 800f616:	801a      	strh	r2, [r3, #0]
      seg = last_unsent;
 800f618:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f61a:	65fb      	str	r3, [r7, #92]	; 0x5c

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 800f61c:	1d7b      	adds	r3, r7, #5
 800f61e:	781b      	ldrb	r3, [r3, #0]
 800f620:	2201      	movs	r2, #1
 800f622:	4013      	ands	r3, r2
 800f624:	d04b      	beq.n	800f6be <tcp_write+0x34e>
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
 800f626:	251e      	movs	r5, #30
 800f628:	1978      	adds	r0, r7, r5
 800f62a:	2344      	movs	r3, #68	; 0x44
 800f62c:	18fb      	adds	r3, r7, r3
 800f62e:	881a      	ldrh	r2, [r3, #0]
 800f630:	193b      	adds	r3, r7, r4
 800f632:	8819      	ldrh	r1, [r3, #0]
 800f634:	2301      	movs	r3, #1
 800f636:	9302      	str	r3, [sp, #8]
 800f638:	1d7b      	adds	r3, r7, #5
 800f63a:	781b      	ldrb	r3, [r3, #0]
 800f63c:	9301      	str	r3, [sp, #4]
 800f63e:	68fb      	ldr	r3, [r7, #12]
 800f640:	9300      	str	r3, [sp, #0]
 800f642:	0003      	movs	r3, r0
 800f644:	2000      	movs	r0, #0
 800f646:	f7ff fd3b 	bl	800f0c0 <tcp_pbuf_prealloc>
 800f64a:	0003      	movs	r3, r0
 800f64c:	64bb      	str	r3, [r7, #72]	; 0x48
 800f64e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f650:	2b00      	cmp	r3, #0
 800f652:	d101      	bne.n	800f658 <tcp_write+0x2e8>
 800f654:	f000 fb98 	bl	800fd88 <tcp_write+0xa18>
                      ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
                       seglen));
          goto memerr;
        }
#if TCP_OVERSIZE_DBGCHECK
        oversize_add = oversize;
 800f658:	2366      	movs	r3, #102	; 0x66
 800f65a:	18fb      	adds	r3, r7, r3
 800f65c:	197a      	adds	r2, r7, r5
 800f65e:	8812      	ldrh	r2, [r2, #0]
 800f660:	801a      	strh	r2, [r3, #0]
#endif /* TCP_OVERSIZE_DBGCHECK */
        TCP_DATA_COPY2(concat_p->payload, (const u8_t *)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
 800f662:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f664:	6858      	ldr	r0, [r3, #4]
 800f666:	2352      	movs	r3, #82	; 0x52
 800f668:	18fb      	adds	r3, r7, r3
 800f66a:	881b      	ldrh	r3, [r3, #0]
 800f66c:	68ba      	ldr	r2, [r7, #8]
 800f66e:	18d1      	adds	r1, r2, r3
 800f670:	0025      	movs	r5, r4
 800f672:	193b      	adds	r3, r7, r4
 800f674:	881b      	ldrh	r3, [r3, #0]
 800f676:	001a      	movs	r2, r3
 800f678:	f7f8 fba9 	bl	8007dce <lwip_chksum_copy>
 800f67c:	0003      	movs	r3, r0
 800f67e:	001c      	movs	r4, r3
 800f680:	231b      	movs	r3, #27
 800f682:	18f8      	adds	r0, r7, r3
 800f684:	231c      	movs	r3, #28
 800f686:	18fa      	adds	r2, r7, r3
 800f688:	197b      	adds	r3, r7, r5
 800f68a:	8819      	ldrh	r1, [r3, #0]
 800f68c:	0003      	movs	r3, r0
 800f68e:	0020      	movs	r0, r4
 800f690:	f7ff fdb2 	bl	800f1f8 <tcp_seg_add_chksum>
#if TCP_CHECKSUM_ON_COPY
        concat_chksummed += seglen;
 800f694:	2246      	movs	r2, #70	; 0x46
 800f696:	18bb      	adds	r3, r7, r2
 800f698:	18b9      	adds	r1, r7, r2
 800f69a:	197a      	adds	r2, r7, r5
 800f69c:	8809      	ldrh	r1, [r1, #0]
 800f69e:	8812      	ldrh	r2, [r2, #0]
 800f6a0:	188a      	adds	r2, r1, r2
 800f6a2:	801a      	strh	r2, [r3, #0]
#endif /* TCP_CHECKSUM_ON_COPY */
        queuelen += pbuf_clen(concat_p);
 800f6a4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f6a6:	0018      	movs	r0, r3
 800f6a8:	f7fa f894 	bl	80097d4 <pbuf_clen>
 800f6ac:	0003      	movs	r3, r0
 800f6ae:	0019      	movs	r1, r3
 800f6b0:	2250      	movs	r2, #80	; 0x50
 800f6b2:	18bb      	adds	r3, r7, r2
 800f6b4:	18ba      	adds	r2, r7, r2
 800f6b6:	8812      	ldrh	r2, [r2, #0]
 800f6b8:	188a      	adds	r2, r1, r2
 800f6ba:	801a      	strh	r2, [r3, #0]
 800f6bc:	e07f      	b.n	800f7be <tcp_write+0x44e>
      } else {
        /* Data is not copied */
        /* If the last unsent pbuf is of type PBUF_ROM, try to extend it. */
        struct pbuf *p;
        for (p = last_unsent->p; p->next != NULL; p = p->next);
 800f6be:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800f6c0:	685b      	ldr	r3, [r3, #4]
 800f6c2:	643b      	str	r3, [r7, #64]	; 0x40
 800f6c4:	e002      	b.n	800f6cc <tcp_write+0x35c>
 800f6c6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f6c8:	681b      	ldr	r3, [r3, #0]
 800f6ca:	643b      	str	r3, [r7, #64]	; 0x40
 800f6cc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f6ce:	681b      	ldr	r3, [r3, #0]
 800f6d0:	2b00      	cmp	r3, #0
 800f6d2:	d1f8      	bne.n	800f6c6 <tcp_write+0x356>
        if (((p->type_internal & (PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_DATA_VOLATILE)) == 0) &&
 800f6d4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f6d6:	7b1b      	ldrb	r3, [r3, #12]
 800f6d8:	001a      	movs	r2, r3
 800f6da:	23c0      	movs	r3, #192	; 0xc0
 800f6dc:	4013      	ands	r3, r2
 800f6de:	d12d      	bne.n	800f73c <tcp_write+0x3cc>
            (const u8_t *)p->payload + p->len == (const u8_t *)arg) {
 800f6e0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800f6e2:	685b      	ldr	r3, [r3, #4]
 800f6e4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800f6e6:	8952      	ldrh	r2, [r2, #10]
 800f6e8:	189b      	adds	r3, r3, r2
        if (((p->type_internal & (PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_DATA_VOLATILE)) == 0) &&
 800f6ea:	68ba      	ldr	r2, [r7, #8]
 800f6ec:	429a      	cmp	r2, r3
 800f6ee:	d125      	bne.n	800f73c <tcp_write+0x3cc>
          LWIP_ASSERT("tcp_write: ROM pbufs cannot be oversized", pos == 0);
 800f6f0:	2352      	movs	r3, #82	; 0x52
 800f6f2:	18fb      	adds	r3, r7, r3
 800f6f4:	881b      	ldrh	r3, [r3, #0]
 800f6f6:	2b00      	cmp	r3, #0
 800f6f8:	d005      	beq.n	800f706 <tcp_write+0x396>
 800f6fa:	4b08      	ldr	r3, [pc, #32]	; (800f71c <tcp_write+0x3ac>)
 800f6fc:	4a0d      	ldr	r2, [pc, #52]	; (800f734 <tcp_write+0x3c4>)
 800f6fe:	490e      	ldr	r1, [pc, #56]	; (800f738 <tcp_write+0x3c8>)
 800f700:	4808      	ldr	r0, [pc, #32]	; (800f724 <tcp_write+0x3b4>)
 800f702:	f7f2 fd63 	bl	80021cc <app_debug_rtt_raw>
          extendlen = seglen;
 800f706:	2364      	movs	r3, #100	; 0x64
 800f708:	18fb      	adds	r3, r7, r3
 800f70a:	222a      	movs	r2, #42	; 0x2a
 800f70c:	18ba      	adds	r2, r7, r2
 800f70e:	8812      	ldrh	r2, [r2, #0]
 800f710:	801a      	strh	r2, [r3, #0]
 800f712:	e034      	b.n	800f77e <tcp_write+0x40e>
 800f714:	0801ffe4 	.word	0x0801ffe4
 800f718:	0801fffc 	.word	0x0801fffc
 800f71c:	0801fe14 	.word	0x0801fe14
 800f720:	08020030 	.word	0x08020030
 800f724:	0801fe60 	.word	0x0801fe60
 800f728:	08020048 	.word	0x08020048
 800f72c:	08020078 	.word	0x08020078
 800f730:	08020098 	.word	0x08020098
 800f734:	00000231 	.word	0x00000231
 800f738:	080200b8 	.word	0x080200b8
        } else {
          if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
 800f73c:	232a      	movs	r3, #42	; 0x2a
 800f73e:	18fb      	adds	r3, r7, r3
 800f740:	881b      	ldrh	r3, [r3, #0]
 800f742:	2201      	movs	r2, #1
 800f744:	0019      	movs	r1, r3
 800f746:	2000      	movs	r0, #0
 800f748:	f7f9 fc2c 	bl	8008fa4 <pbuf_alloc>
 800f74c:	0003      	movs	r3, r0
 800f74e:	64bb      	str	r3, [r7, #72]	; 0x48
 800f750:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f752:	2b00      	cmp	r3, #0
 800f754:	d100      	bne.n	800f758 <tcp_write+0x3e8>
 800f756:	e319      	b.n	800fd8c <tcp_write+0xa1c>
            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                        ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
            goto memerr;
          }
          /* reference the non-volatile payload data */
          ((struct pbuf_rom *)concat_p)->payload = (const u8_t *)arg + pos;
 800f758:	2352      	movs	r3, #82	; 0x52
 800f75a:	18fb      	adds	r3, r7, r3
 800f75c:	881b      	ldrh	r3, [r3, #0]
 800f75e:	68ba      	ldr	r2, [r7, #8]
 800f760:	18d2      	adds	r2, r2, r3
 800f762:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f764:	605a      	str	r2, [r3, #4]
          queuelen += pbuf_clen(concat_p);
 800f766:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800f768:	0018      	movs	r0, r3
 800f76a:	f7fa f833 	bl	80097d4 <pbuf_clen>
 800f76e:	0003      	movs	r3, r0
 800f770:	0019      	movs	r1, r3
 800f772:	2250      	movs	r2, #80	; 0x50
 800f774:	18bb      	adds	r3, r7, r2
 800f776:	18ba      	adds	r2, r7, r2
 800f778:	8812      	ldrh	r2, [r2, #0]
 800f77a:	188a      	adds	r2, r1, r2
 800f77c:	801a      	strh	r2, [r3, #0]
        }
#if TCP_CHECKSUM_ON_COPY
        /* calculate the checksum of nocopy-data */
        tcp_seg_add_chksum(~inet_chksum((const u8_t *)arg + pos, seglen), seglen,
 800f77e:	2352      	movs	r3, #82	; 0x52
 800f780:	18fb      	adds	r3, r7, r3
 800f782:	881b      	ldrh	r3, [r3, #0]
 800f784:	68ba      	ldr	r2, [r7, #8]
 800f786:	18d2      	adds	r2, r2, r3
 800f788:	252a      	movs	r5, #42	; 0x2a
 800f78a:	197b      	adds	r3, r7, r5
 800f78c:	881b      	ldrh	r3, [r3, #0]
 800f78e:	0019      	movs	r1, r3
 800f790:	0010      	movs	r0, r2
 800f792:	f7f8 fab7 	bl	8007d04 <inet_chksum>
 800f796:	0003      	movs	r3, r0
 800f798:	43db      	mvns	r3, r3
 800f79a:	b298      	uxth	r0, r3
 800f79c:	231b      	movs	r3, #27
 800f79e:	18fc      	adds	r4, r7, r3
 800f7a0:	231c      	movs	r3, #28
 800f7a2:	18fa      	adds	r2, r7, r3
 800f7a4:	197b      	adds	r3, r7, r5
 800f7a6:	8819      	ldrh	r1, [r3, #0]
 800f7a8:	0023      	movs	r3, r4
 800f7aa:	f7ff fd25 	bl	800f1f8 <tcp_seg_add_chksum>
                           &concat_chksum, &concat_chksum_swapped);
        concat_chksummed += seglen;
 800f7ae:	2246      	movs	r2, #70	; 0x46
 800f7b0:	18bb      	adds	r3, r7, r2
 800f7b2:	18b9      	adds	r1, r7, r2
 800f7b4:	197a      	adds	r2, r7, r5
 800f7b6:	8809      	ldrh	r1, [r1, #0]
 800f7b8:	8812      	ldrh	r2, [r2, #0]
 800f7ba:	188a      	adds	r2, r1, r2
 800f7bc:	801a      	strh	r2, [r3, #0]
#endif /* TCP_CHECKSUM_ON_COPY */
      }

      pos += seglen;
 800f7be:	2252      	movs	r2, #82	; 0x52
 800f7c0:	18bb      	adds	r3, r7, r2
 800f7c2:	18b9      	adds	r1, r7, r2
 800f7c4:	222a      	movs	r2, #42	; 0x2a
 800f7c6:	18ba      	adds	r2, r7, r2
 800f7c8:	8809      	ldrh	r1, [r1, #0]
 800f7ca:	8812      	ldrh	r2, [r2, #0]
 800f7cc:	188a      	adds	r2, r1, r2
 800f7ce:	801a      	strh	r2, [r3, #0]
 800f7d0:	e146      	b.n	800fa60 <tcp_write+0x6f0>
    }
#endif /* !LWIP_NETIF_TX_SINGLE_PBUF */
  } else {
#if TCP_OVERSIZE
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
 800f7d2:	68fb      	ldr	r3, [r7, #12]
 800f7d4:	226c      	movs	r2, #108	; 0x6c
 800f7d6:	5a9b      	ldrh	r3, [r3, r2]
 800f7d8:	2b00      	cmp	r3, #0
 800f7da:	d100      	bne.n	800f7de <tcp_write+0x46e>
 800f7dc:	e140      	b.n	800fa60 <tcp_write+0x6f0>
 800f7de:	4bb1      	ldr	r3, [pc, #708]	; (800faa4 <tcp_write+0x734>)
 800f7e0:	4ab1      	ldr	r2, [pc, #708]	; (800faa8 <tcp_write+0x738>)
 800f7e2:	49b2      	ldr	r1, [pc, #712]	; (800faac <tcp_write+0x73c>)
 800f7e4:	48b2      	ldr	r0, [pc, #712]	; (800fab0 <tcp_write+0x740>)
 800f7e6:	f7f2 fcf1 	bl	80021cc <app_debug_rtt_raw>
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 800f7ea:	e139      	b.n	800fa60 <tcp_write+0x6f0>
    struct pbuf *p;
    u16_t left = len - pos;
 800f7ec:	2028      	movs	r0, #40	; 0x28
 800f7ee:	183b      	adds	r3, r7, r0
 800f7f0:	1db9      	adds	r1, r7, #6
 800f7f2:	2252      	movs	r2, #82	; 0x52
 800f7f4:	18ba      	adds	r2, r7, r2
 800f7f6:	8809      	ldrh	r1, [r1, #0]
 800f7f8:	8812      	ldrh	r2, [r2, #0]
 800f7fa:	1a8a      	subs	r2, r1, r2
 800f7fc:	801a      	strh	r2, [r3, #0]
    u16_t max_len = mss_local - optlen;
 800f7fe:	232e      	movs	r3, #46	; 0x2e
 800f800:	18fb      	adds	r3, r7, r3
 800f802:	781b      	ldrb	r3, [r3, #0]
 800f804:	b29a      	uxth	r2, r3
 800f806:	2426      	movs	r4, #38	; 0x26
 800f808:	193b      	adds	r3, r7, r4
 800f80a:	2130      	movs	r1, #48	; 0x30
 800f80c:	1879      	adds	r1, r7, r1
 800f80e:	8809      	ldrh	r1, [r1, #0]
 800f810:	1a8a      	subs	r2, r1, r2
 800f812:	801a      	strh	r2, [r3, #0]
    u16_t seglen = LWIP_MIN(left, max_len);
 800f814:	2324      	movs	r3, #36	; 0x24
 800f816:	18fa      	adds	r2, r7, r3
 800f818:	193b      	adds	r3, r7, r4
 800f81a:	1839      	adds	r1, r7, r0
 800f81c:	880c      	ldrh	r4, [r1, #0]
 800f81e:	881b      	ldrh	r3, [r3, #0]
 800f820:	b298      	uxth	r0, r3
 800f822:	b2a1      	uxth	r1, r4
 800f824:	4288      	cmp	r0, r1
 800f826:	d900      	bls.n	800f82a <tcp_write+0x4ba>
 800f828:	1c23      	adds	r3, r4, #0
 800f82a:	8013      	strh	r3, [r2, #0]
#if TCP_CHECKSUM_ON_COPY
    u16_t chksum = 0;
 800f82c:	2318      	movs	r3, #24
 800f82e:	18fb      	adds	r3, r7, r3
 800f830:	2200      	movs	r2, #0
 800f832:	801a      	strh	r2, [r3, #0]
    u8_t chksum_swapped = 0;
 800f834:	2317      	movs	r3, #23
 800f836:	18fb      	adds	r3, r7, r3
 800f838:	2200      	movs	r2, #0
 800f83a:	701a      	strb	r2, [r3, #0]
#endif /* TCP_CHECKSUM_ON_COPY */

    if (apiflags & TCP_WRITE_FLAG_COPY) {
 800f83c:	1d7b      	adds	r3, r7, #5
 800f83e:	781b      	ldrb	r3, [r3, #0]
 800f840:	2201      	movs	r2, #1
 800f842:	4013      	ands	r3, r2
 800f844:	d04c      	beq.n	800f8e0 <tcp_write+0x570>
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
 800f846:	232e      	movs	r3, #46	; 0x2e
 800f848:	18fb      	adds	r3, r7, r3
 800f84a:	781b      	ldrb	r3, [r3, #0]
 800f84c:	b29a      	uxth	r2, r3
 800f84e:	2524      	movs	r5, #36	; 0x24
 800f850:	197b      	adds	r3, r7, r5
 800f852:	881b      	ldrh	r3, [r3, #0]
 800f854:	18d3      	adds	r3, r2, r3
 800f856:	b299      	uxth	r1, r3
 800f858:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800f85a:	425a      	negs	r2, r3
 800f85c:	4153      	adcs	r3, r2
 800f85e:	b2db      	uxtb	r3, r3
 800f860:	001c      	movs	r4, r3
 800f862:	231e      	movs	r3, #30
 800f864:	18f8      	adds	r0, r7, r3
 800f866:	2330      	movs	r3, #48	; 0x30
 800f868:	18fb      	adds	r3, r7, r3
 800f86a:	881a      	ldrh	r2, [r3, #0]
 800f86c:	9402      	str	r4, [sp, #8]
 800f86e:	1d7b      	adds	r3, r7, #5
 800f870:	781b      	ldrb	r3, [r3, #0]
 800f872:	9301      	str	r3, [sp, #4]
 800f874:	68fb      	ldr	r3, [r7, #12]
 800f876:	9300      	str	r3, [sp, #0]
 800f878:	0003      	movs	r3, r0
 800f87a:	2038      	movs	r0, #56	; 0x38
 800f87c:	f7ff fc20 	bl	800f0c0 <tcp_pbuf_prealloc>
 800f880:	0003      	movs	r3, r0
 800f882:	63fb      	str	r3, [r7, #60]	; 0x3c
 800f884:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f886:	2b00      	cmp	r3, #0
 800f888:	d100      	bne.n	800f88c <tcp_write+0x51c>
 800f88a:	e281      	b.n	800fd90 <tcp_write+0xa20>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
 800f88c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f88e:	895b      	ldrh	r3, [r3, #10]
 800f890:	197a      	adds	r2, r7, r5
 800f892:	8812      	ldrh	r2, [r2, #0]
 800f894:	429a      	cmp	r2, r3
 800f896:	d905      	bls.n	800f8a4 <tcp_write+0x534>
 800f898:	4b82      	ldr	r3, [pc, #520]	; (800faa4 <tcp_write+0x734>)
 800f89a:	4a86      	ldr	r2, [pc, #536]	; (800fab4 <tcp_write+0x744>)
 800f89c:	4986      	ldr	r1, [pc, #536]	; (800fab8 <tcp_write+0x748>)
 800f89e:	4884      	ldr	r0, [pc, #528]	; (800fab0 <tcp_write+0x740>)
 800f8a0:	f7f2 fc94 	bl	80021cc <app_debug_rtt_raw>
                  (p->len >= seglen));
      TCP_DATA_COPY2((char *)p->payload + optlen, (const u8_t *)arg + pos, seglen, &chksum, &chksum_swapped);
 800f8a4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f8a6:	685a      	ldr	r2, [r3, #4]
 800f8a8:	232e      	movs	r3, #46	; 0x2e
 800f8aa:	18fb      	adds	r3, r7, r3
 800f8ac:	781b      	ldrb	r3, [r3, #0]
 800f8ae:	18d0      	adds	r0, r2, r3
 800f8b0:	2352      	movs	r3, #82	; 0x52
 800f8b2:	18fb      	adds	r3, r7, r3
 800f8b4:	881b      	ldrh	r3, [r3, #0]
 800f8b6:	68ba      	ldr	r2, [r7, #8]
 800f8b8:	18d1      	adds	r1, r2, r3
 800f8ba:	2524      	movs	r5, #36	; 0x24
 800f8bc:	197b      	adds	r3, r7, r5
 800f8be:	881b      	ldrh	r3, [r3, #0]
 800f8c0:	001a      	movs	r2, r3
 800f8c2:	f7f8 fa84 	bl	8007dce <lwip_chksum_copy>
 800f8c6:	0003      	movs	r3, r0
 800f8c8:	001c      	movs	r4, r3
 800f8ca:	2317      	movs	r3, #23
 800f8cc:	18f8      	adds	r0, r7, r3
 800f8ce:	2318      	movs	r3, #24
 800f8d0:	18fa      	adds	r2, r7, r3
 800f8d2:	197b      	adds	r3, r7, r5
 800f8d4:	8819      	ldrh	r1, [r3, #0]
 800f8d6:	0003      	movs	r3, r0
 800f8d8:	0020      	movs	r0, r4
 800f8da:	f7ff fc8d 	bl	800f1f8 <tcp_seg_add_chksum>
 800f8de:	e061      	b.n	800f9a4 <tcp_write+0x634>
       * sent out on the link (as it has to be ACKed by the remote
       * party) we can safely use PBUF_ROM instead of PBUF_REF here.
       */
      struct pbuf *p2;
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
 800f8e0:	231e      	movs	r3, #30
 800f8e2:	18fb      	adds	r3, r7, r3
 800f8e4:	881b      	ldrh	r3, [r3, #0]
 800f8e6:	2b00      	cmp	r3, #0
 800f8e8:	d005      	beq.n	800f8f6 <tcp_write+0x586>
 800f8ea:	4b6e      	ldr	r3, [pc, #440]	; (800faa4 <tcp_write+0x734>)
 800f8ec:	4a73      	ldr	r2, [pc, #460]	; (800fabc <tcp_write+0x74c>)
 800f8ee:	4974      	ldr	r1, [pc, #464]	; (800fac0 <tcp_write+0x750>)
 800f8f0:	486f      	ldr	r0, [pc, #444]	; (800fab0 <tcp_write+0x740>)
 800f8f2:	f7f2 fc6b 	bl	80021cc <app_debug_rtt_raw>
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
 800f8f6:	2424      	movs	r4, #36	; 0x24
 800f8f8:	193b      	adds	r3, r7, r4
 800f8fa:	881b      	ldrh	r3, [r3, #0]
 800f8fc:	2201      	movs	r2, #1
 800f8fe:	0019      	movs	r1, r3
 800f900:	2038      	movs	r0, #56	; 0x38
 800f902:	f7f9 fb4f 	bl	8008fa4 <pbuf_alloc>
 800f906:	0003      	movs	r3, r0
 800f908:	623b      	str	r3, [r7, #32]
 800f90a:	6a3b      	ldr	r3, [r7, #32]
 800f90c:	2b00      	cmp	r3, #0
 800f90e:	d100      	bne.n	800f912 <tcp_write+0x5a2>
 800f910:	e240      	b.n	800fd94 <tcp_write+0xa24>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
#if TCP_CHECKSUM_ON_COPY
      /* calculate the checksum of nocopy-data */
      chksum = ~inet_chksum((const u8_t *)arg + pos, seglen);
 800f912:	2352      	movs	r3, #82	; 0x52
 800f914:	18fb      	adds	r3, r7, r3
 800f916:	881b      	ldrh	r3, [r3, #0]
 800f918:	68ba      	ldr	r2, [r7, #8]
 800f91a:	18d2      	adds	r2, r2, r3
 800f91c:	193b      	adds	r3, r7, r4
 800f91e:	881b      	ldrh	r3, [r3, #0]
 800f920:	0019      	movs	r1, r3
 800f922:	0010      	movs	r0, r2
 800f924:	f7f8 f9ee 	bl	8007d04 <inet_chksum>
 800f928:	0003      	movs	r3, r0
 800f92a:	43db      	mvns	r3, r3
 800f92c:	b29a      	uxth	r2, r3
 800f92e:	2118      	movs	r1, #24
 800f930:	187b      	adds	r3, r7, r1
 800f932:	801a      	strh	r2, [r3, #0]
      if (seglen & 1) {
 800f934:	193b      	adds	r3, r7, r4
 800f936:	881b      	ldrh	r3, [r3, #0]
 800f938:	2201      	movs	r2, #1
 800f93a:	4013      	ands	r3, r2
 800f93c:	d011      	beq.n	800f962 <tcp_write+0x5f2>
        chksum_swapped = 1;
 800f93e:	2317      	movs	r3, #23
 800f940:	18fb      	adds	r3, r7, r3
 800f942:	2201      	movs	r2, #1
 800f944:	701a      	strb	r2, [r3, #0]
        chksum = SWAP_BYTES_IN_WORD(chksum);
 800f946:	187b      	adds	r3, r7, r1
 800f948:	881b      	ldrh	r3, [r3, #0]
 800f94a:	021b      	lsls	r3, r3, #8
 800f94c:	b21a      	sxth	r2, r3
 800f94e:	187b      	adds	r3, r7, r1
 800f950:	881b      	ldrh	r3, [r3, #0]
 800f952:	0a1b      	lsrs	r3, r3, #8
 800f954:	b29b      	uxth	r3, r3
 800f956:	b21b      	sxth	r3, r3
 800f958:	4313      	orrs	r3, r2
 800f95a:	b21b      	sxth	r3, r3
 800f95c:	b29a      	uxth	r2, r3
 800f95e:	187b      	adds	r3, r7, r1
 800f960:	801a      	strh	r2, [r3, #0]
      }
#endif /* TCP_CHECKSUM_ON_COPY */
      /* reference the non-volatile payload data */
      ((struct pbuf_rom *)p2)->payload = (const u8_t *)arg + pos;
 800f962:	2352      	movs	r3, #82	; 0x52
 800f964:	18fb      	adds	r3, r7, r3
 800f966:	881b      	ldrh	r3, [r3, #0]
 800f968:	68ba      	ldr	r2, [r7, #8]
 800f96a:	18d2      	adds	r2, r2, r3
 800f96c:	6a3b      	ldr	r3, [r7, #32]
 800f96e:	605a      	str	r2, [r3, #4]

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 800f970:	232e      	movs	r3, #46	; 0x2e
 800f972:	18fb      	adds	r3, r7, r3
 800f974:	781b      	ldrb	r3, [r3, #0]
 800f976:	b29b      	uxth	r3, r3
 800f978:	22a0      	movs	r2, #160	; 0xa0
 800f97a:	0092      	lsls	r2, r2, #2
 800f97c:	0019      	movs	r1, r3
 800f97e:	2038      	movs	r0, #56	; 0x38
 800f980:	f7f9 fb10 	bl	8008fa4 <pbuf_alloc>
 800f984:	0003      	movs	r3, r0
 800f986:	63fb      	str	r3, [r7, #60]	; 0x3c
 800f988:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f98a:	2b00      	cmp	r3, #0
 800f98c:	d104      	bne.n	800f998 <tcp_write+0x628>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p2);
 800f98e:	6a3b      	ldr	r3, [r7, #32]
 800f990:	0018      	movs	r0, r3
 800f992:	f7f9 fe7f 	bl	8009694 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: could not allocate memory for header pbuf\n"));
        goto memerr;
 800f996:	e200      	b.n	800fd9a <tcp_write+0xa2a>
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
 800f998:	6a3a      	ldr	r2, [r7, #32]
 800f99a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f99c:	0011      	movs	r1, r2
 800f99e:	0018      	movs	r0, r3
 800f9a0:	f7f9 ff58 	bl	8009854 <pbuf_cat>
    }

    queuelen += pbuf_clen(p);
 800f9a4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f9a6:	0018      	movs	r0, r3
 800f9a8:	f7f9 ff14 	bl	80097d4 <pbuf_clen>
 800f9ac:	0003      	movs	r3, r0
 800f9ae:	0019      	movs	r1, r3
 800f9b0:	2050      	movs	r0, #80	; 0x50
 800f9b2:	183b      	adds	r3, r7, r0
 800f9b4:	183a      	adds	r2, r7, r0
 800f9b6:	8812      	ldrh	r2, [r2, #0]
 800f9b8:	188a      	adds	r2, r1, r2
 800f9ba:	801a      	strh	r2, [r3, #0]

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if (queuelen > LWIP_MIN(TCP_SND_QUEUELEN, TCP_SNDQUEUELEN_OVERFLOW)) {
 800f9bc:	183b      	adds	r3, r7, r0
 800f9be:	881b      	ldrh	r3, [r3, #0]
 800f9c0:	2b08      	cmp	r3, #8
 800f9c2:	d904      	bls.n	800f9ce <tcp_write+0x65e>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: queue too long %"U16_F" (%d)\n",
                  queuelen, (int)TCP_SND_QUEUELEN));
      pbuf_free(p);
 800f9c4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800f9c6:	0018      	movs	r0, r3
 800f9c8:	f7f9 fe64 	bl	8009694 <pbuf_free>
      goto memerr;
 800f9cc:	e1e5      	b.n	800fd9a <tcp_write+0xa2a>
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
 800f9ce:	68fb      	ldr	r3, [r7, #12]
 800f9d0:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800f9d2:	2352      	movs	r3, #82	; 0x52
 800f9d4:	18fb      	adds	r3, r7, r3
 800f9d6:	881b      	ldrh	r3, [r3, #0]
 800f9d8:	18d2      	adds	r2, r2, r3
 800f9da:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800f9dc:	68f8      	ldr	r0, [r7, #12]
 800f9de:	2333      	movs	r3, #51	; 0x33
 800f9e0:	18fb      	adds	r3, r7, r3
 800f9e2:	781b      	ldrb	r3, [r3, #0]
 800f9e4:	9300      	str	r3, [sp, #0]
 800f9e6:	0013      	movs	r3, r2
 800f9e8:	2200      	movs	r2, #0
 800f9ea:	f7ff fa45 	bl	800ee78 <tcp_create_segment>
 800f9ee:	0003      	movs	r3, r0
 800f9f0:	65fb      	str	r3, [r7, #92]	; 0x5c
 800f9f2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800f9f4:	2b00      	cmp	r3, #0
 800f9f6:	d100      	bne.n	800f9fa <tcp_write+0x68a>
 800f9f8:	e1ce      	b.n	800fd98 <tcp_write+0xa28>
      goto memerr;
    }
#if TCP_OVERSIZE_DBGCHECK
    seg->oversize_left = oversize;
 800f9fa:	231e      	movs	r3, #30
 800f9fc:	18fb      	adds	r3, r7, r3
 800f9fe:	881a      	ldrh	r2, [r3, #0]
 800fa00:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800fa02:	815a      	strh	r2, [r3, #10]
#endif /* TCP_OVERSIZE_DBGCHECK */
#if TCP_CHECKSUM_ON_COPY
    seg->chksum = chksum;
 800fa04:	2318      	movs	r3, #24
 800fa06:	18fb      	adds	r3, r7, r3
 800fa08:	881a      	ldrh	r2, [r3, #0]
 800fa0a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800fa0c:	819a      	strh	r2, [r3, #12]
    seg->chksum_swapped = chksum_swapped;
 800fa0e:	2317      	movs	r3, #23
 800fa10:	18fb      	adds	r3, r7, r3
 800fa12:	781a      	ldrb	r2, [r3, #0]
 800fa14:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800fa16:	739a      	strb	r2, [r3, #14]
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
 800fa18:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800fa1a:	7bdb      	ldrb	r3, [r3, #15]
 800fa1c:	2204      	movs	r2, #4
 800fa1e:	4313      	orrs	r3, r2
 800fa20:	b2da      	uxtb	r2, r3
 800fa22:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800fa24:	73da      	strb	r2, [r3, #15]
#endif /* TCP_CHECKSUM_ON_COPY */

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
 800fa26:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fa28:	2b00      	cmp	r3, #0
 800fa2a:	d102      	bne.n	800fa32 <tcp_write+0x6c2>
      queue = seg;
 800fa2c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800fa2e:	657b      	str	r3, [r7, #84]	; 0x54
 800fa30:	e00b      	b.n	800fa4a <tcp_write+0x6da>
    } else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
 800fa32:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800fa34:	2b00      	cmp	r3, #0
 800fa36:	d105      	bne.n	800fa44 <tcp_write+0x6d4>
 800fa38:	4b1a      	ldr	r3, [pc, #104]	; (800faa4 <tcp_write+0x734>)
 800fa3a:	4a22      	ldr	r2, [pc, #136]	; (800fac4 <tcp_write+0x754>)
 800fa3c:	4922      	ldr	r1, [pc, #136]	; (800fac8 <tcp_write+0x758>)
 800fa3e:	481c      	ldr	r0, [pc, #112]	; (800fab0 <tcp_write+0x740>)
 800fa40:	f7f2 fbc4 	bl	80021cc <app_debug_rtt_raw>
      prev_seg->next = seg;
 800fa44:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800fa46:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800fa48:	601a      	str	r2, [r3, #0]
    }
    /* remember last segment of to-be-queued data for next iteration */
    prev_seg = seg;
 800fa4a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800fa4c:	65bb      	str	r3, [r7, #88]	; 0x58

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
                lwip_ntohl(seg->tcphdr->seqno),
                lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));

    pos += seglen;
 800fa4e:	2252      	movs	r2, #82	; 0x52
 800fa50:	18bb      	adds	r3, r7, r2
 800fa52:	18b9      	adds	r1, r7, r2
 800fa54:	2224      	movs	r2, #36	; 0x24
 800fa56:	18ba      	adds	r2, r7, r2
 800fa58:	8809      	ldrh	r1, [r1, #0]
 800fa5a:	8812      	ldrh	r2, [r2, #0]
 800fa5c:	188a      	adds	r2, r1, r2
 800fa5e:	801a      	strh	r2, [r3, #0]
  while (pos < len) {
 800fa60:	2352      	movs	r3, #82	; 0x52
 800fa62:	18fa      	adds	r2, r7, r3
 800fa64:	1dbb      	adds	r3, r7, #6
 800fa66:	8812      	ldrh	r2, [r2, #0]
 800fa68:	881b      	ldrh	r3, [r3, #0]
 800fa6a:	429a      	cmp	r2, r3
 800fa6c:	d200      	bcs.n	800fa70 <tcp_write+0x700>
 800fa6e:	e6bd      	b.n	800f7ec <tcp_write+0x47c>
  /*
   * All three segmentation phases were successful. We can commit the
   * transaction.
   */
#if TCP_OVERSIZE_DBGCHECK
  if ((last_unsent != NULL) && (oversize_add != 0)) {
 800fa70:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fa72:	2b00      	cmp	r3, #0
 800fa74:	d00c      	beq.n	800fa90 <tcp_write+0x720>
 800fa76:	2166      	movs	r1, #102	; 0x66
 800fa78:	187b      	adds	r3, r7, r1
 800fa7a:	881b      	ldrh	r3, [r3, #0]
 800fa7c:	2b00      	cmp	r3, #0
 800fa7e:	d007      	beq.n	800fa90 <tcp_write+0x720>
    last_unsent->oversize_left += oversize_add;
 800fa80:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fa82:	895a      	ldrh	r2, [r3, #10]
 800fa84:	187b      	adds	r3, r7, r1
 800fa86:	881b      	ldrh	r3, [r3, #0]
 800fa88:	18d3      	adds	r3, r2, r3
 800fa8a:	b29a      	uxth	r2, r3
 800fa8c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fa8e:	815a      	strh	r2, [r3, #10]
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
 800fa90:	2362      	movs	r3, #98	; 0x62
 800fa92:	18fb      	adds	r3, r7, r3
 800fa94:	881b      	ldrh	r3, [r3, #0]
 800fa96:	2b00      	cmp	r3, #0
 800fa98:	d100      	bne.n	800fa9c <tcp_write+0x72c>
 800fa9a:	e071      	b.n	800fb80 <tcp_write+0x810>
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
 800fa9c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fa9e:	685b      	ldr	r3, [r3, #4]
 800faa0:	63bb      	str	r3, [r7, #56]	; 0x38
 800faa2:	e04c      	b.n	800fb3e <tcp_write+0x7ce>
 800faa4:	0801fe14 	.word	0x0801fe14
 800faa8:	0000024a 	.word	0x0000024a
 800faac:	080200e4 	.word	0x080200e4
 800fab0:	0801fe60 	.word	0x0801fe60
 800fab4:	00000266 	.word	0x00000266
 800fab8:	08020114 	.word	0x08020114
 800fabc:	00000271 	.word	0x00000271
 800fac0:	08020154 	.word	0x08020154
 800fac4:	000002ab 	.word	0x000002ab
 800fac8:	08020164 	.word	0x08020164
      p->tot_len += oversize_used;
 800facc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800face:	891a      	ldrh	r2, [r3, #8]
 800fad0:	2162      	movs	r1, #98	; 0x62
 800fad2:	187b      	adds	r3, r7, r1
 800fad4:	881b      	ldrh	r3, [r3, #0]
 800fad6:	18d3      	adds	r3, r2, r3
 800fad8:	b29a      	uxth	r2, r3
 800fada:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800fadc:	811a      	strh	r2, [r3, #8]
      if (p->next == NULL) {
 800fade:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800fae0:	681b      	ldr	r3, [r3, #0]
 800fae2:	2b00      	cmp	r3, #0
 800fae4:	d128      	bne.n	800fb38 <tcp_write+0x7c8>
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
 800fae6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800fae8:	685b      	ldr	r3, [r3, #4]
 800faea:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800faec:	8952      	ldrh	r2, [r2, #10]
 800faee:	1898      	adds	r0, r3, r2
 800faf0:	000d      	movs	r5, r1
 800faf2:	197b      	adds	r3, r7, r5
 800faf4:	881a      	ldrh	r2, [r3, #0]
 800faf6:	68bb      	ldr	r3, [r7, #8]
 800faf8:	0019      	movs	r1, r3
 800fafa:	f7f8 f968 	bl	8007dce <lwip_chksum_copy>
 800fafe:	0003      	movs	r3, r0
 800fb00:	001c      	movs	r4, r3
 800fb02:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fb04:	330c      	adds	r3, #12
 800fb06:	001a      	movs	r2, r3
 800fb08:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fb0a:	330e      	adds	r3, #14
 800fb0c:	0018      	movs	r0, r3
 800fb0e:	197b      	adds	r3, r7, r5
 800fb10:	8819      	ldrh	r1, [r3, #0]
 800fb12:	0003      	movs	r3, r0
 800fb14:	0020      	movs	r0, r4
 800fb16:	f7ff fb6f 	bl	800f1f8 <tcp_seg_add_chksum>
 800fb1a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fb1c:	7bdb      	ldrb	r3, [r3, #15]
 800fb1e:	2204      	movs	r2, #4
 800fb20:	4313      	orrs	r3, r2
 800fb22:	b2da      	uxtb	r2, r3
 800fb24:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fb26:	73da      	strb	r2, [r3, #15]
        p->len += oversize_used;
 800fb28:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800fb2a:	895a      	ldrh	r2, [r3, #10]
 800fb2c:	197b      	adds	r3, r7, r5
 800fb2e:	881b      	ldrh	r3, [r3, #0]
 800fb30:	18d3      	adds	r3, r2, r3
 800fb32:	b29a      	uxth	r2, r3
 800fb34:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800fb36:	815a      	strh	r2, [r3, #10]
    for (p = last_unsent->p; p; p = p->next) {
 800fb38:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800fb3a:	681b      	ldr	r3, [r3, #0]
 800fb3c:	63bb      	str	r3, [r7, #56]	; 0x38
 800fb3e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800fb40:	2b00      	cmp	r3, #0
 800fb42:	d1c3      	bne.n	800facc <tcp_write+0x75c>
      }
    }
    last_unsent->len += oversize_used;
 800fb44:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fb46:	891a      	ldrh	r2, [r3, #8]
 800fb48:	2162      	movs	r1, #98	; 0x62
 800fb4a:	187b      	adds	r3, r7, r1
 800fb4c:	881b      	ldrh	r3, [r3, #0]
 800fb4e:	18d3      	adds	r3, r2, r3
 800fb50:	b29a      	uxth	r2, r3
 800fb52:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fb54:	811a      	strh	r2, [r3, #8]
#if TCP_OVERSIZE_DBGCHECK
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
 800fb56:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fb58:	895b      	ldrh	r3, [r3, #10]
 800fb5a:	187a      	adds	r2, r7, r1
 800fb5c:	8812      	ldrh	r2, [r2, #0]
 800fb5e:	429a      	cmp	r2, r3
 800fb60:	d905      	bls.n	800fb6e <tcp_write+0x7fe>
 800fb62:	4ba5      	ldr	r3, [pc, #660]	; (800fdf8 <tcp_write+0xa88>)
 800fb64:	4aa5      	ldr	r2, [pc, #660]	; (800fdfc <tcp_write+0xa8c>)
 800fb66:	49a6      	ldr	r1, [pc, #664]	; (800fe00 <tcp_write+0xa90>)
 800fb68:	48a6      	ldr	r0, [pc, #664]	; (800fe04 <tcp_write+0xa94>)
 800fb6a:	f7f2 fb2f 	bl	80021cc <app_debug_rtt_raw>
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
 800fb6e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fb70:	895a      	ldrh	r2, [r3, #10]
 800fb72:	2362      	movs	r3, #98	; 0x62
 800fb74:	18fb      	adds	r3, r7, r3
 800fb76:	881b      	ldrh	r3, [r3, #0]
 800fb78:	1ad3      	subs	r3, r2, r3
 800fb7a:	b29a      	uxth	r2, r3
 800fb7c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fb7e:	815a      	strh	r2, [r3, #10]
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
 800fb80:	231e      	movs	r3, #30
 800fb82:	18fb      	adds	r3, r7, r3
 800fb84:	8819      	ldrh	r1, [r3, #0]
 800fb86:	68fb      	ldr	r3, [r7, #12]
 800fb88:	226c      	movs	r2, #108	; 0x6c
 800fb8a:	5299      	strh	r1, [r3, r2]

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p, unless we
   * determined that the last ROM pbuf can be extended to include the new data.
   */
  if (concat_p != NULL) {
 800fb8c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800fb8e:	2b00      	cmp	r3, #0
 800fb90:	d019      	beq.n	800fbc6 <tcp_write+0x856>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
 800fb92:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fb94:	2b00      	cmp	r3, #0
 800fb96:	d106      	bne.n	800fba6 <tcp_write+0x836>
 800fb98:	4b97      	ldr	r3, [pc, #604]	; (800fdf8 <tcp_write+0xa88>)
 800fb9a:	22b8      	movs	r2, #184	; 0xb8
 800fb9c:	0092      	lsls	r2, r2, #2
 800fb9e:	499a      	ldr	r1, [pc, #616]	; (800fe08 <tcp_write+0xa98>)
 800fba0:	4898      	ldr	r0, [pc, #608]	; (800fe04 <tcp_write+0xa94>)
 800fba2:	f7f2 fb13 	bl	80021cc <app_debug_rtt_raw>
                (last_unsent != NULL));
    pbuf_cat(last_unsent->p, concat_p);
 800fba6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fba8:	685b      	ldr	r3, [r3, #4]
 800fbaa:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800fbac:	0011      	movs	r1, r2
 800fbae:	0018      	movs	r0, r3
 800fbb0:	f7f9 fe50 	bl	8009854 <pbuf_cat>
    last_unsent->len += concat_p->tot_len;
 800fbb4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fbb6:	891a      	ldrh	r2, [r3, #8]
 800fbb8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800fbba:	891b      	ldrh	r3, [r3, #8]
 800fbbc:	18d3      	adds	r3, r2, r3
 800fbbe:	b29a      	uxth	r2, r3
 800fbc0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fbc2:	811a      	strh	r2, [r3, #8]
 800fbc4:	e03e      	b.n	800fc44 <tcp_write+0x8d4>
  } else if (extendlen > 0) {
 800fbc6:	2364      	movs	r3, #100	; 0x64
 800fbc8:	18fb      	adds	r3, r7, r3
 800fbca:	881b      	ldrh	r3, [r3, #0]
 800fbcc:	2b00      	cmp	r3, #0
 800fbce:	d039      	beq.n	800fc44 <tcp_write+0x8d4>
    struct pbuf *p;
    LWIP_ASSERT("tcp_write: extension of reference requires reference",
 800fbd0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fbd2:	2b00      	cmp	r3, #0
 800fbd4:	d003      	beq.n	800fbde <tcp_write+0x86e>
 800fbd6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fbd8:	685b      	ldr	r3, [r3, #4]
 800fbda:	2b00      	cmp	r3, #0
 800fbdc:	d105      	bne.n	800fbea <tcp_write+0x87a>
 800fbde:	4b86      	ldr	r3, [pc, #536]	; (800fdf8 <tcp_write+0xa88>)
 800fbe0:	4a8a      	ldr	r2, [pc, #552]	; (800fe0c <tcp_write+0xa9c>)
 800fbe2:	498b      	ldr	r1, [pc, #556]	; (800fe10 <tcp_write+0xaa0>)
 800fbe4:	4887      	ldr	r0, [pc, #540]	; (800fe04 <tcp_write+0xa94>)
 800fbe6:	f7f2 faf1 	bl	80021cc <app_debug_rtt_raw>
                last_unsent != NULL && last_unsent->p != NULL);
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
 800fbea:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fbec:	685b      	ldr	r3, [r3, #4]
 800fbee:	637b      	str	r3, [r7, #52]	; 0x34
 800fbf0:	e00b      	b.n	800fc0a <tcp_write+0x89a>
      p->tot_len += extendlen;
 800fbf2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fbf4:	891a      	ldrh	r2, [r3, #8]
 800fbf6:	2364      	movs	r3, #100	; 0x64
 800fbf8:	18fb      	adds	r3, r7, r3
 800fbfa:	881b      	ldrh	r3, [r3, #0]
 800fbfc:	18d3      	adds	r3, r2, r3
 800fbfe:	b29a      	uxth	r2, r3
 800fc00:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fc02:	811a      	strh	r2, [r3, #8]
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
 800fc04:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fc06:	681b      	ldr	r3, [r3, #0]
 800fc08:	637b      	str	r3, [r7, #52]	; 0x34
 800fc0a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fc0c:	681b      	ldr	r3, [r3, #0]
 800fc0e:	2b00      	cmp	r3, #0
 800fc10:	d1ef      	bne.n	800fbf2 <tcp_write+0x882>
    }
    p->tot_len += extendlen;
 800fc12:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fc14:	891a      	ldrh	r2, [r3, #8]
 800fc16:	2164      	movs	r1, #100	; 0x64
 800fc18:	187b      	adds	r3, r7, r1
 800fc1a:	881b      	ldrh	r3, [r3, #0]
 800fc1c:	18d3      	adds	r3, r2, r3
 800fc1e:	b29a      	uxth	r2, r3
 800fc20:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fc22:	811a      	strh	r2, [r3, #8]
    p->len += extendlen;
 800fc24:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fc26:	895a      	ldrh	r2, [r3, #10]
 800fc28:	187b      	adds	r3, r7, r1
 800fc2a:	881b      	ldrh	r3, [r3, #0]
 800fc2c:	18d3      	adds	r3, r2, r3
 800fc2e:	b29a      	uxth	r2, r3
 800fc30:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fc32:	815a      	strh	r2, [r3, #10]
    last_unsent->len += extendlen;
 800fc34:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fc36:	891a      	ldrh	r2, [r3, #8]
 800fc38:	187b      	adds	r3, r7, r1
 800fc3a:	881b      	ldrh	r3, [r3, #0]
 800fc3c:	18d3      	adds	r3, r2, r3
 800fc3e:	b29a      	uxth	r2, r3
 800fc40:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fc42:	811a      	strh	r2, [r3, #8]
  }

#if TCP_CHECKSUM_ON_COPY
  if (concat_chksummed) {
 800fc44:	2346      	movs	r3, #70	; 0x46
 800fc46:	18fb      	adds	r3, r7, r3
 800fc48:	881b      	ldrh	r3, [r3, #0]
 800fc4a:	2b00      	cmp	r3, #0
 800fc4c:	d037      	beq.n	800fcbe <tcp_write+0x94e>
    LWIP_ASSERT("tcp_write: concat checksum needs concatenated data",
 800fc4e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800fc50:	2b00      	cmp	r3, #0
 800fc52:	d10a      	bne.n	800fc6a <tcp_write+0x8fa>
 800fc54:	2364      	movs	r3, #100	; 0x64
 800fc56:	18fb      	adds	r3, r7, r3
 800fc58:	881b      	ldrh	r3, [r3, #0]
 800fc5a:	2b00      	cmp	r3, #0
 800fc5c:	d105      	bne.n	800fc6a <tcp_write+0x8fa>
 800fc5e:	4b66      	ldr	r3, [pc, #408]	; (800fdf8 <tcp_write+0xa88>)
 800fc60:	4a6c      	ldr	r2, [pc, #432]	; (800fe14 <tcp_write+0xaa4>)
 800fc62:	496d      	ldr	r1, [pc, #436]	; (800fe18 <tcp_write+0xaa8>)
 800fc64:	4867      	ldr	r0, [pc, #412]	; (800fe04 <tcp_write+0xa94>)
 800fc66:	f7f2 fab1 	bl	80021cc <app_debug_rtt_raw>
                concat_p != NULL || extendlen > 0);
    /*if concat checksumm swapped - swap it back */
    if (concat_chksum_swapped) {
 800fc6a:	231b      	movs	r3, #27
 800fc6c:	18fb      	adds	r3, r7, r3
 800fc6e:	781b      	ldrb	r3, [r3, #0]
 800fc70:	2b00      	cmp	r3, #0
 800fc72:	d00e      	beq.n	800fc92 <tcp_write+0x922>
      concat_chksum = SWAP_BYTES_IN_WORD(concat_chksum);
 800fc74:	211c      	movs	r1, #28
 800fc76:	187b      	adds	r3, r7, r1
 800fc78:	881b      	ldrh	r3, [r3, #0]
 800fc7a:	021b      	lsls	r3, r3, #8
 800fc7c:	b21a      	sxth	r2, r3
 800fc7e:	187b      	adds	r3, r7, r1
 800fc80:	881b      	ldrh	r3, [r3, #0]
 800fc82:	0a1b      	lsrs	r3, r3, #8
 800fc84:	b29b      	uxth	r3, r3
 800fc86:	b21b      	sxth	r3, r3
 800fc88:	4313      	orrs	r3, r2
 800fc8a:	b21b      	sxth	r3, r3
 800fc8c:	b29a      	uxth	r2, r3
 800fc8e:	187b      	adds	r3, r7, r1
 800fc90:	801a      	strh	r2, [r3, #0]
    }
    tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,
 800fc92:	231c      	movs	r3, #28
 800fc94:	18fb      	adds	r3, r7, r3
 800fc96:	8818      	ldrh	r0, [r3, #0]
 800fc98:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fc9a:	330c      	adds	r3, #12
 800fc9c:	001a      	movs	r2, r3
 800fc9e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fca0:	330e      	adds	r3, #14
 800fca2:	001c      	movs	r4, r3
 800fca4:	2346      	movs	r3, #70	; 0x46
 800fca6:	18fb      	adds	r3, r7, r3
 800fca8:	8819      	ldrh	r1, [r3, #0]
 800fcaa:	0023      	movs	r3, r4
 800fcac:	f7ff faa4 	bl	800f1f8 <tcp_seg_add_chksum>
                       &last_unsent->chksum_swapped);
    last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
 800fcb0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fcb2:	7bdb      	ldrb	r3, [r3, #15]
 800fcb4:	2204      	movs	r2, #4
 800fcb6:	4313      	orrs	r3, r2
 800fcb8:	b2da      	uxtb	r2, r3
 800fcba:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fcbc:	73da      	strb	r2, [r3, #15]

  /*
   * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
   * is harmless
   */
  if (last_unsent == NULL) {
 800fcbe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fcc0:	2b00      	cmp	r3, #0
 800fcc2:	d103      	bne.n	800fccc <tcp_write+0x95c>
    pcb->unsent = queue;
 800fcc4:	68fb      	ldr	r3, [r7, #12]
 800fcc6:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800fcc8:	671a      	str	r2, [r3, #112]	; 0x70
 800fcca:	e002      	b.n	800fcd2 <tcp_write+0x962>
  } else {
    last_unsent->next = queue;
 800fccc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800fcce:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800fcd0:	601a      	str	r2, [r3, #0]
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
 800fcd2:	68fb      	ldr	r3, [r7, #12]
 800fcd4:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800fcd6:	1dbb      	adds	r3, r7, #6
 800fcd8:	881b      	ldrh	r3, [r3, #0]
 800fcda:	18d2      	adds	r2, r2, r3
 800fcdc:	68fb      	ldr	r3, [r7, #12]
 800fcde:	661a      	str	r2, [r3, #96]	; 0x60
  pcb->snd_buf -= len;
 800fce0:	68fb      	ldr	r3, [r7, #12]
 800fce2:	2268      	movs	r2, #104	; 0x68
 800fce4:	5a9a      	ldrh	r2, [r3, r2]
 800fce6:	1dbb      	adds	r3, r7, #6
 800fce8:	881b      	ldrh	r3, [r3, #0]
 800fcea:	1ad3      	subs	r3, r2, r3
 800fcec:	b299      	uxth	r1, r3
 800fcee:	68fb      	ldr	r3, [r7, #12]
 800fcf0:	2268      	movs	r2, #104	; 0x68
 800fcf2:	5299      	strh	r1, [r3, r2]
  pcb->snd_queuelen = queuelen;
 800fcf4:	68fb      	ldr	r3, [r7, #12]
 800fcf6:	2250      	movs	r2, #80	; 0x50
 800fcf8:	18ba      	adds	r2, r7, r2
 800fcfa:	216a      	movs	r1, #106	; 0x6a
 800fcfc:	8812      	ldrh	r2, [r2, #0]
 800fcfe:	525a      	strh	r2, [r3, r1]

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
                               pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
 800fd00:	68fb      	ldr	r3, [r7, #12]
 800fd02:	226a      	movs	r2, #106	; 0x6a
 800fd04:	5a9b      	ldrh	r3, [r3, r2]
 800fd06:	2b00      	cmp	r3, #0
 800fd08:	d00d      	beq.n	800fd26 <tcp_write+0x9b6>
    LWIP_ASSERT("tcp_write: valid queue length",
 800fd0a:	68fb      	ldr	r3, [r7, #12]
 800fd0c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800fd0e:	2b00      	cmp	r3, #0
 800fd10:	d109      	bne.n	800fd26 <tcp_write+0x9b6>
 800fd12:	68fb      	ldr	r3, [r7, #12]
 800fd14:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800fd16:	2b00      	cmp	r3, #0
 800fd18:	d105      	bne.n	800fd26 <tcp_write+0x9b6>
 800fd1a:	4b37      	ldr	r3, [pc, #220]	; (800fdf8 <tcp_write+0xa88>)
 800fd1c:	4a3f      	ldr	r2, [pc, #252]	; (800fe1c <tcp_write+0xaac>)
 800fd1e:	4940      	ldr	r1, [pc, #256]	; (800fe20 <tcp_write+0xab0>)
 800fd20:	4838      	ldr	r0, [pc, #224]	; (800fe04 <tcp_write+0xa94>)
 800fd22:	f7f2 fa53 	bl	80021cc <app_debug_rtt_raw>
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE) == 0)) {
 800fd26:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800fd28:	2b00      	cmp	r3, #0
 800fd2a:	d02b      	beq.n	800fd84 <tcp_write+0xa14>
 800fd2c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800fd2e:	691b      	ldr	r3, [r3, #16]
 800fd30:	2b00      	cmp	r3, #0
 800fd32:	d027      	beq.n	800fd84 <tcp_write+0xa14>
 800fd34:	1d7b      	adds	r3, r7, #5
 800fd36:	781b      	ldrb	r3, [r3, #0]
 800fd38:	2202      	movs	r2, #2
 800fd3a:	4013      	ands	r3, r2
 800fd3c:	d122      	bne.n	800fd84 <tcp_write+0xa14>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
 800fd3e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800fd40:	691b      	ldr	r3, [r3, #16]
 800fd42:	7b1a      	ldrb	r2, [r3, #12]
 800fd44:	7b5b      	ldrb	r3, [r3, #13]
 800fd46:	021b      	lsls	r3, r3, #8
 800fd48:	4313      	orrs	r3, r2
 800fd4a:	b29c      	uxth	r4, r3
 800fd4c:	2008      	movs	r0, #8
 800fd4e:	f7f6 fbf1 	bl	8006534 <lwip_htons>
 800fd52:	0003      	movs	r3, r0
 800fd54:	001a      	movs	r2, r3
 800fd56:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800fd58:	691b      	ldr	r3, [r3, #16]
 800fd5a:	4322      	orrs	r2, r4
 800fd5c:	b292      	uxth	r2, r2
 800fd5e:	21ff      	movs	r1, #255	; 0xff
 800fd60:	4011      	ands	r1, r2
 800fd62:	000c      	movs	r4, r1
 800fd64:	7b19      	ldrb	r1, [r3, #12]
 800fd66:	2000      	movs	r0, #0
 800fd68:	4001      	ands	r1, r0
 800fd6a:	1c08      	adds	r0, r1, #0
 800fd6c:	1c21      	adds	r1, r4, #0
 800fd6e:	4301      	orrs	r1, r0
 800fd70:	7319      	strb	r1, [r3, #12]
 800fd72:	0a12      	lsrs	r2, r2, #8
 800fd74:	b290      	uxth	r0, r2
 800fd76:	7b5a      	ldrb	r2, [r3, #13]
 800fd78:	2100      	movs	r1, #0
 800fd7a:	400a      	ands	r2, r1
 800fd7c:	1c11      	adds	r1, r2, #0
 800fd7e:	1c02      	adds	r2, r0, #0
 800fd80:	430a      	orrs	r2, r1
 800fd82:	735a      	strb	r2, [r3, #13]
  }

  return ERR_OK;
 800fd84:	2300      	movs	r3, #0
 800fd86:	e032      	b.n	800fdee <tcp_write+0xa7e>
          goto memerr;
 800fd88:	46c0      	nop			; (mov r8, r8)
 800fd8a:	e006      	b.n	800fd9a <tcp_write+0xa2a>
            goto memerr;
 800fd8c:	46c0      	nop			; (mov r8, r8)
 800fd8e:	e004      	b.n	800fd9a <tcp_write+0xa2a>
        goto memerr;
 800fd90:	46c0      	nop			; (mov r8, r8)
 800fd92:	e002      	b.n	800fd9a <tcp_write+0xa2a>
        goto memerr;
 800fd94:	46c0      	nop			; (mov r8, r8)
 800fd96:	e000      	b.n	800fd9a <tcp_write+0xa2a>
      goto memerr;
 800fd98:	46c0      	nop			; (mov r8, r8)
memerr:
  tcp_set_flags(pcb, TF_NAGLEMEMERR);
 800fd9a:	68fb      	ldr	r3, [r7, #12]
 800fd9c:	8bdb      	ldrh	r3, [r3, #30]
 800fd9e:	2280      	movs	r2, #128	; 0x80
 800fda0:	4313      	orrs	r3, r2
 800fda2:	b29a      	uxth	r2, r3
 800fda4:	68fb      	ldr	r3, [r7, #12]
 800fda6:	83da      	strh	r2, [r3, #30]
  TCP_STATS_INC(tcp.memerr);

  if (concat_p != NULL) {
 800fda8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800fdaa:	2b00      	cmp	r3, #0
 800fdac:	d003      	beq.n	800fdb6 <tcp_write+0xa46>
    pbuf_free(concat_p);
 800fdae:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800fdb0:	0018      	movs	r0, r3
 800fdb2:	f7f9 fc6f 	bl	8009694 <pbuf_free>
  }
  if (queue != NULL) {
 800fdb6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fdb8:	2b00      	cmp	r3, #0
 800fdba:	d003      	beq.n	800fdc4 <tcp_write+0xa54>
    tcp_segs_free(queue);
 800fdbc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fdbe:	0018      	movs	r0, r3
 800fdc0:	f7fb fcd4 	bl	800b76c <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
 800fdc4:	68fb      	ldr	r3, [r7, #12]
 800fdc6:	226a      	movs	r2, #106	; 0x6a
 800fdc8:	5a9b      	ldrh	r3, [r3, r2]
 800fdca:	2b00      	cmp	r3, #0
 800fdcc:	d00d      	beq.n	800fdea <tcp_write+0xa7a>
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
 800fdce:	68fb      	ldr	r3, [r7, #12]
 800fdd0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800fdd2:	2b00      	cmp	r3, #0
 800fdd4:	d109      	bne.n	800fdea <tcp_write+0xa7a>
 800fdd6:	68fb      	ldr	r3, [r7, #12]
 800fdd8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800fdda:	2b00      	cmp	r3, #0
 800fddc:	d105      	bne.n	800fdea <tcp_write+0xa7a>
 800fdde:	4b06      	ldr	r3, [pc, #24]	; (800fdf8 <tcp_write+0xa88>)
 800fde0:	4a10      	ldr	r2, [pc, #64]	; (800fe24 <tcp_write+0xab4>)
 800fde2:	490f      	ldr	r1, [pc, #60]	; (800fe20 <tcp_write+0xab0>)
 800fde4:	4807      	ldr	r0, [pc, #28]	; (800fe04 <tcp_write+0xa94>)
 800fde6:	f7f2 f9f1 	bl	80021cc <app_debug_rtt_raw>
                pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
 800fdea:	2301      	movs	r3, #1
 800fdec:	425b      	negs	r3, r3
}
 800fdee:	0018      	movs	r0, r3
 800fdf0:	46bd      	mov	sp, r7
 800fdf2:	b01a      	add	sp, #104	; 0x68
 800fdf4:	bdb0      	pop	{r4, r5, r7, pc}
 800fdf6:	46c0      	nop			; (mov r8, r8)
 800fdf8:	0801fe14 	.word	0x0801fe14
 800fdfc:	000002d3 	.word	0x000002d3
 800fe00:	08020178 	.word	0x08020178
 800fe04:	0801fe60 	.word	0x0801fe60
 800fe08:	080201a4 	.word	0x080201a4
 800fe0c:	000002e6 	.word	0x000002e6
 800fe10:	080201dc 	.word	0x080201dc
 800fe14:	000002f2 	.word	0x000002f2
 800fe18:	08020214 	.word	0x08020214
 800fe1c:	00000312 	.word	0x00000312
 800fe20:	08020248 	.word	0x08020248
 800fe24:	00000327 	.word	0x00000327

0800fe28 <tcp_split_unsent_seg>:
 * @param pcb the tcp_pcb for which to split the unsent head
 * @param split the amount of payload to remain in the head
 */
err_t
tcp_split_unsent_seg(struct tcp_pcb *pcb, u16_t split)
{
 800fe28:	b5f0      	push	{r4, r5, r6, r7, lr}
 800fe2a:	b08d      	sub	sp, #52	; 0x34
 800fe2c:	af02      	add	r7, sp, #8
 800fe2e:	6078      	str	r0, [r7, #4]
 800fe30:	000a      	movs	r2, r1
 800fe32:	1cbb      	adds	r3, r7, #2
 800fe34:	801a      	strh	r2, [r3, #0]
  struct tcp_seg *seg = NULL, *useg = NULL;
 800fe36:	2300      	movs	r3, #0
 800fe38:	61fb      	str	r3, [r7, #28]
 800fe3a:	2300      	movs	r3, #0
 800fe3c:	613b      	str	r3, [r7, #16]
  struct pbuf *p = NULL;
 800fe3e:	2300      	movs	r3, #0
 800fe40:	623b      	str	r3, [r7, #32]
  u8_t split_flags;
  u8_t remainder_flags;
  u16_t remainder;
  u16_t offset;
#if TCP_CHECKSUM_ON_COPY
  u16_t chksum = 0;
 800fe42:	230a      	movs	r3, #10
 800fe44:	18fb      	adds	r3, r7, r3
 800fe46:	2200      	movs	r2, #0
 800fe48:	801a      	strh	r2, [r3, #0]
  u8_t chksum_swapped = 0;
 800fe4a:	2309      	movs	r3, #9
 800fe4c:	18fb      	adds	r3, r7, r3
 800fe4e:	2200      	movs	r2, #0
 800fe50:	701a      	strb	r2, [r3, #0]
  struct pbuf *q;
#endif /* TCP_CHECKSUM_ON_COPY */

  LWIP_ASSERT("tcp_split_unsent_seg: invalid pcb", pcb != NULL);
 800fe52:	687b      	ldr	r3, [r7, #4]
 800fe54:	2b00      	cmp	r3, #0
 800fe56:	d105      	bne.n	800fe64 <tcp_split_unsent_seg+0x3c>
 800fe58:	4bd2      	ldr	r3, [pc, #840]	; (80101a4 <tcp_split_unsent_seg+0x37c>)
 800fe5a:	4ad3      	ldr	r2, [pc, #844]	; (80101a8 <tcp_split_unsent_seg+0x380>)
 800fe5c:	49d3      	ldr	r1, [pc, #844]	; (80101ac <tcp_split_unsent_seg+0x384>)
 800fe5e:	48d4      	ldr	r0, [pc, #848]	; (80101b0 <tcp_split_unsent_seg+0x388>)
 800fe60:	f7f2 f9b4 	bl	80021cc <app_debug_rtt_raw>

  useg = pcb->unsent;
 800fe64:	687b      	ldr	r3, [r7, #4]
 800fe66:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800fe68:	613b      	str	r3, [r7, #16]
  if (useg == NULL) {
 800fe6a:	693b      	ldr	r3, [r7, #16]
 800fe6c:	2b00      	cmp	r3, #0
 800fe6e:	d102      	bne.n	800fe76 <tcp_split_unsent_seg+0x4e>
    return ERR_MEM;
 800fe70:	2301      	movs	r3, #1
 800fe72:	425b      	negs	r3, r3
 800fe74:	e207      	b.n	8010286 <tcp_split_unsent_seg+0x45e>
  }

  if (split == 0) {
 800fe76:	1cbb      	adds	r3, r7, #2
 800fe78:	881b      	ldrh	r3, [r3, #0]
 800fe7a:	2b00      	cmp	r3, #0
 800fe7c:	d108      	bne.n	800fe90 <tcp_split_unsent_seg+0x68>
    LWIP_ASSERT("Can't split segment into length 0", 0);
 800fe7e:	4bc9      	ldr	r3, [pc, #804]	; (80101a4 <tcp_split_unsent_seg+0x37c>)
 800fe80:	4acc      	ldr	r2, [pc, #816]	; (80101b4 <tcp_split_unsent_seg+0x38c>)
 800fe82:	49cd      	ldr	r1, [pc, #820]	; (80101b8 <tcp_split_unsent_seg+0x390>)
 800fe84:	48ca      	ldr	r0, [pc, #808]	; (80101b0 <tcp_split_unsent_seg+0x388>)
 800fe86:	f7f2 f9a1 	bl	80021cc <app_debug_rtt_raw>
    return ERR_VAL;
 800fe8a:	2306      	movs	r3, #6
 800fe8c:	425b      	negs	r3, r3
 800fe8e:	e1fa      	b.n	8010286 <tcp_split_unsent_seg+0x45e>
  }

  if (useg->len <= split) {
 800fe90:	693b      	ldr	r3, [r7, #16]
 800fe92:	891b      	ldrh	r3, [r3, #8]
 800fe94:	1cba      	adds	r2, r7, #2
 800fe96:	8812      	ldrh	r2, [r2, #0]
 800fe98:	429a      	cmp	r2, r3
 800fe9a:	d301      	bcc.n	800fea0 <tcp_split_unsent_seg+0x78>
    return ERR_OK;
 800fe9c:	2300      	movs	r3, #0
 800fe9e:	e1f2      	b.n	8010286 <tcp_split_unsent_seg+0x45e>
  }

  LWIP_ASSERT("split <= mss", split <= pcb->mss);
 800fea0:	687b      	ldr	r3, [r7, #4]
 800fea2:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 800fea4:	1cba      	adds	r2, r7, #2
 800fea6:	8812      	ldrh	r2, [r2, #0]
 800fea8:	429a      	cmp	r2, r3
 800feaa:	d905      	bls.n	800feb8 <tcp_split_unsent_seg+0x90>
 800feac:	4bbd      	ldr	r3, [pc, #756]	; (80101a4 <tcp_split_unsent_seg+0x37c>)
 800feae:	4ac3      	ldr	r2, [pc, #780]	; (80101bc <tcp_split_unsent_seg+0x394>)
 800feb0:	49c3      	ldr	r1, [pc, #780]	; (80101c0 <tcp_split_unsent_seg+0x398>)
 800feb2:	48bf      	ldr	r0, [pc, #764]	; (80101b0 <tcp_split_unsent_seg+0x388>)
 800feb4:	f7f2 f98a 	bl	80021cc <app_debug_rtt_raw>
  LWIP_ASSERT("useg->len > 0", useg->len > 0);
 800feb8:	693b      	ldr	r3, [r7, #16]
 800feba:	891b      	ldrh	r3, [r3, #8]
 800febc:	2b00      	cmp	r3, #0
 800febe:	d106      	bne.n	800fece <tcp_split_unsent_seg+0xa6>
 800fec0:	4bb8      	ldr	r3, [pc, #736]	; (80101a4 <tcp_split_unsent_seg+0x37c>)
 800fec2:	22d7      	movs	r2, #215	; 0xd7
 800fec4:	0092      	lsls	r2, r2, #2
 800fec6:	49bf      	ldr	r1, [pc, #764]	; (80101c4 <tcp_split_unsent_seg+0x39c>)
 800fec8:	48b9      	ldr	r0, [pc, #740]	; (80101b0 <tcp_split_unsent_seg+0x388>)
 800feca:	f7f2 f97f 	bl	80021cc <app_debug_rtt_raw>
   * to split this packet so we may actually exceed the max value by
   * one!
   */
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: split_unsent_seg: %u\n", (unsigned int)pcb->snd_queuelen));

  optflags = useg->flags;
 800fece:	200f      	movs	r0, #15
 800fed0:	183b      	adds	r3, r7, r0
 800fed2:	693a      	ldr	r2, [r7, #16]
 800fed4:	7bd2      	ldrb	r2, [r2, #15]
 800fed6:	701a      	strb	r2, [r3, #0]
#if TCP_CHECKSUM_ON_COPY
  /* Remove since checksum is not stored until after tcp_create_segment() */
  optflags &= ~TF_SEG_DATA_CHECKSUMMED;
 800fed8:	183b      	adds	r3, r7, r0
 800feda:	183a      	adds	r2, r7, r0
 800fedc:	7812      	ldrb	r2, [r2, #0]
 800fede:	2104      	movs	r1, #4
 800fee0:	438a      	bics	r2, r1
 800fee2:	701a      	strb	r2, [r3, #0]
#endif /* TCP_CHECKSUM_ON_COPY */
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
 800fee4:	183b      	adds	r3, r7, r0
 800fee6:	781b      	ldrb	r3, [r3, #0]
 800fee8:	009b      	lsls	r3, r3, #2
 800feea:	b2da      	uxtb	r2, r3
 800feec:	240e      	movs	r4, #14
 800feee:	193b      	adds	r3, r7, r4
 800fef0:	2104      	movs	r1, #4
 800fef2:	400a      	ands	r2, r1
 800fef4:	701a      	strb	r2, [r3, #0]
  remainder = useg->len - split;
 800fef6:	693b      	ldr	r3, [r7, #16]
 800fef8:	8919      	ldrh	r1, [r3, #8]
 800fefa:	250c      	movs	r5, #12
 800fefc:	197b      	adds	r3, r7, r5
 800fefe:	1cba      	adds	r2, r7, #2
 800ff00:	8812      	ldrh	r2, [r2, #0]
 800ff02:	1a8a      	subs	r2, r1, r2
 800ff04:	801a      	strh	r2, [r3, #0]

  /* Create new pbuf for the remainder of the split */
  p = pbuf_alloc(PBUF_TRANSPORT, remainder + optlen, PBUF_RAM);
 800ff06:	193b      	adds	r3, r7, r4
 800ff08:	781b      	ldrb	r3, [r3, #0]
 800ff0a:	b29a      	uxth	r2, r3
 800ff0c:	197b      	adds	r3, r7, r5
 800ff0e:	881b      	ldrh	r3, [r3, #0]
 800ff10:	18d3      	adds	r3, r2, r3
 800ff12:	b29b      	uxth	r3, r3
 800ff14:	22a0      	movs	r2, #160	; 0xa0
 800ff16:	0092      	lsls	r2, r2, #2
 800ff18:	0019      	movs	r1, r3
 800ff1a:	2038      	movs	r0, #56	; 0x38
 800ff1c:	f7f9 f842 	bl	8008fa4 <pbuf_alloc>
 800ff20:	0003      	movs	r3, r0
 800ff22:	623b      	str	r3, [r7, #32]
  if (p == NULL) {
 800ff24:	6a3b      	ldr	r3, [r7, #32]
 800ff26:	2b00      	cmp	r3, #0
 800ff28:	d100      	bne.n	800ff2c <tcp_split_unsent_seg+0x104>
 800ff2a:	e197      	b.n	801025c <tcp_split_unsent_seg+0x434>
                ("tcp_split_unsent_seg: could not allocate memory for pbuf remainder %u\n", remainder));
    goto memerr;
  }

  /* Offset into the original pbuf is past TCP/IP headers, options, and split amount */
  offset = useg->p->tot_len - useg->len + split;
 800ff2c:	693b      	ldr	r3, [r7, #16]
 800ff2e:	685b      	ldr	r3, [r3, #4]
 800ff30:	891a      	ldrh	r2, [r3, #8]
 800ff32:	693b      	ldr	r3, [r7, #16]
 800ff34:	891b      	ldrh	r3, [r3, #8]
 800ff36:	1ad3      	subs	r3, r2, r3
 800ff38:	b299      	uxth	r1, r3
 800ff3a:	2318      	movs	r3, #24
 800ff3c:	18fb      	adds	r3, r7, r3
 800ff3e:	1cba      	adds	r2, r7, #2
 800ff40:	8812      	ldrh	r2, [r2, #0]
 800ff42:	188a      	adds	r2, r1, r2
 800ff44:	801a      	strh	r2, [r3, #0]
  /* Copy remainder into new pbuf, headers and options will not be filled out */
  if (pbuf_copy_partial(useg->p, (u8_t *)p->payload + optlen, remainder, offset ) != remainder) {
 800ff46:	693b      	ldr	r3, [r7, #16]
 800ff48:	6858      	ldr	r0, [r3, #4]
 800ff4a:	6a3b      	ldr	r3, [r7, #32]
 800ff4c:	685a      	ldr	r2, [r3, #4]
 800ff4e:	0026      	movs	r6, r4
 800ff50:	193b      	adds	r3, r7, r4
 800ff52:	781b      	ldrb	r3, [r3, #0]
 800ff54:	18d1      	adds	r1, r2, r3
 800ff56:	2318      	movs	r3, #24
 800ff58:	18fb      	adds	r3, r7, r3
 800ff5a:	881c      	ldrh	r4, [r3, #0]
 800ff5c:	197b      	adds	r3, r7, r5
 800ff5e:	881a      	ldrh	r2, [r3, #0]
 800ff60:	0023      	movs	r3, r4
 800ff62:	f7f9 fe61 	bl	8009c28 <pbuf_copy_partial>
 800ff66:	0003      	movs	r3, r0
 800ff68:	001a      	movs	r2, r3
 800ff6a:	197b      	adds	r3, r7, r5
 800ff6c:	881b      	ldrh	r3, [r3, #0]
 800ff6e:	4293      	cmp	r3, r2
 800ff70:	d000      	beq.n	800ff74 <tcp_split_unsent_seg+0x14c>
 800ff72:	e175      	b.n	8010260 <tcp_split_unsent_seg+0x438>
                ("tcp_split_unsent_seg: could not copy pbuf remainder %u\n", remainder));
    goto memerr;
  }
#if TCP_CHECKSUM_ON_COPY
  /* calculate the checksum on remainder data */
  tcp_seg_add_chksum(~inet_chksum((const u8_t *)p->payload + optlen, remainder), remainder,
 800ff74:	6a3b      	ldr	r3, [r7, #32]
 800ff76:	685a      	ldr	r2, [r3, #4]
 800ff78:	19bb      	adds	r3, r7, r6
 800ff7a:	781b      	ldrb	r3, [r3, #0]
 800ff7c:	18d2      	adds	r2, r2, r3
 800ff7e:	197b      	adds	r3, r7, r5
 800ff80:	881b      	ldrh	r3, [r3, #0]
 800ff82:	0019      	movs	r1, r3
 800ff84:	0010      	movs	r0, r2
 800ff86:	f7f7 febd 	bl	8007d04 <inet_chksum>
 800ff8a:	0003      	movs	r3, r0
 800ff8c:	43db      	mvns	r3, r3
 800ff8e:	b298      	uxth	r0, r3
 800ff90:	2309      	movs	r3, #9
 800ff92:	18fc      	adds	r4, r7, r3
 800ff94:	230a      	movs	r3, #10
 800ff96:	18fa      	adds	r2, r7, r3
 800ff98:	197b      	adds	r3, r7, r5
 800ff9a:	8819      	ldrh	r1, [r3, #0]
 800ff9c:	0023      	movs	r3, r4
 800ff9e:	f7ff f92b 	bl	800f1f8 <tcp_seg_add_chksum>
#endif /* TCP_CHECKSUM_ON_COPY */

  /* Options are created when calling tcp_output() */

  /* Migrate flags from original segment */
  split_flags = TCPH_FLAGS(useg->tcphdr);
 800ffa2:	693b      	ldr	r3, [r7, #16]
 800ffa4:	691b      	ldr	r3, [r3, #16]
 800ffa6:	7b1a      	ldrb	r2, [r3, #12]
 800ffa8:	7b5b      	ldrb	r3, [r3, #13]
 800ffaa:	021b      	lsls	r3, r3, #8
 800ffac:	4313      	orrs	r3, r2
 800ffae:	b29b      	uxth	r3, r3
 800ffb0:	0018      	movs	r0, r3
 800ffb2:	f7f6 fabf 	bl	8006534 <lwip_htons>
 800ffb6:	0003      	movs	r3, r0
 800ffb8:	b2da      	uxtb	r2, r3
 800ffba:	2027      	movs	r0, #39	; 0x27
 800ffbc:	183b      	adds	r3, r7, r0
 800ffbe:	213f      	movs	r1, #63	; 0x3f
 800ffc0:	400a      	ands	r2, r1
 800ffc2:	701a      	strb	r2, [r3, #0]
  remainder_flags = 0; /* ACK added in tcp_output() */
 800ffc4:	241b      	movs	r4, #27
 800ffc6:	193b      	adds	r3, r7, r4
 800ffc8:	2200      	movs	r2, #0
 800ffca:	701a      	strb	r2, [r3, #0]

  if (split_flags & TCP_PSH) {
 800ffcc:	183b      	adds	r3, r7, r0
 800ffce:	781b      	ldrb	r3, [r3, #0]
 800ffd0:	2208      	movs	r2, #8
 800ffd2:	4013      	ands	r3, r2
 800ffd4:	d00b      	beq.n	800ffee <tcp_split_unsent_seg+0x1c6>
    split_flags &= ~TCP_PSH;
 800ffd6:	183b      	adds	r3, r7, r0
 800ffd8:	183a      	adds	r2, r7, r0
 800ffda:	7812      	ldrb	r2, [r2, #0]
 800ffdc:	2108      	movs	r1, #8
 800ffde:	438a      	bics	r2, r1
 800ffe0:	701a      	strb	r2, [r3, #0]
    remainder_flags |= TCP_PSH;
 800ffe2:	193b      	adds	r3, r7, r4
 800ffe4:	193a      	adds	r2, r7, r4
 800ffe6:	7812      	ldrb	r2, [r2, #0]
 800ffe8:	2108      	movs	r1, #8
 800ffea:	430a      	orrs	r2, r1
 800ffec:	701a      	strb	r2, [r3, #0]
  }
  if (split_flags & TCP_FIN) {
 800ffee:	2127      	movs	r1, #39	; 0x27
 800fff0:	187b      	adds	r3, r7, r1
 800fff2:	781b      	ldrb	r3, [r3, #0]
 800fff4:	2201      	movs	r2, #1
 800fff6:	4013      	ands	r3, r2
 800fff8:	d00c      	beq.n	8010014 <tcp_split_unsent_seg+0x1ec>
    split_flags &= ~TCP_FIN;
 800fffa:	187b      	adds	r3, r7, r1
 800fffc:	187a      	adds	r2, r7, r1
 800fffe:	7812      	ldrb	r2, [r2, #0]
 8010000:	2101      	movs	r1, #1
 8010002:	438a      	bics	r2, r1
 8010004:	701a      	strb	r2, [r3, #0]
    remainder_flags |= TCP_FIN;
 8010006:	221b      	movs	r2, #27
 8010008:	18bb      	adds	r3, r7, r2
 801000a:	18ba      	adds	r2, r7, r2
 801000c:	7812      	ldrb	r2, [r2, #0]
 801000e:	2101      	movs	r1, #1
 8010010:	430a      	orrs	r2, r1
 8010012:	701a      	strb	r2, [r3, #0]
  }
  /* SYN should be left on split, RST should not be present with data */

  seg = tcp_create_segment(pcb, p, remainder_flags, lwip_ntohl(useg->tcphdr->seqno) + split, optflags);
 8010014:	693b      	ldr	r3, [r7, #16]
 8010016:	691b      	ldr	r3, [r3, #16]
 8010018:	791a      	ldrb	r2, [r3, #4]
 801001a:	7959      	ldrb	r1, [r3, #5]
 801001c:	0209      	lsls	r1, r1, #8
 801001e:	430a      	orrs	r2, r1
 8010020:	7999      	ldrb	r1, [r3, #6]
 8010022:	0409      	lsls	r1, r1, #16
 8010024:	430a      	orrs	r2, r1
 8010026:	79db      	ldrb	r3, [r3, #7]
 8010028:	061b      	lsls	r3, r3, #24
 801002a:	4313      	orrs	r3, r2
 801002c:	0018      	movs	r0, r3
 801002e:	f7f6 fa97 	bl	8006560 <lwip_htonl>
 8010032:	0002      	movs	r2, r0
 8010034:	1cbb      	adds	r3, r7, #2
 8010036:	881b      	ldrh	r3, [r3, #0]
 8010038:	18d4      	adds	r4, r2, r3
 801003a:	231b      	movs	r3, #27
 801003c:	18fb      	adds	r3, r7, r3
 801003e:	781a      	ldrb	r2, [r3, #0]
 8010040:	6a39      	ldr	r1, [r7, #32]
 8010042:	6878      	ldr	r0, [r7, #4]
 8010044:	230f      	movs	r3, #15
 8010046:	18fb      	adds	r3, r7, r3
 8010048:	781b      	ldrb	r3, [r3, #0]
 801004a:	9300      	str	r3, [sp, #0]
 801004c:	0023      	movs	r3, r4
 801004e:	f7fe ff13 	bl	800ee78 <tcp_create_segment>
 8010052:	0003      	movs	r3, r0
 8010054:	61fb      	str	r3, [r7, #28]
  if (seg == NULL) {
 8010056:	69fb      	ldr	r3, [r7, #28]
 8010058:	2b00      	cmp	r3, #0
 801005a:	d102      	bne.n	8010062 <tcp_split_unsent_seg+0x23a>
    p = NULL; /* Freed by tcp_create_segment */
 801005c:	2300      	movs	r3, #0
 801005e:	623b      	str	r3, [r7, #32]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                ("tcp_split_unsent_seg: could not create new TCP segment\n"));
    goto memerr;
 8010060:	e0ff      	b.n	8010262 <tcp_split_unsent_seg+0x43a>
  }

#if TCP_CHECKSUM_ON_COPY
  seg->chksum = chksum;
 8010062:	230a      	movs	r3, #10
 8010064:	18fb      	adds	r3, r7, r3
 8010066:	881a      	ldrh	r2, [r3, #0]
 8010068:	69fb      	ldr	r3, [r7, #28]
 801006a:	819a      	strh	r2, [r3, #12]
  seg->chksum_swapped = chksum_swapped;
 801006c:	2309      	movs	r3, #9
 801006e:	18fb      	adds	r3, r7, r3
 8010070:	781a      	ldrb	r2, [r3, #0]
 8010072:	69fb      	ldr	r3, [r7, #28]
 8010074:	739a      	strb	r2, [r3, #14]
  seg->flags |= TF_SEG_DATA_CHECKSUMMED;
 8010076:	69fb      	ldr	r3, [r7, #28]
 8010078:	7bdb      	ldrb	r3, [r3, #15]
 801007a:	2204      	movs	r2, #4
 801007c:	4313      	orrs	r3, r2
 801007e:	b2da      	uxtb	r2, r3
 8010080:	69fb      	ldr	r3, [r7, #28]
 8010082:	73da      	strb	r2, [r3, #15]
#endif /* TCP_CHECKSUM_ON_COPY */

  /* Remove this segment from the queue since trimming it may free pbufs */
  pcb->snd_queuelen -= pbuf_clen(useg->p);
 8010084:	693b      	ldr	r3, [r7, #16]
 8010086:	685b      	ldr	r3, [r3, #4]
 8010088:	0018      	movs	r0, r3
 801008a:	f7f9 fba3 	bl	80097d4 <pbuf_clen>
 801008e:	0003      	movs	r3, r0
 8010090:	0019      	movs	r1, r3
 8010092:	687b      	ldr	r3, [r7, #4]
 8010094:	226a      	movs	r2, #106	; 0x6a
 8010096:	5a9b      	ldrh	r3, [r3, r2]
 8010098:	1a5b      	subs	r3, r3, r1
 801009a:	b299      	uxth	r1, r3
 801009c:	687b      	ldr	r3, [r7, #4]
 801009e:	226a      	movs	r2, #106	; 0x6a
 80100a0:	5299      	strh	r1, [r3, r2]

  /* Trim the original pbuf into our split size.  At this point our remainder segment must be setup
  successfully because we are modifying the original segment */
  pbuf_realloc(useg->p, useg->p->tot_len - remainder);
 80100a2:	693b      	ldr	r3, [r7, #16]
 80100a4:	6858      	ldr	r0, [r3, #4]
 80100a6:	693b      	ldr	r3, [r7, #16]
 80100a8:	685b      	ldr	r3, [r3, #4]
 80100aa:	891a      	ldrh	r2, [r3, #8]
 80100ac:	240c      	movs	r4, #12
 80100ae:	193b      	adds	r3, r7, r4
 80100b0:	881b      	ldrh	r3, [r3, #0]
 80100b2:	1ad3      	subs	r3, r2, r3
 80100b4:	b29b      	uxth	r3, r3
 80100b6:	0019      	movs	r1, r3
 80100b8:	f7f9 f8f2 	bl	80092a0 <pbuf_realloc>
  useg->len -= remainder;
 80100bc:	693b      	ldr	r3, [r7, #16]
 80100be:	891a      	ldrh	r2, [r3, #8]
 80100c0:	193b      	adds	r3, r7, r4
 80100c2:	881b      	ldrh	r3, [r3, #0]
 80100c4:	1ad3      	subs	r3, r2, r3
 80100c6:	b29a      	uxth	r2, r3
 80100c8:	693b      	ldr	r3, [r7, #16]
 80100ca:	811a      	strh	r2, [r3, #8]
  TCPH_SET_FLAG(useg->tcphdr, split_flags);
 80100cc:	693b      	ldr	r3, [r7, #16]
 80100ce:	691b      	ldr	r3, [r3, #16]
 80100d0:	7b1a      	ldrb	r2, [r3, #12]
 80100d2:	7b5b      	ldrb	r3, [r3, #13]
 80100d4:	021b      	lsls	r3, r3, #8
 80100d6:	4313      	orrs	r3, r2
 80100d8:	b29c      	uxth	r4, r3
 80100da:	2327      	movs	r3, #39	; 0x27
 80100dc:	18fb      	adds	r3, r7, r3
 80100de:	781b      	ldrb	r3, [r3, #0]
 80100e0:	b29b      	uxth	r3, r3
 80100e2:	0018      	movs	r0, r3
 80100e4:	f7f6 fa26 	bl	8006534 <lwip_htons>
 80100e8:	0003      	movs	r3, r0
 80100ea:	001a      	movs	r2, r3
 80100ec:	693b      	ldr	r3, [r7, #16]
 80100ee:	691b      	ldr	r3, [r3, #16]
 80100f0:	4322      	orrs	r2, r4
 80100f2:	b292      	uxth	r2, r2
 80100f4:	21ff      	movs	r1, #255	; 0xff
 80100f6:	4011      	ands	r1, r2
 80100f8:	000c      	movs	r4, r1
 80100fa:	7b19      	ldrb	r1, [r3, #12]
 80100fc:	2000      	movs	r0, #0
 80100fe:	4001      	ands	r1, r0
 8010100:	1c08      	adds	r0, r1, #0
 8010102:	1c21      	adds	r1, r4, #0
 8010104:	4301      	orrs	r1, r0
 8010106:	7319      	strb	r1, [r3, #12]
 8010108:	0a12      	lsrs	r2, r2, #8
 801010a:	b290      	uxth	r0, r2
 801010c:	7b5a      	ldrb	r2, [r3, #13]
 801010e:	2100      	movs	r1, #0
 8010110:	400a      	ands	r2, r1
 8010112:	1c11      	adds	r1, r2, #0
 8010114:	1c02      	adds	r2, r0, #0
 8010116:	430a      	orrs	r2, r1
 8010118:	735a      	strb	r2, [r3, #13]
#if TCP_OVERSIZE_DBGCHECK
  /* By trimming, realloc may have actually shrunk the pbuf, so clear oversize_left */
  useg->oversize_left = 0;
 801011a:	693b      	ldr	r3, [r7, #16]
 801011c:	2200      	movs	r2, #0
 801011e:	815a      	strh	r2, [r3, #10]
#endif /* TCP_OVERSIZE_DBGCHECK */

  /* Add back to the queue with new trimmed pbuf */
  pcb->snd_queuelen += pbuf_clen(useg->p);
 8010120:	693b      	ldr	r3, [r7, #16]
 8010122:	685b      	ldr	r3, [r3, #4]
 8010124:	0018      	movs	r0, r3
 8010126:	f7f9 fb55 	bl	80097d4 <pbuf_clen>
 801012a:	0003      	movs	r3, r0
 801012c:	0019      	movs	r1, r3
 801012e:	687b      	ldr	r3, [r7, #4]
 8010130:	226a      	movs	r2, #106	; 0x6a
 8010132:	5a9b      	ldrh	r3, [r3, r2]
 8010134:	18cb      	adds	r3, r1, r3
 8010136:	b299      	uxth	r1, r3
 8010138:	687b      	ldr	r3, [r7, #4]
 801013a:	226a      	movs	r2, #106	; 0x6a
 801013c:	5299      	strh	r1, [r3, r2]

#if TCP_CHECKSUM_ON_COPY
  /* The checksum on the split segment is now incorrect. We need to re-run it over the split */
  useg->chksum = 0;
 801013e:	693b      	ldr	r3, [r7, #16]
 8010140:	2200      	movs	r2, #0
 8010142:	819a      	strh	r2, [r3, #12]
  useg->chksum_swapped = 0;
 8010144:	693b      	ldr	r3, [r7, #16]
 8010146:	2200      	movs	r2, #0
 8010148:	739a      	strb	r2, [r3, #14]
  q = useg->p;
 801014a:	693b      	ldr	r3, [r7, #16]
 801014c:	685b      	ldr	r3, [r3, #4]
 801014e:	617b      	str	r3, [r7, #20]
  offset = q->tot_len - useg->len; /* Offset due to exposed headers */
 8010150:	697b      	ldr	r3, [r7, #20]
 8010152:	8919      	ldrh	r1, [r3, #8]
 8010154:	693b      	ldr	r3, [r7, #16]
 8010156:	891a      	ldrh	r2, [r3, #8]
 8010158:	2318      	movs	r3, #24
 801015a:	18fb      	adds	r3, r7, r3
 801015c:	1a8a      	subs	r2, r1, r2
 801015e:	801a      	strh	r2, [r3, #0]

  /* Advance to the pbuf where the offset ends */
  while (q != NULL && offset > q->len) {
 8010160:	e00a      	b.n	8010178 <tcp_split_unsent_seg+0x350>
    offset -= q->len;
 8010162:	697b      	ldr	r3, [r7, #20]
 8010164:	895a      	ldrh	r2, [r3, #10]
 8010166:	2118      	movs	r1, #24
 8010168:	187b      	adds	r3, r7, r1
 801016a:	1879      	adds	r1, r7, r1
 801016c:	8809      	ldrh	r1, [r1, #0]
 801016e:	1a8a      	subs	r2, r1, r2
 8010170:	801a      	strh	r2, [r3, #0]
    q = q->next;
 8010172:	697b      	ldr	r3, [r7, #20]
 8010174:	681b      	ldr	r3, [r3, #0]
 8010176:	617b      	str	r3, [r7, #20]
  while (q != NULL && offset > q->len) {
 8010178:	697b      	ldr	r3, [r7, #20]
 801017a:	2b00      	cmp	r3, #0
 801017c:	d006      	beq.n	801018c <tcp_split_unsent_seg+0x364>
 801017e:	697b      	ldr	r3, [r7, #20]
 8010180:	895b      	ldrh	r3, [r3, #10]
 8010182:	2218      	movs	r2, #24
 8010184:	18ba      	adds	r2, r7, r2
 8010186:	8812      	ldrh	r2, [r2, #0]
 8010188:	429a      	cmp	r2, r3
 801018a:	d8ea      	bhi.n	8010162 <tcp_split_unsent_seg+0x33a>
  }
  LWIP_ASSERT("Found start of payload pbuf", q != NULL);
 801018c:	697b      	ldr	r3, [r7, #20]
 801018e:	2b00      	cmp	r3, #0
 8010190:	d141      	bne.n	8010216 <tcp_split_unsent_seg+0x3ee>
 8010192:	4b04      	ldr	r3, [pc, #16]	; (80101a4 <tcp_split_unsent_seg+0x37c>)
 8010194:	22ef      	movs	r2, #239	; 0xef
 8010196:	0092      	lsls	r2, r2, #2
 8010198:	490b      	ldr	r1, [pc, #44]	; (80101c8 <tcp_split_unsent_seg+0x3a0>)
 801019a:	4805      	ldr	r0, [pc, #20]	; (80101b0 <tcp_split_unsent_seg+0x388>)
 801019c:	f7f2 f816 	bl	80021cc <app_debug_rtt_raw>
  /* Checksum the first payload pbuf accounting for offset, then other pbufs are all payload */
  for (; q != NULL; offset = 0, q = q->next) {
 80101a0:	e039      	b.n	8010216 <tcp_split_unsent_seg+0x3ee>
 80101a2:	46c0      	nop			; (mov r8, r8)
 80101a4:	0801fe14 	.word	0x0801fe14
 80101a8:	0000034b 	.word	0x0000034b
 80101ac:	08020268 	.word	0x08020268
 80101b0:	0801fe60 	.word	0x0801fe60
 80101b4:	00000353 	.word	0x00000353
 80101b8:	0802028c 	.word	0x0802028c
 80101bc:	0000035b 	.word	0x0000035b
 80101c0:	080202b0 	.word	0x080202b0
 80101c4:	080202c0 	.word	0x080202c0
 80101c8:	080202d0 	.word	0x080202d0
    tcp_seg_add_chksum(~inet_chksum((const u8_t *)q->payload + offset, q->len - offset), q->len - offset,
 80101cc:	697b      	ldr	r3, [r7, #20]
 80101ce:	685a      	ldr	r2, [r3, #4]
 80101d0:	2418      	movs	r4, #24
 80101d2:	193b      	adds	r3, r7, r4
 80101d4:	881b      	ldrh	r3, [r3, #0]
 80101d6:	18d0      	adds	r0, r2, r3
 80101d8:	697b      	ldr	r3, [r7, #20]
 80101da:	895a      	ldrh	r2, [r3, #10]
 80101dc:	193b      	adds	r3, r7, r4
 80101de:	881b      	ldrh	r3, [r3, #0]
 80101e0:	1ad3      	subs	r3, r2, r3
 80101e2:	b29b      	uxth	r3, r3
 80101e4:	0019      	movs	r1, r3
 80101e6:	f7f7 fd8d 	bl	8007d04 <inet_chksum>
 80101ea:	0003      	movs	r3, r0
 80101ec:	43db      	mvns	r3, r3
 80101ee:	b298      	uxth	r0, r3
 80101f0:	697b      	ldr	r3, [r7, #20]
 80101f2:	895a      	ldrh	r2, [r3, #10]
 80101f4:	193b      	adds	r3, r7, r4
 80101f6:	881b      	ldrh	r3, [r3, #0]
 80101f8:	1ad3      	subs	r3, r2, r3
 80101fa:	b299      	uxth	r1, r3
 80101fc:	693b      	ldr	r3, [r7, #16]
 80101fe:	330c      	adds	r3, #12
 8010200:	001a      	movs	r2, r3
 8010202:	693b      	ldr	r3, [r7, #16]
 8010204:	330e      	adds	r3, #14
 8010206:	f7fe fff7 	bl	800f1f8 <tcp_seg_add_chksum>
  for (; q != NULL; offset = 0, q = q->next) {
 801020a:	193b      	adds	r3, r7, r4
 801020c:	2200      	movs	r2, #0
 801020e:	801a      	strh	r2, [r3, #0]
 8010210:	697b      	ldr	r3, [r7, #20]
 8010212:	681b      	ldr	r3, [r3, #0]
 8010214:	617b      	str	r3, [r7, #20]
 8010216:	697b      	ldr	r3, [r7, #20]
 8010218:	2b00      	cmp	r3, #0
 801021a:	d1d7      	bne.n	80101cc <tcp_split_unsent_seg+0x3a4>
#endif /* TCP_CHECKSUM_ON_COPY */

  /* Update number of segments on the queues. Note that length now may
   * exceed TCP_SND_QUEUELEN! We don't have to touch pcb->snd_buf
   * because the total amount of data is constant when packet is split */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 801021c:	69fb      	ldr	r3, [r7, #28]
 801021e:	685b      	ldr	r3, [r3, #4]
 8010220:	0018      	movs	r0, r3
 8010222:	f7f9 fad7 	bl	80097d4 <pbuf_clen>
 8010226:	0003      	movs	r3, r0
 8010228:	0019      	movs	r1, r3
 801022a:	687b      	ldr	r3, [r7, #4]
 801022c:	226a      	movs	r2, #106	; 0x6a
 801022e:	5a9b      	ldrh	r3, [r3, r2]
 8010230:	18cb      	adds	r3, r1, r3
 8010232:	b299      	uxth	r1, r3
 8010234:	687b      	ldr	r3, [r7, #4]
 8010236:	226a      	movs	r2, #106	; 0x6a
 8010238:	5299      	strh	r1, [r3, r2]

  /* Finally insert remainder into queue after split (which stays head) */
  seg->next = useg->next;
 801023a:	693b      	ldr	r3, [r7, #16]
 801023c:	681a      	ldr	r2, [r3, #0]
 801023e:	69fb      	ldr	r3, [r7, #28]
 8010240:	601a      	str	r2, [r3, #0]
  useg->next = seg;
 8010242:	693b      	ldr	r3, [r7, #16]
 8010244:	69fa      	ldr	r2, [r7, #28]
 8010246:	601a      	str	r2, [r3, #0]

#if TCP_OVERSIZE
  /* If remainder is last segment on the unsent, ensure we clear the oversize amount
   * because the remainder is always sized to the exact remaining amount */
  if (seg->next == NULL) {
 8010248:	69fb      	ldr	r3, [r7, #28]
 801024a:	681b      	ldr	r3, [r3, #0]
 801024c:	2b00      	cmp	r3, #0
 801024e:	d103      	bne.n	8010258 <tcp_split_unsent_seg+0x430>
    pcb->unsent_oversize = 0;
 8010250:	687b      	ldr	r3, [r7, #4]
 8010252:	226c      	movs	r2, #108	; 0x6c
 8010254:	2100      	movs	r1, #0
 8010256:	5299      	strh	r1, [r3, r2]
  }
#endif /* TCP_OVERSIZE */

  return ERR_OK;
 8010258:	2300      	movs	r3, #0
 801025a:	e014      	b.n	8010286 <tcp_split_unsent_seg+0x45e>
    goto memerr;
 801025c:	46c0      	nop			; (mov r8, r8)
 801025e:	e000      	b.n	8010262 <tcp_split_unsent_seg+0x43a>
    goto memerr;
 8010260:	46c0      	nop			; (mov r8, r8)
memerr:
  TCP_STATS_INC(tcp.memerr);

  LWIP_ASSERT("seg == NULL", seg == NULL);
 8010262:	69fb      	ldr	r3, [r7, #28]
 8010264:	2b00      	cmp	r3, #0
 8010266:	d005      	beq.n	8010274 <tcp_split_unsent_seg+0x44c>
 8010268:	4b09      	ldr	r3, [pc, #36]	; (8010290 <tcp_split_unsent_seg+0x468>)
 801026a:	4a0a      	ldr	r2, [pc, #40]	; (8010294 <tcp_split_unsent_seg+0x46c>)
 801026c:	490a      	ldr	r1, [pc, #40]	; (8010298 <tcp_split_unsent_seg+0x470>)
 801026e:	480b      	ldr	r0, [pc, #44]	; (801029c <tcp_split_unsent_seg+0x474>)
 8010270:	f7f1 ffac 	bl	80021cc <app_debug_rtt_raw>
  if (p != NULL) {
 8010274:	6a3b      	ldr	r3, [r7, #32]
 8010276:	2b00      	cmp	r3, #0
 8010278:	d003      	beq.n	8010282 <tcp_split_unsent_seg+0x45a>
    pbuf_free(p);
 801027a:	6a3b      	ldr	r3, [r7, #32]
 801027c:	0018      	movs	r0, r3
 801027e:	f7f9 fa09 	bl	8009694 <pbuf_free>
  }

  return ERR_MEM;
 8010282:	2301      	movs	r3, #1
 8010284:	425b      	negs	r3, r3
}
 8010286:	0018      	movs	r0, r3
 8010288:	46bd      	mov	sp, r7
 801028a:	b00b      	add	sp, #44	; 0x2c
 801028c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801028e:	46c0      	nop			; (mov r8, r8)
 8010290:	0801fe14 	.word	0x0801fe14
 8010294:	000003d9 	.word	0x000003d9
 8010298:	080202ec 	.word	0x080202ec
 801029c:	0801fe60 	.word	0x0801fe60

080102a0 <tcp_send_fin>:
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
 80102a0:	b590      	push	{r4, r7, lr}
 80102a2:	b085      	sub	sp, #20
 80102a4:	af00      	add	r7, sp, #0
 80102a6:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_send_fin: invalid pcb", pcb != NULL);
 80102a8:	687b      	ldr	r3, [r7, #4]
 80102aa:	2b00      	cmp	r3, #0
 80102ac:	d106      	bne.n	80102bc <tcp_send_fin+0x1c>
 80102ae:	4b2e      	ldr	r3, [pc, #184]	; (8010368 <tcp_send_fin+0xc8>)
 80102b0:	22fb      	movs	r2, #251	; 0xfb
 80102b2:	0092      	lsls	r2, r2, #2
 80102b4:	492d      	ldr	r1, [pc, #180]	; (801036c <tcp_send_fin+0xcc>)
 80102b6:	482e      	ldr	r0, [pc, #184]	; (8010370 <tcp_send_fin+0xd0>)
 80102b8:	f7f1 ff88 	bl	80021cc <app_debug_rtt_raw>

  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
 80102bc:	687b      	ldr	r3, [r7, #4]
 80102be:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80102c0:	2b00      	cmp	r3, #0
 80102c2:	d046      	beq.n	8010352 <tcp_send_fin+0xb2>
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 80102c4:	687b      	ldr	r3, [r7, #4]
 80102c6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80102c8:	60fb      	str	r3, [r7, #12]
 80102ca:	e002      	b.n	80102d2 <tcp_send_fin+0x32>
         last_unsent = last_unsent->next);
 80102cc:	68fb      	ldr	r3, [r7, #12]
 80102ce:	681b      	ldr	r3, [r3, #0]
 80102d0:	60fb      	str	r3, [r7, #12]
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 80102d2:	68fb      	ldr	r3, [r7, #12]
 80102d4:	681b      	ldr	r3, [r3, #0]
 80102d6:	2b00      	cmp	r3, #0
 80102d8:	d1f8      	bne.n	80102cc <tcp_send_fin+0x2c>

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
 80102da:	68fb      	ldr	r3, [r7, #12]
 80102dc:	691b      	ldr	r3, [r3, #16]
 80102de:	7b1a      	ldrb	r2, [r3, #12]
 80102e0:	7b5b      	ldrb	r3, [r3, #13]
 80102e2:	021b      	lsls	r3, r3, #8
 80102e4:	4313      	orrs	r3, r2
 80102e6:	b29b      	uxth	r3, r3
 80102e8:	0018      	movs	r0, r3
 80102ea:	f7f6 f923 	bl	8006534 <lwip_htons>
 80102ee:	0003      	movs	r3, r0
 80102f0:	b2db      	uxtb	r3, r3
 80102f2:	001a      	movs	r2, r3
 80102f4:	2307      	movs	r3, #7
 80102f6:	4013      	ands	r3, r2
 80102f8:	d12b      	bne.n	8010352 <tcp_send_fin+0xb2>
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
 80102fa:	68fb      	ldr	r3, [r7, #12]
 80102fc:	691b      	ldr	r3, [r3, #16]
 80102fe:	7b1a      	ldrb	r2, [r3, #12]
 8010300:	7b5b      	ldrb	r3, [r3, #13]
 8010302:	021b      	lsls	r3, r3, #8
 8010304:	4313      	orrs	r3, r2
 8010306:	b29c      	uxth	r4, r3
 8010308:	2001      	movs	r0, #1
 801030a:	f7f6 f913 	bl	8006534 <lwip_htons>
 801030e:	0003      	movs	r3, r0
 8010310:	001a      	movs	r2, r3
 8010312:	68fb      	ldr	r3, [r7, #12]
 8010314:	691b      	ldr	r3, [r3, #16]
 8010316:	4322      	orrs	r2, r4
 8010318:	b292      	uxth	r2, r2
 801031a:	21ff      	movs	r1, #255	; 0xff
 801031c:	4011      	ands	r1, r2
 801031e:	000c      	movs	r4, r1
 8010320:	7b19      	ldrb	r1, [r3, #12]
 8010322:	2000      	movs	r0, #0
 8010324:	4001      	ands	r1, r0
 8010326:	1c08      	adds	r0, r1, #0
 8010328:	1c21      	adds	r1, r4, #0
 801032a:	4301      	orrs	r1, r0
 801032c:	7319      	strb	r1, [r3, #12]
 801032e:	0a12      	lsrs	r2, r2, #8
 8010330:	b290      	uxth	r0, r2
 8010332:	7b5a      	ldrb	r2, [r3, #13]
 8010334:	2100      	movs	r1, #0
 8010336:	400a      	ands	r2, r1
 8010338:	1c11      	adds	r1, r2, #0
 801033a:	1c02      	adds	r2, r0, #0
 801033c:	430a      	orrs	r2, r1
 801033e:	735a      	strb	r2, [r3, #13]
      tcp_set_flags(pcb, TF_FIN);
 8010340:	687b      	ldr	r3, [r7, #4]
 8010342:	8bdb      	ldrh	r3, [r3, #30]
 8010344:	2220      	movs	r2, #32
 8010346:	4313      	orrs	r3, r2
 8010348:	b29a      	uxth	r2, r3
 801034a:	687b      	ldr	r3, [r7, #4]
 801034c:	83da      	strh	r2, [r3, #30]
      return ERR_OK;
 801034e:	2300      	movs	r3, #0
 8010350:	e005      	b.n	801035e <tcp_send_fin+0xbe>
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
 8010352:	687b      	ldr	r3, [r7, #4]
 8010354:	2101      	movs	r1, #1
 8010356:	0018      	movs	r0, r3
 8010358:	f000 f80c 	bl	8010374 <tcp_enqueue_flags>
 801035c:	0003      	movs	r3, r0
}
 801035e:	0018      	movs	r0, r3
 8010360:	46bd      	mov	sp, r7
 8010362:	b005      	add	sp, #20
 8010364:	bd90      	pop	{r4, r7, pc}
 8010366:	46c0      	nop			; (mov r8, r8)
 8010368:	0801fe14 	.word	0x0801fe14
 801036c:	080202f8 	.word	0x080202f8
 8010370:	0801fe60 	.word	0x0801fe60

08010374 <tcp_enqueue_flags>:
 * @param pcb Protocol control block for the TCP connection.
 * @param flags TCP header flags to set in the outgoing segment.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
 8010374:	b590      	push	{r4, r7, lr}
 8010376:	b089      	sub	sp, #36	; 0x24
 8010378:	af02      	add	r7, sp, #8
 801037a:	6078      	str	r0, [r7, #4]
 801037c:	000a      	movs	r2, r1
 801037e:	1cfb      	adds	r3, r7, #3
 8010380:	701a      	strb	r2, [r3, #0]
  struct pbuf *p;
  struct tcp_seg *seg;
  u8_t optflags = 0;
 8010382:	2317      	movs	r3, #23
 8010384:	18fb      	adds	r3, r7, r3
 8010386:	2200      	movs	r2, #0
 8010388:	701a      	strb	r2, [r3, #0]
  u8_t optlen = 0;
 801038a:	2316      	movs	r3, #22
 801038c:	18fb      	adds	r3, r7, r3
 801038e:	2200      	movs	r2, #0
 8010390:	701a      	strb	r2, [r3, #0]

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
 8010392:	1cfb      	adds	r3, r7, #3
 8010394:	781b      	ldrb	r3, [r3, #0]
 8010396:	2203      	movs	r2, #3
 8010398:	4013      	ands	r3, r2
 801039a:	d105      	bne.n	80103a8 <tcp_enqueue_flags+0x34>
 801039c:	4b6a      	ldr	r3, [pc, #424]	; (8010548 <tcp_enqueue_flags+0x1d4>)
 801039e:	4a6b      	ldr	r2, [pc, #428]	; (801054c <tcp_enqueue_flags+0x1d8>)
 80103a0:	496b      	ldr	r1, [pc, #428]	; (8010550 <tcp_enqueue_flags+0x1dc>)
 80103a2:	486c      	ldr	r0, [pc, #432]	; (8010554 <tcp_enqueue_flags+0x1e0>)
 80103a4:	f7f1 ff12 	bl	80021cc <app_debug_rtt_raw>
              (flags & (TCP_SYN | TCP_FIN)) != 0);
  LWIP_ASSERT("tcp_enqueue_flags: invalid pcb", pcb != NULL);
 80103a8:	687b      	ldr	r3, [r7, #4]
 80103aa:	2b00      	cmp	r3, #0
 80103ac:	d105      	bne.n	80103ba <tcp_enqueue_flags+0x46>
 80103ae:	4b66      	ldr	r3, [pc, #408]	; (8010548 <tcp_enqueue_flags+0x1d4>)
 80103b0:	4a69      	ldr	r2, [pc, #420]	; (8010558 <tcp_enqueue_flags+0x1e4>)
 80103b2:	496a      	ldr	r1, [pc, #424]	; (801055c <tcp_enqueue_flags+0x1e8>)
 80103b4:	4867      	ldr	r0, [pc, #412]	; (8010554 <tcp_enqueue_flags+0x1e0>)
 80103b6:	f7f1 ff09 	bl	80021cc <app_debug_rtt_raw>

  /* No need to check pcb->snd_queuelen if only SYN or FIN are allowed! */

  /* Get options for this segment. This is a special case since this is the
     only place where a SYN can be sent. */
  if (flags & TCP_SYN) {
 80103ba:	1cfb      	adds	r3, r7, #3
 80103bc:	781b      	ldrb	r3, [r3, #0]
 80103be:	2202      	movs	r2, #2
 80103c0:	4013      	ands	r3, r2
 80103c2:	d003      	beq.n	80103cc <tcp_enqueue_flags+0x58>
    optflags = TF_SEG_OPTS_MSS;
 80103c4:	2317      	movs	r3, #23
 80103c6:	18fb      	adds	r3, r7, r3
 80103c8:	2201      	movs	r2, #1
 80103ca:	701a      	strb	r2, [r3, #0]
    /* Make sure the timestamp option is only included in data segments if we
       agreed about it with the remote host (and in active open SYN segments). */
    optflags |= TF_SEG_OPTS_TS;
  }
#endif /* LWIP_TCP_TIMESTAMPS */
  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 80103cc:	2317      	movs	r3, #23
 80103ce:	18fb      	adds	r3, r7, r3
 80103d0:	781b      	ldrb	r3, [r3, #0]
 80103d2:	009b      	lsls	r3, r3, #2
 80103d4:	b2da      	uxtb	r2, r3
 80103d6:	2016      	movs	r0, #22
 80103d8:	183b      	adds	r3, r7, r0
 80103da:	2104      	movs	r1, #4
 80103dc:	400a      	ands	r2, r1
 80103de:	701a      	strb	r2, [r3, #0]

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 80103e0:	183b      	adds	r3, r7, r0
 80103e2:	781b      	ldrb	r3, [r3, #0]
 80103e4:	b29b      	uxth	r3, r3
 80103e6:	22a0      	movs	r2, #160	; 0xa0
 80103e8:	0092      	lsls	r2, r2, #2
 80103ea:	0019      	movs	r1, r3
 80103ec:	2038      	movs	r0, #56	; 0x38
 80103ee:	f7f8 fdd9 	bl	8008fa4 <pbuf_alloc>
 80103f2:	0003      	movs	r3, r0
 80103f4:	60fb      	str	r3, [r7, #12]
 80103f6:	68fb      	ldr	r3, [r7, #12]
 80103f8:	2b00      	cmp	r3, #0
 80103fa:	d109      	bne.n	8010410 <tcp_enqueue_flags+0x9c>
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 80103fc:	687b      	ldr	r3, [r7, #4]
 80103fe:	8bdb      	ldrh	r3, [r3, #30]
 8010400:	2280      	movs	r2, #128	; 0x80
 8010402:	4313      	orrs	r3, r2
 8010404:	b29a      	uxth	r2, r3
 8010406:	687b      	ldr	r3, [r7, #4]
 8010408:	83da      	strh	r2, [r3, #30]
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
 801040a:	2301      	movs	r3, #1
 801040c:	425b      	negs	r3, r3
 801040e:	e097      	b.n	8010540 <tcp_enqueue_flags+0x1cc>
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
 8010410:	68fb      	ldr	r3, [r7, #12]
 8010412:	895a      	ldrh	r2, [r3, #10]
 8010414:	2316      	movs	r3, #22
 8010416:	18fb      	adds	r3, r7, r3
 8010418:	781b      	ldrb	r3, [r3, #0]
 801041a:	b29b      	uxth	r3, r3
 801041c:	429a      	cmp	r2, r3
 801041e:	d205      	bcs.n	801042c <tcp_enqueue_flags+0xb8>
 8010420:	4b49      	ldr	r3, [pc, #292]	; (8010548 <tcp_enqueue_flags+0x1d4>)
 8010422:	4a4f      	ldr	r2, [pc, #316]	; (8010560 <tcp_enqueue_flags+0x1ec>)
 8010424:	494f      	ldr	r1, [pc, #316]	; (8010564 <tcp_enqueue_flags+0x1f0>)
 8010426:	484b      	ldr	r0, [pc, #300]	; (8010554 <tcp_enqueue_flags+0x1e0>)
 8010428:	f7f1 fed0 	bl	80021cc <app_debug_rtt_raw>
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
 801042c:	687b      	ldr	r3, [r7, #4]
 801042e:	6e1c      	ldr	r4, [r3, #96]	; 0x60
 8010430:	1cfb      	adds	r3, r7, #3
 8010432:	781a      	ldrb	r2, [r3, #0]
 8010434:	68f9      	ldr	r1, [r7, #12]
 8010436:	6878      	ldr	r0, [r7, #4]
 8010438:	2317      	movs	r3, #23
 801043a:	18fb      	adds	r3, r7, r3
 801043c:	781b      	ldrb	r3, [r3, #0]
 801043e:	9300      	str	r3, [sp, #0]
 8010440:	0023      	movs	r3, r4
 8010442:	f7fe fd19 	bl	800ee78 <tcp_create_segment>
 8010446:	0003      	movs	r3, r0
 8010448:	60bb      	str	r3, [r7, #8]
 801044a:	68bb      	ldr	r3, [r7, #8]
 801044c:	2b00      	cmp	r3, #0
 801044e:	d109      	bne.n	8010464 <tcp_enqueue_flags+0xf0>
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
 8010450:	687b      	ldr	r3, [r7, #4]
 8010452:	8bdb      	ldrh	r3, [r3, #30]
 8010454:	2280      	movs	r2, #128	; 0x80
 8010456:	4313      	orrs	r3, r2
 8010458:	b29a      	uxth	r2, r3
 801045a:	687b      	ldr	r3, [r7, #4]
 801045c:	83da      	strh	r2, [r3, #30]
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
 801045e:	2301      	movs	r3, #1
 8010460:	425b      	negs	r3, r3
 8010462:	e06d      	b.n	8010540 <tcp_enqueue_flags+0x1cc>
  }
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % LWIP_MIN(MEM_ALIGNMENT, 4)) == 0);
 8010464:	68bb      	ldr	r3, [r7, #8]
 8010466:	691b      	ldr	r3, [r3, #16]
 8010468:	001a      	movs	r2, r3
 801046a:	2303      	movs	r3, #3
 801046c:	4013      	ands	r3, r2
 801046e:	d005      	beq.n	801047c <tcp_enqueue_flags+0x108>
 8010470:	4b35      	ldr	r3, [pc, #212]	; (8010548 <tcp_enqueue_flags+0x1d4>)
 8010472:	4a3d      	ldr	r2, [pc, #244]	; (8010568 <tcp_enqueue_flags+0x1f4>)
 8010474:	493d      	ldr	r1, [pc, #244]	; (801056c <tcp_enqueue_flags+0x1f8>)
 8010476:	4837      	ldr	r0, [pc, #220]	; (8010554 <tcp_enqueue_flags+0x1e0>)
 8010478:	f7f1 fea8 	bl	80021cc <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
 801047c:	68bb      	ldr	r3, [r7, #8]
 801047e:	891b      	ldrh	r3, [r3, #8]
 8010480:	2b00      	cmp	r3, #0
 8010482:	d005      	beq.n	8010490 <tcp_enqueue_flags+0x11c>
 8010484:	4b30      	ldr	r3, [pc, #192]	; (8010548 <tcp_enqueue_flags+0x1d4>)
 8010486:	4a3a      	ldr	r2, [pc, #232]	; (8010570 <tcp_enqueue_flags+0x1fc>)
 8010488:	493a      	ldr	r1, [pc, #232]	; (8010574 <tcp_enqueue_flags+0x200>)
 801048a:	4832      	ldr	r0, [pc, #200]	; (8010554 <tcp_enqueue_flags+0x1e0>)
 801048c:	f7f1 fe9e 	bl	80021cc <app_debug_rtt_raw>
               lwip_ntohl(seg->tcphdr->seqno),
               lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
 8010490:	687b      	ldr	r3, [r7, #4]
 8010492:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010494:	2b00      	cmp	r3, #0
 8010496:	d103      	bne.n	80104a0 <tcp_enqueue_flags+0x12c>
    pcb->unsent = seg;
 8010498:	687b      	ldr	r3, [r7, #4]
 801049a:	68ba      	ldr	r2, [r7, #8]
 801049c:	671a      	str	r2, [r3, #112]	; 0x70
 801049e:	e00d      	b.n	80104bc <tcp_enqueue_flags+0x148>
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 80104a0:	687b      	ldr	r3, [r7, #4]
 80104a2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80104a4:	613b      	str	r3, [r7, #16]
 80104a6:	e002      	b.n	80104ae <tcp_enqueue_flags+0x13a>
 80104a8:	693b      	ldr	r3, [r7, #16]
 80104aa:	681b      	ldr	r3, [r3, #0]
 80104ac:	613b      	str	r3, [r7, #16]
 80104ae:	693b      	ldr	r3, [r7, #16]
 80104b0:	681b      	ldr	r3, [r3, #0]
 80104b2:	2b00      	cmp	r3, #0
 80104b4:	d1f8      	bne.n	80104a8 <tcp_enqueue_flags+0x134>
    useg->next = seg;
 80104b6:	693b      	ldr	r3, [r7, #16]
 80104b8:	68ba      	ldr	r2, [r7, #8]
 80104ba:	601a      	str	r2, [r3, #0]
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
 80104bc:	687b      	ldr	r3, [r7, #4]
 80104be:	226c      	movs	r2, #108	; 0x6c
 80104c0:	2100      	movs	r1, #0
 80104c2:	5299      	strh	r1, [r3, r2]
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 80104c4:	1cfb      	adds	r3, r7, #3
 80104c6:	781b      	ldrb	r3, [r3, #0]
 80104c8:	2202      	movs	r2, #2
 80104ca:	4013      	ands	r3, r2
 80104cc:	d104      	bne.n	80104d8 <tcp_enqueue_flags+0x164>
 80104ce:	1cfb      	adds	r3, r7, #3
 80104d0:	781b      	ldrb	r3, [r3, #0]
 80104d2:	2201      	movs	r2, #1
 80104d4:	4013      	ands	r3, r2
 80104d6:	d004      	beq.n	80104e2 <tcp_enqueue_flags+0x16e>
    pcb->snd_lbb++;
 80104d8:	687b      	ldr	r3, [r7, #4]
 80104da:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80104dc:	1c5a      	adds	r2, r3, #1
 80104de:	687b      	ldr	r3, [r7, #4]
 80104e0:	661a      	str	r2, [r3, #96]	; 0x60
    /* optlen does not influence snd_buf */
  }
  if (flags & TCP_FIN) {
 80104e2:	1cfb      	adds	r3, r7, #3
 80104e4:	781b      	ldrb	r3, [r3, #0]
 80104e6:	2201      	movs	r2, #1
 80104e8:	4013      	ands	r3, r2
 80104ea:	d006      	beq.n	80104fa <tcp_enqueue_flags+0x186>
    tcp_set_flags(pcb, TF_FIN);
 80104ec:	687b      	ldr	r3, [r7, #4]
 80104ee:	8bdb      	ldrh	r3, [r3, #30]
 80104f0:	2220      	movs	r2, #32
 80104f2:	4313      	orrs	r3, r2
 80104f4:	b29a      	uxth	r2, r3
 80104f6:	687b      	ldr	r3, [r7, #4]
 80104f8:	83da      	strh	r2, [r3, #30]
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 80104fa:	68bb      	ldr	r3, [r7, #8]
 80104fc:	685b      	ldr	r3, [r3, #4]
 80104fe:	0018      	movs	r0, r3
 8010500:	f7f9 f968 	bl	80097d4 <pbuf_clen>
 8010504:	0003      	movs	r3, r0
 8010506:	0019      	movs	r1, r3
 8010508:	687b      	ldr	r3, [r7, #4]
 801050a:	226a      	movs	r2, #106	; 0x6a
 801050c:	5a9b      	ldrh	r3, [r3, r2]
 801050e:	18cb      	adds	r3, r1, r3
 8010510:	b299      	uxth	r1, r3
 8010512:	687b      	ldr	r3, [r7, #4]
 8010514:	226a      	movs	r2, #106	; 0x6a
 8010516:	5299      	strh	r1, [r3, r2]
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
 8010518:	687b      	ldr	r3, [r7, #4]
 801051a:	226a      	movs	r2, #106	; 0x6a
 801051c:	5a9b      	ldrh	r3, [r3, r2]
 801051e:	2b00      	cmp	r3, #0
 8010520:	d00d      	beq.n	801053e <tcp_enqueue_flags+0x1ca>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
 8010522:	687b      	ldr	r3, [r7, #4]
 8010524:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8010526:	2b00      	cmp	r3, #0
 8010528:	d109      	bne.n	801053e <tcp_enqueue_flags+0x1ca>
 801052a:	687b      	ldr	r3, [r7, #4]
 801052c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801052e:	2b00      	cmp	r3, #0
 8010530:	d105      	bne.n	801053e <tcp_enqueue_flags+0x1ca>
 8010532:	4b05      	ldr	r3, [pc, #20]	; (8010548 <tcp_enqueue_flags+0x1d4>)
 8010534:	4a10      	ldr	r2, [pc, #64]	; (8010578 <tcp_enqueue_flags+0x204>)
 8010536:	4911      	ldr	r1, [pc, #68]	; (801057c <tcp_enqueue_flags+0x208>)
 8010538:	4806      	ldr	r0, [pc, #24]	; (8010554 <tcp_enqueue_flags+0x1e0>)
 801053a:	f7f1 fe47 	bl	80021cc <app_debug_rtt_raw>
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
 801053e:	2300      	movs	r3, #0
}
 8010540:	0018      	movs	r0, r3
 8010542:	46bd      	mov	sp, r7
 8010544:	b007      	add	sp, #28
 8010546:	bd90      	pop	{r4, r7, pc}
 8010548:	0801fe14 	.word	0x0801fe14
 801054c:	00000412 	.word	0x00000412
 8010550:	08020314 	.word	0x08020314
 8010554:	0801fe60 	.word	0x0801fe60
 8010558:	00000414 	.word	0x00000414
 801055c:	0802036c 	.word	0x0802036c
 8010560:	0000043a 	.word	0x0000043a
 8010564:	0802038c 	.word	0x0802038c
 8010568:	00000443 	.word	0x00000443
 801056c:	080203c8 	.word	0x080203c8
 8010570:	00000444 	.word	0x00000444
 8010574:	080203e0 	.word	0x080203e0
 8010578:	00000466 	.word	0x00000466
 801057c:	0802040c 	.word	0x0802040c

08010580 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
 8010580:	b5b0      	push	{r4, r5, r7, lr}
 8010582:	b08a      	sub	sp, #40	; 0x28
 8010584:	af00      	add	r7, sp, #0
 8010586:	6078      	str	r0, [r7, #4]
  s16_t i = 0;
#endif /* TCP_CWND_DEBUG */

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("tcp_output: invalid pcb", pcb != NULL);
 8010588:	687b      	ldr	r3, [r7, #4]
 801058a:	2b00      	cmp	r3, #0
 801058c:	d105      	bne.n	801059a <tcp_output+0x1a>
 801058e:	4bcb      	ldr	r3, [pc, #812]	; (80108bc <tcp_output+0x33c>)
 8010590:	4acb      	ldr	r2, [pc, #812]	; (80108c0 <tcp_output+0x340>)
 8010592:	49cc      	ldr	r1, [pc, #816]	; (80108c4 <tcp_output+0x344>)
 8010594:	48cc      	ldr	r0, [pc, #816]	; (80108c8 <tcp_output+0x348>)
 8010596:	f7f1 fe19 	bl	80021cc <app_debug_rtt_raw>
  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
 801059a:	687b      	ldr	r3, [r7, #4]
 801059c:	7e1b      	ldrb	r3, [r3, #24]
 801059e:	2b01      	cmp	r3, #1
 80105a0:	d105      	bne.n	80105ae <tcp_output+0x2e>
 80105a2:	4bc6      	ldr	r3, [pc, #792]	; (80108bc <tcp_output+0x33c>)
 80105a4:	4ac9      	ldr	r2, [pc, #804]	; (80108cc <tcp_output+0x34c>)
 80105a6:	49ca      	ldr	r1, [pc, #808]	; (80108d0 <tcp_output+0x350>)
 80105a8:	48c7      	ldr	r0, [pc, #796]	; (80108c8 <tcp_output+0x348>)
 80105aa:	f7f1 fe0f 	bl	80021cc <app_debug_rtt_raw>

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
 80105ae:	4bc9      	ldr	r3, [pc, #804]	; (80108d4 <tcp_output+0x354>)
 80105b0:	681b      	ldr	r3, [r3, #0]
 80105b2:	687a      	ldr	r2, [r7, #4]
 80105b4:	429a      	cmp	r2, r3
 80105b6:	d101      	bne.n	80105bc <tcp_output+0x3c>
    return ERR_OK;
 80105b8:	2300      	movs	r3, #0
 80105ba:	e23d      	b.n	8010a38 <tcp_output+0x4b8>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 80105bc:	687b      	ldr	r3, [r7, #4]
 80105be:	224c      	movs	r2, #76	; 0x4c
 80105c0:	5a99      	ldrh	r1, [r3, r2]
 80105c2:	687b      	ldr	r3, [r7, #4]
 80105c4:	2264      	movs	r2, #100	; 0x64
 80105c6:	5a9b      	ldrh	r3, [r3, r2]
 80105c8:	1c18      	adds	r0, r3, #0
 80105ca:	b28a      	uxth	r2, r1
 80105cc:	b283      	uxth	r3, r0
 80105ce:	429a      	cmp	r2, r3
 80105d0:	d900      	bls.n	80105d4 <tcp_output+0x54>
 80105d2:	1c01      	adds	r1, r0, #0
 80105d4:	b28b      	uxth	r3, r1
 80105d6:	61bb      	str	r3, [r7, #24]

  seg = pcb->unsent;
 80105d8:	687b      	ldr	r3, [r7, #4]
 80105da:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80105dc:	627b      	str	r3, [r7, #36]	; 0x24

  if (seg == NULL) {
 80105de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80105e0:	2b00      	cmp	r3, #0
 80105e2:	d10c      	bne.n	80105fe <tcp_output+0x7e>
                                 ", seg == NULL, ack %"U32_F"\n",
                                 pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));

    /* If the TF_ACK_NOW flag is set and the ->unsent queue is empty, construct
     * an empty ACK segment and send it. */
    if (pcb->flags & TF_ACK_NOW) {
 80105e4:	687b      	ldr	r3, [r7, #4]
 80105e6:	8bdb      	ldrh	r3, [r3, #30]
 80105e8:	001a      	movs	r2, r3
 80105ea:	2302      	movs	r3, #2
 80105ec:	4013      	ands	r3, r2
 80105ee:	d100      	bne.n	80105f2 <tcp_output+0x72>
 80105f0:	e215      	b.n	8010a1e <tcp_output+0x49e>
      return tcp_send_empty_ack(pcb);
 80105f2:	687b      	ldr	r3, [r7, #4]
 80105f4:	0018      	movs	r0, r3
 80105f6:	f001 f877 	bl	80116e8 <tcp_send_empty_ack>
 80105fa:	0003      	movs	r3, r0
 80105fc:	e21c      	b.n	8010a38 <tcp_output+0x4b8>
                 pcb->snd_wnd, pcb->cwnd, wnd,
                 lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 lwip_ntohl(seg->tcphdr->seqno), pcb->lastack));
  }

  netif = tcp_route(pcb, &pcb->local_ip, &pcb->remote_ip);
 80105fe:	6879      	ldr	r1, [r7, #4]
 8010600:	687b      	ldr	r3, [r7, #4]
 8010602:	1d1a      	adds	r2, r3, #4
 8010604:	687b      	ldr	r3, [r7, #4]
 8010606:	0018      	movs	r0, r3
 8010608:	f7fe fc18 	bl	800ee3c <tcp_route>
 801060c:	0003      	movs	r3, r0
 801060e:	617b      	str	r3, [r7, #20]
  if (netif == NULL) {
 8010610:	697b      	ldr	r3, [r7, #20]
 8010612:	2b00      	cmp	r3, #0
 8010614:	d102      	bne.n	801061c <tcp_output+0x9c>
    return ERR_RTE;
 8010616:	2304      	movs	r3, #4
 8010618:	425b      	negs	r3, r3
 801061a:	e20d      	b.n	8010a38 <tcp_output+0x4b8>
  }

  /* If we don't have a local IP address, we get one from netif */
  if (ip_addr_isany(&pcb->local_ip)) {
 801061c:	687b      	ldr	r3, [r7, #4]
 801061e:	2b00      	cmp	r3, #0
 8010620:	d003      	beq.n	801062a <tcp_output+0xaa>
 8010622:	687b      	ldr	r3, [r7, #4]
 8010624:	681b      	ldr	r3, [r3, #0]
 8010626:	2b00      	cmp	r3, #0
 8010628:	d111      	bne.n	801064e <tcp_output+0xce>
    const ip_addr_t *local_ip = ip_netif_get_local_ip(netif, &pcb->remote_ip);
 801062a:	697b      	ldr	r3, [r7, #20]
 801062c:	2b00      	cmp	r3, #0
 801062e:	d002      	beq.n	8010636 <tcp_output+0xb6>
 8010630:	697b      	ldr	r3, [r7, #20]
 8010632:	3304      	adds	r3, #4
 8010634:	e000      	b.n	8010638 <tcp_output+0xb8>
 8010636:	2300      	movs	r3, #0
 8010638:	613b      	str	r3, [r7, #16]
    if (local_ip == NULL) {
 801063a:	693b      	ldr	r3, [r7, #16]
 801063c:	2b00      	cmp	r3, #0
 801063e:	d102      	bne.n	8010646 <tcp_output+0xc6>
      return ERR_RTE;
 8010640:	2304      	movs	r3, #4
 8010642:	425b      	negs	r3, r3
 8010644:	e1f8      	b.n	8010a38 <tcp_output+0x4b8>
    }
    ip_addr_copy(pcb->local_ip, *local_ip);
 8010646:	693b      	ldr	r3, [r7, #16]
 8010648:	681a      	ldr	r2, [r3, #0]
 801064a:	687b      	ldr	r3, [r7, #4]
 801064c:	601a      	str	r2, [r3, #0]
  }

  /* Handle the current segment not fitting within the window */
  if (lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd) {
 801064e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010650:	691b      	ldr	r3, [r3, #16]
 8010652:	791a      	ldrb	r2, [r3, #4]
 8010654:	7959      	ldrb	r1, [r3, #5]
 8010656:	0209      	lsls	r1, r1, #8
 8010658:	430a      	orrs	r2, r1
 801065a:	7999      	ldrb	r1, [r3, #6]
 801065c:	0409      	lsls	r1, r1, #16
 801065e:	430a      	orrs	r2, r1
 8010660:	79db      	ldrb	r3, [r3, #7]
 8010662:	061b      	lsls	r3, r3, #24
 8010664:	4313      	orrs	r3, r2
 8010666:	0018      	movs	r0, r3
 8010668:	f7f5 ff7a 	bl	8006560 <lwip_htonl>
 801066c:	0002      	movs	r2, r0
 801066e:	687b      	ldr	r3, [r7, #4]
 8010670:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8010672:	1ad3      	subs	r3, r2, r3
 8010674:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8010676:	8912      	ldrh	r2, [r2, #8]
 8010678:	189b      	adds	r3, r3, r2
 801067a:	69ba      	ldr	r2, [r7, #24]
 801067c:	429a      	cmp	r2, r3
 801067e:	d228      	bcs.n	80106d2 <tcp_output+0x152>
     * within the remaining (could be 0) send window and RTO timer is not running (we
     * have no in-flight data). If window is still too small after persist timer fires,
     * then we split the segment. We don't consider the congestion window since a cwnd
     * smaller than 1 SMSS implies in-flight data
     */
    if (wnd == pcb->snd_wnd && pcb->unacked == NULL && pcb->persist_backoff == 0) {
 8010680:	687b      	ldr	r3, [r7, #4]
 8010682:	2264      	movs	r2, #100	; 0x64
 8010684:	5a9b      	ldrh	r3, [r3, r2]
 8010686:	001a      	movs	r2, r3
 8010688:	69bb      	ldr	r3, [r7, #24]
 801068a:	4293      	cmp	r3, r2
 801068c:	d114      	bne.n	80106b8 <tcp_output+0x138>
 801068e:	687b      	ldr	r3, [r7, #4]
 8010690:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8010692:	2b00      	cmp	r3, #0
 8010694:	d110      	bne.n	80106b8 <tcp_output+0x138>
 8010696:	687b      	ldr	r3, [r7, #4]
 8010698:	22a5      	movs	r2, #165	; 0xa5
 801069a:	5c9b      	ldrb	r3, [r3, r2]
 801069c:	2b00      	cmp	r3, #0
 801069e:	d10b      	bne.n	80106b8 <tcp_output+0x138>
      pcb->persist_cnt = 0;
 80106a0:	687b      	ldr	r3, [r7, #4]
 80106a2:	22a4      	movs	r2, #164	; 0xa4
 80106a4:	2100      	movs	r1, #0
 80106a6:	5499      	strb	r1, [r3, r2]
      pcb->persist_backoff = 1;
 80106a8:	687b      	ldr	r3, [r7, #4]
 80106aa:	22a5      	movs	r2, #165	; 0xa5
 80106ac:	2101      	movs	r1, #1
 80106ae:	5499      	strb	r1, [r3, r2]
      pcb->persist_probe = 0;
 80106b0:	687b      	ldr	r3, [r7, #4]
 80106b2:	22a6      	movs	r2, #166	; 0xa6
 80106b4:	2100      	movs	r1, #0
 80106b6:	5499      	strb	r1, [r3, r2]
    }
    /* We need an ACK, but can't send data now, so send an empty ACK */
    if (pcb->flags & TF_ACK_NOW) {
 80106b8:	687b      	ldr	r3, [r7, #4]
 80106ba:	8bdb      	ldrh	r3, [r3, #30]
 80106bc:	001a      	movs	r2, r3
 80106be:	2302      	movs	r3, #2
 80106c0:	4013      	ands	r3, r2
 80106c2:	d100      	bne.n	80106c6 <tcp_output+0x146>
 80106c4:	e1ad      	b.n	8010a22 <tcp_output+0x4a2>
      return tcp_send_empty_ack(pcb);
 80106c6:	687b      	ldr	r3, [r7, #4]
 80106c8:	0018      	movs	r0, r3
 80106ca:	f001 f80d 	bl	80116e8 <tcp_send_empty_ack>
 80106ce:	0003      	movs	r3, r0
 80106d0:	e1b2      	b.n	8010a38 <tcp_output+0x4b8>
    }
    goto output_done;
  }
  /* Stop persist timer, above conditions are not active */
  pcb->persist_backoff = 0;
 80106d2:	687b      	ldr	r3, [r7, #4]
 80106d4:	22a5      	movs	r2, #165	; 0xa5
 80106d6:	2100      	movs	r1, #0
 80106d8:	5499      	strb	r1, [r3, r2]

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
 80106da:	687b      	ldr	r3, [r7, #4]
 80106dc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80106de:	623b      	str	r3, [r7, #32]
  if (useg != NULL) {
 80106e0:	6a3b      	ldr	r3, [r7, #32]
 80106e2:	2b00      	cmp	r3, #0
 80106e4:	d100      	bne.n	80106e8 <tcp_output+0x168>
 80106e6:	e172      	b.n	80109ce <tcp_output+0x44e>
    for (; useg->next != NULL; useg = useg->next);
 80106e8:	e002      	b.n	80106f0 <tcp_output+0x170>
 80106ea:	6a3b      	ldr	r3, [r7, #32]
 80106ec:	681b      	ldr	r3, [r3, #0]
 80106ee:	623b      	str	r3, [r7, #32]
 80106f0:	6a3b      	ldr	r3, [r7, #32]
 80106f2:	681b      	ldr	r3, [r3, #0]
 80106f4:	2b00      	cmp	r3, #0
 80106f6:	d1f8      	bne.n	80106ea <tcp_output+0x16a>
  }
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 80106f8:	e169      	b.n	80109ce <tcp_output+0x44e>
         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!",
 80106fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80106fc:	691b      	ldr	r3, [r3, #16]
 80106fe:	7b1a      	ldrb	r2, [r3, #12]
 8010700:	7b5b      	ldrb	r3, [r3, #13]
 8010702:	021b      	lsls	r3, r3, #8
 8010704:	4313      	orrs	r3, r2
 8010706:	b29b      	uxth	r3, r3
 8010708:	0018      	movs	r0, r3
 801070a:	f7f5 ff13 	bl	8006534 <lwip_htons>
 801070e:	0003      	movs	r3, r0
 8010710:	b2db      	uxtb	r3, r3
 8010712:	001a      	movs	r2, r3
 8010714:	2304      	movs	r3, #4
 8010716:	4013      	ands	r3, r2
 8010718:	d005      	beq.n	8010726 <tcp_output+0x1a6>
 801071a:	4b68      	ldr	r3, [pc, #416]	; (80108bc <tcp_output+0x33c>)
 801071c:	4a6e      	ldr	r2, [pc, #440]	; (80108d8 <tcp_output+0x358>)
 801071e:	496f      	ldr	r1, [pc, #444]	; (80108dc <tcp_output+0x35c>)
 8010720:	4869      	ldr	r0, [pc, #420]	; (80108c8 <tcp_output+0x348>)
 8010722:	f7f1 fd53 	bl	80021cc <app_debug_rtt_raw>
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if ((tcp_do_output_nagle(pcb) == 0) &&
 8010726:	687b      	ldr	r3, [r7, #4]
 8010728:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801072a:	2b00      	cmp	r3, #0
 801072c:	d01f      	beq.n	801076e <tcp_output+0x1ee>
 801072e:	687b      	ldr	r3, [r7, #4]
 8010730:	8bdb      	ldrh	r3, [r3, #30]
 8010732:	001a      	movs	r2, r3
 8010734:	2344      	movs	r3, #68	; 0x44
 8010736:	4013      	ands	r3, r2
 8010738:	d119      	bne.n	801076e <tcp_output+0x1ee>
 801073a:	687b      	ldr	r3, [r7, #4]
 801073c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801073e:	2b00      	cmp	r3, #0
 8010740:	d00b      	beq.n	801075a <tcp_output+0x1da>
 8010742:	687b      	ldr	r3, [r7, #4]
 8010744:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010746:	681b      	ldr	r3, [r3, #0]
 8010748:	2b00      	cmp	r3, #0
 801074a:	d110      	bne.n	801076e <tcp_output+0x1ee>
 801074c:	687b      	ldr	r3, [r7, #4]
 801074e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010750:	891a      	ldrh	r2, [r3, #8]
 8010752:	687b      	ldr	r3, [r7, #4]
 8010754:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8010756:	429a      	cmp	r2, r3
 8010758:	d209      	bcs.n	801076e <tcp_output+0x1ee>
 801075a:	687b      	ldr	r3, [r7, #4]
 801075c:	2268      	movs	r2, #104	; 0x68
 801075e:	5a9b      	ldrh	r3, [r3, r2]
 8010760:	2b00      	cmp	r3, #0
 8010762:	d004      	beq.n	801076e <tcp_output+0x1ee>
 8010764:	687b      	ldr	r3, [r7, #4]
 8010766:	226a      	movs	r2, #106	; 0x6a
 8010768:	5a9b      	ldrh	r3, [r3, r2]
 801076a:	2b07      	cmp	r3, #7
 801076c:	d901      	bls.n	8010772 <tcp_output+0x1f2>
 801076e:	2301      	movs	r3, #1
 8010770:	e000      	b.n	8010774 <tcp_output+0x1f4>
 8010772:	2300      	movs	r3, #0
 8010774:	2b00      	cmp	r3, #0
 8010776:	d106      	bne.n	8010786 <tcp_output+0x206>
        ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
 8010778:	687b      	ldr	r3, [r7, #4]
 801077a:	8bdb      	ldrh	r3, [r3, #30]
 801077c:	001a      	movs	r2, r3
 801077e:	23a0      	movs	r3, #160	; 0xa0
 8010780:	4013      	ands	r3, r2
    if ((tcp_do_output_nagle(pcb) == 0) &&
 8010782:	d100      	bne.n	8010786 <tcp_output+0x206>
 8010784:	e141      	b.n	8010a0a <tcp_output+0x48a>
                                 pcb->lastack,
                                 lwip_ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    if (pcb->state != SYN_SENT) {
 8010786:	687b      	ldr	r3, [r7, #4]
 8010788:	7e1b      	ldrb	r3, [r3, #24]
 801078a:	2b02      	cmp	r3, #2
 801078c:	d022      	beq.n	80107d4 <tcp_output+0x254>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 801078e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010790:	691b      	ldr	r3, [r3, #16]
 8010792:	7b1a      	ldrb	r2, [r3, #12]
 8010794:	7b5b      	ldrb	r3, [r3, #13]
 8010796:	021b      	lsls	r3, r3, #8
 8010798:	4313      	orrs	r3, r2
 801079a:	b29c      	uxth	r4, r3
 801079c:	2010      	movs	r0, #16
 801079e:	f7f5 fec9 	bl	8006534 <lwip_htons>
 80107a2:	0003      	movs	r3, r0
 80107a4:	001a      	movs	r2, r3
 80107a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80107a8:	691b      	ldr	r3, [r3, #16]
 80107aa:	4322      	orrs	r2, r4
 80107ac:	b292      	uxth	r2, r2
 80107ae:	21ff      	movs	r1, #255	; 0xff
 80107b0:	4011      	ands	r1, r2
 80107b2:	000c      	movs	r4, r1
 80107b4:	7b19      	ldrb	r1, [r3, #12]
 80107b6:	2000      	movs	r0, #0
 80107b8:	4001      	ands	r1, r0
 80107ba:	1c08      	adds	r0, r1, #0
 80107bc:	1c21      	adds	r1, r4, #0
 80107be:	4301      	orrs	r1, r0
 80107c0:	7319      	strb	r1, [r3, #12]
 80107c2:	0a12      	lsrs	r2, r2, #8
 80107c4:	b290      	uxth	r0, r2
 80107c6:	7b5a      	ldrb	r2, [r3, #13]
 80107c8:	2100      	movs	r1, #0
 80107ca:	400a      	ands	r2, r1
 80107cc:	1c11      	adds	r1, r2, #0
 80107ce:	1c02      	adds	r2, r0, #0
 80107d0:	430a      	orrs	r2, r1
 80107d2:	735a      	strb	r2, [r3, #13]
    }

    err = tcp_output_segment(seg, pcb, netif);
 80107d4:	250f      	movs	r5, #15
 80107d6:	197c      	adds	r4, r7, r5
 80107d8:	697a      	ldr	r2, [r7, #20]
 80107da:	6879      	ldr	r1, [r7, #4]
 80107dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80107de:	0018      	movs	r0, r3
 80107e0:	f000 f950 	bl	8010a84 <tcp_output_segment>
 80107e4:	0003      	movs	r3, r0
 80107e6:	7023      	strb	r3, [r4, #0]
    if (err != ERR_OK) {
 80107e8:	0029      	movs	r1, r5
 80107ea:	187b      	adds	r3, r7, r1
 80107ec:	781b      	ldrb	r3, [r3, #0]
 80107ee:	b25b      	sxtb	r3, r3
 80107f0:	2b00      	cmp	r3, #0
 80107f2:	d00a      	beq.n	801080a <tcp_output+0x28a>
      /* segment could not be sent, for whatever reason */
      tcp_set_flags(pcb, TF_NAGLEMEMERR);
 80107f4:	687b      	ldr	r3, [r7, #4]
 80107f6:	8bdb      	ldrh	r3, [r3, #30]
 80107f8:	2280      	movs	r2, #128	; 0x80
 80107fa:	4313      	orrs	r3, r2
 80107fc:	b29a      	uxth	r2, r3
 80107fe:	687b      	ldr	r3, [r7, #4]
 8010800:	83da      	strh	r2, [r3, #30]
      return err;
 8010802:	187b      	adds	r3, r7, r1
 8010804:	781b      	ldrb	r3, [r3, #0]
 8010806:	b25b      	sxtb	r3, r3
 8010808:	e116      	b.n	8010a38 <tcp_output+0x4b8>
    }
#if TCP_OVERSIZE_DBGCHECK
    seg->oversize_left = 0;
 801080a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801080c:	2200      	movs	r2, #0
 801080e:	815a      	strh	r2, [r3, #10]
#endif /* TCP_OVERSIZE_DBGCHECK */
    pcb->unsent = seg->next;
 8010810:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010812:	681a      	ldr	r2, [r3, #0]
 8010814:	687b      	ldr	r3, [r7, #4]
 8010816:	671a      	str	r2, [r3, #112]	; 0x70
    if (pcb->state != SYN_SENT) {
 8010818:	687b      	ldr	r3, [r7, #4]
 801081a:	7e1b      	ldrb	r3, [r3, #24]
 801081c:	2b02      	cmp	r3, #2
 801081e:	d006      	beq.n	801082e <tcp_output+0x2ae>
      tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 8010820:	687b      	ldr	r3, [r7, #4]
 8010822:	8bdb      	ldrh	r3, [r3, #30]
 8010824:	2203      	movs	r2, #3
 8010826:	4393      	bics	r3, r2
 8010828:	b29a      	uxth	r2, r3
 801082a:	687b      	ldr	r3, [r7, #4]
 801082c:	83da      	strh	r2, [r3, #30]
    }
    snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 801082e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010830:	691b      	ldr	r3, [r3, #16]
 8010832:	791a      	ldrb	r2, [r3, #4]
 8010834:	7959      	ldrb	r1, [r3, #5]
 8010836:	0209      	lsls	r1, r1, #8
 8010838:	430a      	orrs	r2, r1
 801083a:	7999      	ldrb	r1, [r3, #6]
 801083c:	0409      	lsls	r1, r1, #16
 801083e:	430a      	orrs	r2, r1
 8010840:	79db      	ldrb	r3, [r3, #7]
 8010842:	061b      	lsls	r3, r3, #24
 8010844:	4313      	orrs	r3, r2
 8010846:	0018      	movs	r0, r3
 8010848:	f7f5 fe8a 	bl	8006560 <lwip_htonl>
 801084c:	0004      	movs	r4, r0
 801084e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010850:	891b      	ldrh	r3, [r3, #8]
 8010852:	001d      	movs	r5, r3
 8010854:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010856:	691b      	ldr	r3, [r3, #16]
 8010858:	7b1a      	ldrb	r2, [r3, #12]
 801085a:	7b5b      	ldrb	r3, [r3, #13]
 801085c:	021b      	lsls	r3, r3, #8
 801085e:	4313      	orrs	r3, r2
 8010860:	b29b      	uxth	r3, r3
 8010862:	0018      	movs	r0, r3
 8010864:	f7f5 fe66 	bl	8006534 <lwip_htons>
 8010868:	0003      	movs	r3, r0
 801086a:	b2db      	uxtb	r3, r3
 801086c:	001a      	movs	r2, r3
 801086e:	2303      	movs	r3, #3
 8010870:	4013      	ands	r3, r2
 8010872:	d001      	beq.n	8010878 <tcp_output+0x2f8>
 8010874:	2301      	movs	r3, #1
 8010876:	e000      	b.n	801087a <tcp_output+0x2fa>
 8010878:	2300      	movs	r3, #0
 801087a:	195b      	adds	r3, r3, r5
 801087c:	18e3      	adds	r3, r4, r3
 801087e:	60bb      	str	r3, [r7, #8]
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 8010880:	687b      	ldr	r3, [r7, #4]
 8010882:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8010884:	68bb      	ldr	r3, [r7, #8]
 8010886:	1ad3      	subs	r3, r2, r3
 8010888:	d502      	bpl.n	8010890 <tcp_output+0x310>
      pcb->snd_nxt = snd_nxt;
 801088a:	687b      	ldr	r3, [r7, #4]
 801088c:	68ba      	ldr	r2, [r7, #8]
 801088e:	655a      	str	r2, [r3, #84]	; 0x54
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
 8010890:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010892:	891b      	ldrh	r3, [r3, #8]
 8010894:	001c      	movs	r4, r3
 8010896:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010898:	691b      	ldr	r3, [r3, #16]
 801089a:	7b1a      	ldrb	r2, [r3, #12]
 801089c:	7b5b      	ldrb	r3, [r3, #13]
 801089e:	021b      	lsls	r3, r3, #8
 80108a0:	4313      	orrs	r3, r2
 80108a2:	b29b      	uxth	r3, r3
 80108a4:	0018      	movs	r0, r3
 80108a6:	f7f5 fe45 	bl	8006534 <lwip_htons>
 80108aa:	0003      	movs	r3, r0
 80108ac:	b2db      	uxtb	r3, r3
 80108ae:	001a      	movs	r2, r3
 80108b0:	2303      	movs	r3, #3
 80108b2:	4013      	ands	r3, r2
 80108b4:	d014      	beq.n	80108e0 <tcp_output+0x360>
 80108b6:	2301      	movs	r3, #1
 80108b8:	e013      	b.n	80108e2 <tcp_output+0x362>
 80108ba:	46c0      	nop			; (mov r8, r8)
 80108bc:	0801fe14 	.word	0x0801fe14
 80108c0:	000004e2 	.word	0x000004e2
 80108c4:	08020434 	.word	0x08020434
 80108c8:	0801fe60 	.word	0x0801fe60
 80108cc:	000004e4 	.word	0x000004e4
 80108d0:	0802044c 	.word	0x0802044c
 80108d4:	20002b2c 	.word	0x20002b2c
 80108d8:	00000537 	.word	0x00000537
 80108dc:	08020474 	.word	0x08020474
 80108e0:	2300      	movs	r3, #0
 80108e2:	191b      	adds	r3, r3, r4
 80108e4:	2b00      	cmp	r3, #0
 80108e6:	d06b      	beq.n	80109c0 <tcp_output+0x440>
      seg->next = NULL;
 80108e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80108ea:	2200      	movs	r2, #0
 80108ec:	601a      	str	r2, [r3, #0]
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
 80108ee:	687b      	ldr	r3, [r7, #4]
 80108f0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80108f2:	2b00      	cmp	r3, #0
 80108f4:	d105      	bne.n	8010902 <tcp_output+0x382>
        pcb->unacked = seg;
 80108f6:	687b      	ldr	r3, [r7, #4]
 80108f8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80108fa:	675a      	str	r2, [r3, #116]	; 0x74
        useg = seg;
 80108fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80108fe:	623b      	str	r3, [r7, #32]
 8010900:	e062      	b.n	80109c8 <tcp_output+0x448>
        /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(useg->tcphdr->seqno))) {
 8010902:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010904:	691b      	ldr	r3, [r3, #16]
 8010906:	791a      	ldrb	r2, [r3, #4]
 8010908:	7959      	ldrb	r1, [r3, #5]
 801090a:	0209      	lsls	r1, r1, #8
 801090c:	430a      	orrs	r2, r1
 801090e:	7999      	ldrb	r1, [r3, #6]
 8010910:	0409      	lsls	r1, r1, #16
 8010912:	430a      	orrs	r2, r1
 8010914:	79db      	ldrb	r3, [r3, #7]
 8010916:	061b      	lsls	r3, r3, #24
 8010918:	4313      	orrs	r3, r2
 801091a:	0018      	movs	r0, r3
 801091c:	f7f5 fe20 	bl	8006560 <lwip_htonl>
 8010920:	0004      	movs	r4, r0
 8010922:	6a3b      	ldr	r3, [r7, #32]
 8010924:	691b      	ldr	r3, [r3, #16]
 8010926:	791a      	ldrb	r2, [r3, #4]
 8010928:	7959      	ldrb	r1, [r3, #5]
 801092a:	0209      	lsls	r1, r1, #8
 801092c:	430a      	orrs	r2, r1
 801092e:	7999      	ldrb	r1, [r3, #6]
 8010930:	0409      	lsls	r1, r1, #16
 8010932:	430a      	orrs	r2, r1
 8010934:	79db      	ldrb	r3, [r3, #7]
 8010936:	061b      	lsls	r3, r3, #24
 8010938:	4313      	orrs	r3, r2
 801093a:	0018      	movs	r0, r3
 801093c:	f7f5 fe10 	bl	8006560 <lwip_htonl>
 8010940:	0003      	movs	r3, r0
 8010942:	1ae3      	subs	r3, r4, r3
 8010944:	d535      	bpl.n	80109b2 <tcp_output+0x432>
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
 8010946:	687b      	ldr	r3, [r7, #4]
 8010948:	3374      	adds	r3, #116	; 0x74
 801094a:	61fb      	str	r3, [r7, #28]
          while (*cur_seg &&
 801094c:	e002      	b.n	8010954 <tcp_output+0x3d4>
                 TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
            cur_seg = &((*cur_seg)->next );
 801094e:	69fb      	ldr	r3, [r7, #28]
 8010950:	681b      	ldr	r3, [r3, #0]
 8010952:	61fb      	str	r3, [r7, #28]
          while (*cur_seg &&
 8010954:	69fb      	ldr	r3, [r7, #28]
 8010956:	681b      	ldr	r3, [r3, #0]
 8010958:	2b00      	cmp	r3, #0
 801095a:	d022      	beq.n	80109a2 <tcp_output+0x422>
                 TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
 801095c:	69fb      	ldr	r3, [r7, #28]
 801095e:	681b      	ldr	r3, [r3, #0]
 8010960:	691b      	ldr	r3, [r3, #16]
 8010962:	791a      	ldrb	r2, [r3, #4]
 8010964:	7959      	ldrb	r1, [r3, #5]
 8010966:	0209      	lsls	r1, r1, #8
 8010968:	430a      	orrs	r2, r1
 801096a:	7999      	ldrb	r1, [r3, #6]
 801096c:	0409      	lsls	r1, r1, #16
 801096e:	430a      	orrs	r2, r1
 8010970:	79db      	ldrb	r3, [r3, #7]
 8010972:	061b      	lsls	r3, r3, #24
 8010974:	4313      	orrs	r3, r2
 8010976:	0018      	movs	r0, r3
 8010978:	f7f5 fdf2 	bl	8006560 <lwip_htonl>
 801097c:	0004      	movs	r4, r0
 801097e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010980:	691b      	ldr	r3, [r3, #16]
 8010982:	791a      	ldrb	r2, [r3, #4]
 8010984:	7959      	ldrb	r1, [r3, #5]
 8010986:	0209      	lsls	r1, r1, #8
 8010988:	430a      	orrs	r2, r1
 801098a:	7999      	ldrb	r1, [r3, #6]
 801098c:	0409      	lsls	r1, r1, #16
 801098e:	430a      	orrs	r2, r1
 8010990:	79db      	ldrb	r3, [r3, #7]
 8010992:	061b      	lsls	r3, r3, #24
 8010994:	4313      	orrs	r3, r2
 8010996:	0018      	movs	r0, r3
 8010998:	f7f5 fde2 	bl	8006560 <lwip_htonl>
 801099c:	0003      	movs	r3, r0
 801099e:	1ae3      	subs	r3, r4, r3
          while (*cur_seg &&
 80109a0:	d4d5      	bmi.n	801094e <tcp_output+0x3ce>
          }
          seg->next = (*cur_seg);
 80109a2:	69fb      	ldr	r3, [r7, #28]
 80109a4:	681a      	ldr	r2, [r3, #0]
 80109a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80109a8:	601a      	str	r2, [r3, #0]
          (*cur_seg) = seg;
 80109aa:	69fb      	ldr	r3, [r7, #28]
 80109ac:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80109ae:	601a      	str	r2, [r3, #0]
 80109b0:	e00a      	b.n	80109c8 <tcp_output+0x448>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
 80109b2:	6a3b      	ldr	r3, [r7, #32]
 80109b4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80109b6:	601a      	str	r2, [r3, #0]
          useg = useg->next;
 80109b8:	6a3b      	ldr	r3, [r7, #32]
 80109ba:	681b      	ldr	r3, [r3, #0]
 80109bc:	623b      	str	r3, [r7, #32]
 80109be:	e003      	b.n	80109c8 <tcp_output+0x448>
        }
      }
      /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
 80109c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80109c2:	0018      	movs	r0, r3
 80109c4:	f7fa fee8 	bl	800b798 <tcp_seg_free>
    }
    seg = pcb->unsent;
 80109c8:	687b      	ldr	r3, [r7, #4]
 80109ca:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80109cc:	627b      	str	r3, [r7, #36]	; 0x24
  while (seg != NULL &&
 80109ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80109d0:	2b00      	cmp	r3, #0
 80109d2:	d01b      	beq.n	8010a0c <tcp_output+0x48c>
         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 80109d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80109d6:	691b      	ldr	r3, [r3, #16]
 80109d8:	791a      	ldrb	r2, [r3, #4]
 80109da:	7959      	ldrb	r1, [r3, #5]
 80109dc:	0209      	lsls	r1, r1, #8
 80109de:	430a      	orrs	r2, r1
 80109e0:	7999      	ldrb	r1, [r3, #6]
 80109e2:	0409      	lsls	r1, r1, #16
 80109e4:	430a      	orrs	r2, r1
 80109e6:	79db      	ldrb	r3, [r3, #7]
 80109e8:	061b      	lsls	r3, r3, #24
 80109ea:	4313      	orrs	r3, r2
 80109ec:	0018      	movs	r0, r3
 80109ee:	f7f5 fdb7 	bl	8006560 <lwip_htonl>
 80109f2:	0002      	movs	r2, r0
 80109f4:	687b      	ldr	r3, [r7, #4]
 80109f6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80109f8:	1ad3      	subs	r3, r2, r3
 80109fa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80109fc:	8912      	ldrh	r2, [r2, #8]
 80109fe:	189b      	adds	r3, r3, r2
  while (seg != NULL &&
 8010a00:	69ba      	ldr	r2, [r7, #24]
 8010a02:	429a      	cmp	r2, r3
 8010a04:	d300      	bcc.n	8010a08 <tcp_output+0x488>
 8010a06:	e678      	b.n	80106fa <tcp_output+0x17a>
 8010a08:	e000      	b.n	8010a0c <tcp_output+0x48c>
      break;
 8010a0a:	46c0      	nop			; (mov r8, r8)
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
 8010a0c:	687b      	ldr	r3, [r7, #4]
 8010a0e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010a10:	2b00      	cmp	r3, #0
 8010a12:	d108      	bne.n	8010a26 <tcp_output+0x4a6>
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
 8010a14:	687b      	ldr	r3, [r7, #4]
 8010a16:	226c      	movs	r2, #108	; 0x6c
 8010a18:	2100      	movs	r1, #0
 8010a1a:	5299      	strh	r1, [r3, r2]
 8010a1c:	e004      	b.n	8010a28 <tcp_output+0x4a8>
    goto output_done;
 8010a1e:	46c0      	nop			; (mov r8, r8)
 8010a20:	e002      	b.n	8010a28 <tcp_output+0x4a8>
    goto output_done;
 8010a22:	46c0      	nop			; (mov r8, r8)
 8010a24:	e000      	b.n	8010a28 <tcp_output+0x4a8>
  }
#endif /* TCP_OVERSIZE */

output_done:
 8010a26:	46c0      	nop			; (mov r8, r8)
  tcp_clear_flags(pcb, TF_NAGLEMEMERR);
 8010a28:	687b      	ldr	r3, [r7, #4]
 8010a2a:	8bdb      	ldrh	r3, [r3, #30]
 8010a2c:	2280      	movs	r2, #128	; 0x80
 8010a2e:	4393      	bics	r3, r2
 8010a30:	b29a      	uxth	r2, r3
 8010a32:	687b      	ldr	r3, [r7, #4]
 8010a34:	83da      	strh	r2, [r3, #30]
  return ERR_OK;
 8010a36:	2300      	movs	r3, #0
}
 8010a38:	0018      	movs	r0, r3
 8010a3a:	46bd      	mov	sp, r7
 8010a3c:	b00a      	add	sp, #40	; 0x28
 8010a3e:	bdb0      	pop	{r4, r5, r7, pc}

08010a40 <tcp_output_segment_busy>:
 * @arg seg the tcp segment to check
 * @return 1 if ref != 1, 0 if ref == 1
 */
static int
tcp_output_segment_busy(const struct tcp_seg *seg)
{
 8010a40:	b580      	push	{r7, lr}
 8010a42:	b082      	sub	sp, #8
 8010a44:	af00      	add	r7, sp, #0
 8010a46:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_output_segment_busy: invalid seg", seg != NULL);
 8010a48:	687b      	ldr	r3, [r7, #4]
 8010a4a:	2b00      	cmp	r3, #0
 8010a4c:	d105      	bne.n	8010a5a <tcp_output_segment_busy+0x1a>
 8010a4e:	4b09      	ldr	r3, [pc, #36]	; (8010a74 <tcp_output_segment_busy+0x34>)
 8010a50:	4a09      	ldr	r2, [pc, #36]	; (8010a78 <tcp_output_segment_busy+0x38>)
 8010a52:	490a      	ldr	r1, [pc, #40]	; (8010a7c <tcp_output_segment_busy+0x3c>)
 8010a54:	480a      	ldr	r0, [pc, #40]	; (8010a80 <tcp_output_segment_busy+0x40>)
 8010a56:	f7f1 fbb9 	bl	80021cc <app_debug_rtt_raw>

  /* We only need to check the first pbuf here:
     If a pbuf is queued for transmission, a driver calls pbuf_ref(),
     which only changes the ref count of the first pbuf */
  if (seg->p->ref != 1) {
 8010a5a:	687b      	ldr	r3, [r7, #4]
 8010a5c:	685b      	ldr	r3, [r3, #4]
 8010a5e:	7b9b      	ldrb	r3, [r3, #14]
 8010a60:	2b01      	cmp	r3, #1
 8010a62:	d001      	beq.n	8010a68 <tcp_output_segment_busy+0x28>
    /* other reference found */
    return 1;
 8010a64:	2301      	movs	r3, #1
 8010a66:	e000      	b.n	8010a6a <tcp_output_segment_busy+0x2a>
  }
  /* no other references found */
  return 0;
 8010a68:	2300      	movs	r3, #0
}
 8010a6a:	0018      	movs	r0, r3
 8010a6c:	46bd      	mov	sp, r7
 8010a6e:	b002      	add	sp, #8
 8010a70:	bd80      	pop	{r7, pc}
 8010a72:	46c0      	nop			; (mov r8, r8)
 8010a74:	0801fe14 	.word	0x0801fe14
 8010a78:	0000059b 	.word	0x0000059b
 8010a7c:	0802048c 	.word	0x0802048c
 8010a80:	0801fe60 	.word	0x0801fe60

08010a84 <tcp_output_segment>:
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 * @param netif the netif used to send the segment
 */
static err_t
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb, struct netif *netif)
{
 8010a84:	b5f0      	push	{r4, r5, r6, r7, lr}
 8010a86:	b08f      	sub	sp, #60	; 0x3c
 8010a88:	af04      	add	r7, sp, #16
 8010a8a:	60f8      	str	r0, [r7, #12]
 8010a8c:	60b9      	str	r1, [r7, #8]
 8010a8e:	607a      	str	r2, [r7, #4]
  err_t err;
  u16_t len;
  u32_t *opts;
#if TCP_CHECKSUM_ON_COPY
  int seg_chksum_was_swapped = 0;
 8010a90:	2300      	movs	r3, #0
 8010a92:	623b      	str	r3, [r7, #32]
#endif

  LWIP_ASSERT("tcp_output_segment: invalid seg", seg != NULL);
 8010a94:	68fb      	ldr	r3, [r7, #12]
 8010a96:	2b00      	cmp	r3, #0
 8010a98:	d105      	bne.n	8010aa6 <tcp_output_segment+0x22>
 8010a9a:	4bda      	ldr	r3, [pc, #872]	; (8010e04 <tcp_output_segment+0x380>)
 8010a9c:	4ada      	ldr	r2, [pc, #872]	; (8010e08 <tcp_output_segment+0x384>)
 8010a9e:	49db      	ldr	r1, [pc, #876]	; (8010e0c <tcp_output_segment+0x388>)
 8010aa0:	48db      	ldr	r0, [pc, #876]	; (8010e10 <tcp_output_segment+0x38c>)
 8010aa2:	f7f1 fb93 	bl	80021cc <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_output_segment: invalid pcb", pcb != NULL);
 8010aa6:	68bb      	ldr	r3, [r7, #8]
 8010aa8:	2b00      	cmp	r3, #0
 8010aaa:	d105      	bne.n	8010ab8 <tcp_output_segment+0x34>
 8010aac:	4bd5      	ldr	r3, [pc, #852]	; (8010e04 <tcp_output_segment+0x380>)
 8010aae:	4ad9      	ldr	r2, [pc, #868]	; (8010e14 <tcp_output_segment+0x390>)
 8010ab0:	49d9      	ldr	r1, [pc, #868]	; (8010e18 <tcp_output_segment+0x394>)
 8010ab2:	48d7      	ldr	r0, [pc, #860]	; (8010e10 <tcp_output_segment+0x38c>)
 8010ab4:	f7f1 fb8a 	bl	80021cc <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_output_segment: invalid netif", netif != NULL);
 8010ab8:	687b      	ldr	r3, [r7, #4]
 8010aba:	2b00      	cmp	r3, #0
 8010abc:	d105      	bne.n	8010aca <tcp_output_segment+0x46>
 8010abe:	4bd1      	ldr	r3, [pc, #836]	; (8010e04 <tcp_output_segment+0x380>)
 8010ac0:	4ad6      	ldr	r2, [pc, #856]	; (8010e1c <tcp_output_segment+0x398>)
 8010ac2:	49d7      	ldr	r1, [pc, #860]	; (8010e20 <tcp_output_segment+0x39c>)
 8010ac4:	48d2      	ldr	r0, [pc, #840]	; (8010e10 <tcp_output_segment+0x38c>)
 8010ac6:	f7f1 fb81 	bl	80021cc <app_debug_rtt_raw>

  if (tcp_output_segment_busy(seg)) {
 8010aca:	68fb      	ldr	r3, [r7, #12]
 8010acc:	0018      	movs	r0, r3
 8010ace:	f7ff ffb7 	bl	8010a40 <tcp_output_segment_busy>
 8010ad2:	1e03      	subs	r3, r0, #0
 8010ad4:	d001      	beq.n	8010ada <tcp_output_segment+0x56>
    /* This should not happen: rexmit functions should have checked this.
       However, since this function modifies p->len, we must not continue in this case. */
    LWIP_DEBUGF(TCP_RTO_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_output_segment: segment busy\n"));
    return ERR_OK;
 8010ad6:	2300      	movs	r3, #0
 8010ad8:	e190      	b.n	8010dfc <tcp_output_segment+0x378>
  }

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);
 8010ada:	68bb      	ldr	r3, [r7, #8]
 8010adc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8010ade:	68fb      	ldr	r3, [r7, #12]
 8010ae0:	691c      	ldr	r4, [r3, #16]
 8010ae2:	0010      	movs	r0, r2
 8010ae4:	f7f5 fd3c 	bl	8006560 <lwip_htonl>
 8010ae8:	0003      	movs	r3, r0
 8010aea:	22ff      	movs	r2, #255	; 0xff
 8010aec:	401a      	ands	r2, r3
 8010aee:	0010      	movs	r0, r2
 8010af0:	7a22      	ldrb	r2, [r4, #8]
 8010af2:	2100      	movs	r1, #0
 8010af4:	400a      	ands	r2, r1
 8010af6:	1c11      	adds	r1, r2, #0
 8010af8:	1c02      	adds	r2, r0, #0
 8010afa:	430a      	orrs	r2, r1
 8010afc:	7222      	strb	r2, [r4, #8]
 8010afe:	0a1a      	lsrs	r2, r3, #8
 8010b00:	21ff      	movs	r1, #255	; 0xff
 8010b02:	400a      	ands	r2, r1
 8010b04:	0010      	movs	r0, r2
 8010b06:	7a62      	ldrb	r2, [r4, #9]
 8010b08:	2100      	movs	r1, #0
 8010b0a:	400a      	ands	r2, r1
 8010b0c:	1c11      	adds	r1, r2, #0
 8010b0e:	1c02      	adds	r2, r0, #0
 8010b10:	430a      	orrs	r2, r1
 8010b12:	7262      	strb	r2, [r4, #9]
 8010b14:	0c1a      	lsrs	r2, r3, #16
 8010b16:	21ff      	movs	r1, #255	; 0xff
 8010b18:	400a      	ands	r2, r1
 8010b1a:	0010      	movs	r0, r2
 8010b1c:	7aa2      	ldrb	r2, [r4, #10]
 8010b1e:	2100      	movs	r1, #0
 8010b20:	400a      	ands	r2, r1
 8010b22:	1c11      	adds	r1, r2, #0
 8010b24:	1c02      	adds	r2, r0, #0
 8010b26:	430a      	orrs	r2, r1
 8010b28:	72a2      	strb	r2, [r4, #10]
 8010b2a:	0e19      	lsrs	r1, r3, #24
 8010b2c:	7ae3      	ldrb	r3, [r4, #11]
 8010b2e:	2200      	movs	r2, #0
 8010b30:	4013      	ands	r3, r2
 8010b32:	1c1a      	adds	r2, r3, #0
 8010b34:	1c0b      	adds	r3, r1, #0
 8010b36:	4313      	orrs	r3, r2
 8010b38:	72e3      	strb	r3, [r4, #11]
       the window scale option) is never scaled. */
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(pcb->rcv_ann_wnd));
  } else
#endif /* LWIP_WND_SCALE */
  {
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
 8010b3a:	68bb      	ldr	r3, [r7, #8]
 8010b3c:	8dda      	ldrh	r2, [r3, #46]	; 0x2e
 8010b3e:	68fb      	ldr	r3, [r7, #12]
 8010b40:	691c      	ldr	r4, [r3, #16]
 8010b42:	0010      	movs	r0, r2
 8010b44:	f7f5 fcf6 	bl	8006534 <lwip_htons>
 8010b48:	0003      	movs	r3, r0
 8010b4a:	22ff      	movs	r2, #255	; 0xff
 8010b4c:	401a      	ands	r2, r3
 8010b4e:	0010      	movs	r0, r2
 8010b50:	7ba2      	ldrb	r2, [r4, #14]
 8010b52:	2100      	movs	r1, #0
 8010b54:	400a      	ands	r2, r1
 8010b56:	1c11      	adds	r1, r2, #0
 8010b58:	1c02      	adds	r2, r0, #0
 8010b5a:	430a      	orrs	r2, r1
 8010b5c:	73a2      	strb	r2, [r4, #14]
 8010b5e:	0a1b      	lsrs	r3, r3, #8
 8010b60:	b299      	uxth	r1, r3
 8010b62:	7be3      	ldrb	r3, [r4, #15]
 8010b64:	2200      	movs	r2, #0
 8010b66:	4013      	ands	r3, r2
 8010b68:	1c1a      	adds	r2, r3, #0
 8010b6a:	1c0b      	adds	r3, r1, #0
 8010b6c:	4313      	orrs	r3, r2
 8010b6e:	73e3      	strb	r3, [r4, #15]
  }

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8010b70:	68bb      	ldr	r3, [r7, #8]
 8010b72:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8010b74:	68ba      	ldr	r2, [r7, #8]
 8010b76:	8dd2      	ldrh	r2, [r2, #46]	; 0x2e
 8010b78:	189a      	adds	r2, r3, r2
 8010b7a:	68bb      	ldr	r3, [r7, #8]
 8010b7c:	631a      	str	r2, [r3, #48]	; 0x30

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  /* cast through void* to get rid of alignment warnings */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
 8010b7e:	68fb      	ldr	r3, [r7, #12]
 8010b80:	691b      	ldr	r3, [r3, #16]
 8010b82:	3314      	adds	r3, #20
 8010b84:	627b      	str	r3, [r7, #36]	; 0x24
  if (seg->flags & TF_SEG_OPTS_MSS) {
 8010b86:	68fb      	ldr	r3, [r7, #12]
 8010b88:	7bdb      	ldrb	r3, [r3, #15]
 8010b8a:	001a      	movs	r2, r3
 8010b8c:	2301      	movs	r3, #1
 8010b8e:	4013      	ands	r3, r2
 8010b90:	d019      	beq.n	8010bc6 <tcp_output_segment+0x142>
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss_netif(TCP_MSS, netif, &pcb->remote_ip);
 8010b92:	68bb      	ldr	r3, [r7, #8]
 8010b94:	1d1a      	adds	r2, r3, #4
 8010b96:	251e      	movs	r5, #30
 8010b98:	197c      	adds	r4, r7, r5
 8010b9a:	6879      	ldr	r1, [r7, #4]
 8010b9c:	2386      	movs	r3, #134	; 0x86
 8010b9e:	009b      	lsls	r3, r3, #2
 8010ba0:	0018      	movs	r0, r3
 8010ba2:	f7fb f9cb 	bl	800bf3c <tcp_eff_send_mss_netif>
 8010ba6:	0003      	movs	r3, r0
 8010ba8:	8023      	strh	r3, [r4, #0]
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
 8010baa:	197b      	adds	r3, r7, r5
 8010bac:	881b      	ldrh	r3, [r3, #0]
 8010bae:	2281      	movs	r2, #129	; 0x81
 8010bb0:	0492      	lsls	r2, r2, #18
 8010bb2:	4313      	orrs	r3, r2
 8010bb4:	0018      	movs	r0, r3
 8010bb6:	f7f5 fcd3 	bl	8006560 <lwip_htonl>
 8010bba:	0002      	movs	r2, r0
 8010bbc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010bbe:	601a      	str	r2, [r3, #0]
    opts += 1;
 8010bc0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010bc2:	3304      	adds	r3, #4
 8010bc4:	627b      	str	r3, [r7, #36]	; 0x24
  }
#endif

  /* Set retransmission timer running if it is not currently enabled
     This must be set before checking the route. */
  if (pcb->rtime < 0) {
 8010bc6:	68bb      	ldr	r3, [r7, #8]
 8010bc8:	2234      	movs	r2, #52	; 0x34
 8010bca:	5e9b      	ldrsh	r3, [r3, r2]
 8010bcc:	2b00      	cmp	r3, #0
 8010bce:	da02      	bge.n	8010bd6 <tcp_output_segment+0x152>
    pcb->rtime = 0;
 8010bd0:	68bb      	ldr	r3, [r7, #8]
 8010bd2:	2200      	movs	r2, #0
 8010bd4:	869a      	strh	r2, [r3, #52]	; 0x34
  }

  if (pcb->rttest == 0) {
 8010bd6:	68bb      	ldr	r3, [r7, #8]
 8010bd8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8010bda:	2b00      	cmp	r3, #0
 8010bdc:	d115      	bne.n	8010c0a <tcp_output_segment+0x186>
    pcb->rttest = tcp_ticks;
 8010bde:	4b91      	ldr	r3, [pc, #580]	; (8010e24 <tcp_output_segment+0x3a0>)
 8010be0:	681a      	ldr	r2, [r3, #0]
 8010be2:	68bb      	ldr	r3, [r7, #8]
 8010be4:	639a      	str	r2, [r3, #56]	; 0x38
    pcb->rtseq = lwip_ntohl(seg->tcphdr->seqno);
 8010be6:	68fb      	ldr	r3, [r7, #12]
 8010be8:	691b      	ldr	r3, [r3, #16]
 8010bea:	791a      	ldrb	r2, [r3, #4]
 8010bec:	7959      	ldrb	r1, [r3, #5]
 8010bee:	0209      	lsls	r1, r1, #8
 8010bf0:	430a      	orrs	r2, r1
 8010bf2:	7999      	ldrb	r1, [r3, #6]
 8010bf4:	0409      	lsls	r1, r1, #16
 8010bf6:	430a      	orrs	r2, r1
 8010bf8:	79db      	ldrb	r3, [r3, #7]
 8010bfa:	061b      	lsls	r3, r3, #24
 8010bfc:	4313      	orrs	r3, r2
 8010bfe:	0018      	movs	r0, r3
 8010c00:	f7f5 fcae 	bl	8006560 <lwip_htonl>
 8010c04:	0002      	movs	r2, r0
 8010c06:	68bb      	ldr	r3, [r7, #8]
 8010c08:	63da      	str	r2, [r3, #60]	; 0x3c
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
                                 lwip_htonl(seg->tcphdr->seqno), lwip_htonl(seg->tcphdr->seqno) +
                                 seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 8010c0a:	68fb      	ldr	r3, [r7, #12]
 8010c0c:	691a      	ldr	r2, [r3, #16]
 8010c0e:	68fb      	ldr	r3, [r7, #12]
 8010c10:	685b      	ldr	r3, [r3, #4]
 8010c12:	685b      	ldr	r3, [r3, #4]
 8010c14:	1ad2      	subs	r2, r2, r3
 8010c16:	201c      	movs	r0, #28
 8010c18:	183b      	adds	r3, r7, r0
 8010c1a:	801a      	strh	r2, [r3, #0]
  if (len == 0) {
    /** Exclude retransmitted segments from this count. */
    MIB2_STATS_INC(mib2.tcpoutsegs);
  }

  seg->p->len -= len;
 8010c1c:	68fb      	ldr	r3, [r7, #12]
 8010c1e:	685b      	ldr	r3, [r3, #4]
 8010c20:	8959      	ldrh	r1, [r3, #10]
 8010c22:	68fb      	ldr	r3, [r7, #12]
 8010c24:	685b      	ldr	r3, [r3, #4]
 8010c26:	183a      	adds	r2, r7, r0
 8010c28:	8812      	ldrh	r2, [r2, #0]
 8010c2a:	1a8a      	subs	r2, r1, r2
 8010c2c:	b292      	uxth	r2, r2
 8010c2e:	815a      	strh	r2, [r3, #10]
  seg->p->tot_len -= len;
 8010c30:	68fb      	ldr	r3, [r7, #12]
 8010c32:	685b      	ldr	r3, [r3, #4]
 8010c34:	8919      	ldrh	r1, [r3, #8]
 8010c36:	68fb      	ldr	r3, [r7, #12]
 8010c38:	685b      	ldr	r3, [r3, #4]
 8010c3a:	183a      	adds	r2, r7, r0
 8010c3c:	8812      	ldrh	r2, [r2, #0]
 8010c3e:	1a8a      	subs	r2, r1, r2
 8010c40:	b292      	uxth	r2, r2
 8010c42:	811a      	strh	r2, [r3, #8]

  seg->p->payload = seg->tcphdr;
 8010c44:	68fb      	ldr	r3, [r7, #12]
 8010c46:	685b      	ldr	r3, [r3, #4]
 8010c48:	68fa      	ldr	r2, [r7, #12]
 8010c4a:	6912      	ldr	r2, [r2, #16]
 8010c4c:	605a      	str	r2, [r3, #4]

  seg->tcphdr->chksum = 0;
 8010c4e:	68fb      	ldr	r3, [r7, #12]
 8010c50:	691b      	ldr	r3, [r3, #16]
 8010c52:	7c1a      	ldrb	r2, [r3, #16]
 8010c54:	2100      	movs	r1, #0
 8010c56:	400a      	ands	r2, r1
 8010c58:	741a      	strb	r2, [r3, #16]
 8010c5a:	7c5a      	ldrb	r2, [r3, #17]
 8010c5c:	2100      	movs	r1, #0
 8010c5e:	400a      	ands	r2, r1
 8010c60:	745a      	strb	r2, [r3, #17]

#ifdef LWIP_HOOK_TCP_OUT_ADD_TCPOPTS
  opts = LWIP_HOOK_TCP_OUT_ADD_TCPOPTS(seg->p, seg->tcphdr, pcb, opts);
#endif
  LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(seg->tcphdr + 1)) + LWIP_TCP_OPT_LENGTH_SEGMENT(seg->flags, pcb));
 8010c62:	68fb      	ldr	r3, [r7, #12]
 8010c64:	691b      	ldr	r3, [r3, #16]
 8010c66:	3314      	adds	r3, #20
 8010c68:	001a      	movs	r2, r3
 8010c6a:	68fb      	ldr	r3, [r7, #12]
 8010c6c:	7bdb      	ldrb	r3, [r3, #15]
 8010c6e:	009b      	lsls	r3, r3, #2
 8010c70:	2104      	movs	r1, #4
 8010c72:	400b      	ands	r3, r1
 8010c74:	18d3      	adds	r3, r2, r3
 8010c76:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8010c78:	429a      	cmp	r2, r3
 8010c7a:	d005      	beq.n	8010c88 <tcp_output_segment+0x204>
 8010c7c:	4b61      	ldr	r3, [pc, #388]	; (8010e04 <tcp_output_segment+0x380>)
 8010c7e:	4a6a      	ldr	r2, [pc, #424]	; (8010e28 <tcp_output_segment+0x3a4>)
 8010c80:	496a      	ldr	r1, [pc, #424]	; (8010e2c <tcp_output_segment+0x3a8>)
 8010c82:	4863      	ldr	r0, [pc, #396]	; (8010e10 <tcp_output_segment+0x38c>)
 8010c84:	f7f1 faa2 	bl	80021cc <app_debug_rtt_raw>
    u32_t acc;
#if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
    u16_t chksum_slow = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
                                         seg->p->tot_len, &pcb->local_ip, &pcb->remote_ip);
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
    if ((seg->flags & TF_SEG_DATA_CHECKSUMMED) == 0) {
 8010c88:	68fb      	ldr	r3, [r7, #12]
 8010c8a:	7bdb      	ldrb	r3, [r3, #15]
 8010c8c:	001a      	movs	r2, r3
 8010c8e:	2304      	movs	r3, #4
 8010c90:	4013      	ands	r3, r2
 8010c92:	d11c      	bne.n	8010cce <tcp_output_segment+0x24a>
      LWIP_ASSERT("data included but not checksummed",
 8010c94:	68fb      	ldr	r3, [r7, #12]
 8010c96:	685b      	ldr	r3, [r3, #4]
 8010c98:	891c      	ldrh	r4, [r3, #8]
 8010c9a:	68fb      	ldr	r3, [r7, #12]
 8010c9c:	691b      	ldr	r3, [r3, #16]
 8010c9e:	7b1a      	ldrb	r2, [r3, #12]
 8010ca0:	7b5b      	ldrb	r3, [r3, #13]
 8010ca2:	021b      	lsls	r3, r3, #8
 8010ca4:	4313      	orrs	r3, r2
 8010ca6:	b29b      	uxth	r3, r3
 8010ca8:	0018      	movs	r0, r3
 8010caa:	f7f5 fc43 	bl	8006534 <lwip_htons>
 8010cae:	0003      	movs	r3, r0
 8010cb0:	0b1b      	lsrs	r3, r3, #12
 8010cb2:	b29b      	uxth	r3, r3
 8010cb4:	b2db      	uxtb	r3, r3
 8010cb6:	009b      	lsls	r3, r3, #2
 8010cb8:	b2db      	uxtb	r3, r3
 8010cba:	b29b      	uxth	r3, r3
 8010cbc:	429c      	cmp	r4, r3
 8010cbe:	d006      	beq.n	8010cce <tcp_output_segment+0x24a>
 8010cc0:	4b50      	ldr	r3, [pc, #320]	; (8010e04 <tcp_output_segment+0x380>)
 8010cc2:	22c5      	movs	r2, #197	; 0xc5
 8010cc4:	00d2      	lsls	r2, r2, #3
 8010cc6:	495a      	ldr	r1, [pc, #360]	; (8010e30 <tcp_output_segment+0x3ac>)
 8010cc8:	4851      	ldr	r0, [pc, #324]	; (8010e10 <tcp_output_segment+0x38c>)
 8010cca:	f7f1 fa7f 	bl	80021cc <app_debug_rtt_raw>
                  seg->p->tot_len == TCPH_HDRLEN_BYTES(seg->tcphdr));
    }

    /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
    acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
 8010cce:	68fb      	ldr	r3, [r7, #12]
 8010cd0:	685c      	ldr	r4, [r3, #4]
                                   seg->p->tot_len, TCPH_HDRLEN_BYTES(seg->tcphdr), &pcb->local_ip, &pcb->remote_ip);
 8010cd2:	68fb      	ldr	r3, [r7, #12]
 8010cd4:	685b      	ldr	r3, [r3, #4]
    acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
 8010cd6:	891d      	ldrh	r5, [r3, #8]
                                   seg->p->tot_len, TCPH_HDRLEN_BYTES(seg->tcphdr), &pcb->local_ip, &pcb->remote_ip);
 8010cd8:	68fb      	ldr	r3, [r7, #12]
 8010cda:	691b      	ldr	r3, [r3, #16]
 8010cdc:	7b1a      	ldrb	r2, [r3, #12]
 8010cde:	7b5b      	ldrb	r3, [r3, #13]
 8010ce0:	021b      	lsls	r3, r3, #8
 8010ce2:	4313      	orrs	r3, r2
 8010ce4:	b29b      	uxth	r3, r3
 8010ce6:	0018      	movs	r0, r3
 8010ce8:	f7f5 fc24 	bl	8006534 <lwip_htons>
 8010cec:	0003      	movs	r3, r0
 8010cee:	0b1b      	lsrs	r3, r3, #12
 8010cf0:	b29b      	uxth	r3, r3
 8010cf2:	b2db      	uxtb	r3, r3
 8010cf4:	009b      	lsls	r3, r3, #2
 8010cf6:	b2db      	uxtb	r3, r3
    acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
 8010cf8:	b299      	uxth	r1, r3
                                   seg->p->tot_len, TCPH_HDRLEN_BYTES(seg->tcphdr), &pcb->local_ip, &pcb->remote_ip);
 8010cfa:	68bb      	ldr	r3, [r7, #8]
 8010cfc:	68ba      	ldr	r2, [r7, #8]
 8010cfe:	3204      	adds	r2, #4
    acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
 8010d00:	9201      	str	r2, [sp, #4]
 8010d02:	9300      	str	r3, [sp, #0]
 8010d04:	000b      	movs	r3, r1
 8010d06:	002a      	movs	r2, r5
 8010d08:	2106      	movs	r1, #6
 8010d0a:	0020      	movs	r0, r4
 8010d0c:	f7f6 ffd5 	bl	8007cba <ip_chksum_pseudo_partial>
 8010d10:	0003      	movs	r3, r0
 8010d12:	61bb      	str	r3, [r7, #24]
    /* add payload checksum */
    if (seg->chksum_swapped) {
 8010d14:	68fb      	ldr	r3, [r7, #12]
 8010d16:	7b9b      	ldrb	r3, [r3, #14]
 8010d18:	2b00      	cmp	r3, #0
 8010d1a:	d012      	beq.n	8010d42 <tcp_output_segment+0x2be>
      seg_chksum_was_swapped = 1;
 8010d1c:	2301      	movs	r3, #1
 8010d1e:	623b      	str	r3, [r7, #32]
      seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
 8010d20:	68fb      	ldr	r3, [r7, #12]
 8010d22:	899b      	ldrh	r3, [r3, #12]
 8010d24:	021b      	lsls	r3, r3, #8
 8010d26:	b21a      	sxth	r2, r3
 8010d28:	68fb      	ldr	r3, [r7, #12]
 8010d2a:	899b      	ldrh	r3, [r3, #12]
 8010d2c:	0a1b      	lsrs	r3, r3, #8
 8010d2e:	b29b      	uxth	r3, r3
 8010d30:	b21b      	sxth	r3, r3
 8010d32:	4313      	orrs	r3, r2
 8010d34:	b21b      	sxth	r3, r3
 8010d36:	b29a      	uxth	r2, r3
 8010d38:	68fb      	ldr	r3, [r7, #12]
 8010d3a:	819a      	strh	r2, [r3, #12]
      seg->chksum_swapped = 0;
 8010d3c:	68fb      	ldr	r3, [r7, #12]
 8010d3e:	2200      	movs	r2, #0
 8010d40:	739a      	strb	r2, [r3, #14]
    }
    acc = (u16_t)~acc + seg->chksum;
 8010d42:	69bb      	ldr	r3, [r7, #24]
 8010d44:	b29b      	uxth	r3, r3
 8010d46:	43db      	mvns	r3, r3
 8010d48:	b29b      	uxth	r3, r3
 8010d4a:	001a      	movs	r2, r3
 8010d4c:	68fb      	ldr	r3, [r7, #12]
 8010d4e:	899b      	ldrh	r3, [r3, #12]
 8010d50:	18d3      	adds	r3, r2, r3
 8010d52:	61bb      	str	r3, [r7, #24]
    seg->tcphdr->chksum = (u16_t)~FOLD_U32T(acc);
 8010d54:	69bb      	ldr	r3, [r7, #24]
 8010d56:	0c1b      	lsrs	r3, r3, #16
 8010d58:	b29a      	uxth	r2, r3
 8010d5a:	69bb      	ldr	r3, [r7, #24]
 8010d5c:	b29b      	uxth	r3, r3
 8010d5e:	18d3      	adds	r3, r2, r3
 8010d60:	b29a      	uxth	r2, r3
 8010d62:	68fb      	ldr	r3, [r7, #12]
 8010d64:	691b      	ldr	r3, [r3, #16]
 8010d66:	43d2      	mvns	r2, r2
 8010d68:	b292      	uxth	r2, r2
 8010d6a:	21ff      	movs	r1, #255	; 0xff
 8010d6c:	4011      	ands	r1, r2
 8010d6e:	000c      	movs	r4, r1
 8010d70:	7c19      	ldrb	r1, [r3, #16]
 8010d72:	2000      	movs	r0, #0
 8010d74:	4001      	ands	r1, r0
 8010d76:	1c08      	adds	r0, r1, #0
 8010d78:	1c21      	adds	r1, r4, #0
 8010d7a:	4301      	orrs	r1, r0
 8010d7c:	7419      	strb	r1, [r3, #16]
 8010d7e:	0a12      	lsrs	r2, r2, #8
 8010d80:	b290      	uxth	r0, r2
 8010d82:	7c5a      	ldrb	r2, [r3, #17]
 8010d84:	2100      	movs	r1, #0
 8010d86:	400a      	ands	r2, r1
 8010d88:	1c11      	adds	r1, r2, #0
 8010d8a:	1c02      	adds	r2, r0, #0
 8010d8c:	430a      	orrs	r2, r1
 8010d8e:	745a      	strb	r2, [r3, #17]
#endif /* TCP_CHECKSUM_ON_COPY */
  }
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);

  NETIF_SET_HINTS(netif, &(pcb->netif_hints));
 8010d90:	68bb      	ldr	r3, [r7, #8]
 8010d92:	330c      	adds	r3, #12
 8010d94:	001a      	movs	r2, r3
 8010d96:	687b      	ldr	r3, [r7, #4]
 8010d98:	639a      	str	r2, [r3, #56]	; 0x38
  err = ip_output_if(seg->p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
 8010d9a:	68fb      	ldr	r3, [r7, #12]
 8010d9c:	6858      	ldr	r0, [r3, #4]
 8010d9e:	68b9      	ldr	r1, [r7, #8]
 8010da0:	68bb      	ldr	r3, [r7, #8]
 8010da2:	1d1d      	adds	r5, r3, #4
 8010da4:	68bb      	ldr	r3, [r7, #8]
 8010da6:	7ade      	ldrb	r6, [r3, #11]
 8010da8:	68bb      	ldr	r3, [r7, #8]
 8010daa:	7a9b      	ldrb	r3, [r3, #10]
 8010dac:	2217      	movs	r2, #23
 8010dae:	18bc      	adds	r4, r7, r2
 8010db0:	687a      	ldr	r2, [r7, #4]
 8010db2:	9202      	str	r2, [sp, #8]
 8010db4:	2206      	movs	r2, #6
 8010db6:	9201      	str	r2, [sp, #4]
 8010db8:	9300      	str	r3, [sp, #0]
 8010dba:	0033      	movs	r3, r6
 8010dbc:	002a      	movs	r2, r5
 8010dbe:	f002 fa77 	bl	80132b0 <ip4_output_if>
 8010dc2:	0003      	movs	r3, r0
 8010dc4:	7023      	strb	r3, [r4, #0]
                     pcb->tos, IP_PROTO_TCP, netif);
  NETIF_RESET_HINTS(netif);
 8010dc6:	687b      	ldr	r3, [r7, #4]
 8010dc8:	2200      	movs	r2, #0
 8010dca:	639a      	str	r2, [r3, #56]	; 0x38

#if TCP_CHECKSUM_ON_COPY
  if (seg_chksum_was_swapped) {
 8010dcc:	6a3b      	ldr	r3, [r7, #32]
 8010dce:	2b00      	cmp	r3, #0
 8010dd0:	d010      	beq.n	8010df4 <tcp_output_segment+0x370>
    /* if data is added to this segment later, chksum needs to be swapped,
       so restore this now */
    seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
 8010dd2:	68fb      	ldr	r3, [r7, #12]
 8010dd4:	899b      	ldrh	r3, [r3, #12]
 8010dd6:	021b      	lsls	r3, r3, #8
 8010dd8:	b21a      	sxth	r2, r3
 8010dda:	68fb      	ldr	r3, [r7, #12]
 8010ddc:	899b      	ldrh	r3, [r3, #12]
 8010dde:	0a1b      	lsrs	r3, r3, #8
 8010de0:	b29b      	uxth	r3, r3
 8010de2:	b21b      	sxth	r3, r3
 8010de4:	4313      	orrs	r3, r2
 8010de6:	b21b      	sxth	r3, r3
 8010de8:	b29a      	uxth	r2, r3
 8010dea:	68fb      	ldr	r3, [r7, #12]
 8010dec:	819a      	strh	r2, [r3, #12]
    seg->chksum_swapped = 1;
 8010dee:	68fb      	ldr	r3, [r7, #12]
 8010df0:	2201      	movs	r2, #1
 8010df2:	739a      	strb	r2, [r3, #14]
  }
#endif

  return err;
 8010df4:	2317      	movs	r3, #23
 8010df6:	18fb      	adds	r3, r7, r3
 8010df8:	781b      	ldrb	r3, [r3, #0]
 8010dfa:	b25b      	sxtb	r3, r3
}
 8010dfc:	0018      	movs	r0, r3
 8010dfe:	46bd      	mov	sp, r7
 8010e00:	b00b      	add	sp, #44	; 0x2c
 8010e02:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8010e04:	0801fe14 	.word	0x0801fe14
 8010e08:	000005b9 	.word	0x000005b9
 8010e0c:	080204b4 	.word	0x080204b4
 8010e10:	0801fe60 	.word	0x0801fe60
 8010e14:	000005ba 	.word	0x000005ba
 8010e18:	080204d4 	.word	0x080204d4
 8010e1c:	000005bb 	.word	0x000005bb
 8010e20:	080204f4 	.word	0x080204f4
 8010e24:	20002b1c 	.word	0x20002b1c
 8010e28:	0000061d 	.word	0x0000061d
 8010e2c:	08020518 	.word	0x08020518
 8010e30:	0802052c 	.word	0x0802052c

08010e34 <tcp_rexmit_rto_prepare>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
err_t
tcp_rexmit_rto_prepare(struct tcp_pcb *pcb)
{
 8010e34:	b5b0      	push	{r4, r5, r7, lr}
 8010e36:	b084      	sub	sp, #16
 8010e38:	af00      	add	r7, sp, #0
 8010e3a:	6078      	str	r0, [r7, #4]
  struct tcp_seg *seg;

  LWIP_ASSERT("tcp_rexmit_rto_prepare: invalid pcb", pcb != NULL);
 8010e3c:	687b      	ldr	r3, [r7, #4]
 8010e3e:	2b00      	cmp	r3, #0
 8010e40:	d105      	bne.n	8010e4e <tcp_rexmit_rto_prepare+0x1a>
 8010e42:	4b3c      	ldr	r3, [pc, #240]	; (8010f34 <tcp_rexmit_rto_prepare+0x100>)
 8010e44:	4a3c      	ldr	r2, [pc, #240]	; (8010f38 <tcp_rexmit_rto_prepare+0x104>)
 8010e46:	493d      	ldr	r1, [pc, #244]	; (8010f3c <tcp_rexmit_rto_prepare+0x108>)
 8010e48:	483d      	ldr	r0, [pc, #244]	; (8010f40 <tcp_rexmit_rto_prepare+0x10c>)
 8010e4a:	f7f1 f9bf 	bl	80021cc <app_debug_rtt_raw>

  if (pcb->unacked == NULL) {
 8010e4e:	687b      	ldr	r3, [r7, #4]
 8010e50:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8010e52:	2b00      	cmp	r3, #0
 8010e54:	d102      	bne.n	8010e5c <tcp_rexmit_rto_prepare+0x28>
    return ERR_VAL;
 8010e56:	2306      	movs	r3, #6
 8010e58:	425b      	negs	r3, r3
 8010e5a:	e066      	b.n	8010f2a <tcp_rexmit_rto_prepare+0xf6>

  /* Move all unacked segments to the head of the unsent queue.
     However, give up if any of the unsent pbufs are still referenced by the
     netif driver due to deferred transmission. No point loading the link further
     if it is struggling to flush its buffered writes. */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next) {
 8010e5c:	687b      	ldr	r3, [r7, #4]
 8010e5e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8010e60:	60fb      	str	r3, [r7, #12]
 8010e62:	e00b      	b.n	8010e7c <tcp_rexmit_rto_prepare+0x48>
    if (tcp_output_segment_busy(seg)) {
 8010e64:	68fb      	ldr	r3, [r7, #12]
 8010e66:	0018      	movs	r0, r3
 8010e68:	f7ff fdea 	bl	8010a40 <tcp_output_segment_busy>
 8010e6c:	1e03      	subs	r3, r0, #0
 8010e6e:	d002      	beq.n	8010e76 <tcp_rexmit_rto_prepare+0x42>
      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit_rto: segment busy\n"));
      return ERR_VAL;
 8010e70:	2306      	movs	r3, #6
 8010e72:	425b      	negs	r3, r3
 8010e74:	e059      	b.n	8010f2a <tcp_rexmit_rto_prepare+0xf6>
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next) {
 8010e76:	68fb      	ldr	r3, [r7, #12]
 8010e78:	681b      	ldr	r3, [r3, #0]
 8010e7a:	60fb      	str	r3, [r7, #12]
 8010e7c:	68fb      	ldr	r3, [r7, #12]
 8010e7e:	681b      	ldr	r3, [r3, #0]
 8010e80:	2b00      	cmp	r3, #0
 8010e82:	d1ef      	bne.n	8010e64 <tcp_rexmit_rto_prepare+0x30>
    }
  }
  if (tcp_output_segment_busy(seg)) {
 8010e84:	68fb      	ldr	r3, [r7, #12]
 8010e86:	0018      	movs	r0, r3
 8010e88:	f7ff fdda 	bl	8010a40 <tcp_output_segment_busy>
 8010e8c:	1e03      	subs	r3, r0, #0
 8010e8e:	d002      	beq.n	8010e96 <tcp_rexmit_rto_prepare+0x62>
    LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit_rto: segment busy\n"));
    return ERR_VAL;
 8010e90:	2306      	movs	r3, #6
 8010e92:	425b      	negs	r3, r3
 8010e94:	e049      	b.n	8010f2a <tcp_rexmit_rto_prepare+0xf6>
  }
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
 8010e96:	687b      	ldr	r3, [r7, #4]
 8010e98:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8010e9a:	68fb      	ldr	r3, [r7, #12]
 8010e9c:	601a      	str	r2, [r3, #0]
#if TCP_OVERSIZE_DBGCHECK
  /* if last unsent changed, we need to update unsent_oversize */
  if (pcb->unsent == NULL) {
 8010e9e:	687b      	ldr	r3, [r7, #4]
 8010ea0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8010ea2:	2b00      	cmp	r3, #0
 8010ea4:	d104      	bne.n	8010eb0 <tcp_rexmit_rto_prepare+0x7c>
    pcb->unsent_oversize = seg->oversize_left;
 8010ea6:	68fb      	ldr	r3, [r7, #12]
 8010ea8:	8959      	ldrh	r1, [r3, #10]
 8010eaa:	687b      	ldr	r3, [r7, #4]
 8010eac:	226c      	movs	r2, #108	; 0x6c
 8010eae:	5299      	strh	r1, [r3, r2]
  }
#endif /* TCP_OVERSIZE_DBGCHECK */
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
 8010eb0:	687b      	ldr	r3, [r7, #4]
 8010eb2:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8010eb4:	687b      	ldr	r3, [r7, #4]
 8010eb6:	671a      	str	r2, [r3, #112]	; 0x70
  /* unacked queue is now empty */
  pcb->unacked = NULL;
 8010eb8:	687b      	ldr	r3, [r7, #4]
 8010eba:	2200      	movs	r2, #0
 8010ebc:	675a      	str	r2, [r3, #116]	; 0x74

  /* Mark RTO in-progress */
  tcp_set_flags(pcb, TF_RTO);
 8010ebe:	687b      	ldr	r3, [r7, #4]
 8010ec0:	8bdb      	ldrh	r3, [r3, #30]
 8010ec2:	2280      	movs	r2, #128	; 0x80
 8010ec4:	0112      	lsls	r2, r2, #4
 8010ec6:	4313      	orrs	r3, r2
 8010ec8:	b29a      	uxth	r2, r3
 8010eca:	687b      	ldr	r3, [r7, #4]
 8010ecc:	83da      	strh	r2, [r3, #30]
  /* Record the next byte following retransmit */
  pcb->rto_end = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 8010ece:	68fb      	ldr	r3, [r7, #12]
 8010ed0:	691b      	ldr	r3, [r3, #16]
 8010ed2:	791a      	ldrb	r2, [r3, #4]
 8010ed4:	7959      	ldrb	r1, [r3, #5]
 8010ed6:	0209      	lsls	r1, r1, #8
 8010ed8:	430a      	orrs	r2, r1
 8010eda:	7999      	ldrb	r1, [r3, #6]
 8010edc:	0409      	lsls	r1, r1, #16
 8010ede:	430a      	orrs	r2, r1
 8010ee0:	79db      	ldrb	r3, [r3, #7]
 8010ee2:	061b      	lsls	r3, r3, #24
 8010ee4:	4313      	orrs	r3, r2
 8010ee6:	0018      	movs	r0, r3
 8010ee8:	f7f5 fb3a 	bl	8006560 <lwip_htonl>
 8010eec:	0004      	movs	r4, r0
 8010eee:	68fb      	ldr	r3, [r7, #12]
 8010ef0:	891b      	ldrh	r3, [r3, #8]
 8010ef2:	001d      	movs	r5, r3
 8010ef4:	68fb      	ldr	r3, [r7, #12]
 8010ef6:	691b      	ldr	r3, [r3, #16]
 8010ef8:	7b1a      	ldrb	r2, [r3, #12]
 8010efa:	7b5b      	ldrb	r3, [r3, #13]
 8010efc:	021b      	lsls	r3, r3, #8
 8010efe:	4313      	orrs	r3, r2
 8010f00:	b29b      	uxth	r3, r3
 8010f02:	0018      	movs	r0, r3
 8010f04:	f7f5 fb16 	bl	8006534 <lwip_htons>
 8010f08:	0003      	movs	r3, r0
 8010f0a:	b2db      	uxtb	r3, r3
 8010f0c:	001a      	movs	r2, r3
 8010f0e:	2303      	movs	r3, #3
 8010f10:	4013      	ands	r3, r2
 8010f12:	d001      	beq.n	8010f18 <tcp_rexmit_rto_prepare+0xe4>
 8010f14:	2301      	movs	r3, #1
 8010f16:	e000      	b.n	8010f1a <tcp_rexmit_rto_prepare+0xe6>
 8010f18:	2300      	movs	r3, #0
 8010f1a:	195b      	adds	r3, r3, r5
 8010f1c:	18e2      	adds	r2, r4, r3
 8010f1e:	687b      	ldr	r3, [r7, #4]
 8010f20:	651a      	str	r2, [r3, #80]	; 0x50
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
 8010f22:	687b      	ldr	r3, [r7, #4]
 8010f24:	2200      	movs	r2, #0
 8010f26:	639a      	str	r2, [r3, #56]	; 0x38

  return ERR_OK;
 8010f28:	2300      	movs	r3, #0
}
 8010f2a:	0018      	movs	r0, r3
 8010f2c:	46bd      	mov	sp, r7
 8010f2e:	b004      	add	sp, #16
 8010f30:	bdb0      	pop	{r4, r5, r7, pc}
 8010f32:	46c0      	nop			; (mov r8, r8)
 8010f34:	0801fe14 	.word	0x0801fe14
 8010f38:	00000664 	.word	0x00000664
 8010f3c:	08020550 	.word	0x08020550
 8010f40:	0801fe60 	.word	0x0801fe60

08010f44 <tcp_rexmit_rto_commit>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto_commit(struct tcp_pcb *pcb)
{
 8010f44:	b580      	push	{r7, lr}
 8010f46:	b082      	sub	sp, #8
 8010f48:	af00      	add	r7, sp, #0
 8010f4a:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_rexmit_rto_commit: invalid pcb", pcb != NULL);
 8010f4c:	687b      	ldr	r3, [r7, #4]
 8010f4e:	2b00      	cmp	r3, #0
 8010f50:	d105      	bne.n	8010f5e <tcp_rexmit_rto_commit+0x1a>
 8010f52:	4b0d      	ldr	r3, [pc, #52]	; (8010f88 <tcp_rexmit_rto_commit+0x44>)
 8010f54:	4a0d      	ldr	r2, [pc, #52]	; (8010f8c <tcp_rexmit_rto_commit+0x48>)
 8010f56:	490e      	ldr	r1, [pc, #56]	; (8010f90 <tcp_rexmit_rto_commit+0x4c>)
 8010f58:	480e      	ldr	r0, [pc, #56]	; (8010f94 <tcp_rexmit_rto_commit+0x50>)
 8010f5a:	f7f1 f937 	bl	80021cc <app_debug_rtt_raw>

  /* increment number of retransmissions */
  if (pcb->nrtx < 0xFF) {
 8010f5e:	687b      	ldr	r3, [r7, #4]
 8010f60:	2246      	movs	r2, #70	; 0x46
 8010f62:	5c9b      	ldrb	r3, [r3, r2]
 8010f64:	2bff      	cmp	r3, #255	; 0xff
 8010f66:	d007      	beq.n	8010f78 <tcp_rexmit_rto_commit+0x34>
    ++pcb->nrtx;
 8010f68:	687b      	ldr	r3, [r7, #4]
 8010f6a:	2246      	movs	r2, #70	; 0x46
 8010f6c:	5c9b      	ldrb	r3, [r3, r2]
 8010f6e:	3301      	adds	r3, #1
 8010f70:	b2d9      	uxtb	r1, r3
 8010f72:	687b      	ldr	r3, [r7, #4]
 8010f74:	2246      	movs	r2, #70	; 0x46
 8010f76:	5499      	strb	r1, [r3, r2]
  }
  /* Do the actual retransmission */
  tcp_output(pcb);
 8010f78:	687b      	ldr	r3, [r7, #4]
 8010f7a:	0018      	movs	r0, r3
 8010f7c:	f7ff fb00 	bl	8010580 <tcp_output>
}
 8010f80:	46c0      	nop			; (mov r8, r8)
 8010f82:	46bd      	mov	sp, r7
 8010f84:	b002      	add	sp, #8
 8010f86:	bd80      	pop	{r7, pc}
 8010f88:	0801fe14 	.word	0x0801fe14
 8010f8c:	00000699 	.word	0x00000699
 8010f90:	08020574 	.word	0x08020574
 8010f94:	0801fe60 	.word	0x0801fe60

08010f98 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
 8010f98:	b580      	push	{r7, lr}
 8010f9a:	b082      	sub	sp, #8
 8010f9c:	af00      	add	r7, sp, #0
 8010f9e:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_rexmit_rto: invalid pcb", pcb != NULL);
 8010fa0:	687b      	ldr	r3, [r7, #4]
 8010fa2:	2b00      	cmp	r3, #0
 8010fa4:	d105      	bne.n	8010fb2 <tcp_rexmit_rto+0x1a>
 8010fa6:	4b0a      	ldr	r3, [pc, #40]	; (8010fd0 <tcp_rexmit_rto+0x38>)
 8010fa8:	4a0a      	ldr	r2, [pc, #40]	; (8010fd4 <tcp_rexmit_rto+0x3c>)
 8010faa:	490b      	ldr	r1, [pc, #44]	; (8010fd8 <tcp_rexmit_rto+0x40>)
 8010fac:	480b      	ldr	r0, [pc, #44]	; (8010fdc <tcp_rexmit_rto+0x44>)
 8010fae:	f7f1 f90d 	bl	80021cc <app_debug_rtt_raw>

  if (tcp_rexmit_rto_prepare(pcb) == ERR_OK) {
 8010fb2:	687b      	ldr	r3, [r7, #4]
 8010fb4:	0018      	movs	r0, r3
 8010fb6:	f7ff ff3d 	bl	8010e34 <tcp_rexmit_rto_prepare>
 8010fba:	1e03      	subs	r3, r0, #0
 8010fbc:	d103      	bne.n	8010fc6 <tcp_rexmit_rto+0x2e>
    tcp_rexmit_rto_commit(pcb);
 8010fbe:	687b      	ldr	r3, [r7, #4]
 8010fc0:	0018      	movs	r0, r3
 8010fc2:	f7ff ffbf 	bl	8010f44 <tcp_rexmit_rto_commit>
  }
}
 8010fc6:	46c0      	nop			; (mov r8, r8)
 8010fc8:	46bd      	mov	sp, r7
 8010fca:	b002      	add	sp, #8
 8010fcc:	bd80      	pop	{r7, pc}
 8010fce:	46c0      	nop			; (mov r8, r8)
 8010fd0:	0801fe14 	.word	0x0801fe14
 8010fd4:	000006ae 	.word	0x000006ae
 8010fd8:	08020598 	.word	0x08020598
 8010fdc:	0801fe60 	.word	0x0801fe60

08010fe0 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
err_t
tcp_rexmit(struct tcp_pcb *pcb)
{
 8010fe0:	b590      	push	{r4, r7, lr}
 8010fe2:	b085      	sub	sp, #20
 8010fe4:	af00      	add	r7, sp, #0
 8010fe6:	6078      	str	r0, [r7, #4]
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  LWIP_ASSERT("tcp_rexmit: invalid pcb", pcb != NULL);
 8010fe8:	687b      	ldr	r3, [r7, #4]
 8010fea:	2b00      	cmp	r3, #0
 8010fec:	d105      	bne.n	8010ffa <tcp_rexmit+0x1a>
 8010fee:	4b37      	ldr	r3, [pc, #220]	; (80110cc <tcp_rexmit+0xec>)
 8010ff0:	4a37      	ldr	r2, [pc, #220]	; (80110d0 <tcp_rexmit+0xf0>)
 8010ff2:	4938      	ldr	r1, [pc, #224]	; (80110d4 <tcp_rexmit+0xf4>)
 8010ff4:	4838      	ldr	r0, [pc, #224]	; (80110d8 <tcp_rexmit+0xf8>)
 8010ff6:	f7f1 f8e9 	bl	80021cc <app_debug_rtt_raw>

  if (pcb->unacked == NULL) {
 8010ffa:	687b      	ldr	r3, [r7, #4]
 8010ffc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8010ffe:	2b00      	cmp	r3, #0
 8011000:	d102      	bne.n	8011008 <tcp_rexmit+0x28>
    return ERR_VAL;
 8011002:	2306      	movs	r3, #6
 8011004:	425b      	negs	r3, r3
 8011006:	e05d      	b.n	80110c4 <tcp_rexmit+0xe4>
  }

  seg = pcb->unacked;
 8011008:	687b      	ldr	r3, [r7, #4]
 801100a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 801100c:	60bb      	str	r3, [r7, #8]

  /* Give up if the segment is still referenced by the netif driver
     due to deferred transmission. */
  if (tcp_output_segment_busy(seg)) {
 801100e:	68bb      	ldr	r3, [r7, #8]
 8011010:	0018      	movs	r0, r3
 8011012:	f7ff fd15 	bl	8010a40 <tcp_output_segment_busy>
 8011016:	1e03      	subs	r3, r0, #0
 8011018:	d002      	beq.n	8011020 <tcp_rexmit+0x40>
    LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit busy\n"));
    return ERR_VAL;
 801101a:	2306      	movs	r3, #6
 801101c:	425b      	negs	r3, r3
 801101e:	e051      	b.n	80110c4 <tcp_rexmit+0xe4>
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  pcb->unacked = seg->next;
 8011020:	68bb      	ldr	r3, [r7, #8]
 8011022:	681a      	ldr	r2, [r3, #0]
 8011024:	687b      	ldr	r3, [r7, #4]
 8011026:	675a      	str	r2, [r3, #116]	; 0x74

  cur_seg = &(pcb->unsent);
 8011028:	687b      	ldr	r3, [r7, #4]
 801102a:	3370      	adds	r3, #112	; 0x70
 801102c:	60fb      	str	r3, [r7, #12]
  while (*cur_seg &&
 801102e:	e002      	b.n	8011036 <tcp_rexmit+0x56>
         TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
    cur_seg = &((*cur_seg)->next );
 8011030:	68fb      	ldr	r3, [r7, #12]
 8011032:	681b      	ldr	r3, [r3, #0]
 8011034:	60fb      	str	r3, [r7, #12]
  while (*cur_seg &&
 8011036:	68fb      	ldr	r3, [r7, #12]
 8011038:	681b      	ldr	r3, [r3, #0]
 801103a:	2b00      	cmp	r3, #0
 801103c:	d022      	beq.n	8011084 <tcp_rexmit+0xa4>
         TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
 801103e:	68fb      	ldr	r3, [r7, #12]
 8011040:	681b      	ldr	r3, [r3, #0]
 8011042:	691b      	ldr	r3, [r3, #16]
 8011044:	791a      	ldrb	r2, [r3, #4]
 8011046:	7959      	ldrb	r1, [r3, #5]
 8011048:	0209      	lsls	r1, r1, #8
 801104a:	430a      	orrs	r2, r1
 801104c:	7999      	ldrb	r1, [r3, #6]
 801104e:	0409      	lsls	r1, r1, #16
 8011050:	430a      	orrs	r2, r1
 8011052:	79db      	ldrb	r3, [r3, #7]
 8011054:	061b      	lsls	r3, r3, #24
 8011056:	4313      	orrs	r3, r2
 8011058:	0018      	movs	r0, r3
 801105a:	f7f5 fa81 	bl	8006560 <lwip_htonl>
 801105e:	0004      	movs	r4, r0
 8011060:	68bb      	ldr	r3, [r7, #8]
 8011062:	691b      	ldr	r3, [r3, #16]
 8011064:	791a      	ldrb	r2, [r3, #4]
 8011066:	7959      	ldrb	r1, [r3, #5]
 8011068:	0209      	lsls	r1, r1, #8
 801106a:	430a      	orrs	r2, r1
 801106c:	7999      	ldrb	r1, [r3, #6]
 801106e:	0409      	lsls	r1, r1, #16
 8011070:	430a      	orrs	r2, r1
 8011072:	79db      	ldrb	r3, [r3, #7]
 8011074:	061b      	lsls	r3, r3, #24
 8011076:	4313      	orrs	r3, r2
 8011078:	0018      	movs	r0, r3
 801107a:	f7f5 fa71 	bl	8006560 <lwip_htonl>
 801107e:	0003      	movs	r3, r0
 8011080:	1ae3      	subs	r3, r4, r3
  while (*cur_seg &&
 8011082:	d4d5      	bmi.n	8011030 <tcp_rexmit+0x50>
  }
  seg->next = *cur_seg;
 8011084:	68fb      	ldr	r3, [r7, #12]
 8011086:	681a      	ldr	r2, [r3, #0]
 8011088:	68bb      	ldr	r3, [r7, #8]
 801108a:	601a      	str	r2, [r3, #0]
  *cur_seg = seg;
 801108c:	68fb      	ldr	r3, [r7, #12]
 801108e:	68ba      	ldr	r2, [r7, #8]
 8011090:	601a      	str	r2, [r3, #0]
#if TCP_OVERSIZE
  if (seg->next == NULL) {
 8011092:	68bb      	ldr	r3, [r7, #8]
 8011094:	681b      	ldr	r3, [r3, #0]
 8011096:	2b00      	cmp	r3, #0
 8011098:	d103      	bne.n	80110a2 <tcp_rexmit+0xc2>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
 801109a:	687b      	ldr	r3, [r7, #4]
 801109c:	226c      	movs	r2, #108	; 0x6c
 801109e:	2100      	movs	r1, #0
 80110a0:	5299      	strh	r1, [r3, r2]
  }
#endif /* TCP_OVERSIZE */

  if (pcb->nrtx < 0xFF) {
 80110a2:	687b      	ldr	r3, [r7, #4]
 80110a4:	2246      	movs	r2, #70	; 0x46
 80110a6:	5c9b      	ldrb	r3, [r3, r2]
 80110a8:	2bff      	cmp	r3, #255	; 0xff
 80110aa:	d007      	beq.n	80110bc <tcp_rexmit+0xdc>
    ++pcb->nrtx;
 80110ac:	687b      	ldr	r3, [r7, #4]
 80110ae:	2246      	movs	r2, #70	; 0x46
 80110b0:	5c9b      	ldrb	r3, [r3, r2]
 80110b2:	3301      	adds	r3, #1
 80110b4:	b2d9      	uxtb	r1, r3
 80110b6:	687b      	ldr	r3, [r7, #4]
 80110b8:	2246      	movs	r2, #70	; 0x46
 80110ba:	5499      	strb	r1, [r3, r2]
  }

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 80110bc:	687b      	ldr	r3, [r7, #4]
 80110be:	2200      	movs	r2, #0
 80110c0:	639a      	str	r2, [r3, #56]	; 0x38

  /* Do the actual retransmission. */
  MIB2_STATS_INC(mib2.tcpretranssegs);
  /* No need to call tcp_output: we are always called from tcp_input()
     and thus tcp_output directly returns. */
  return ERR_OK;
 80110c2:	2300      	movs	r3, #0
}
 80110c4:	0018      	movs	r0, r3
 80110c6:	46bd      	mov	sp, r7
 80110c8:	b005      	add	sp, #20
 80110ca:	bd90      	pop	{r4, r7, pc}
 80110cc:	0801fe14 	.word	0x0801fe14
 80110d0:	000006c2 	.word	0x000006c2
 80110d4:	080205b4 	.word	0x080205b4
 80110d8:	0801fe60 	.word	0x0801fe60

080110dc <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
 80110dc:	b580      	push	{r7, lr}
 80110de:	b082      	sub	sp, #8
 80110e0:	af00      	add	r7, sp, #0
 80110e2:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("tcp_rexmit_fast: invalid pcb", pcb != NULL);
 80110e4:	687b      	ldr	r3, [r7, #4]
 80110e6:	2b00      	cmp	r3, #0
 80110e8:	d105      	bne.n	80110f6 <tcp_rexmit_fast+0x1a>
 80110ea:	4b2c      	ldr	r3, [pc, #176]	; (801119c <tcp_rexmit_fast+0xc0>)
 80110ec:	4a2c      	ldr	r2, [pc, #176]	; (80111a0 <tcp_rexmit_fast+0xc4>)
 80110ee:	492d      	ldr	r1, [pc, #180]	; (80111a4 <tcp_rexmit_fast+0xc8>)
 80110f0:	482d      	ldr	r0, [pc, #180]	; (80111a8 <tcp_rexmit_fast+0xcc>)
 80110f2:	f7f1 f86b 	bl	80021cc <app_debug_rtt_raw>

  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 80110f6:	687b      	ldr	r3, [r7, #4]
 80110f8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80110fa:	2b00      	cmp	r3, #0
 80110fc:	d049      	beq.n	8011192 <tcp_rexmit_fast+0xb6>
 80110fe:	687b      	ldr	r3, [r7, #4]
 8011100:	8bdb      	ldrh	r3, [r3, #30]
 8011102:	001a      	movs	r2, r3
 8011104:	2304      	movs	r3, #4
 8011106:	4013      	ands	r3, r2
 8011108:	d143      	bne.n	8011192 <tcp_rexmit_fast+0xb6>
    LWIP_DEBUGF(TCP_FR_DEBUG,
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 lwip_ntohl(pcb->unacked->tcphdr->seqno)));
    if (tcp_rexmit(pcb) == ERR_OK) {
 801110a:	687b      	ldr	r3, [r7, #4]
 801110c:	0018      	movs	r0, r3
 801110e:	f7ff ff67 	bl	8010fe0 <tcp_rexmit>
 8011112:	1e03      	subs	r3, r0, #0
 8011114:	d13d      	bne.n	8011192 <tcp_rexmit_fast+0xb6>
      /* Set ssthresh to half of the minimum of the current
       * cwnd and the advertised window */
      pcb->ssthresh = LWIP_MIN(pcb->cwnd, pcb->snd_wnd) / 2;
 8011116:	687b      	ldr	r3, [r7, #4]
 8011118:	2264      	movs	r2, #100	; 0x64
 801111a:	5a99      	ldrh	r1, [r3, r2]
 801111c:	687b      	ldr	r3, [r7, #4]
 801111e:	224c      	movs	r2, #76	; 0x4c
 8011120:	5a9b      	ldrh	r3, [r3, r2]
 8011122:	1c18      	adds	r0, r3, #0
 8011124:	b28a      	uxth	r2, r1
 8011126:	b283      	uxth	r3, r0
 8011128:	429a      	cmp	r2, r3
 801112a:	d900      	bls.n	801112e <tcp_rexmit_fast+0x52>
 801112c:	1c01      	adds	r1, r0, #0
 801112e:	b28b      	uxth	r3, r1
 8011130:	2b00      	cmp	r3, #0
 8011132:	da00      	bge.n	8011136 <tcp_rexmit_fast+0x5a>
 8011134:	3301      	adds	r3, #1
 8011136:	105b      	asrs	r3, r3, #1
 8011138:	b299      	uxth	r1, r3
 801113a:	687b      	ldr	r3, [r7, #4]
 801113c:	224e      	movs	r2, #78	; 0x4e
 801113e:	5299      	strh	r1, [r3, r2]

      /* The minimum value for ssthresh should be 2 MSS */
      if (pcb->ssthresh < (2U * pcb->mss)) {
 8011140:	687b      	ldr	r3, [r7, #4]
 8011142:	224e      	movs	r2, #78	; 0x4e
 8011144:	5a9b      	ldrh	r3, [r3, r2]
 8011146:	001a      	movs	r2, r3
 8011148:	687b      	ldr	r3, [r7, #4]
 801114a:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 801114c:	005b      	lsls	r3, r3, #1
 801114e:	429a      	cmp	r2, r3
 8011150:	d206      	bcs.n	8011160 <tcp_rexmit_fast+0x84>
        LWIP_DEBUGF(TCP_FR_DEBUG,
                    ("tcp_receive: The minimum value for ssthresh %"TCPWNDSIZE_F
                     " should be min 2 mss %"U16_F"...\n",
                     pcb->ssthresh, (u16_t)(2 * pcb->mss)));
        pcb->ssthresh = 2 * pcb->mss;
 8011152:	687b      	ldr	r3, [r7, #4]
 8011154:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 8011156:	18db      	adds	r3, r3, r3
 8011158:	b299      	uxth	r1, r3
 801115a:	687b      	ldr	r3, [r7, #4]
 801115c:	224e      	movs	r2, #78	; 0x4e
 801115e:	5299      	strh	r1, [r3, r2]
      }

      pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 8011160:	687b      	ldr	r3, [r7, #4]
 8011162:	224e      	movs	r2, #78	; 0x4e
 8011164:	5a9a      	ldrh	r2, [r3, r2]
 8011166:	687b      	ldr	r3, [r7, #4]
 8011168:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 801116a:	1c19      	adds	r1, r3, #0
 801116c:	1c0b      	adds	r3, r1, #0
 801116e:	18db      	adds	r3, r3, r3
 8011170:	185b      	adds	r3, r3, r1
 8011172:	b29b      	uxth	r3, r3
 8011174:	18d3      	adds	r3, r2, r3
 8011176:	b299      	uxth	r1, r3
 8011178:	687b      	ldr	r3, [r7, #4]
 801117a:	224c      	movs	r2, #76	; 0x4c
 801117c:	5299      	strh	r1, [r3, r2]
      tcp_set_flags(pcb, TF_INFR);
 801117e:	687b      	ldr	r3, [r7, #4]
 8011180:	8bdb      	ldrh	r3, [r3, #30]
 8011182:	2204      	movs	r2, #4
 8011184:	4313      	orrs	r3, r2
 8011186:	b29a      	uxth	r2, r3
 8011188:	687b      	ldr	r3, [r7, #4]
 801118a:	83da      	strh	r2, [r3, #30]

      /* Reset the retransmission timer to prevent immediate rto retransmissions */
      pcb->rtime = 0;
 801118c:	687b      	ldr	r3, [r7, #4]
 801118e:	2200      	movs	r2, #0
 8011190:	869a      	strh	r2, [r3, #52]	; 0x34
    }
  }
}
 8011192:	46c0      	nop			; (mov r8, r8)
 8011194:	46bd      	mov	sp, r7
 8011196:	b002      	add	sp, #8
 8011198:	bd80      	pop	{r7, pc}
 801119a:	46c0      	nop			; (mov r8, r8)
 801119c:	0801fe14 	.word	0x0801fe14
 80111a0:	000006fa 	.word	0x000006fa
 80111a4:	080205cc 	.word	0x080205cc
 80111a8:	0801fe60 	.word	0x0801fe60

080111ac <tcp_output_alloc_header_common>:

static struct pbuf *
tcp_output_alloc_header_common(u32_t ackno, u16_t optlen, u16_t datalen,
                        u32_t seqno_be /* already in network byte order */,
                        u16_t src_port, u16_t dst_port, u8_t flags, u16_t wnd)
{
 80111ac:	b590      	push	{r4, r7, lr}
 80111ae:	b087      	sub	sp, #28
 80111b0:	af00      	add	r7, sp, #0
 80111b2:	60f8      	str	r0, [r7, #12]
 80111b4:	0008      	movs	r0, r1
 80111b6:	0011      	movs	r1, r2
 80111b8:	607b      	str	r3, [r7, #4]
 80111ba:	240a      	movs	r4, #10
 80111bc:	193b      	adds	r3, r7, r4
 80111be:	1c02      	adds	r2, r0, #0
 80111c0:	801a      	strh	r2, [r3, #0]
 80111c2:	2008      	movs	r0, #8
 80111c4:	183b      	adds	r3, r7, r0
 80111c6:	1c0a      	adds	r2, r1, #0
 80111c8:	801a      	strh	r2, [r3, #0]
  struct tcp_hdr *tcphdr;
  struct pbuf *p;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 80111ca:	193a      	adds	r2, r7, r4
 80111cc:	183b      	adds	r3, r7, r0
 80111ce:	8812      	ldrh	r2, [r2, #0]
 80111d0:	881b      	ldrh	r3, [r3, #0]
 80111d2:	18d3      	adds	r3, r2, r3
 80111d4:	b29b      	uxth	r3, r3
 80111d6:	3314      	adds	r3, #20
 80111d8:	b29b      	uxth	r3, r3
 80111da:	22a0      	movs	r2, #160	; 0xa0
 80111dc:	0092      	lsls	r2, r2, #2
 80111de:	0019      	movs	r1, r3
 80111e0:	2024      	movs	r0, #36	; 0x24
 80111e2:	f7f7 fedf 	bl	8008fa4 <pbuf_alloc>
 80111e6:	0003      	movs	r3, r0
 80111e8:	617b      	str	r3, [r7, #20]
  if (p != NULL) {
 80111ea:	697b      	ldr	r3, [r7, #20]
 80111ec:	2b00      	cmp	r3, #0
 80111ee:	d100      	bne.n	80111f2 <tcp_output_alloc_header_common+0x46>
 80111f0:	e0f0      	b.n	80113d4 <tcp_output_alloc_header_common+0x228>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 80111f2:	193b      	adds	r3, r7, r4
 80111f4:	881b      	ldrh	r3, [r3, #0]
 80111f6:	3313      	adds	r3, #19
 80111f8:	697a      	ldr	r2, [r7, #20]
 80111fa:	8952      	ldrh	r2, [r2, #10]
 80111fc:	4293      	cmp	r3, r2
 80111fe:	db05      	blt.n	801120c <tcp_output_alloc_header_common+0x60>
 8011200:	4b77      	ldr	r3, [pc, #476]	; (80113e0 <tcp_output_alloc_header_common+0x234>)
 8011202:	4a78      	ldr	r2, [pc, #480]	; (80113e4 <tcp_output_alloc_header_common+0x238>)
 8011204:	4978      	ldr	r1, [pc, #480]	; (80113e8 <tcp_output_alloc_header_common+0x23c>)
 8011206:	4879      	ldr	r0, [pc, #484]	; (80113ec <tcp_output_alloc_header_common+0x240>)
 8011208:	f7f0 ffe0 	bl	80021cc <app_debug_rtt_raw>
                (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
 801120c:	697b      	ldr	r3, [r7, #20]
 801120e:	685b      	ldr	r3, [r3, #4]
 8011210:	613b      	str	r3, [r7, #16]
    tcphdr->src = lwip_htons(src_port);
 8011212:	2328      	movs	r3, #40	; 0x28
 8011214:	18fb      	adds	r3, r7, r3
 8011216:	881b      	ldrh	r3, [r3, #0]
 8011218:	0018      	movs	r0, r3
 801121a:	f7f5 f98b 	bl	8006534 <lwip_htons>
 801121e:	0003      	movs	r3, r0
 8011220:	001a      	movs	r2, r3
 8011222:	693b      	ldr	r3, [r7, #16]
 8011224:	21ff      	movs	r1, #255	; 0xff
 8011226:	4011      	ands	r1, r2
 8011228:	000c      	movs	r4, r1
 801122a:	7819      	ldrb	r1, [r3, #0]
 801122c:	2000      	movs	r0, #0
 801122e:	4001      	ands	r1, r0
 8011230:	1c08      	adds	r0, r1, #0
 8011232:	1c21      	adds	r1, r4, #0
 8011234:	4301      	orrs	r1, r0
 8011236:	7019      	strb	r1, [r3, #0]
 8011238:	0a12      	lsrs	r2, r2, #8
 801123a:	b290      	uxth	r0, r2
 801123c:	785a      	ldrb	r2, [r3, #1]
 801123e:	2100      	movs	r1, #0
 8011240:	400a      	ands	r2, r1
 8011242:	1c11      	adds	r1, r2, #0
 8011244:	1c02      	adds	r2, r0, #0
 8011246:	430a      	orrs	r2, r1
 8011248:	705a      	strb	r2, [r3, #1]
    tcphdr->dest = lwip_htons(dst_port);
 801124a:	232c      	movs	r3, #44	; 0x2c
 801124c:	18fb      	adds	r3, r7, r3
 801124e:	881b      	ldrh	r3, [r3, #0]
 8011250:	0018      	movs	r0, r3
 8011252:	f7f5 f96f 	bl	8006534 <lwip_htons>
 8011256:	0003      	movs	r3, r0
 8011258:	001a      	movs	r2, r3
 801125a:	693b      	ldr	r3, [r7, #16]
 801125c:	21ff      	movs	r1, #255	; 0xff
 801125e:	4011      	ands	r1, r2
 8011260:	000c      	movs	r4, r1
 8011262:	7899      	ldrb	r1, [r3, #2]
 8011264:	2000      	movs	r0, #0
 8011266:	4001      	ands	r1, r0
 8011268:	1c08      	adds	r0, r1, #0
 801126a:	1c21      	adds	r1, r4, #0
 801126c:	4301      	orrs	r1, r0
 801126e:	7099      	strb	r1, [r3, #2]
 8011270:	0a12      	lsrs	r2, r2, #8
 8011272:	b290      	uxth	r0, r2
 8011274:	78da      	ldrb	r2, [r3, #3]
 8011276:	2100      	movs	r1, #0
 8011278:	400a      	ands	r2, r1
 801127a:	1c11      	adds	r1, r2, #0
 801127c:	1c02      	adds	r2, r0, #0
 801127e:	430a      	orrs	r2, r1
 8011280:	70da      	strb	r2, [r3, #3]
    tcphdr->seqno = seqno_be;
 8011282:	693b      	ldr	r3, [r7, #16]
 8011284:	1d3a      	adds	r2, r7, #4
 8011286:	7810      	ldrb	r0, [r2, #0]
 8011288:	791a      	ldrb	r2, [r3, #4]
 801128a:	2100      	movs	r1, #0
 801128c:	400a      	ands	r2, r1
 801128e:	1c11      	adds	r1, r2, #0
 8011290:	1c02      	adds	r2, r0, #0
 8011292:	430a      	orrs	r2, r1
 8011294:	711a      	strb	r2, [r3, #4]
 8011296:	1d7a      	adds	r2, r7, #5
 8011298:	7810      	ldrb	r0, [r2, #0]
 801129a:	795a      	ldrb	r2, [r3, #5]
 801129c:	2100      	movs	r1, #0
 801129e:	400a      	ands	r2, r1
 80112a0:	1c11      	adds	r1, r2, #0
 80112a2:	1c02      	adds	r2, r0, #0
 80112a4:	430a      	orrs	r2, r1
 80112a6:	715a      	strb	r2, [r3, #5]
 80112a8:	1dba      	adds	r2, r7, #6
 80112aa:	7810      	ldrb	r0, [r2, #0]
 80112ac:	799a      	ldrb	r2, [r3, #6]
 80112ae:	2100      	movs	r1, #0
 80112b0:	400a      	ands	r2, r1
 80112b2:	1c11      	adds	r1, r2, #0
 80112b4:	1c02      	adds	r2, r0, #0
 80112b6:	430a      	orrs	r2, r1
 80112b8:	719a      	strb	r2, [r3, #6]
 80112ba:	1dfa      	adds	r2, r7, #7
 80112bc:	7810      	ldrb	r0, [r2, #0]
 80112be:	79da      	ldrb	r2, [r3, #7]
 80112c0:	2100      	movs	r1, #0
 80112c2:	400a      	ands	r2, r1
 80112c4:	1c11      	adds	r1, r2, #0
 80112c6:	1c02      	adds	r2, r0, #0
 80112c8:	430a      	orrs	r2, r1
 80112ca:	71da      	strb	r2, [r3, #7]
    tcphdr->ackno = lwip_htonl(ackno);
 80112cc:	68fb      	ldr	r3, [r7, #12]
 80112ce:	0018      	movs	r0, r3
 80112d0:	f7f5 f946 	bl	8006560 <lwip_htonl>
 80112d4:	0002      	movs	r2, r0
 80112d6:	693b      	ldr	r3, [r7, #16]
 80112d8:	21ff      	movs	r1, #255	; 0xff
 80112da:	4011      	ands	r1, r2
 80112dc:	000c      	movs	r4, r1
 80112de:	7a19      	ldrb	r1, [r3, #8]
 80112e0:	2000      	movs	r0, #0
 80112e2:	4001      	ands	r1, r0
 80112e4:	1c08      	adds	r0, r1, #0
 80112e6:	1c21      	adds	r1, r4, #0
 80112e8:	4301      	orrs	r1, r0
 80112ea:	7219      	strb	r1, [r3, #8]
 80112ec:	0a11      	lsrs	r1, r2, #8
 80112ee:	20ff      	movs	r0, #255	; 0xff
 80112f0:	4001      	ands	r1, r0
 80112f2:	000c      	movs	r4, r1
 80112f4:	7a59      	ldrb	r1, [r3, #9]
 80112f6:	2000      	movs	r0, #0
 80112f8:	4001      	ands	r1, r0
 80112fa:	1c08      	adds	r0, r1, #0
 80112fc:	1c21      	adds	r1, r4, #0
 80112fe:	4301      	orrs	r1, r0
 8011300:	7259      	strb	r1, [r3, #9]
 8011302:	0c11      	lsrs	r1, r2, #16
 8011304:	20ff      	movs	r0, #255	; 0xff
 8011306:	4001      	ands	r1, r0
 8011308:	000c      	movs	r4, r1
 801130a:	7a99      	ldrb	r1, [r3, #10]
 801130c:	2000      	movs	r0, #0
 801130e:	4001      	ands	r1, r0
 8011310:	1c08      	adds	r0, r1, #0
 8011312:	1c21      	adds	r1, r4, #0
 8011314:	4301      	orrs	r1, r0
 8011316:	7299      	strb	r1, [r3, #10]
 8011318:	0e10      	lsrs	r0, r2, #24
 801131a:	7ada      	ldrb	r2, [r3, #11]
 801131c:	2100      	movs	r1, #0
 801131e:	400a      	ands	r2, r1
 8011320:	1c11      	adds	r1, r2, #0
 8011322:	1c02      	adds	r2, r0, #0
 8011324:	430a      	orrs	r2, r1
 8011326:	72da      	strb	r2, [r3, #11]
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), flags);
 8011328:	230a      	movs	r3, #10
 801132a:	18fb      	adds	r3, r7, r3
 801132c:	881b      	ldrh	r3, [r3, #0]
 801132e:	089b      	lsrs	r3, r3, #2
 8011330:	b29b      	uxth	r3, r3
 8011332:	3305      	adds	r3, #5
 8011334:	b29b      	uxth	r3, r3
 8011336:	031b      	lsls	r3, r3, #12
 8011338:	b29a      	uxth	r2, r3
 801133a:	2330      	movs	r3, #48	; 0x30
 801133c:	18fb      	adds	r3, r7, r3
 801133e:	781b      	ldrb	r3, [r3, #0]
 8011340:	b29b      	uxth	r3, r3
 8011342:	4313      	orrs	r3, r2
 8011344:	b29b      	uxth	r3, r3
 8011346:	0018      	movs	r0, r3
 8011348:	f7f5 f8f4 	bl	8006534 <lwip_htons>
 801134c:	0003      	movs	r3, r0
 801134e:	001a      	movs	r2, r3
 8011350:	693b      	ldr	r3, [r7, #16]
 8011352:	21ff      	movs	r1, #255	; 0xff
 8011354:	4011      	ands	r1, r2
 8011356:	000c      	movs	r4, r1
 8011358:	7b19      	ldrb	r1, [r3, #12]
 801135a:	2000      	movs	r0, #0
 801135c:	4001      	ands	r1, r0
 801135e:	1c08      	adds	r0, r1, #0
 8011360:	1c21      	adds	r1, r4, #0
 8011362:	4301      	orrs	r1, r0
 8011364:	7319      	strb	r1, [r3, #12]
 8011366:	0a12      	lsrs	r2, r2, #8
 8011368:	b290      	uxth	r0, r2
 801136a:	7b5a      	ldrb	r2, [r3, #13]
 801136c:	2100      	movs	r1, #0
 801136e:	400a      	ands	r2, r1
 8011370:	1c11      	adds	r1, r2, #0
 8011372:	1c02      	adds	r2, r0, #0
 8011374:	430a      	orrs	r2, r1
 8011376:	735a      	strb	r2, [r3, #13]
    tcphdr->wnd = lwip_htons(wnd);
 8011378:	2334      	movs	r3, #52	; 0x34
 801137a:	18fb      	adds	r3, r7, r3
 801137c:	881b      	ldrh	r3, [r3, #0]
 801137e:	0018      	movs	r0, r3
 8011380:	f7f5 f8d8 	bl	8006534 <lwip_htons>
 8011384:	0003      	movs	r3, r0
 8011386:	001a      	movs	r2, r3
 8011388:	693b      	ldr	r3, [r7, #16]
 801138a:	21ff      	movs	r1, #255	; 0xff
 801138c:	4011      	ands	r1, r2
 801138e:	000c      	movs	r4, r1
 8011390:	7b99      	ldrb	r1, [r3, #14]
 8011392:	2000      	movs	r0, #0
 8011394:	4001      	ands	r1, r0
 8011396:	1c08      	adds	r0, r1, #0
 8011398:	1c21      	adds	r1, r4, #0
 801139a:	4301      	orrs	r1, r0
 801139c:	7399      	strb	r1, [r3, #14]
 801139e:	0a12      	lsrs	r2, r2, #8
 80113a0:	b290      	uxth	r0, r2
 80113a2:	7bda      	ldrb	r2, [r3, #15]
 80113a4:	2100      	movs	r1, #0
 80113a6:	400a      	ands	r2, r1
 80113a8:	1c11      	adds	r1, r2, #0
 80113aa:	1c02      	adds	r2, r0, #0
 80113ac:	430a      	orrs	r2, r1
 80113ae:	73da      	strb	r2, [r3, #15]
    tcphdr->chksum = 0;
 80113b0:	693b      	ldr	r3, [r7, #16]
 80113b2:	7c1a      	ldrb	r2, [r3, #16]
 80113b4:	2100      	movs	r1, #0
 80113b6:	400a      	ands	r2, r1
 80113b8:	741a      	strb	r2, [r3, #16]
 80113ba:	7c5a      	ldrb	r2, [r3, #17]
 80113bc:	2100      	movs	r1, #0
 80113be:	400a      	ands	r2, r1
 80113c0:	745a      	strb	r2, [r3, #17]
    tcphdr->urgp = 0;
 80113c2:	693b      	ldr	r3, [r7, #16]
 80113c4:	7c9a      	ldrb	r2, [r3, #18]
 80113c6:	2100      	movs	r1, #0
 80113c8:	400a      	ands	r2, r1
 80113ca:	749a      	strb	r2, [r3, #18]
 80113cc:	7cda      	ldrb	r2, [r3, #19]
 80113ce:	2100      	movs	r1, #0
 80113d0:	400a      	ands	r2, r1
 80113d2:	74da      	strb	r2, [r3, #19]
  }
  return p;
 80113d4:	697b      	ldr	r3, [r7, #20]
}
 80113d6:	0018      	movs	r0, r3
 80113d8:	46bd      	mov	sp, r7
 80113da:	b007      	add	sp, #28
 80113dc:	bd90      	pop	{r4, r7, pc}
 80113de:	46c0      	nop			; (mov r8, r8)
 80113e0:	0801fe14 	.word	0x0801fe14
 80113e4:	00000724 	.word	0x00000724
 80113e8:	080205ec 	.word	0x080205ec
 80113ec:	0801fe60 	.word	0x0801fe60

080113f0 <tcp_output_alloc_header>:
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                        u32_t seqno_be /* already in network byte order */)
{
 80113f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80113f2:	b08b      	sub	sp, #44	; 0x2c
 80113f4:	af04      	add	r7, sp, #16
 80113f6:	60f8      	str	r0, [r7, #12]
 80113f8:	0008      	movs	r0, r1
 80113fa:	0011      	movs	r1, r2
 80113fc:	607b      	str	r3, [r7, #4]
 80113fe:	230a      	movs	r3, #10
 8011400:	18fb      	adds	r3, r7, r3
 8011402:	1c02      	adds	r2, r0, #0
 8011404:	801a      	strh	r2, [r3, #0]
 8011406:	2308      	movs	r3, #8
 8011408:	18fb      	adds	r3, r7, r3
 801140a:	1c0a      	adds	r2, r1, #0
 801140c:	801a      	strh	r2, [r3, #0]
  struct pbuf *p;

  LWIP_ASSERT("tcp_output_alloc_header: invalid pcb", pcb != NULL);
 801140e:	68fb      	ldr	r3, [r7, #12]
 8011410:	2b00      	cmp	r3, #0
 8011412:	d105      	bne.n	8011420 <tcp_output_alloc_header+0x30>
 8011414:	4b18      	ldr	r3, [pc, #96]	; (8011478 <tcp_output_alloc_header+0x88>)
 8011416:	4a19      	ldr	r2, [pc, #100]	; (801147c <tcp_output_alloc_header+0x8c>)
 8011418:	4919      	ldr	r1, [pc, #100]	; (8011480 <tcp_output_alloc_header+0x90>)
 801141a:	481a      	ldr	r0, [pc, #104]	; (8011484 <tcp_output_alloc_header+0x94>)
 801141c:	f7f0 fed6 	bl	80021cc <app_debug_rtt_raw>

  p = tcp_output_alloc_header_common(pcb->rcv_nxt, optlen, datalen,
 8011420:	68fb      	ldr	r3, [r7, #12]
 8011422:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 8011424:	68fb      	ldr	r3, [r7, #12]
 8011426:	8b5b      	ldrh	r3, [r3, #26]
 8011428:	68fa      	ldr	r2, [r7, #12]
 801142a:	8b92      	ldrh	r2, [r2, #28]
 801142c:	68f9      	ldr	r1, [r7, #12]
 801142e:	8dc9      	ldrh	r1, [r1, #46]	; 0x2e
 8011430:	687e      	ldr	r6, [r7, #4]
 8011432:	2008      	movs	r0, #8
 8011434:	1838      	adds	r0, r7, r0
 8011436:	8805      	ldrh	r5, [r0, #0]
 8011438:	200a      	movs	r0, #10
 801143a:	1838      	adds	r0, r7, r0
 801143c:	8800      	ldrh	r0, [r0, #0]
 801143e:	9103      	str	r1, [sp, #12]
 8011440:	2110      	movs	r1, #16
 8011442:	9102      	str	r1, [sp, #8]
 8011444:	9201      	str	r2, [sp, #4]
 8011446:	9300      	str	r3, [sp, #0]
 8011448:	0033      	movs	r3, r6
 801144a:	002a      	movs	r2, r5
 801144c:	0001      	movs	r1, r0
 801144e:	0020      	movs	r0, r4
 8011450:	f7ff feac 	bl	80111ac <tcp_output_alloc_header_common>
 8011454:	0003      	movs	r3, r0
 8011456:	617b      	str	r3, [r7, #20]
    seqno_be, pcb->local_port, pcb->remote_port, TCP_ACK,
    TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
  if (p != NULL) {
 8011458:	697b      	ldr	r3, [r7, #20]
 801145a:	2b00      	cmp	r3, #0
 801145c:	d006      	beq.n	801146c <tcp_output_alloc_header+0x7c>
    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 801145e:	68fb      	ldr	r3, [r7, #12]
 8011460:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8011462:	68fa      	ldr	r2, [r7, #12]
 8011464:	8dd2      	ldrh	r2, [r2, #46]	; 0x2e
 8011466:	189a      	adds	r2, r3, r2
 8011468:	68fb      	ldr	r3, [r7, #12]
 801146a:	631a      	str	r2, [r3, #48]	; 0x30
  }
  return p;
 801146c:	697b      	ldr	r3, [r7, #20]
}
 801146e:	0018      	movs	r0, r3
 8011470:	46bd      	mov	sp, r7
 8011472:	b007      	add	sp, #28
 8011474:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8011476:	46c0      	nop			; (mov r8, r8)
 8011478:	0801fe14 	.word	0x0801fe14
 801147c:	00000743 	.word	0x00000743
 8011480:	0802061c 	.word	0x0802061c
 8011484:	0801fe60 	.word	0x0801fe60

08011488 <tcp_output_fill_options>:

/* Fill in options for control segments */
static void
tcp_output_fill_options(const struct tcp_pcb *pcb, struct pbuf *p, u8_t optflags, u8_t num_sacks)
{
 8011488:	b580      	push	{r7, lr}
 801148a:	b088      	sub	sp, #32
 801148c:	af00      	add	r7, sp, #0
 801148e:	60f8      	str	r0, [r7, #12]
 8011490:	60b9      	str	r1, [r7, #8]
 8011492:	0019      	movs	r1, r3
 8011494:	1dfb      	adds	r3, r7, #7
 8011496:	701a      	strb	r2, [r3, #0]
 8011498:	1dbb      	adds	r3, r7, #6
 801149a:	1c0a      	adds	r2, r1, #0
 801149c:	701a      	strb	r2, [r3, #0]
  struct tcp_hdr *tcphdr;
  u32_t *opts;
  u16_t sacks_len = 0;
 801149e:	231e      	movs	r3, #30
 80114a0:	18fb      	adds	r3, r7, r3
 80114a2:	2200      	movs	r2, #0
 80114a4:	801a      	strh	r2, [r3, #0]

  LWIP_ASSERT("tcp_output_fill_options: invalid pbuf", p != NULL);
 80114a6:	68bb      	ldr	r3, [r7, #8]
 80114a8:	2b00      	cmp	r3, #0
 80114aa:	d105      	bne.n	80114b8 <tcp_output_fill_options+0x30>
 80114ac:	4b13      	ldr	r3, [pc, #76]	; (80114fc <tcp_output_fill_options+0x74>)
 80114ae:	4a14      	ldr	r2, [pc, #80]	; (8011500 <tcp_output_fill_options+0x78>)
 80114b0:	4914      	ldr	r1, [pc, #80]	; (8011504 <tcp_output_fill_options+0x7c>)
 80114b2:	4815      	ldr	r0, [pc, #84]	; (8011508 <tcp_output_fill_options+0x80>)
 80114b4:	f7f0 fe8a 	bl	80021cc <app_debug_rtt_raw>

  tcphdr = (struct tcp_hdr *)p->payload;
 80114b8:	68bb      	ldr	r3, [r7, #8]
 80114ba:	685b      	ldr	r3, [r3, #4]
 80114bc:	61bb      	str	r3, [r7, #24]
  opts = (u32_t *)(void *)(tcphdr + 1);
 80114be:	69bb      	ldr	r3, [r7, #24]
 80114c0:	3314      	adds	r3, #20
 80114c2:	617b      	str	r3, [r7, #20]
  opts = LWIP_HOOK_TCP_OUT_ADD_TCPOPTS(p, tcphdr, pcb, opts);
#endif

  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(sacks_len);
  LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(tcphdr + 1)) + sacks_len * 4 + LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb));
 80114c4:	69bb      	ldr	r3, [r7, #24]
 80114c6:	3314      	adds	r3, #20
 80114c8:	001a      	movs	r2, r3
 80114ca:	231e      	movs	r3, #30
 80114cc:	18fb      	adds	r3, r7, r3
 80114ce:	881b      	ldrh	r3, [r3, #0]
 80114d0:	009b      	lsls	r3, r3, #2
 80114d2:	0018      	movs	r0, r3
 80114d4:	1dfb      	adds	r3, r7, #7
 80114d6:	781b      	ldrb	r3, [r3, #0]
 80114d8:	009b      	lsls	r3, r3, #2
 80114da:	2104      	movs	r1, #4
 80114dc:	400b      	ands	r3, r1
 80114de:	18c3      	adds	r3, r0, r3
 80114e0:	18d3      	adds	r3, r2, r3
 80114e2:	697a      	ldr	r2, [r7, #20]
 80114e4:	429a      	cmp	r2, r3
 80114e6:	d005      	beq.n	80114f4 <tcp_output_fill_options+0x6c>
 80114e8:	4b04      	ldr	r3, [pc, #16]	; (80114fc <tcp_output_fill_options+0x74>)
 80114ea:	4a08      	ldr	r2, [pc, #32]	; (801150c <tcp_output_fill_options+0x84>)
 80114ec:	4908      	ldr	r1, [pc, #32]	; (8011510 <tcp_output_fill_options+0x88>)
 80114ee:	4806      	ldr	r0, [pc, #24]	; (8011508 <tcp_output_fill_options+0x80>)
 80114f0:	f7f0 fe6c 	bl	80021cc <app_debug_rtt_raw>
  LWIP_UNUSED_ARG(optflags); /* for LWIP_NOASSERT */
  LWIP_UNUSED_ARG(opts); /* for LWIP_NOASSERT */
}
 80114f4:	46c0      	nop			; (mov r8, r8)
 80114f6:	46bd      	mov	sp, r7
 80114f8:	b008      	add	sp, #32
 80114fa:	bd80      	pop	{r7, pc}
 80114fc:	0801fe14 	.word	0x0801fe14
 8011500:	00000757 	.word	0x00000757
 8011504:	08020644 	.word	0x08020644
 8011508:	0801fe60 	.word	0x0801fe60
 801150c:	00000776 	.word	0x00000776
 8011510:	08020518 	.word	0x08020518

08011514 <tcp_output_control_segment>:
 * header checksum and calling ip_output_if while handling netif hints and stats.
 */
static err_t
tcp_output_control_segment(const struct tcp_pcb *pcb, struct pbuf *p,
                           const ip_addr_t *src, const ip_addr_t *dst)
{
 8011514:	b5b0      	push	{r4, r5, r7, lr}
 8011516:	b08c      	sub	sp, #48	; 0x30
 8011518:	af04      	add	r7, sp, #16
 801151a:	60f8      	str	r0, [r7, #12]
 801151c:	60b9      	str	r1, [r7, #8]
 801151e:	607a      	str	r2, [r7, #4]
 8011520:	603b      	str	r3, [r7, #0]
  err_t err;
  struct netif *netif;

  LWIP_ASSERT("tcp_output_control_segment: invalid pbuf", p != NULL);
 8011522:	68bb      	ldr	r3, [r7, #8]
 8011524:	2b00      	cmp	r3, #0
 8011526:	d106      	bne.n	8011536 <tcp_output_control_segment+0x22>
 8011528:	4b3c      	ldr	r3, [pc, #240]	; (801161c <tcp_output_control_segment+0x108>)
 801152a:	22f1      	movs	r2, #241	; 0xf1
 801152c:	00d2      	lsls	r2, r2, #3
 801152e:	493c      	ldr	r1, [pc, #240]	; (8011620 <tcp_output_control_segment+0x10c>)
 8011530:	483c      	ldr	r0, [pc, #240]	; (8011624 <tcp_output_control_segment+0x110>)
 8011532:	f7f0 fe4b 	bl	80021cc <app_debug_rtt_raw>

  netif = tcp_route(pcb, src, dst);
 8011536:	683a      	ldr	r2, [r7, #0]
 8011538:	6879      	ldr	r1, [r7, #4]
 801153a:	68fb      	ldr	r3, [r7, #12]
 801153c:	0018      	movs	r0, r3
 801153e:	f7fd fc7d 	bl	800ee3c <tcp_route>
 8011542:	0003      	movs	r3, r0
 8011544:	61bb      	str	r3, [r7, #24]
  if (netif == NULL) {
 8011546:	69bb      	ldr	r3, [r7, #24]
 8011548:	2b00      	cmp	r3, #0
 801154a:	d104      	bne.n	8011556 <tcp_output_control_segment+0x42>
    err = ERR_RTE;
 801154c:	231f      	movs	r3, #31
 801154e:	18fb      	adds	r3, r7, r3
 8011550:	22fc      	movs	r2, #252	; 0xfc
 8011552:	701a      	strb	r2, [r3, #0]
 8011554:	e055      	b.n	8011602 <tcp_output_control_segment+0xee>
  } else {
    u8_t ttl, tos;
#if CHECKSUM_GEN_TCP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
      struct tcp_hdr *tcphdr = (struct tcp_hdr *)p->payload;
 8011556:	68bb      	ldr	r3, [r7, #8]
 8011558:	685b      	ldr	r3, [r3, #4]
 801155a:	617b      	str	r3, [r7, #20]
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
 801155c:	68bb      	ldr	r3, [r7, #8]
 801155e:	891a      	ldrh	r2, [r3, #8]
 8011560:	6879      	ldr	r1, [r7, #4]
 8011562:	68b8      	ldr	r0, [r7, #8]
 8011564:	683b      	ldr	r3, [r7, #0]
 8011566:	9300      	str	r3, [sp, #0]
 8011568:	000b      	movs	r3, r1
 801156a:	2106      	movs	r1, #6
 801156c:	f7f6 fa8b 	bl	8007a86 <ip_chksum_pseudo>
 8011570:	0003      	movs	r3, r0
 8011572:	001a      	movs	r2, r3
 8011574:	697b      	ldr	r3, [r7, #20]
 8011576:	21ff      	movs	r1, #255	; 0xff
 8011578:	4011      	ands	r1, r2
 801157a:	000c      	movs	r4, r1
 801157c:	7c19      	ldrb	r1, [r3, #16]
 801157e:	2000      	movs	r0, #0
 8011580:	4001      	ands	r1, r0
 8011582:	1c08      	adds	r0, r1, #0
 8011584:	1c21      	adds	r1, r4, #0
 8011586:	4301      	orrs	r1, r0
 8011588:	7419      	strb	r1, [r3, #16]
 801158a:	0a12      	lsrs	r2, r2, #8
 801158c:	b290      	uxth	r0, r2
 801158e:	7c5a      	ldrb	r2, [r3, #17]
 8011590:	2100      	movs	r1, #0
 8011592:	400a      	ands	r2, r1
 8011594:	1c11      	adds	r1, r2, #0
 8011596:	1c02      	adds	r2, r0, #0
 8011598:	430a      	orrs	r2, r1
 801159a:	745a      	strb	r2, [r3, #17]
                                        src, dst);
    }
#endif
    if (pcb != NULL) {
 801159c:	68fb      	ldr	r3, [r7, #12]
 801159e:	2b00      	cmp	r3, #0
 80115a0:	d00f      	beq.n	80115c2 <tcp_output_control_segment+0xae>
      NETIF_SET_HINTS(netif, LWIP_CONST_CAST(struct netif_hint*, &(pcb->netif_hints)));
 80115a2:	68fb      	ldr	r3, [r7, #12]
 80115a4:	330c      	adds	r3, #12
 80115a6:	001a      	movs	r2, r3
 80115a8:	69bb      	ldr	r3, [r7, #24]
 80115aa:	639a      	str	r2, [r3, #56]	; 0x38
      ttl = pcb->ttl;
 80115ac:	231e      	movs	r3, #30
 80115ae:	18fb      	adds	r3, r7, r3
 80115b0:	68fa      	ldr	r2, [r7, #12]
 80115b2:	7ad2      	ldrb	r2, [r2, #11]
 80115b4:	701a      	strb	r2, [r3, #0]
      tos = pcb->tos;
 80115b6:	231d      	movs	r3, #29
 80115b8:	18fb      	adds	r3, r7, r3
 80115ba:	68fa      	ldr	r2, [r7, #12]
 80115bc:	7a92      	ldrb	r2, [r2, #10]
 80115be:	701a      	strb	r2, [r3, #0]
 80115c0:	e007      	b.n	80115d2 <tcp_output_control_segment+0xbe>
    } else {
      /* Send output with hardcoded TTL/HL since we have no access to the pcb */
      ttl = TCP_TTL;
 80115c2:	231e      	movs	r3, #30
 80115c4:	18fb      	adds	r3, r7, r3
 80115c6:	22ff      	movs	r2, #255	; 0xff
 80115c8:	701a      	strb	r2, [r3, #0]
      tos = 0;
 80115ca:	231d      	movs	r3, #29
 80115cc:	18fb      	adds	r3, r7, r3
 80115ce:	2200      	movs	r2, #0
 80115d0:	701a      	strb	r2, [r3, #0]
    }
    TCP_STATS_INC(tcp.xmit);
    err = ip_output_if(p, src, dst, ttl, tos, IP_PROTO_TCP, netif);
 80115d2:	231f      	movs	r3, #31
 80115d4:	18fc      	adds	r4, r7, r3
 80115d6:	231e      	movs	r3, #30
 80115d8:	18fb      	adds	r3, r7, r3
 80115da:	781d      	ldrb	r5, [r3, #0]
 80115dc:	683a      	ldr	r2, [r7, #0]
 80115de:	6879      	ldr	r1, [r7, #4]
 80115e0:	68b8      	ldr	r0, [r7, #8]
 80115e2:	69bb      	ldr	r3, [r7, #24]
 80115e4:	9302      	str	r3, [sp, #8]
 80115e6:	2306      	movs	r3, #6
 80115e8:	9301      	str	r3, [sp, #4]
 80115ea:	231d      	movs	r3, #29
 80115ec:	18fb      	adds	r3, r7, r3
 80115ee:	781b      	ldrb	r3, [r3, #0]
 80115f0:	9300      	str	r3, [sp, #0]
 80115f2:	002b      	movs	r3, r5
 80115f4:	f001 fe5c 	bl	80132b0 <ip4_output_if>
 80115f8:	0003      	movs	r3, r0
 80115fa:	7023      	strb	r3, [r4, #0]
    NETIF_RESET_HINTS(netif);
 80115fc:	69bb      	ldr	r3, [r7, #24]
 80115fe:	2200      	movs	r2, #0
 8011600:	639a      	str	r2, [r3, #56]	; 0x38
  }
  pbuf_free(p);
 8011602:	68bb      	ldr	r3, [r7, #8]
 8011604:	0018      	movs	r0, r3
 8011606:	f7f8 f845 	bl	8009694 <pbuf_free>
  return err;
 801160a:	231f      	movs	r3, #31
 801160c:	18fb      	adds	r3, r7, r3
 801160e:	781b      	ldrb	r3, [r3, #0]
 8011610:	b25b      	sxtb	r3, r3
}
 8011612:	0018      	movs	r0, r3
 8011614:	46bd      	mov	sp, r7
 8011616:	b008      	add	sp, #32
 8011618:	bdb0      	pop	{r4, r5, r7, pc}
 801161a:	46c0      	nop			; (mov r8, r8)
 801161c:	0801fe14 	.word	0x0801fe14
 8011620:	0802066c 	.word	0x0802066c
 8011624:	0801fe60 	.word	0x0801fe60

08011628 <tcp_rst>:
 */
void
tcp_rst(const struct tcp_pcb *pcb, u32_t seqno, u32_t ackno,
        const ip_addr_t *local_ip, const ip_addr_t *remote_ip,
        u16_t local_port, u16_t remote_port)
{
 8011628:	b5b0      	push	{r4, r5, r7, lr}
 801162a:	b08a      	sub	sp, #40	; 0x28
 801162c:	af04      	add	r7, sp, #16
 801162e:	60f8      	str	r0, [r7, #12]
 8011630:	60b9      	str	r1, [r7, #8]
 8011632:	607a      	str	r2, [r7, #4]
 8011634:	603b      	str	r3, [r7, #0]
  struct pbuf *p;
  u16_t wnd;
  u8_t optlen;

  LWIP_ASSERT("tcp_rst: invalid local_ip", local_ip != NULL);
 8011636:	683b      	ldr	r3, [r7, #0]
 8011638:	2b00      	cmp	r3, #0
 801163a:	d105      	bne.n	8011648 <tcp_rst+0x20>
 801163c:	4b23      	ldr	r3, [pc, #140]	; (80116cc <tcp_rst+0xa4>)
 801163e:	4a24      	ldr	r2, [pc, #144]	; (80116d0 <tcp_rst+0xa8>)
 8011640:	4924      	ldr	r1, [pc, #144]	; (80116d4 <tcp_rst+0xac>)
 8011642:	4825      	ldr	r0, [pc, #148]	; (80116d8 <tcp_rst+0xb0>)
 8011644:	f7f0 fdc2 	bl	80021cc <app_debug_rtt_raw>
  LWIP_ASSERT("tcp_rst: invalid remote_ip", remote_ip != NULL);
 8011648:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801164a:	2b00      	cmp	r3, #0
 801164c:	d105      	bne.n	801165a <tcp_rst+0x32>
 801164e:	4b1f      	ldr	r3, [pc, #124]	; (80116cc <tcp_rst+0xa4>)
 8011650:	4a22      	ldr	r2, [pc, #136]	; (80116dc <tcp_rst+0xb4>)
 8011652:	4923      	ldr	r1, [pc, #140]	; (80116e0 <tcp_rst+0xb8>)
 8011654:	4820      	ldr	r0, [pc, #128]	; (80116d8 <tcp_rst+0xb0>)
 8011656:	f7f0 fdb9 	bl	80021cc <app_debug_rtt_raw>

  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 801165a:	2117      	movs	r1, #23
 801165c:	187b      	adds	r3, r7, r1
 801165e:	2200      	movs	r2, #0
 8011660:	701a      	strb	r2, [r3, #0]

#if LWIP_WND_SCALE
  wnd = PP_HTONS(((TCP_WND >> TCP_RCV_SCALE) & 0xFFFF));
#else
  wnd = PP_HTONS(TCP_WND);
 8011662:	2514      	movs	r5, #20
 8011664:	197b      	adds	r3, r7, r5
 8011666:	4a1f      	ldr	r2, [pc, #124]	; (80116e4 <tcp_rst+0xbc>)
 8011668:	801a      	strh	r2, [r3, #0]
#endif

  p = tcp_output_alloc_header_common(ackno, optlen, 0, lwip_htonl(seqno), local_port,
 801166a:	187b      	adds	r3, r7, r1
 801166c:	781b      	ldrb	r3, [r3, #0]
 801166e:	b29c      	uxth	r4, r3
 8011670:	68bb      	ldr	r3, [r7, #8]
 8011672:	0018      	movs	r0, r3
 8011674:	f7f4 ff74 	bl	8006560 <lwip_htonl>
 8011678:	0002      	movs	r2, r0
 801167a:	6878      	ldr	r0, [r7, #4]
 801167c:	197b      	adds	r3, r7, r5
 801167e:	881b      	ldrh	r3, [r3, #0]
 8011680:	9303      	str	r3, [sp, #12]
 8011682:	2314      	movs	r3, #20
 8011684:	9302      	str	r3, [sp, #8]
 8011686:	2330      	movs	r3, #48	; 0x30
 8011688:	18fb      	adds	r3, r7, r3
 801168a:	881b      	ldrh	r3, [r3, #0]
 801168c:	9301      	str	r3, [sp, #4]
 801168e:	232c      	movs	r3, #44	; 0x2c
 8011690:	18fb      	adds	r3, r7, r3
 8011692:	881b      	ldrh	r3, [r3, #0]
 8011694:	9300      	str	r3, [sp, #0]
 8011696:	0013      	movs	r3, r2
 8011698:	2200      	movs	r2, #0
 801169a:	0021      	movs	r1, r4
 801169c:	f7ff fd86 	bl	80111ac <tcp_output_alloc_header_common>
 80116a0:	0003      	movs	r3, r0
 80116a2:	613b      	str	r3, [r7, #16]
    remote_port, TCP_RST | TCP_ACK, wnd);
  if (p == NULL) {
 80116a4:	693b      	ldr	r3, [r7, #16]
 80116a6:	2b00      	cmp	r3, #0
 80116a8:	d00c      	beq.n	80116c4 <tcp_rst+0x9c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
    return;
  }
  tcp_output_fill_options(pcb, p, 0, 0);
 80116aa:	6939      	ldr	r1, [r7, #16]
 80116ac:	68f8      	ldr	r0, [r7, #12]
 80116ae:	2300      	movs	r3, #0
 80116b0:	2200      	movs	r2, #0
 80116b2:	f7ff fee9 	bl	8011488 <tcp_output_fill_options>

  MIB2_STATS_INC(mib2.tcpoutrsts);

  tcp_output_control_segment(pcb, p, local_ip, remote_ip);
 80116b6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80116b8:	683a      	ldr	r2, [r7, #0]
 80116ba:	6939      	ldr	r1, [r7, #16]
 80116bc:	68f8      	ldr	r0, [r7, #12]
 80116be:	f7ff ff29 	bl	8011514 <tcp_output_control_segment>
 80116c2:	e000      	b.n	80116c6 <tcp_rst+0x9e>
    return;
 80116c4:	46c0      	nop			; (mov r8, r8)
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 80116c6:	46bd      	mov	sp, r7
 80116c8:	b006      	add	sp, #24
 80116ca:	bdb0      	pop	{r4, r5, r7, pc}
 80116cc:	0801fe14 	.word	0x0801fe14
 80116d0:	000007c5 	.word	0x000007c5
 80116d4:	08020698 	.word	0x08020698
 80116d8:	0801fe60 	.word	0x0801fe60
 80116dc:	000007c6 	.word	0x000007c6
 80116e0:	080206b4 	.word	0x080206b4
 80116e4:	00003004 	.word	0x00003004

080116e8 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
 80116e8:	b5b0      	push	{r4, r5, r7, lr}
 80116ea:	b086      	sub	sp, #24
 80116ec:	af00      	add	r7, sp, #0
 80116ee:	6078      	str	r0, [r7, #4]
  err_t err;
  struct pbuf *p;
  u8_t optlen, optflags = 0;
 80116f0:	2317      	movs	r3, #23
 80116f2:	18fb      	adds	r3, r7, r3
 80116f4:	2200      	movs	r2, #0
 80116f6:	701a      	strb	r2, [r3, #0]
  u8_t num_sacks = 0;
 80116f8:	2316      	movs	r3, #22
 80116fa:	18fb      	adds	r3, r7, r3
 80116fc:	2200      	movs	r2, #0
 80116fe:	701a      	strb	r2, [r3, #0]

  LWIP_ASSERT("tcp_send_empty_ack: invalid pcb", pcb != NULL);
 8011700:	687b      	ldr	r3, [r7, #4]
 8011702:	2b00      	cmp	r3, #0
 8011704:	d105      	bne.n	8011712 <tcp_send_empty_ack+0x2a>
 8011706:	4b2f      	ldr	r3, [pc, #188]	; (80117c4 <tcp_send_empty_ack+0xdc>)
 8011708:	4a2f      	ldr	r2, [pc, #188]	; (80117c8 <tcp_send_empty_ack+0xe0>)
 801170a:	4930      	ldr	r1, [pc, #192]	; (80117cc <tcp_send_empty_ack+0xe4>)
 801170c:	4830      	ldr	r0, [pc, #192]	; (80117d0 <tcp_send_empty_ack+0xe8>)
 801170e:	f7f0 fd5d 	bl	80021cc <app_debug_rtt_raw>
#if LWIP_TCP_TIMESTAMPS
  if (pcb->flags & TF_TIMESTAMP) {
    optflags = TF_SEG_OPTS_TS;
  }
#endif
  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
 8011712:	2317      	movs	r3, #23
 8011714:	18fb      	adds	r3, r7, r3
 8011716:	781b      	ldrb	r3, [r3, #0]
 8011718:	009b      	lsls	r3, r3, #2
 801171a:	b2da      	uxtb	r2, r3
 801171c:	2015      	movs	r0, #21
 801171e:	183b      	adds	r3, r7, r0
 8011720:	2104      	movs	r1, #4
 8011722:	400a      	ands	r2, r1
 8011724:	701a      	strb	r2, [r3, #0]
  if ((num_sacks = tcp_get_num_sacks(pcb, optlen)) > 0) {
    optlen += 4 + num_sacks * 8; /* 4 bytes for header (including 2*NOP), plus 8B for each SACK */
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt));
 8011726:	183b      	adds	r3, r7, r0
 8011728:	781b      	ldrb	r3, [r3, #0]
 801172a:	b29c      	uxth	r4, r3
 801172c:	687b      	ldr	r3, [r7, #4]
 801172e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8011730:	0018      	movs	r0, r3
 8011732:	f7f4 ff15 	bl	8006560 <lwip_htonl>
 8011736:	0003      	movs	r3, r0
 8011738:	6878      	ldr	r0, [r7, #4]
 801173a:	2200      	movs	r2, #0
 801173c:	0021      	movs	r1, r4
 801173e:	f7ff fe57 	bl	80113f0 <tcp_output_alloc_header>
 8011742:	0003      	movs	r3, r0
 8011744:	613b      	str	r3, [r7, #16]
  if (p == NULL) {
 8011746:	693b      	ldr	r3, [r7, #16]
 8011748:	2b00      	cmp	r3, #0
 801174a:	d109      	bne.n	8011760 <tcp_send_empty_ack+0x78>
    /* let tcp_fasttmr retry sending this ACK */
    tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 801174c:	687b      	ldr	r3, [r7, #4]
 801174e:	8bdb      	ldrh	r3, [r3, #30]
 8011750:	2203      	movs	r2, #3
 8011752:	4313      	orrs	r3, r2
 8011754:	b29a      	uxth	r2, r3
 8011756:	687b      	ldr	r3, [r7, #4]
 8011758:	83da      	strh	r2, [r3, #30]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
 801175a:	2302      	movs	r3, #2
 801175c:	425b      	negs	r3, r3
 801175e:	e02d      	b.n	80117bc <tcp_send_empty_ack+0xd4>
  }
  tcp_output_fill_options(pcb, p, optflags, num_sacks);
 8011760:	2316      	movs	r3, #22
 8011762:	18fb      	adds	r3, r7, r3
 8011764:	781c      	ldrb	r4, [r3, #0]
 8011766:	2317      	movs	r3, #23
 8011768:	18fb      	adds	r3, r7, r3
 801176a:	781a      	ldrb	r2, [r3, #0]
 801176c:	6939      	ldr	r1, [r7, #16]
 801176e:	6878      	ldr	r0, [r7, #4]
 8011770:	0023      	movs	r3, r4
 8011772:	f7ff fe89 	bl	8011488 <tcp_output_fill_options>
  pcb->ts_lastacksent = pcb->rcv_nxt;
#endif

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG,
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 8011776:	687a      	ldr	r2, [r7, #4]
 8011778:	687b      	ldr	r3, [r7, #4]
 801177a:	3304      	adds	r3, #4
 801177c:	250f      	movs	r5, #15
 801177e:	197c      	adds	r4, r7, r5
 8011780:	6939      	ldr	r1, [r7, #16]
 8011782:	6878      	ldr	r0, [r7, #4]
 8011784:	f7ff fec6 	bl	8011514 <tcp_output_control_segment>
 8011788:	0003      	movs	r3, r0
 801178a:	7023      	strb	r3, [r4, #0]
  if (err != ERR_OK) {
 801178c:	197b      	adds	r3, r7, r5
 801178e:	781b      	ldrb	r3, [r3, #0]
 8011790:	b25b      	sxtb	r3, r3
 8011792:	2b00      	cmp	r3, #0
 8011794:	d007      	beq.n	80117a6 <tcp_send_empty_ack+0xbe>
    /* let tcp_fasttmr retry sending this ACK */
    tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 8011796:	687b      	ldr	r3, [r7, #4]
 8011798:	8bdb      	ldrh	r3, [r3, #30]
 801179a:	2203      	movs	r2, #3
 801179c:	4313      	orrs	r3, r2
 801179e:	b29a      	uxth	r2, r3
 80117a0:	687b      	ldr	r3, [r7, #4]
 80117a2:	83da      	strh	r2, [r3, #30]
 80117a4:	e006      	b.n	80117b4 <tcp_send_empty_ack+0xcc>
  } else {
    /* remove ACK flags from the PCB, as we sent an empty ACK now */
    tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
 80117a6:	687b      	ldr	r3, [r7, #4]
 80117a8:	8bdb      	ldrh	r3, [r3, #30]
 80117aa:	2203      	movs	r2, #3
 80117ac:	4393      	bics	r3, r2
 80117ae:	b29a      	uxth	r2, r3
 80117b0:	687b      	ldr	r3, [r7, #4]
 80117b2:	83da      	strh	r2, [r3, #30]
  }

  return err;
 80117b4:	230f      	movs	r3, #15
 80117b6:	18fb      	adds	r3, r7, r3
 80117b8:	781b      	ldrb	r3, [r3, #0]
 80117ba:	b25b      	sxtb	r3, r3
}
 80117bc:	0018      	movs	r0, r3
 80117be:	46bd      	mov	sp, r7
 80117c0:	b006      	add	sp, #24
 80117c2:	bdb0      	pop	{r4, r5, r7, pc}
 80117c4:	0801fe14 	.word	0x0801fe14
 80117c8:	000007eb 	.word	0x000007eb
 80117cc:	080206d0 	.word	0x080206d0
 80117d0:	0801fe60 	.word	0x0801fe60

080117d4 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
err_t
tcp_keepalive(struct tcp_pcb *pcb)
{
 80117d4:	b5b0      	push	{r4, r5, r7, lr}
 80117d6:	b084      	sub	sp, #16
 80117d8:	af00      	add	r7, sp, #0
 80117da:	6078      	str	r0, [r7, #4]
  err_t err;
  struct pbuf *p;
  u8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 80117dc:	230a      	movs	r3, #10
 80117de:	18fb      	adds	r3, r7, r3
 80117e0:	2200      	movs	r2, #0
 80117e2:	701a      	strb	r2, [r3, #0]

  LWIP_ASSERT("tcp_keepalive: invalid pcb", pcb != NULL);
 80117e4:	687b      	ldr	r3, [r7, #4]
 80117e6:	2b00      	cmp	r3, #0
 80117e8:	d105      	bne.n	80117f6 <tcp_keepalive+0x22>
 80117ea:	4b1b      	ldr	r3, [pc, #108]	; (8011858 <tcp_keepalive+0x84>)
 80117ec:	4a1b      	ldr	r2, [pc, #108]	; (801185c <tcp_keepalive+0x88>)
 80117ee:	491c      	ldr	r1, [pc, #112]	; (8011860 <tcp_keepalive+0x8c>)
 80117f0:	481c      	ldr	r0, [pc, #112]	; (8011864 <tcp_keepalive+0x90>)
 80117f2:	f7f0 fceb 	bl	80021cc <app_debug_rtt_raw>
  LWIP_DEBUGF(TCP_DEBUG, ("\n"));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
                          tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt - 1));
 80117f6:	230a      	movs	r3, #10
 80117f8:	18fb      	adds	r3, r7, r3
 80117fa:	781b      	ldrb	r3, [r3, #0]
 80117fc:	b29c      	uxth	r4, r3
 80117fe:	687b      	ldr	r3, [r7, #4]
 8011800:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8011802:	3b01      	subs	r3, #1
 8011804:	0018      	movs	r0, r3
 8011806:	f7f4 feab 	bl	8006560 <lwip_htonl>
 801180a:	0003      	movs	r3, r0
 801180c:	6878      	ldr	r0, [r7, #4]
 801180e:	2200      	movs	r2, #0
 8011810:	0021      	movs	r1, r4
 8011812:	f7ff fded 	bl	80113f0 <tcp_output_alloc_header>
 8011816:	0003      	movs	r3, r0
 8011818:	60fb      	str	r3, [r7, #12]
  if (p == NULL) {
 801181a:	68fb      	ldr	r3, [r7, #12]
 801181c:	2b00      	cmp	r3, #0
 801181e:	d102      	bne.n	8011826 <tcp_keepalive+0x52>
    LWIP_DEBUGF(TCP_DEBUG,
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return ERR_MEM;
 8011820:	2301      	movs	r3, #1
 8011822:	425b      	negs	r3, r3
 8011824:	e013      	b.n	801184e <tcp_keepalive+0x7a>
  }
  tcp_output_fill_options(pcb, p, 0, 0);
 8011826:	68f9      	ldr	r1, [r7, #12]
 8011828:	6878      	ldr	r0, [r7, #4]
 801182a:	2300      	movs	r3, #0
 801182c:	2200      	movs	r2, #0
 801182e:	f7ff fe2b 	bl	8011488 <tcp_output_fill_options>
  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 8011832:	687a      	ldr	r2, [r7, #4]
 8011834:	687b      	ldr	r3, [r7, #4]
 8011836:	3304      	adds	r3, #4
 8011838:	250b      	movs	r5, #11
 801183a:	197c      	adds	r4, r7, r5
 801183c:	68f9      	ldr	r1, [r7, #12]
 801183e:	6878      	ldr	r0, [r7, #4]
 8011840:	f7ff fe68 	bl	8011514 <tcp_output_control_segment>
 8011844:	0003      	movs	r3, r0
 8011846:	7023      	strb	r3, [r4, #0]

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
 8011848:	197b      	adds	r3, r7, r5
 801184a:	781b      	ldrb	r3, [r3, #0]
 801184c:	b25b      	sxtb	r3, r3
}
 801184e:	0018      	movs	r0, r3
 8011850:	46bd      	mov	sp, r7
 8011852:	b004      	add	sp, #16
 8011854:	bdb0      	pop	{r4, r5, r7, pc}
 8011856:	46c0      	nop			; (mov r8, r8)
 8011858:	0801fe14 	.word	0x0801fe14
 801185c:	00000825 	.word	0x00000825
 8011860:	080206f0 	.word	0x080206f0
 8011864:	0801fe60 	.word	0x0801fe60

08011868 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
err_t
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 8011868:	b5b0      	push	{r4, r5, r7, lr}
 801186a:	b08a      	sub	sp, #40	; 0x28
 801186c:	af00      	add	r7, sp, #0
 801186e:	6078      	str	r0, [r7, #4]
  struct tcp_hdr *tcphdr;
  struct tcp_seg *seg;
  u16_t len;
  u8_t is_fin;
  u32_t snd_nxt;
  u8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
 8011870:	2313      	movs	r3, #19
 8011872:	18fb      	adds	r3, r7, r3
 8011874:	2200      	movs	r2, #0
 8011876:	701a      	strb	r2, [r3, #0]

  LWIP_ASSERT("tcp_zero_window_probe: invalid pcb", pcb != NULL);
 8011878:	687b      	ldr	r3, [r7, #4]
 801187a:	2b00      	cmp	r3, #0
 801187c:	d106      	bne.n	801188c <tcp_zero_window_probe+0x24>
 801187e:	4b68      	ldr	r3, [pc, #416]	; (8011a20 <tcp_zero_window_probe+0x1b8>)
 8011880:	2285      	movs	r2, #133	; 0x85
 8011882:	0112      	lsls	r2, r2, #4
 8011884:	4967      	ldr	r1, [pc, #412]	; (8011a24 <tcp_zero_window_probe+0x1bc>)
 8011886:	4868      	ldr	r0, [pc, #416]	; (8011a28 <tcp_zero_window_probe+0x1c0>)
 8011888:	f7f0 fca0 	bl	80021cc <app_debug_rtt_raw>
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
               tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  /* Only consider unsent, persist timer should be off when there is data in-flight */
  seg = pcb->unsent;
 801188c:	687b      	ldr	r3, [r7, #4]
 801188e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8011890:	627b      	str	r3, [r7, #36]	; 0x24
  if (seg == NULL) {
 8011892:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011894:	2b00      	cmp	r3, #0
 8011896:	d101      	bne.n	801189c <tcp_zero_window_probe+0x34>
    /* Not expected, persist timer should be off when the send buffer is empty */
    return ERR_OK;
 8011898:	2300      	movs	r3, #0
 801189a:	e0bc      	b.n	8011a16 <tcp_zero_window_probe+0x1ae>

  /* increment probe count. NOTE: we record probe even if it fails
     to actually transmit due to an error. This ensures memory exhaustion/
     routing problem doesn't leave a zero-window pcb as an indefinite zombie.
     RTO mechanism has similar behavior, see pcb->nrtx */
  if (pcb->persist_probe < 0xFF) {
 801189c:	687b      	ldr	r3, [r7, #4]
 801189e:	22a6      	movs	r2, #166	; 0xa6
 80118a0:	5c9b      	ldrb	r3, [r3, r2]
 80118a2:	2bff      	cmp	r3, #255	; 0xff
 80118a4:	d007      	beq.n	80118b6 <tcp_zero_window_probe+0x4e>
    ++pcb->persist_probe;
 80118a6:	687b      	ldr	r3, [r7, #4]
 80118a8:	22a6      	movs	r2, #166	; 0xa6
 80118aa:	5c9b      	ldrb	r3, [r3, r2]
 80118ac:	3301      	adds	r3, #1
 80118ae:	b2d9      	uxtb	r1, r3
 80118b0:	687b      	ldr	r3, [r7, #4]
 80118b2:	22a6      	movs	r2, #166	; 0xa6
 80118b4:	5499      	strb	r1, [r3, r2]
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 80118b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80118b8:	691b      	ldr	r3, [r3, #16]
 80118ba:	7b1a      	ldrb	r2, [r3, #12]
 80118bc:	7b5b      	ldrb	r3, [r3, #13]
 80118be:	021b      	lsls	r3, r3, #8
 80118c0:	4313      	orrs	r3, r2
 80118c2:	b29b      	uxth	r3, r3
 80118c4:	0018      	movs	r0, r3
 80118c6:	f7f4 fe35 	bl	8006534 <lwip_htons>
 80118ca:	0003      	movs	r3, r0
 80118cc:	b2db      	uxtb	r3, r3
 80118ce:	001a      	movs	r2, r3
 80118d0:	2301      	movs	r3, #1
 80118d2:	4013      	ands	r3, r2
 80118d4:	d005      	beq.n	80118e2 <tcp_zero_window_probe+0x7a>
 80118d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80118d8:	891b      	ldrh	r3, [r3, #8]
 80118da:	2b00      	cmp	r3, #0
 80118dc:	d101      	bne.n	80118e2 <tcp_zero_window_probe+0x7a>
 80118de:	2201      	movs	r2, #1
 80118e0:	e000      	b.n	80118e4 <tcp_zero_window_probe+0x7c>
 80118e2:	2200      	movs	r2, #0
 80118e4:	2123      	movs	r1, #35	; 0x23
 80118e6:	187b      	adds	r3, r7, r1
 80118e8:	701a      	strb	r2, [r3, #0]
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;
 80118ea:	187b      	adds	r3, r7, r1
 80118ec:	781b      	ldrb	r3, [r3, #0]
 80118ee:	425a      	negs	r2, r3
 80118f0:	4153      	adcs	r3, r2
 80118f2:	b2da      	uxtb	r2, r3
 80118f4:	2020      	movs	r0, #32
 80118f6:	183b      	adds	r3, r7, r0
 80118f8:	801a      	strh	r2, [r3, #0]

  p = tcp_output_alloc_header(pcb, optlen, len, seg->tcphdr->seqno);
 80118fa:	2313      	movs	r3, #19
 80118fc:	18fb      	adds	r3, r7, r3
 80118fe:	781b      	ldrb	r3, [r3, #0]
 8011900:	b29c      	uxth	r4, r3
 8011902:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011904:	691b      	ldr	r3, [r3, #16]
 8011906:	791a      	ldrb	r2, [r3, #4]
 8011908:	7959      	ldrb	r1, [r3, #5]
 801190a:	0209      	lsls	r1, r1, #8
 801190c:	430a      	orrs	r2, r1
 801190e:	7999      	ldrb	r1, [r3, #6]
 8011910:	0409      	lsls	r1, r1, #16
 8011912:	430a      	orrs	r2, r1
 8011914:	79db      	ldrb	r3, [r3, #7]
 8011916:	061b      	lsls	r3, r3, #24
 8011918:	4313      	orrs	r3, r2
 801191a:	0019      	movs	r1, r3
 801191c:	183b      	adds	r3, r7, r0
 801191e:	881a      	ldrh	r2, [r3, #0]
 8011920:	6878      	ldr	r0, [r7, #4]
 8011922:	000b      	movs	r3, r1
 8011924:	0021      	movs	r1, r4
 8011926:	f7ff fd63 	bl	80113f0 <tcp_output_alloc_header>
 801192a:	0003      	movs	r3, r0
 801192c:	61fb      	str	r3, [r7, #28]
  if (p == NULL) {
 801192e:	69fb      	ldr	r3, [r7, #28]
 8011930:	2b00      	cmp	r3, #0
 8011932:	d102      	bne.n	801193a <tcp_zero_window_probe+0xd2>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return ERR_MEM;
 8011934:	2301      	movs	r3, #1
 8011936:	425b      	negs	r3, r3
 8011938:	e06d      	b.n	8011a16 <tcp_zero_window_probe+0x1ae>
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 801193a:	69fb      	ldr	r3, [r7, #28]
 801193c:	685b      	ldr	r3, [r3, #4]
 801193e:	61bb      	str	r3, [r7, #24]

  if (is_fin) {
 8011940:	2323      	movs	r3, #35	; 0x23
 8011942:	18fb      	adds	r3, r7, r3
 8011944:	781b      	ldrb	r3, [r3, #0]
 8011946:	2b00      	cmp	r3, #0
 8011948:	d026      	beq.n	8011998 <tcp_zero_window_probe+0x130>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 801194a:	69bb      	ldr	r3, [r7, #24]
 801194c:	7b1a      	ldrb	r2, [r3, #12]
 801194e:	7b5b      	ldrb	r3, [r3, #13]
 8011950:	021b      	lsls	r3, r3, #8
 8011952:	4313      	orrs	r3, r2
 8011954:	b29b      	uxth	r3, r3
 8011956:	b21b      	sxth	r3, r3
 8011958:	4a34      	ldr	r2, [pc, #208]	; (8011a2c <tcp_zero_window_probe+0x1c4>)
 801195a:	4013      	ands	r3, r2
 801195c:	b21c      	sxth	r4, r3
 801195e:	2011      	movs	r0, #17
 8011960:	f7f4 fde8 	bl	8006534 <lwip_htons>
 8011964:	0003      	movs	r3, r0
 8011966:	b21b      	sxth	r3, r3
 8011968:	4323      	orrs	r3, r4
 801196a:	b21b      	sxth	r3, r3
 801196c:	b29a      	uxth	r2, r3
 801196e:	69bb      	ldr	r3, [r7, #24]
 8011970:	21ff      	movs	r1, #255	; 0xff
 8011972:	4011      	ands	r1, r2
 8011974:	000c      	movs	r4, r1
 8011976:	7b19      	ldrb	r1, [r3, #12]
 8011978:	2000      	movs	r0, #0
 801197a:	4001      	ands	r1, r0
 801197c:	1c08      	adds	r0, r1, #0
 801197e:	1c21      	adds	r1, r4, #0
 8011980:	4301      	orrs	r1, r0
 8011982:	7319      	strb	r1, [r3, #12]
 8011984:	0a12      	lsrs	r2, r2, #8
 8011986:	b290      	uxth	r0, r2
 8011988:	7b5a      	ldrb	r2, [r3, #13]
 801198a:	2100      	movs	r1, #0
 801198c:	400a      	ands	r2, r1
 801198e:	1c11      	adds	r1, r2, #0
 8011990:	1c02      	adds	r2, r0, #0
 8011992:	430a      	orrs	r2, r1
 8011994:	735a      	strb	r2, [r3, #13]
 8011996:	e010      	b.n	80119ba <tcp_zero_window_probe+0x152>
  } else {
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
 8011998:	69fb      	ldr	r3, [r7, #28]
 801199a:	685b      	ldr	r3, [r3, #4]
 801199c:	3314      	adds	r3, #20
 801199e:	617b      	str	r3, [r7, #20]
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 80119a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80119a2:	6858      	ldr	r0, [r3, #4]
 80119a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80119a6:	685b      	ldr	r3, [r3, #4]
 80119a8:	891a      	ldrh	r2, [r3, #8]
 80119aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80119ac:	891b      	ldrh	r3, [r3, #8]
 80119ae:	1ad3      	subs	r3, r2, r3
 80119b0:	b29b      	uxth	r3, r3
 80119b2:	6979      	ldr	r1, [r7, #20]
 80119b4:	2201      	movs	r2, #1
 80119b6:	f7f8 f937 	bl	8009c28 <pbuf_copy_partial>
  }

  /* The byte may be acknowledged without the window being opened. */
  snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + 1;
 80119ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80119bc:	691b      	ldr	r3, [r3, #16]
 80119be:	791a      	ldrb	r2, [r3, #4]
 80119c0:	7959      	ldrb	r1, [r3, #5]
 80119c2:	0209      	lsls	r1, r1, #8
 80119c4:	430a      	orrs	r2, r1
 80119c6:	7999      	ldrb	r1, [r3, #6]
 80119c8:	0409      	lsls	r1, r1, #16
 80119ca:	430a      	orrs	r2, r1
 80119cc:	79db      	ldrb	r3, [r3, #7]
 80119ce:	061b      	lsls	r3, r3, #24
 80119d0:	4313      	orrs	r3, r2
 80119d2:	0018      	movs	r0, r3
 80119d4:	f7f4 fdc4 	bl	8006560 <lwip_htonl>
 80119d8:	0003      	movs	r3, r0
 80119da:	3301      	adds	r3, #1
 80119dc:	60fb      	str	r3, [r7, #12]
  if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 80119de:	687b      	ldr	r3, [r7, #4]
 80119e0:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80119e2:	68fb      	ldr	r3, [r7, #12]
 80119e4:	1ad3      	subs	r3, r2, r3
 80119e6:	d502      	bpl.n	80119ee <tcp_zero_window_probe+0x186>
    pcb->snd_nxt = snd_nxt;
 80119e8:	687b      	ldr	r3, [r7, #4]
 80119ea:	68fa      	ldr	r2, [r7, #12]
 80119ec:	655a      	str	r2, [r3, #84]	; 0x54
  }
  tcp_output_fill_options(pcb, p, 0, 0);
 80119ee:	69f9      	ldr	r1, [r7, #28]
 80119f0:	6878      	ldr	r0, [r7, #4]
 80119f2:	2300      	movs	r3, #0
 80119f4:	2200      	movs	r2, #0
 80119f6:	f7ff fd47 	bl	8011488 <tcp_output_fill_options>

  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
 80119fa:	687a      	ldr	r2, [r7, #4]
 80119fc:	687b      	ldr	r3, [r7, #4]
 80119fe:	3304      	adds	r3, #4
 8011a00:	250b      	movs	r5, #11
 8011a02:	197c      	adds	r4, r7, r5
 8011a04:	69f9      	ldr	r1, [r7, #28]
 8011a06:	6878      	ldr	r0, [r7, #4]
 8011a08:	f7ff fd84 	bl	8011514 <tcp_output_control_segment>
 8011a0c:	0003      	movs	r3, r0
 8011a0e:	7023      	strb	r3, [r4, #0]

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
 8011a10:	197b      	adds	r3, r7, r5
 8011a12:	781b      	ldrb	r3, [r3, #0]
 8011a14:	b25b      	sxtb	r3, r3
}
 8011a16:	0018      	movs	r0, r3
 8011a18:	46bd      	mov	sp, r7
 8011a1a:	b00a      	add	sp, #40	; 0x28
 8011a1c:	bdb0      	pop	{r4, r5, r7, pc}
 8011a1e:	46c0      	nop			; (mov r8, r8)
 8011a20:	0801fe14 	.word	0x0801fe14
 8011a24:	0802070c 	.word	0x0802070c
 8011a28:	0801fe60 	.word	0x0801fe60
 8011a2c:	ffffc0ff 	.word	0xffffc0ff

08011a30 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
 8011a30:	b580      	push	{r7, lr}
 8011a32:	b082      	sub	sp, #8
 8011a34:	af00      	add	r7, sp, #0
 8011a36:	6078      	str	r0, [r7, #4]
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
 8011a38:	f7f8 fcd4 	bl	800a3e4 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 8011a3c:	4b0b      	ldr	r3, [pc, #44]	; (8011a6c <tcpip_tcp_timer+0x3c>)
 8011a3e:	681b      	ldr	r3, [r3, #0]
 8011a40:	2b00      	cmp	r3, #0
 8011a42:	d103      	bne.n	8011a4c <tcpip_tcp_timer+0x1c>
 8011a44:	4b0a      	ldr	r3, [pc, #40]	; (8011a70 <tcpip_tcp_timer+0x40>)
 8011a46:	681b      	ldr	r3, [r3, #0]
 8011a48:	2b00      	cmp	r3, #0
 8011a4a:	d007      	beq.n	8011a5c <tcpip_tcp_timer+0x2c>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 8011a4c:	4909      	ldr	r1, [pc, #36]	; (8011a74 <tcpip_tcp_timer+0x44>)
 8011a4e:	23fa      	movs	r3, #250	; 0xfa
 8011a50:	005b      	lsls	r3, r3, #1
 8011a52:	2200      	movs	r2, #0
 8011a54:	0018      	movs	r0, r3
 8011a56:	f000 f8ff 	bl	8011c58 <sys_timeout>
 8011a5a:	e003      	b.n	8011a64 <tcpip_tcp_timer+0x34>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
 8011a5c:	4b06      	ldr	r3, [pc, #24]	; (8011a78 <tcpip_tcp_timer+0x48>)
 8011a5e:	2200      	movs	r2, #0
 8011a60:	601a      	str	r2, [r3, #0]
  }
}
 8011a62:	46c0      	nop			; (mov r8, r8)
 8011a64:	46c0      	nop			; (mov r8, r8)
 8011a66:	46bd      	mov	sp, r7
 8011a68:	b002      	add	sp, #8
 8011a6a:	bd80      	pop	{r7, pc}
 8011a6c:	20002b18 	.word	0x20002b18
 8011a70:	20002b28 	.word	0x20002b28
 8011a74:	08011a31 	.word	0x08011a31
 8011a78:	2000139c 	.word	0x2000139c

08011a7c <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
 8011a7c:	b580      	push	{r7, lr}
 8011a7e:	af00      	add	r7, sp, #0
  LWIP_ASSERT_CORE_LOCKED();

  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 8011a80:	4b0c      	ldr	r3, [pc, #48]	; (8011ab4 <tcp_timer_needed+0x38>)
 8011a82:	681b      	ldr	r3, [r3, #0]
 8011a84:	2b00      	cmp	r3, #0
 8011a86:	d111      	bne.n	8011aac <tcp_timer_needed+0x30>
 8011a88:	4b0b      	ldr	r3, [pc, #44]	; (8011ab8 <tcp_timer_needed+0x3c>)
 8011a8a:	681b      	ldr	r3, [r3, #0]
 8011a8c:	2b00      	cmp	r3, #0
 8011a8e:	d103      	bne.n	8011a98 <tcp_timer_needed+0x1c>
 8011a90:	4b0a      	ldr	r3, [pc, #40]	; (8011abc <tcp_timer_needed+0x40>)
 8011a92:	681b      	ldr	r3, [r3, #0]
 8011a94:	2b00      	cmp	r3, #0
 8011a96:	d009      	beq.n	8011aac <tcp_timer_needed+0x30>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
 8011a98:	4b06      	ldr	r3, [pc, #24]	; (8011ab4 <tcp_timer_needed+0x38>)
 8011a9a:	2201      	movs	r2, #1
 8011a9c:	601a      	str	r2, [r3, #0]
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 8011a9e:	4908      	ldr	r1, [pc, #32]	; (8011ac0 <tcp_timer_needed+0x44>)
 8011aa0:	23fa      	movs	r3, #250	; 0xfa
 8011aa2:	005b      	lsls	r3, r3, #1
 8011aa4:	2200      	movs	r2, #0
 8011aa6:	0018      	movs	r0, r3
 8011aa8:	f000 f8d6 	bl	8011c58 <sys_timeout>
  }
}
 8011aac:	46c0      	nop			; (mov r8, r8)
 8011aae:	46bd      	mov	sp, r7
 8011ab0:	bd80      	pop	{r7, pc}
 8011ab2:	46c0      	nop			; (mov r8, r8)
 8011ab4:	2000139c 	.word	0x2000139c
 8011ab8:	20002b18 	.word	0x20002b18
 8011abc:	20002b28 	.word	0x20002b28
 8011ac0:	08011a31 	.word	0x08011a31

08011ac4 <sys_timeout_abs>:
#if LWIP_DEBUG_TIMERNAMES
sys_timeout_abs(u32_t abs_time, sys_timeout_handler handler, void *arg, const char *handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
sys_timeout_abs(u32_t abs_time, sys_timeout_handler handler, void *arg)
#endif
{
 8011ac4:	b580      	push	{r7, lr}
 8011ac6:	b086      	sub	sp, #24
 8011ac8:	af00      	add	r7, sp, #0
 8011aca:	60f8      	str	r0, [r7, #12]
 8011acc:	60b9      	str	r1, [r7, #8]
 8011ace:	607a      	str	r2, [r7, #4]
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 8011ad0:	2004      	movs	r0, #4
 8011ad2:	f7f6 fe79 	bl	80087c8 <memp_malloc>
 8011ad6:	0003      	movs	r3, r0
 8011ad8:	613b      	str	r3, [r7, #16]
  if (timeout == NULL) {
 8011ada:	693b      	ldr	r3, [r7, #16]
 8011adc:	2b00      	cmp	r3, #0
 8011ade:	d109      	bne.n	8011af4 <sys_timeout_abs+0x30>
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
 8011ae0:	693b      	ldr	r3, [r7, #16]
 8011ae2:	2b00      	cmp	r3, #0
 8011ae4:	d153      	bne.n	8011b8e <sys_timeout_abs+0xca>
 8011ae6:	4b2c      	ldr	r3, [pc, #176]	; (8011b98 <sys_timeout_abs+0xd4>)
 8011ae8:	492c      	ldr	r1, [pc, #176]	; (8011b9c <sys_timeout_abs+0xd8>)
 8011aea:	482d      	ldr	r0, [pc, #180]	; (8011ba0 <sys_timeout_abs+0xdc>)
 8011aec:	22be      	movs	r2, #190	; 0xbe
 8011aee:	f7f0 fb6d 	bl	80021cc <app_debug_rtt_raw>
    return;
 8011af2:	e04c      	b.n	8011b8e <sys_timeout_abs+0xca>
  }

  timeout->next = NULL;
 8011af4:	693b      	ldr	r3, [r7, #16]
 8011af6:	2200      	movs	r2, #0
 8011af8:	601a      	str	r2, [r3, #0]
  timeout->h = handler;
 8011afa:	693b      	ldr	r3, [r7, #16]
 8011afc:	68ba      	ldr	r2, [r7, #8]
 8011afe:	609a      	str	r2, [r3, #8]
  timeout->arg = arg;
 8011b00:	693b      	ldr	r3, [r7, #16]
 8011b02:	687a      	ldr	r2, [r7, #4]
 8011b04:	60da      	str	r2, [r3, #12]
  timeout->time = abs_time;
 8011b06:	693b      	ldr	r3, [r7, #16]
 8011b08:	68fa      	ldr	r2, [r7, #12]
 8011b0a:	605a      	str	r2, [r3, #4]
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p abs_time=%"U32_F" handler=%s arg=%p\n",
                             (void *)timeout, abs_time, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
 8011b0c:	4b25      	ldr	r3, [pc, #148]	; (8011ba4 <sys_timeout_abs+0xe0>)
 8011b0e:	681b      	ldr	r3, [r3, #0]
 8011b10:	2b00      	cmp	r3, #0
 8011b12:	d103      	bne.n	8011b1c <sys_timeout_abs+0x58>
    next_timeout = timeout;
 8011b14:	4b23      	ldr	r3, [pc, #140]	; (8011ba4 <sys_timeout_abs+0xe0>)
 8011b16:	693a      	ldr	r2, [r7, #16]
 8011b18:	601a      	str	r2, [r3, #0]
    return;
 8011b1a:	e039      	b.n	8011b90 <sys_timeout_abs+0xcc>
  }
  if (TIME_LESS_THAN(timeout->time, next_timeout->time)) {
 8011b1c:	693b      	ldr	r3, [r7, #16]
 8011b1e:	685a      	ldr	r2, [r3, #4]
 8011b20:	4b20      	ldr	r3, [pc, #128]	; (8011ba4 <sys_timeout_abs+0xe0>)
 8011b22:	681b      	ldr	r3, [r3, #0]
 8011b24:	685b      	ldr	r3, [r3, #4]
 8011b26:	1ad3      	subs	r3, r2, r3
 8011b28:	0fdb      	lsrs	r3, r3, #31
 8011b2a:	1c1a      	adds	r2, r3, #0
 8011b2c:	2301      	movs	r3, #1
 8011b2e:	4013      	ands	r3, r2
 8011b30:	b2db      	uxtb	r3, r3
 8011b32:	2b00      	cmp	r3, #0
 8011b34:	d007      	beq.n	8011b46 <sys_timeout_abs+0x82>
    timeout->next = next_timeout;
 8011b36:	4b1b      	ldr	r3, [pc, #108]	; (8011ba4 <sys_timeout_abs+0xe0>)
 8011b38:	681a      	ldr	r2, [r3, #0]
 8011b3a:	693b      	ldr	r3, [r7, #16]
 8011b3c:	601a      	str	r2, [r3, #0]
    next_timeout = timeout;
 8011b3e:	4b19      	ldr	r3, [pc, #100]	; (8011ba4 <sys_timeout_abs+0xe0>)
 8011b40:	693a      	ldr	r2, [r7, #16]
 8011b42:	601a      	str	r2, [r3, #0]
 8011b44:	e024      	b.n	8011b90 <sys_timeout_abs+0xcc>
  } else {
    for (t = next_timeout; t != NULL; t = t->next) {
 8011b46:	4b17      	ldr	r3, [pc, #92]	; (8011ba4 <sys_timeout_abs+0xe0>)
 8011b48:	681b      	ldr	r3, [r3, #0]
 8011b4a:	617b      	str	r3, [r7, #20]
 8011b4c:	e01b      	b.n	8011b86 <sys_timeout_abs+0xc2>
      if ((t->next == NULL) || TIME_LESS_THAN(timeout->time, t->next->time)) {
 8011b4e:	697b      	ldr	r3, [r7, #20]
 8011b50:	681b      	ldr	r3, [r3, #0]
 8011b52:	2b00      	cmp	r3, #0
 8011b54:	d00c      	beq.n	8011b70 <sys_timeout_abs+0xac>
 8011b56:	693b      	ldr	r3, [r7, #16]
 8011b58:	685a      	ldr	r2, [r3, #4]
 8011b5a:	697b      	ldr	r3, [r7, #20]
 8011b5c:	681b      	ldr	r3, [r3, #0]
 8011b5e:	685b      	ldr	r3, [r3, #4]
 8011b60:	1ad3      	subs	r3, r2, r3
 8011b62:	0fdb      	lsrs	r3, r3, #31
 8011b64:	1c1a      	adds	r2, r3, #0
 8011b66:	2301      	movs	r3, #1
 8011b68:	4013      	ands	r3, r2
 8011b6a:	b2db      	uxtb	r3, r3
 8011b6c:	2b00      	cmp	r3, #0
 8011b6e:	d007      	beq.n	8011b80 <sys_timeout_abs+0xbc>
        timeout->next = t->next;
 8011b70:	697b      	ldr	r3, [r7, #20]
 8011b72:	681a      	ldr	r2, [r3, #0]
 8011b74:	693b      	ldr	r3, [r7, #16]
 8011b76:	601a      	str	r2, [r3, #0]
        t->next = timeout;
 8011b78:	697b      	ldr	r3, [r7, #20]
 8011b7a:	693a      	ldr	r2, [r7, #16]
 8011b7c:	601a      	str	r2, [r3, #0]
        break;
 8011b7e:	e007      	b.n	8011b90 <sys_timeout_abs+0xcc>
    for (t = next_timeout; t != NULL; t = t->next) {
 8011b80:	697b      	ldr	r3, [r7, #20]
 8011b82:	681b      	ldr	r3, [r3, #0]
 8011b84:	617b      	str	r3, [r7, #20]
 8011b86:	697b      	ldr	r3, [r7, #20]
 8011b88:	2b00      	cmp	r3, #0
 8011b8a:	d1e0      	bne.n	8011b4e <sys_timeout_abs+0x8a>
 8011b8c:	e000      	b.n	8011b90 <sys_timeout_abs+0xcc>
    return;
 8011b8e:	46c0      	nop			; (mov r8, r8)
      }
    }
  }
}
 8011b90:	46bd      	mov	sp, r7
 8011b92:	b006      	add	sp, #24
 8011b94:	bd80      	pop	{r7, pc}
 8011b96:	46c0      	nop			; (mov r8, r8)
 8011b98:	08020730 	.word	0x08020730
 8011b9c:	0802075c 	.word	0x0802075c
 8011ba0:	0802079c 	.word	0x0802079c
 8011ba4:	20001394 	.word	0x20001394

08011ba8 <lwip_cyclic_timer>:
#if !LWIP_TESTMODE
static
#endif
void
lwip_cyclic_timer(void *arg)
{
 8011ba8:	b580      	push	{r7, lr}
 8011baa:	b086      	sub	sp, #24
 8011bac:	af00      	add	r7, sp, #0
 8011bae:	6078      	str	r0, [r7, #4]
  u32_t now;
  u32_t next_timeout_time;
  const struct lwip_cyclic_timer *cyclic = (const struct lwip_cyclic_timer *)arg;
 8011bb0:	687b      	ldr	r3, [r7, #4]
 8011bb2:	617b      	str	r3, [r7, #20]

#if LWIP_DEBUG_TIMERNAMES
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: %s()\n", cyclic->handler_name));
#endif
  cyclic->handler();
 8011bb4:	697b      	ldr	r3, [r7, #20]
 8011bb6:	685b      	ldr	r3, [r3, #4]
 8011bb8:	4798      	blx	r3

  now = sys_now();
 8011bba:	f00a fdc9 	bl	801c750 <sys_now>
 8011bbe:	0003      	movs	r3, r0
 8011bc0:	613b      	str	r3, [r7, #16]
  next_timeout_time = (u32_t)(current_timeout_due_time + cyclic->interval_ms);  /* overflow handled by TIME_LESS_THAN macro */ 
 8011bc2:	697b      	ldr	r3, [r7, #20]
 8011bc4:	681a      	ldr	r2, [r3, #0]
 8011bc6:	4b11      	ldr	r3, [pc, #68]	; (8011c0c <lwip_cyclic_timer+0x64>)
 8011bc8:	681b      	ldr	r3, [r3, #0]
 8011bca:	18d3      	adds	r3, r2, r3
 8011bcc:	60fb      	str	r3, [r7, #12]
  if (TIME_LESS_THAN(next_timeout_time, now)) {
 8011bce:	68fa      	ldr	r2, [r7, #12]
 8011bd0:	693b      	ldr	r3, [r7, #16]
 8011bd2:	1ad3      	subs	r3, r2, r3
 8011bd4:	0fdb      	lsrs	r3, r3, #31
 8011bd6:	1c1a      	adds	r2, r3, #0
 8011bd8:	2301      	movs	r3, #1
 8011bda:	4013      	ands	r3, r2
 8011bdc:	b2db      	uxtb	r3, r3
 8011bde:	2b00      	cmp	r3, #0
 8011be0:	d009      	beq.n	8011bf6 <lwip_cyclic_timer+0x4e>
    /* timer would immediately expire again -> "overload" -> restart without any correction */
#if LWIP_DEBUG_TIMERNAMES
    sys_timeout_abs((u32_t)(now + cyclic->interval_ms), lwip_cyclic_timer, arg, cyclic->handler_name);
#else
    sys_timeout_abs((u32_t)(now + cyclic->interval_ms), lwip_cyclic_timer, arg);
 8011be2:	697b      	ldr	r3, [r7, #20]
 8011be4:	681a      	ldr	r2, [r3, #0]
 8011be6:	693b      	ldr	r3, [r7, #16]
 8011be8:	18d3      	adds	r3, r2, r3
 8011bea:	687a      	ldr	r2, [r7, #4]
 8011bec:	4908      	ldr	r1, [pc, #32]	; (8011c10 <lwip_cyclic_timer+0x68>)
 8011bee:	0018      	movs	r0, r3
 8011bf0:	f7ff ff68 	bl	8011ac4 <sys_timeout_abs>
    sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg, cyclic->handler_name);
#else
    sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg);
#endif
  }
}
 8011bf4:	e005      	b.n	8011c02 <lwip_cyclic_timer+0x5a>
    sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg);
 8011bf6:	687a      	ldr	r2, [r7, #4]
 8011bf8:	4905      	ldr	r1, [pc, #20]	; (8011c10 <lwip_cyclic_timer+0x68>)
 8011bfa:	68fb      	ldr	r3, [r7, #12]
 8011bfc:	0018      	movs	r0, r3
 8011bfe:	f7ff ff61 	bl	8011ac4 <sys_timeout_abs>
}
 8011c02:	46c0      	nop			; (mov r8, r8)
 8011c04:	46bd      	mov	sp, r7
 8011c06:	b006      	add	sp, #24
 8011c08:	bd80      	pop	{r7, pc}
 8011c0a:	46c0      	nop			; (mov r8, r8)
 8011c0c:	20001398 	.word	0x20001398
 8011c10:	08011ba9 	.word	0x08011ba9

08011c14 <sys_timeouts_init>:

/** Initialize this module */
void sys_timeouts_init(void)
{
 8011c14:	b580      	push	{r7, lr}
 8011c16:	b082      	sub	sp, #8
 8011c18:	af00      	add	r7, sp, #0
  size_t i;
  /* tcp_tmr() at index 0 is started on demand */
  for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
 8011c1a:	2301      	movs	r3, #1
 8011c1c:	607b      	str	r3, [r7, #4]
 8011c1e:	e00e      	b.n	8011c3e <sys_timeouts_init+0x2a>
    /* we have to cast via size_t to get rid of const warning
      (this is OK as cyclic_timer() casts back to const* */
    sys_timeout(lwip_cyclic_timers[i].interval_ms, lwip_cyclic_timer, LWIP_CONST_CAST(void *, &lwip_cyclic_timers[i]));
 8011c20:	4b0b      	ldr	r3, [pc, #44]	; (8011c50 <sys_timeouts_init+0x3c>)
 8011c22:	687a      	ldr	r2, [r7, #4]
 8011c24:	00d2      	lsls	r2, r2, #3
 8011c26:	58d0      	ldr	r0, [r2, r3]
 8011c28:	687b      	ldr	r3, [r7, #4]
 8011c2a:	00da      	lsls	r2, r3, #3
 8011c2c:	4b08      	ldr	r3, [pc, #32]	; (8011c50 <sys_timeouts_init+0x3c>)
 8011c2e:	18d2      	adds	r2, r2, r3
 8011c30:	4b08      	ldr	r3, [pc, #32]	; (8011c54 <sys_timeouts_init+0x40>)
 8011c32:	0019      	movs	r1, r3
 8011c34:	f000 f810 	bl	8011c58 <sys_timeout>
  for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
 8011c38:	687b      	ldr	r3, [r7, #4]
 8011c3a:	3301      	adds	r3, #1
 8011c3c:	607b      	str	r3, [r7, #4]
 8011c3e:	687b      	ldr	r3, [r7, #4]
 8011c40:	2b01      	cmp	r3, #1
 8011c42:	d9ed      	bls.n	8011c20 <sys_timeouts_init+0xc>
  }
}
 8011c44:	46c0      	nop			; (mov r8, r8)
 8011c46:	46c0      	nop			; (mov r8, r8)
 8011c48:	46bd      	mov	sp, r7
 8011c4a:	b002      	add	sp, #8
 8011c4c:	bd80      	pop	{r7, pc}
 8011c4e:	46c0      	nop			; (mov r8, r8)
 8011c50:	08021a40 	.word	0x08021a40
 8011c54:	08011ba9 	.word	0x08011ba9

08011c58 <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char *handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
 8011c58:	b580      	push	{r7, lr}
 8011c5a:	b086      	sub	sp, #24
 8011c5c:	af00      	add	r7, sp, #0
 8011c5e:	60f8      	str	r0, [r7, #12]
 8011c60:	60b9      	str	r1, [r7, #8]
 8011c62:	607a      	str	r2, [r7, #4]
  u32_t next_timeout_time;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("Timeout time too long, max is LWIP_UINT32_MAX/4 msecs", msecs <= (LWIP_UINT32_MAX / 4));
 8011c64:	68fa      	ldr	r2, [r7, #12]
 8011c66:	2380      	movs	r3, #128	; 0x80
 8011c68:	05db      	lsls	r3, r3, #23
 8011c6a:	429a      	cmp	r2, r3
 8011c6c:	d306      	bcc.n	8011c7c <sys_timeout+0x24>
 8011c6e:	4b0b      	ldr	r3, [pc, #44]	; (8011c9c <sys_timeout+0x44>)
 8011c70:	222a      	movs	r2, #42	; 0x2a
 8011c72:	32ff      	adds	r2, #255	; 0xff
 8011c74:	490a      	ldr	r1, [pc, #40]	; (8011ca0 <sys_timeout+0x48>)
 8011c76:	480b      	ldr	r0, [pc, #44]	; (8011ca4 <sys_timeout+0x4c>)
 8011c78:	f7f0 faa8 	bl	80021cc <app_debug_rtt_raw>

  next_timeout_time = (u32_t)(sys_now() + msecs); /* overflow handled by TIME_LESS_THAN macro */ 
 8011c7c:	f00a fd68 	bl	801c750 <sys_now>
 8011c80:	0002      	movs	r2, r0
 8011c82:	68fb      	ldr	r3, [r7, #12]
 8011c84:	189b      	adds	r3, r3, r2
 8011c86:	617b      	str	r3, [r7, #20]

#if LWIP_DEBUG_TIMERNAMES
  sys_timeout_abs(next_timeout_time, handler, arg, handler_name);
#else
  sys_timeout_abs(next_timeout_time, handler, arg);
 8011c88:	687a      	ldr	r2, [r7, #4]
 8011c8a:	68b9      	ldr	r1, [r7, #8]
 8011c8c:	697b      	ldr	r3, [r7, #20]
 8011c8e:	0018      	movs	r0, r3
 8011c90:	f7ff ff18 	bl	8011ac4 <sys_timeout_abs>
#endif
}
 8011c94:	46c0      	nop			; (mov r8, r8)
 8011c96:	46bd      	mov	sp, r7
 8011c98:	b006      	add	sp, #24
 8011c9a:	bd80      	pop	{r7, pc}
 8011c9c:	08020730 	.word	0x08020730
 8011ca0:	080207c8 	.word	0x080207c8
 8011ca4:	0802079c 	.word	0x0802079c

08011ca8 <sys_untimeout>:
 * @param handler callback function that would be called by the timeout
 * @param arg callback argument that would be passed to handler
*/
void
sys_untimeout(sys_timeout_handler handler, void *arg)
{
 8011ca8:	b580      	push	{r7, lr}
 8011caa:	b084      	sub	sp, #16
 8011cac:	af00      	add	r7, sp, #0
 8011cae:	6078      	str	r0, [r7, #4]
 8011cb0:	6039      	str	r1, [r7, #0]
  struct sys_timeo *prev_t, *t;

  LWIP_ASSERT_CORE_LOCKED();

  if (next_timeout == NULL) {
 8011cb2:	4b19      	ldr	r3, [pc, #100]	; (8011d18 <sys_untimeout+0x70>)
 8011cb4:	681b      	ldr	r3, [r3, #0]
 8011cb6:	2b00      	cmp	r3, #0
 8011cb8:	d02a      	beq.n	8011d10 <sys_untimeout+0x68>
    return;
  }

  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
 8011cba:	4b17      	ldr	r3, [pc, #92]	; (8011d18 <sys_untimeout+0x70>)
 8011cbc:	681b      	ldr	r3, [r3, #0]
 8011cbe:	60bb      	str	r3, [r7, #8]
 8011cc0:	2300      	movs	r3, #0
 8011cc2:	60fb      	str	r3, [r7, #12]
 8011cc4:	e020      	b.n	8011d08 <sys_untimeout+0x60>
    if ((t->h == handler) && (t->arg == arg)) {
 8011cc6:	68bb      	ldr	r3, [r7, #8]
 8011cc8:	689b      	ldr	r3, [r3, #8]
 8011cca:	687a      	ldr	r2, [r7, #4]
 8011ccc:	429a      	cmp	r2, r3
 8011cce:	d116      	bne.n	8011cfe <sys_untimeout+0x56>
 8011cd0:	68bb      	ldr	r3, [r7, #8]
 8011cd2:	68db      	ldr	r3, [r3, #12]
 8011cd4:	683a      	ldr	r2, [r7, #0]
 8011cd6:	429a      	cmp	r2, r3
 8011cd8:	d111      	bne.n	8011cfe <sys_untimeout+0x56>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL) {
 8011cda:	68fb      	ldr	r3, [r7, #12]
 8011cdc:	2b00      	cmp	r3, #0
 8011cde:	d104      	bne.n	8011cea <sys_untimeout+0x42>
        next_timeout = t->next;
 8011ce0:	68bb      	ldr	r3, [r7, #8]
 8011ce2:	681a      	ldr	r2, [r3, #0]
 8011ce4:	4b0c      	ldr	r3, [pc, #48]	; (8011d18 <sys_untimeout+0x70>)
 8011ce6:	601a      	str	r2, [r3, #0]
 8011ce8:	e003      	b.n	8011cf2 <sys_untimeout+0x4a>
      } else {
        prev_t->next = t->next;
 8011cea:	68bb      	ldr	r3, [r7, #8]
 8011cec:	681a      	ldr	r2, [r3, #0]
 8011cee:	68fb      	ldr	r3, [r7, #12]
 8011cf0:	601a      	str	r2, [r3, #0]
      }
      memp_free(MEMP_SYS_TIMEOUT, t);
 8011cf2:	68bb      	ldr	r3, [r7, #8]
 8011cf4:	0019      	movs	r1, r3
 8011cf6:	2004      	movs	r0, #4
 8011cf8:	f7f6 fdd6 	bl	80088a8 <memp_free>
      return;
 8011cfc:	e009      	b.n	8011d12 <sys_untimeout+0x6a>
  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
 8011cfe:	68bb      	ldr	r3, [r7, #8]
 8011d00:	60fb      	str	r3, [r7, #12]
 8011d02:	68bb      	ldr	r3, [r7, #8]
 8011d04:	681b      	ldr	r3, [r3, #0]
 8011d06:	60bb      	str	r3, [r7, #8]
 8011d08:	68bb      	ldr	r3, [r7, #8]
 8011d0a:	2b00      	cmp	r3, #0
 8011d0c:	d1db      	bne.n	8011cc6 <sys_untimeout+0x1e>
    }
  }
  return;
 8011d0e:	e000      	b.n	8011d12 <sys_untimeout+0x6a>
    return;
 8011d10:	46c0      	nop			; (mov r8, r8)
}
 8011d12:	46bd      	mov	sp, r7
 8011d14:	b004      	add	sp, #16
 8011d16:	bd80      	pop	{r7, pc}
 8011d18:	20001394 	.word	0x20001394

08011d1c <sys_check_timeouts>:
 *
 * Must be called periodically from your main loop.
 */
void
sys_check_timeouts(void)
{
 8011d1c:	b580      	push	{r7, lr}
 8011d1e:	b084      	sub	sp, #16
 8011d20:	af00      	add	r7, sp, #0
  u32_t now;

  LWIP_ASSERT_CORE_LOCKED();

  /* Process only timers expired at the start of the function. */
  now = sys_now();
 8011d22:	f00a fd15 	bl	801c750 <sys_now>
 8011d26:	0003      	movs	r3, r0
 8011d28:	60fb      	str	r3, [r7, #12]
  do {
    struct sys_timeo *tmptimeout;
    sys_timeout_handler handler;
    void *arg;

    PBUF_CHECK_FREE_OOSEQ();
 8011d2a:	4b1c      	ldr	r3, [pc, #112]	; (8011d9c <sys_check_timeouts+0x80>)
 8011d2c:	781b      	ldrb	r3, [r3, #0]
 8011d2e:	b2db      	uxtb	r3, r3
 8011d30:	2b00      	cmp	r3, #0
 8011d32:	d001      	beq.n	8011d38 <sys_check_timeouts+0x1c>
 8011d34:	f7f7 f8de 	bl	8008ef4 <pbuf_free_ooseq>

    tmptimeout = next_timeout;
 8011d38:	4b19      	ldr	r3, [pc, #100]	; (8011da0 <sys_check_timeouts+0x84>)
 8011d3a:	681b      	ldr	r3, [r3, #0]
 8011d3c:	60bb      	str	r3, [r7, #8]
    if (tmptimeout == NULL) {
 8011d3e:	68bb      	ldr	r3, [r7, #8]
 8011d40:	2b00      	cmp	r3, #0
 8011d42:	d025      	beq.n	8011d90 <sys_check_timeouts+0x74>
      return;
    }

    if (TIME_LESS_THAN(now, tmptimeout->time)) {
 8011d44:	68bb      	ldr	r3, [r7, #8]
 8011d46:	685b      	ldr	r3, [r3, #4]
 8011d48:	68fa      	ldr	r2, [r7, #12]
 8011d4a:	1ad3      	subs	r3, r2, r3
 8011d4c:	0fdb      	lsrs	r3, r3, #31
 8011d4e:	1c1a      	adds	r2, r3, #0
 8011d50:	2301      	movs	r3, #1
 8011d52:	4013      	ands	r3, r2
 8011d54:	b2db      	uxtb	r3, r3
 8011d56:	2b00      	cmp	r3, #0
 8011d58:	d11c      	bne.n	8011d94 <sys_check_timeouts+0x78>
      return;
    }

    /* Timeout has expired */
    next_timeout = tmptimeout->next;
 8011d5a:	68bb      	ldr	r3, [r7, #8]
 8011d5c:	681a      	ldr	r2, [r3, #0]
 8011d5e:	4b10      	ldr	r3, [pc, #64]	; (8011da0 <sys_check_timeouts+0x84>)
 8011d60:	601a      	str	r2, [r3, #0]
    handler = tmptimeout->h;
 8011d62:	68bb      	ldr	r3, [r7, #8]
 8011d64:	689b      	ldr	r3, [r3, #8]
 8011d66:	607b      	str	r3, [r7, #4]
    arg = tmptimeout->arg;
 8011d68:	68bb      	ldr	r3, [r7, #8]
 8011d6a:	68db      	ldr	r3, [r3, #12]
 8011d6c:	603b      	str	r3, [r7, #0]
    current_timeout_due_time = tmptimeout->time;
 8011d6e:	68bb      	ldr	r3, [r7, #8]
 8011d70:	685a      	ldr	r2, [r3, #4]
 8011d72:	4b0c      	ldr	r3, [pc, #48]	; (8011da4 <sys_check_timeouts+0x88>)
 8011d74:	601a      	str	r2, [r3, #0]
    if (handler != NULL) {
      LWIP_DEBUGF(TIMERS_DEBUG, ("sct calling h=%s t=%"U32_F" arg=%p\n",
                                 tmptimeout->handler_name, sys_now() - tmptimeout->time, arg));
    }
#endif /* LWIP_DEBUG_TIMERNAMES */
    memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
 8011d76:	68bb      	ldr	r3, [r7, #8]
 8011d78:	0019      	movs	r1, r3
 8011d7a:	2004      	movs	r0, #4
 8011d7c:	f7f6 fd94 	bl	80088a8 <memp_free>
    if (handler != NULL) {
 8011d80:	687b      	ldr	r3, [r7, #4]
 8011d82:	2b00      	cmp	r3, #0
 8011d84:	d0d1      	beq.n	8011d2a <sys_check_timeouts+0xe>
      handler(arg);
 8011d86:	683a      	ldr	r2, [r7, #0]
 8011d88:	687b      	ldr	r3, [r7, #4]
 8011d8a:	0010      	movs	r0, r2
 8011d8c:	4798      	blx	r3
  do {
 8011d8e:	e7cc      	b.n	8011d2a <sys_check_timeouts+0xe>
      return;
 8011d90:	46c0      	nop			; (mov r8, r8)
 8011d92:	e000      	b.n	8011d96 <sys_check_timeouts+0x7a>
      return;
 8011d94:	46c0      	nop			; (mov r8, r8)
    }
    LWIP_TCPIP_THREAD_ALIVE();

    /* Repeat until all expired timers have been called */
  } while (1);
}
 8011d96:	46bd      	mov	sp, r7
 8011d98:	b004      	add	sp, #16
 8011d9a:	bd80      	pop	{r7, pc}
 8011d9c:	20002b10 	.word	0x20002b10
 8011da0:	20001394 	.word	0x20001394
 8011da4:	20001398 	.word	0x20001398

08011da8 <udp_init>:
/**
 * Initialize this module.
 */
void
udp_init(void)
{
 8011da8:	b580      	push	{r7, lr}
 8011daa:	af00      	add	r7, sp, #0
#ifdef LWIP_RAND
  udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
 8011dac:	f00a fcbe 	bl	801c72c <sys_rand>
 8011db0:	0003      	movs	r3, r0
 8011db2:	b29b      	uxth	r3, r3
 8011db4:	049b      	lsls	r3, r3, #18
 8011db6:	0c9b      	lsrs	r3, r3, #18
 8011db8:	b29b      	uxth	r3, r3
 8011dba:	4a04      	ldr	r2, [pc, #16]	; (8011dcc <udp_init+0x24>)
 8011dbc:	4694      	mov	ip, r2
 8011dbe:	4463      	add	r3, ip
 8011dc0:	b29a      	uxth	r2, r3
 8011dc2:	4b03      	ldr	r3, [pc, #12]	; (8011dd0 <udp_init+0x28>)
 8011dc4:	801a      	strh	r2, [r3, #0]
#endif /* LWIP_RAND */
}
 8011dc6:	46c0      	nop			; (mov r8, r8)
 8011dc8:	46bd      	mov	sp, r7
 8011dca:	bd80      	pop	{r7, pc}
 8011dcc:	ffffc000 	.word	0xffffc000
 8011dd0:	20000214 	.word	0x20000214

08011dd4 <udp_new_port>:
 *
 * @return a new (free) local UDP port number
 */
static u16_t
udp_new_port(void)
{
 8011dd4:	b580      	push	{r7, lr}
 8011dd6:	b082      	sub	sp, #8
 8011dd8:	af00      	add	r7, sp, #0
  u16_t n = 0;
 8011dda:	1dbb      	adds	r3, r7, #6
 8011ddc:	2200      	movs	r2, #0
 8011dde:	801a      	strh	r2, [r3, #0]
  struct udp_pcb *pcb;

again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 8011de0:	4b17      	ldr	r3, [pc, #92]	; (8011e40 <udp_new_port+0x6c>)
 8011de2:	881b      	ldrh	r3, [r3, #0]
 8011de4:	1c5a      	adds	r2, r3, #1
 8011de6:	b291      	uxth	r1, r2
 8011de8:	4a15      	ldr	r2, [pc, #84]	; (8011e40 <udp_new_port+0x6c>)
 8011dea:	8011      	strh	r1, [r2, #0]
 8011dec:	4a15      	ldr	r2, [pc, #84]	; (8011e44 <udp_new_port+0x70>)
 8011dee:	4293      	cmp	r3, r2
 8011df0:	d102      	bne.n	8011df8 <udp_new_port+0x24>
    udp_port = UDP_LOCAL_PORT_RANGE_START;
 8011df2:	4b13      	ldr	r3, [pc, #76]	; (8011e40 <udp_new_port+0x6c>)
 8011df4:	4a14      	ldr	r2, [pc, #80]	; (8011e48 <udp_new_port+0x74>)
 8011df6:	801a      	strh	r2, [r3, #0]
  }
  /* Check all PCBs. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8011df8:	4b14      	ldr	r3, [pc, #80]	; (8011e4c <udp_new_port+0x78>)
 8011dfa:	681b      	ldr	r3, [r3, #0]
 8011dfc:	603b      	str	r3, [r7, #0]
 8011dfe:	e015      	b.n	8011e2c <udp_new_port+0x58>
    if (pcb->local_port == udp_port) {
 8011e00:	683b      	ldr	r3, [r7, #0]
 8011e02:	8ada      	ldrh	r2, [r3, #22]
 8011e04:	4b0e      	ldr	r3, [pc, #56]	; (8011e40 <udp_new_port+0x6c>)
 8011e06:	881b      	ldrh	r3, [r3, #0]
 8011e08:	429a      	cmp	r2, r3
 8011e0a:	d10c      	bne.n	8011e26 <udp_new_port+0x52>
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 8011e0c:	1dbb      	adds	r3, r7, #6
 8011e0e:	1dba      	adds	r2, r7, #6
 8011e10:	8812      	ldrh	r2, [r2, #0]
 8011e12:	3201      	adds	r2, #1
 8011e14:	801a      	strh	r2, [r3, #0]
 8011e16:	1dbb      	adds	r3, r7, #6
 8011e18:	881a      	ldrh	r2, [r3, #0]
 8011e1a:	2380      	movs	r3, #128	; 0x80
 8011e1c:	01db      	lsls	r3, r3, #7
 8011e1e:	429a      	cmp	r2, r3
 8011e20:	d3de      	bcc.n	8011de0 <udp_new_port+0xc>
        return 0;
 8011e22:	2300      	movs	r3, #0
 8011e24:	e007      	b.n	8011e36 <udp_new_port+0x62>
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8011e26:	683b      	ldr	r3, [r7, #0]
 8011e28:	691b      	ldr	r3, [r3, #16]
 8011e2a:	603b      	str	r3, [r7, #0]
 8011e2c:	683b      	ldr	r3, [r7, #0]
 8011e2e:	2b00      	cmp	r3, #0
 8011e30:	d1e6      	bne.n	8011e00 <udp_new_port+0x2c>
      }
      goto again;
    }
  }
  return udp_port;
 8011e32:	4b03      	ldr	r3, [pc, #12]	; (8011e40 <udp_new_port+0x6c>)
 8011e34:	881b      	ldrh	r3, [r3, #0]
}
 8011e36:	0018      	movs	r0, r3
 8011e38:	46bd      	mov	sp, r7
 8011e3a:	b002      	add	sp, #8
 8011e3c:	bd80      	pop	{r7, pc}
 8011e3e:	46c0      	nop			; (mov r8, r8)
 8011e40:	20000214 	.word	0x20000214
 8011e44:	0000ffff 	.word	0x0000ffff
 8011e48:	ffffc000 	.word	0xffffc000
 8011e4c:	20002b30 	.word	0x20002b30

08011e50 <udp_input_local_match>:
 * @param broadcast 1 if his is an IPv4 broadcast (global or subnet-only), 0 otherwise (only used for IPv4)
 * @return 1 on match, 0 otherwise
 */
static u8_t
udp_input_local_match(struct udp_pcb *pcb, struct netif *inp, u8_t broadcast)
{
 8011e50:	b580      	push	{r7, lr}
 8011e52:	b084      	sub	sp, #16
 8011e54:	af00      	add	r7, sp, #0
 8011e56:	60f8      	str	r0, [r7, #12]
 8011e58:	60b9      	str	r1, [r7, #8]
 8011e5a:	1dfb      	adds	r3, r7, #7
 8011e5c:	701a      	strb	r2, [r3, #0]
  LWIP_UNUSED_ARG(inp);       /* in IPv6 only case */
  LWIP_UNUSED_ARG(broadcast); /* in IPv6 only case */

  LWIP_ASSERT("udp_input_local_match: invalid pcb", pcb != NULL);
 8011e5e:	68fb      	ldr	r3, [r7, #12]
 8011e60:	2b00      	cmp	r3, #0
 8011e62:	d105      	bne.n	8011e70 <udp_input_local_match+0x20>
 8011e64:	4b26      	ldr	r3, [pc, #152]	; (8011f00 <udp_input_local_match+0xb0>)
 8011e66:	4927      	ldr	r1, [pc, #156]	; (8011f04 <udp_input_local_match+0xb4>)
 8011e68:	4827      	ldr	r0, [pc, #156]	; (8011f08 <udp_input_local_match+0xb8>)
 8011e6a:	2287      	movs	r2, #135	; 0x87
 8011e6c:	f7f0 f9ae 	bl	80021cc <app_debug_rtt_raw>
  LWIP_ASSERT("udp_input_local_match: invalid netif", inp != NULL);
 8011e70:	68bb      	ldr	r3, [r7, #8]
 8011e72:	2b00      	cmp	r3, #0
 8011e74:	d105      	bne.n	8011e82 <udp_input_local_match+0x32>
 8011e76:	4b22      	ldr	r3, [pc, #136]	; (8011f00 <udp_input_local_match+0xb0>)
 8011e78:	4924      	ldr	r1, [pc, #144]	; (8011f0c <udp_input_local_match+0xbc>)
 8011e7a:	4823      	ldr	r0, [pc, #140]	; (8011f08 <udp_input_local_match+0xb8>)
 8011e7c:	2288      	movs	r2, #136	; 0x88
 8011e7e:	f7f0 f9a5 	bl	80021cc <app_debug_rtt_raw>

  /* check if PCB is bound to specific netif */
  if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 8011e82:	68fb      	ldr	r3, [r7, #12]
 8011e84:	7a1b      	ldrb	r3, [r3, #8]
 8011e86:	2b00      	cmp	r3, #0
 8011e88:	d00b      	beq.n	8011ea2 <udp_input_local_match+0x52>
      (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
 8011e8a:	68fb      	ldr	r3, [r7, #12]
 8011e8c:	7a1a      	ldrb	r2, [r3, #8]
 8011e8e:	4b20      	ldr	r3, [pc, #128]	; (8011f10 <udp_input_local_match+0xc0>)
 8011e90:	685b      	ldr	r3, [r3, #4]
 8011e92:	2134      	movs	r1, #52	; 0x34
 8011e94:	5c5b      	ldrb	r3, [r3, r1]
 8011e96:	3301      	adds	r3, #1
 8011e98:	b2db      	uxtb	r3, r3
  if ((pcb->netif_idx != NETIF_NO_INDEX) &&
 8011e9a:	429a      	cmp	r2, r3
 8011e9c:	d001      	beq.n	8011ea2 <udp_input_local_match+0x52>
    return 0;
 8011e9e:	2300      	movs	r3, #0
 8011ea0:	e02a      	b.n	8011ef8 <udp_input_local_match+0xa8>
  /* Only need to check PCB if incoming IP version matches PCB IP version */
  if (IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ip_current_dest_addr())) {
#if LWIP_IPV4
    /* Special case: IPv4 broadcast: all or broadcasts in my subnet
     * Note: broadcast variable can only be 1 if it is an IPv4 broadcast */
    if (broadcast != 0) {
 8011ea2:	1dfb      	adds	r3, r7, #7
 8011ea4:	781b      	ldrb	r3, [r3, #0]
 8011ea6:	2b00      	cmp	r3, #0
 8011ea8:	d016      	beq.n	8011ed8 <udp_input_local_match+0x88>
#if IP_SOF_BROADCAST_RECV
      if (ip_get_option(pcb, SOF_BROADCAST))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 8011eaa:	68fb      	ldr	r3, [r7, #12]
 8011eac:	2b00      	cmp	r3, #0
 8011eae:	d011      	beq.n	8011ed4 <udp_input_local_match+0x84>
 8011eb0:	68fb      	ldr	r3, [r7, #12]
 8011eb2:	681b      	ldr	r3, [r3, #0]
 8011eb4:	2b00      	cmp	r3, #0
 8011eb6:	d00d      	beq.n	8011ed4 <udp_input_local_match+0x84>
            ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 8011eb8:	4b15      	ldr	r3, [pc, #84]	; (8011f10 <udp_input_local_match+0xc0>)
 8011eba:	695b      	ldr	r3, [r3, #20]
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 8011ebc:	3301      	adds	r3, #1
 8011ebe:	d009      	beq.n	8011ed4 <udp_input_local_match+0x84>
            ip4_addr_netcmp(ip_2_ip4(&pcb->local_ip), ip4_current_dest_addr(), netif_ip4_netmask(inp))) {
 8011ec0:	68fb      	ldr	r3, [r7, #12]
 8011ec2:	681a      	ldr	r2, [r3, #0]
 8011ec4:	4b12      	ldr	r3, [pc, #72]	; (8011f10 <udp_input_local_match+0xc0>)
 8011ec6:	695b      	ldr	r3, [r3, #20]
 8011ec8:	405a      	eors	r2, r3
 8011eca:	68bb      	ldr	r3, [r7, #8]
 8011ecc:	3308      	adds	r3, #8
 8011ece:	681b      	ldr	r3, [r3, #0]
 8011ed0:	4013      	ands	r3, r2
            ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 8011ed2:	d110      	bne.n	8011ef6 <udp_input_local_match+0xa6>
          return 1;
 8011ed4:	2301      	movs	r3, #1
 8011ed6:	e00f      	b.n	8011ef8 <udp_input_local_match+0xa8>
        }
      }
    } else
#endif /* LWIP_IPV4 */
      /* Handle IPv4 and IPv6: all or exact match */
      if (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 8011ed8:	68fb      	ldr	r3, [r7, #12]
 8011eda:	2b00      	cmp	r3, #0
 8011edc:	d009      	beq.n	8011ef2 <udp_input_local_match+0xa2>
 8011ede:	68fb      	ldr	r3, [r7, #12]
 8011ee0:	681b      	ldr	r3, [r3, #0]
 8011ee2:	2b00      	cmp	r3, #0
 8011ee4:	d005      	beq.n	8011ef2 <udp_input_local_match+0xa2>
 8011ee6:	68fb      	ldr	r3, [r7, #12]
 8011ee8:	681a      	ldr	r2, [r3, #0]
 8011eea:	4b09      	ldr	r3, [pc, #36]	; (8011f10 <udp_input_local_match+0xc0>)
 8011eec:	695b      	ldr	r3, [r3, #20]
 8011eee:	429a      	cmp	r2, r3
 8011ef0:	d101      	bne.n	8011ef6 <udp_input_local_match+0xa6>
        return 1;
 8011ef2:	2301      	movs	r3, #1
 8011ef4:	e000      	b.n	8011ef8 <udp_input_local_match+0xa8>
      }
  }

  return 0;
 8011ef6:	2300      	movs	r3, #0
}
 8011ef8:	0018      	movs	r0, r3
 8011efa:	46bd      	mov	sp, r7
 8011efc:	b004      	add	sp, #16
 8011efe:	bd80      	pop	{r7, pc}
 8011f00:	08020814 	.word	0x08020814
 8011f04:	0802083c 	.word	0x0802083c
 8011f08:	08020860 	.word	0x08020860
 8011f0c:	0802088c 	.word	0x0802088c
 8011f10:	200014c4 	.word	0x200014c4

08011f14 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 8011f14:	b5b0      	push	{r4, r5, r7, lr}
 8011f16:	b08c      	sub	sp, #48	; 0x30
 8011f18:	af02      	add	r7, sp, #8
 8011f1a:	6078      	str	r0, [r7, #4]
 8011f1c:	6039      	str	r1, [r7, #0]
  struct udp_hdr *udphdr;
  struct udp_pcb *pcb, *prev;
  struct udp_pcb *uncon_pcb;
  u16_t src, dest;
  u8_t broadcast;
  u8_t for_us = 0;
 8011f1e:	231b      	movs	r3, #27
 8011f20:	18fb      	adds	r3, r7, r3
 8011f22:	2200      	movs	r2, #0
 8011f24:	701a      	strb	r2, [r3, #0]

  LWIP_UNUSED_ARG(inp);

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("udp_input: invalid pbuf", p != NULL);
 8011f26:	687b      	ldr	r3, [r7, #4]
 8011f28:	2b00      	cmp	r3, #0
 8011f2a:	d105      	bne.n	8011f38 <udp_input+0x24>
 8011f2c:	4ba1      	ldr	r3, [pc, #644]	; (80121b4 <udp_input+0x2a0>)
 8011f2e:	49a2      	ldr	r1, [pc, #648]	; (80121b8 <udp_input+0x2a4>)
 8011f30:	48a2      	ldr	r0, [pc, #648]	; (80121bc <udp_input+0x2a8>)
 8011f32:	22cf      	movs	r2, #207	; 0xcf
 8011f34:	f7f0 f94a 	bl	80021cc <app_debug_rtt_raw>
  LWIP_ASSERT("udp_input: invalid netif", inp != NULL);
 8011f38:	683b      	ldr	r3, [r7, #0]
 8011f3a:	2b00      	cmp	r3, #0
 8011f3c:	d105      	bne.n	8011f4a <udp_input+0x36>
 8011f3e:	4b9d      	ldr	r3, [pc, #628]	; (80121b4 <udp_input+0x2a0>)
 8011f40:	499f      	ldr	r1, [pc, #636]	; (80121c0 <udp_input+0x2ac>)
 8011f42:	489e      	ldr	r0, [pc, #632]	; (80121bc <udp_input+0x2a8>)
 8011f44:	22d0      	movs	r2, #208	; 0xd0
 8011f46:	f7f0 f941 	bl	80021cc <app_debug_rtt_raw>
  PERF_START;

  UDP_STATS_INC(udp.recv);

  /* Check minimum length (UDP header) */
  if (p->len < UDP_HLEN) {
 8011f4a:	687b      	ldr	r3, [r7, #4]
 8011f4c:	895b      	ldrh	r3, [r3, #10]
 8011f4e:	2b07      	cmp	r3, #7
 8011f50:	d804      	bhi.n	8011f5c <udp_input+0x48>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    MIB2_STATS_INC(mib2.udpinerrors);
    pbuf_free(p);
 8011f52:	687b      	ldr	r3, [r7, #4]
 8011f54:	0018      	movs	r0, r3
 8011f56:	f7f7 fb9d 	bl	8009694 <pbuf_free>
    goto end;
 8011f5a:	e121      	b.n	80121a0 <udp_input+0x28c>
  }

  udphdr = (struct udp_hdr *)p->payload;
 8011f5c:	687b      	ldr	r3, [r7, #4]
 8011f5e:	685b      	ldr	r3, [r3, #4]
 8011f60:	617b      	str	r3, [r7, #20]

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
 8011f62:	4b98      	ldr	r3, [pc, #608]	; (80121c4 <udp_input+0x2b0>)
 8011f64:	695a      	ldr	r2, [r3, #20]
 8011f66:	4b97      	ldr	r3, [pc, #604]	; (80121c4 <udp_input+0x2b0>)
 8011f68:	681b      	ldr	r3, [r3, #0]
 8011f6a:	2113      	movs	r1, #19
 8011f6c:	187c      	adds	r4, r7, r1
 8011f6e:	0019      	movs	r1, r3
 8011f70:	0010      	movs	r0, r2
 8011f72:	f001 fbc3 	bl	80136fc <ip4_addr_isbroadcast_u32>
 8011f76:	0003      	movs	r3, r0
 8011f78:	7023      	strb	r3, [r4, #0]

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = lwip_ntohs(udphdr->src);
 8011f7a:	697b      	ldr	r3, [r7, #20]
 8011f7c:	781a      	ldrb	r2, [r3, #0]
 8011f7e:	785b      	ldrb	r3, [r3, #1]
 8011f80:	021b      	lsls	r3, r3, #8
 8011f82:	4313      	orrs	r3, r2
 8011f84:	b29b      	uxth	r3, r3
 8011f86:	2210      	movs	r2, #16
 8011f88:	18bc      	adds	r4, r7, r2
 8011f8a:	0018      	movs	r0, r3
 8011f8c:	f7f4 fad2 	bl	8006534 <lwip_htons>
 8011f90:	0003      	movs	r3, r0
 8011f92:	8023      	strh	r3, [r4, #0]
  dest = lwip_ntohs(udphdr->dest);
 8011f94:	697b      	ldr	r3, [r7, #20]
 8011f96:	789a      	ldrb	r2, [r3, #2]
 8011f98:	78db      	ldrb	r3, [r3, #3]
 8011f9a:	021b      	lsls	r3, r3, #8
 8011f9c:	4313      	orrs	r3, r2
 8011f9e:	b29b      	uxth	r3, r3
 8011fa0:	220e      	movs	r2, #14
 8011fa2:	18bc      	adds	r4, r7, r2
 8011fa4:	0018      	movs	r0, r3
 8011fa6:	f7f4 fac5 	bl	8006534 <lwip_htons>
 8011faa:	0003      	movs	r3, r0
 8011fac:	8023      	strh	r3, [r4, #0]
  ip_addr_debug_print_val(UDP_DEBUG, *ip_current_dest_addr());
  LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", lwip_ntohs(udphdr->dest)));
  ip_addr_debug_print_val(UDP_DEBUG, *ip_current_src_addr());
  LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", lwip_ntohs(udphdr->src)));

  pcb = NULL;
 8011fae:	2300      	movs	r3, #0
 8011fb0:	61fb      	str	r3, [r7, #28]
  prev = NULL;
 8011fb2:	2300      	movs	r3, #0
 8011fb4:	623b      	str	r3, [r7, #32]
  uncon_pcb = NULL;
 8011fb6:	2300      	movs	r3, #0
 8011fb8:	627b      	str	r3, [r7, #36]	; 0x24
  /* Iterate through the UDP pcb list for a matching pcb.
   * 'Perfect match' pcbs (connected to the remote port & ip address) are
   * preferred. If no perfect match is found, the first unconnected pcb that
   * matches the local port and ip address gets the datagram. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8011fba:	4b83      	ldr	r3, [pc, #524]	; (80121c8 <udp_input+0x2b4>)
 8011fbc:	681b      	ldr	r3, [r3, #0]
 8011fbe:	61fb      	str	r3, [r7, #28]
 8011fc0:	e066      	b.n	8012090 <udp_input+0x17c>
    LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", pcb->local_port));
    ip_addr_debug_print_val(UDP_DEBUG, pcb->remote_ip);
    LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", pcb->remote_port));

    /* compare PCB local addr+port to UDP destination addr+port */
    if ((pcb->local_port == dest) &&
 8011fc2:	69fb      	ldr	r3, [r7, #28]
 8011fc4:	8adb      	ldrh	r3, [r3, #22]
 8011fc6:	220e      	movs	r2, #14
 8011fc8:	18ba      	adds	r2, r7, r2
 8011fca:	8812      	ldrh	r2, [r2, #0]
 8011fcc:	429a      	cmp	r2, r3
 8011fce:	d15a      	bne.n	8012086 <udp_input+0x172>
        (udp_input_local_match(pcb, inp, broadcast) != 0)) {
 8011fd0:	2313      	movs	r3, #19
 8011fd2:	18fb      	adds	r3, r7, r3
 8011fd4:	781a      	ldrb	r2, [r3, #0]
 8011fd6:	6839      	ldr	r1, [r7, #0]
 8011fd8:	69fb      	ldr	r3, [r7, #28]
 8011fda:	0018      	movs	r0, r3
 8011fdc:	f7ff ff38 	bl	8011e50 <udp_input_local_match>
 8011fe0:	1e03      	subs	r3, r0, #0
    if ((pcb->local_port == dest) &&
 8011fe2:	d050      	beq.n	8012086 <udp_input+0x172>
      if ((pcb->flags & UDP_FLAGS_CONNECTED) == 0) {
 8011fe4:	69fb      	ldr	r3, [r7, #28]
 8011fe6:	7d1b      	ldrb	r3, [r3, #20]
 8011fe8:	001a      	movs	r2, r3
 8011fea:	2304      	movs	r3, #4
 8011fec:	4013      	ands	r3, r2
 8011fee:	d12a      	bne.n	8012046 <udp_input+0x132>
        if (uncon_pcb == NULL) {
 8011ff0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011ff2:	2b00      	cmp	r3, #0
 8011ff4:	d102      	bne.n	8011ffc <udp_input+0xe8>
          /* the first unconnected matching PCB */
          uncon_pcb = pcb;
 8011ff6:	69fb      	ldr	r3, [r7, #28]
 8011ff8:	627b      	str	r3, [r7, #36]	; 0x24
 8011ffa:	e024      	b.n	8012046 <udp_input+0x132>
#if LWIP_IPV4
        } else if (broadcast && ip4_current_dest_addr()->addr == IPADDR_BROADCAST) {
 8011ffc:	2313      	movs	r3, #19
 8011ffe:	18fb      	adds	r3, r7, r3
 8012000:	781b      	ldrb	r3, [r3, #0]
 8012002:	2b00      	cmp	r3, #0
 8012004:	d014      	beq.n	8012030 <udp_input+0x11c>
 8012006:	4b6f      	ldr	r3, [pc, #444]	; (80121c4 <udp_input+0x2b0>)
 8012008:	695b      	ldr	r3, [r3, #20]
 801200a:	3301      	adds	r3, #1
 801200c:	d110      	bne.n	8012030 <udp_input+0x11c>
          /* global broadcast address (only valid for IPv4; match was checked before) */
          if (!IP_IS_V4_VAL(uncon_pcb->local_ip) || !ip4_addr_cmp(ip_2_ip4(&uncon_pcb->local_ip), netif_ip4_addr(inp))) {
 801200e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012010:	681a      	ldr	r2, [r3, #0]
 8012012:	683b      	ldr	r3, [r7, #0]
 8012014:	3304      	adds	r3, #4
 8012016:	681b      	ldr	r3, [r3, #0]
 8012018:	429a      	cmp	r2, r3
 801201a:	d013      	beq.n	8012044 <udp_input+0x130>
            /* uncon_pcb does not match the input netif, check this pcb */
            if (IP_IS_V4_VAL(pcb->local_ip) && ip4_addr_cmp(ip_2_ip4(&pcb->local_ip), netif_ip4_addr(inp))) {
 801201c:	69fb      	ldr	r3, [r7, #28]
 801201e:	681a      	ldr	r2, [r3, #0]
 8012020:	683b      	ldr	r3, [r7, #0]
 8012022:	3304      	adds	r3, #4
 8012024:	681b      	ldr	r3, [r3, #0]
 8012026:	429a      	cmp	r2, r3
 8012028:	d10c      	bne.n	8012044 <udp_input+0x130>
              /* better match */
              uncon_pcb = pcb;
 801202a:	69fb      	ldr	r3, [r7, #28]
 801202c:	627b      	str	r3, [r7, #36]	; 0x24
          if (!IP_IS_V4_VAL(uncon_pcb->local_ip) || !ip4_addr_cmp(ip_2_ip4(&uncon_pcb->local_ip), netif_ip4_addr(inp))) {
 801202e:	e009      	b.n	8012044 <udp_input+0x130>
            }
          }
#endif /* LWIP_IPV4 */
        }
#if SO_REUSE
        else if (!ip_addr_isany(&pcb->local_ip)) {
 8012030:	69fb      	ldr	r3, [r7, #28]
 8012032:	2b00      	cmp	r3, #0
 8012034:	d007      	beq.n	8012046 <udp_input+0x132>
 8012036:	69fb      	ldr	r3, [r7, #28]
 8012038:	681b      	ldr	r3, [r3, #0]
 801203a:	2b00      	cmp	r3, #0
 801203c:	d003      	beq.n	8012046 <udp_input+0x132>
          /* prefer specific IPs over catch-all */
          uncon_pcb = pcb;
 801203e:	69fb      	ldr	r3, [r7, #28]
 8012040:	627b      	str	r3, [r7, #36]	; 0x24
 8012042:	e000      	b.n	8012046 <udp_input+0x132>
          if (!IP_IS_V4_VAL(uncon_pcb->local_ip) || !ip4_addr_cmp(ip_2_ip4(&uncon_pcb->local_ip), netif_ip4_addr(inp))) {
 8012044:	46c0      	nop			; (mov r8, r8)
        }
#endif /* SO_REUSE */
      }

      /* compare PCB remote addr+port to UDP source addr+port */
      if ((pcb->remote_port == src) &&
 8012046:	69fb      	ldr	r3, [r7, #28]
 8012048:	8b1b      	ldrh	r3, [r3, #24]
 801204a:	2210      	movs	r2, #16
 801204c:	18ba      	adds	r2, r7, r2
 801204e:	8812      	ldrh	r2, [r2, #0]
 8012050:	429a      	cmp	r2, r3
 8012052:	d118      	bne.n	8012086 <udp_input+0x172>
          (ip_addr_isany_val(pcb->remote_ip) ||
 8012054:	69fb      	ldr	r3, [r7, #28]
 8012056:	685b      	ldr	r3, [r3, #4]
      if ((pcb->remote_port == src) &&
 8012058:	2b00      	cmp	r3, #0
 801205a:	d005      	beq.n	8012068 <udp_input+0x154>
           ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
 801205c:	69fb      	ldr	r3, [r7, #28]
 801205e:	685a      	ldr	r2, [r3, #4]
 8012060:	4b58      	ldr	r3, [pc, #352]	; (80121c4 <udp_input+0x2b0>)
 8012062:	691b      	ldr	r3, [r3, #16]
          (ip_addr_isany_val(pcb->remote_ip) ||
 8012064:	429a      	cmp	r2, r3
 8012066:	d10e      	bne.n	8012086 <udp_input+0x172>
        /* the first fully matching PCB */
        if (prev != NULL) {
 8012068:	6a3b      	ldr	r3, [r7, #32]
 801206a:	2b00      	cmp	r3, #0
 801206c:	d014      	beq.n	8012098 <udp_input+0x184>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
 801206e:	69fb      	ldr	r3, [r7, #28]
 8012070:	691a      	ldr	r2, [r3, #16]
 8012072:	6a3b      	ldr	r3, [r7, #32]
 8012074:	611a      	str	r2, [r3, #16]
          pcb->next = udp_pcbs;
 8012076:	4b54      	ldr	r3, [pc, #336]	; (80121c8 <udp_input+0x2b4>)
 8012078:	681a      	ldr	r2, [r3, #0]
 801207a:	69fb      	ldr	r3, [r7, #28]
 801207c:	611a      	str	r2, [r3, #16]
          udp_pcbs = pcb;
 801207e:	4b52      	ldr	r3, [pc, #328]	; (80121c8 <udp_input+0x2b4>)
 8012080:	69fa      	ldr	r2, [r7, #28]
 8012082:	601a      	str	r2, [r3, #0]
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
 8012084:	e008      	b.n	8012098 <udp_input+0x184>
      }
    }

    prev = pcb;
 8012086:	69fb      	ldr	r3, [r7, #28]
 8012088:	623b      	str	r3, [r7, #32]
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 801208a:	69fb      	ldr	r3, [r7, #28]
 801208c:	691b      	ldr	r3, [r3, #16]
 801208e:	61fb      	str	r3, [r7, #28]
 8012090:	69fb      	ldr	r3, [r7, #28]
 8012092:	2b00      	cmp	r3, #0
 8012094:	d195      	bne.n	8011fc2 <udp_input+0xae>
 8012096:	e000      	b.n	801209a <udp_input+0x186>
        break;
 8012098:	46c0      	nop			; (mov r8, r8)
  }
  /* no fully matching pcb found? then look for an unconnected pcb */
  if (pcb == NULL) {
 801209a:	69fb      	ldr	r3, [r7, #28]
 801209c:	2b00      	cmp	r3, #0
 801209e:	d101      	bne.n	80120a4 <udp_input+0x190>
    pcb = uncon_pcb;
 80120a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80120a2:	61fb      	str	r3, [r7, #28]
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL) {
 80120a4:	69fb      	ldr	r3, [r7, #28]
 80120a6:	2b00      	cmp	r3, #0
 80120a8:	d004      	beq.n	80120b4 <udp_input+0x1a0>
    for_us = 1;
 80120aa:	231b      	movs	r3, #27
 80120ac:	18fb      	adds	r3, r7, r3
 80120ae:	2201      	movs	r2, #1
 80120b0:	701a      	strb	r2, [r3, #0]
 80120b2:	e00b      	b.n	80120cc <udp_input+0x1b8>
      for_us = netif_get_ip6_addr_match(inp, ip6_current_dest_addr()) >= 0;
    }
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
    if (!ip_current_is_v6()) {
      for_us = ip4_addr_cmp(netif_ip4_addr(inp), ip4_current_dest_addr());
 80120b4:	683b      	ldr	r3, [r7, #0]
 80120b6:	3304      	adds	r3, #4
 80120b8:	681a      	ldr	r2, [r3, #0]
 80120ba:	4b42      	ldr	r3, [pc, #264]	; (80121c4 <udp_input+0x2b0>)
 80120bc:	695b      	ldr	r3, [r3, #20]
 80120be:	1ad3      	subs	r3, r2, r3
 80120c0:	425a      	negs	r2, r3
 80120c2:	4153      	adcs	r3, r2
 80120c4:	b2da      	uxtb	r2, r3
 80120c6:	231b      	movs	r3, #27
 80120c8:	18fb      	adds	r3, r7, r3
 80120ca:	701a      	strb	r2, [r3, #0]
    }
#endif /* LWIP_IPV4 */
  }

  if (for_us) {
 80120cc:	231b      	movs	r3, #27
 80120ce:	18fb      	adds	r3, r7, r3
 80120d0:	781b      	ldrb	r3, [r3, #0]
 80120d2:	2b00      	cmp	r3, #0
 80120d4:	d05f      	beq.n	8012196 <udp_input+0x282>
          goto chkerr;
        }
      } else
#endif /* LWIP_UDPLITE */
      {
        if (udphdr->chksum != 0) {
 80120d6:	697b      	ldr	r3, [r7, #20]
 80120d8:	799a      	ldrb	r2, [r3, #6]
 80120da:	79db      	ldrb	r3, [r3, #7]
 80120dc:	021b      	lsls	r3, r3, #8
 80120de:	4313      	orrs	r3, r2
 80120e0:	b29b      	uxth	r3, r3
 80120e2:	2b00      	cmp	r3, #0
 80120e4:	d00b      	beq.n	80120fe <udp_input+0x1ea>
          if (ip_chksum_pseudo(p, IP_PROTO_UDP, p->tot_len,
 80120e6:	687b      	ldr	r3, [r7, #4]
 80120e8:	891a      	ldrh	r2, [r3, #8]
 80120ea:	4938      	ldr	r1, [pc, #224]	; (80121cc <udp_input+0x2b8>)
 80120ec:	6878      	ldr	r0, [r7, #4]
 80120ee:	4b38      	ldr	r3, [pc, #224]	; (80121d0 <udp_input+0x2bc>)
 80120f0:	9300      	str	r3, [sp, #0]
 80120f2:	000b      	movs	r3, r1
 80120f4:	2111      	movs	r1, #17
 80120f6:	f7f5 fcc6 	bl	8007a86 <ip_chksum_pseudo>
 80120fa:	1e03      	subs	r3, r0, #0
 80120fc:	d151      	bne.n	80121a2 <udp_input+0x28e>
          }
        }
      }
    }
#endif /* CHECKSUM_CHECK_UDP */
    if (pbuf_remove_header(p, UDP_HLEN)) {
 80120fe:	687b      	ldr	r3, [r7, #4]
 8012100:	2108      	movs	r1, #8
 8012102:	0018      	movs	r0, r3
 8012104:	f7f7 f9ee 	bl	80094e4 <pbuf_remove_header>
 8012108:	1e03      	subs	r3, r0, #0
 801210a:	d00b      	beq.n	8012124 <udp_input+0x210>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 801210c:	4b29      	ldr	r3, [pc, #164]	; (80121b4 <udp_input+0x2a0>)
 801210e:	22b8      	movs	r2, #184	; 0xb8
 8012110:	0052      	lsls	r2, r2, #1
 8012112:	4930      	ldr	r1, [pc, #192]	; (80121d4 <udp_input+0x2c0>)
 8012114:	4829      	ldr	r0, [pc, #164]	; (80121bc <udp_input+0x2a8>)
 8012116:	f7f0 f859 	bl	80021cc <app_debug_rtt_raw>
      UDP_STATS_INC(udp.drop);
      MIB2_STATS_INC(mib2.udpinerrors);
      pbuf_free(p);
 801211a:	687b      	ldr	r3, [r7, #4]
 801211c:	0018      	movs	r0, r3
 801211e:	f7f7 fab9 	bl	8009694 <pbuf_free>
      goto end;
 8012122:	e03d      	b.n	80121a0 <udp_input+0x28c>
    }

    if (pcb != NULL) {
 8012124:	69fb      	ldr	r3, [r7, #28]
 8012126:	2b00      	cmp	r3, #0
 8012128:	d016      	beq.n	8012158 <udp_input+0x244>
          }
        }
      }
#endif /* SO_REUSE && SO_REUSE_RXTOALL */
      /* callback */
      if (pcb->recv != NULL) {
 801212a:	69fb      	ldr	r3, [r7, #28]
 801212c:	69db      	ldr	r3, [r3, #28]
 801212e:	2b00      	cmp	r3, #0
 8012130:	d00d      	beq.n	801214e <udp_input+0x23a>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 8012132:	69fb      	ldr	r3, [r7, #28]
 8012134:	69dc      	ldr	r4, [r3, #28]
 8012136:	69fb      	ldr	r3, [r7, #28]
 8012138:	6a18      	ldr	r0, [r3, #32]
 801213a:	4d24      	ldr	r5, [pc, #144]	; (80121cc <udp_input+0x2b8>)
 801213c:	687a      	ldr	r2, [r7, #4]
 801213e:	69f9      	ldr	r1, [r7, #28]
 8012140:	2310      	movs	r3, #16
 8012142:	18fb      	adds	r3, r7, r3
 8012144:	881b      	ldrh	r3, [r3, #0]
 8012146:	9300      	str	r3, [sp, #0]
 8012148:	002b      	movs	r3, r5
 801214a:	47a0      	blx	r4
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
  return;
 801214c:	e02e      	b.n	80121ac <udp_input+0x298>
        pbuf_free(p);
 801214e:	687b      	ldr	r3, [r7, #4]
 8012150:	0018      	movs	r0, r3
 8012152:	f7f7 fa9f 	bl	8009694 <pbuf_free>
        goto end;
 8012156:	e023      	b.n	80121a0 <udp_input+0x28c>
      if (!broadcast && !ip_addr_ismulticast(ip_current_dest_addr())) {
 8012158:	2313      	movs	r3, #19
 801215a:	18fb      	adds	r3, r7, r3
 801215c:	781b      	ldrb	r3, [r3, #0]
 801215e:	2b00      	cmp	r3, #0
 8012160:	d114      	bne.n	801218c <udp_input+0x278>
 8012162:	4b18      	ldr	r3, [pc, #96]	; (80121c4 <udp_input+0x2b0>)
 8012164:	695b      	ldr	r3, [r3, #20]
 8012166:	22f0      	movs	r2, #240	; 0xf0
 8012168:	4013      	ands	r3, r2
 801216a:	2be0      	cmp	r3, #224	; 0xe0
 801216c:	d00e      	beq.n	801218c <udp_input+0x278>
        pbuf_header_force(p, (s16_t)(ip_current_header_tot_len() + UDP_HLEN));
 801216e:	4b15      	ldr	r3, [pc, #84]	; (80121c4 <udp_input+0x2b0>)
 8012170:	899b      	ldrh	r3, [r3, #12]
 8012172:	3308      	adds	r3, #8
 8012174:	b29b      	uxth	r3, r3
 8012176:	b21a      	sxth	r2, r3
 8012178:	687b      	ldr	r3, [r7, #4]
 801217a:	0011      	movs	r1, r2
 801217c:	0018      	movs	r0, r3
 801217e:	f7f7 fa32 	bl	80095e6 <pbuf_header_force>
        icmp_port_unreach(ip_current_is_v6(), p);
 8012182:	687b      	ldr	r3, [r7, #4]
 8012184:	2103      	movs	r1, #3
 8012186:	0018      	movs	r0, r3
 8012188:	f000 fdc0 	bl	8012d0c <icmp_dest_unreach>
      pbuf_free(p);
 801218c:	687b      	ldr	r3, [r7, #4]
 801218e:	0018      	movs	r0, r3
 8012190:	f7f7 fa80 	bl	8009694 <pbuf_free>
  return;
 8012194:	e00a      	b.n	80121ac <udp_input+0x298>
    pbuf_free(p);
 8012196:	687b      	ldr	r3, [r7, #4]
 8012198:	0018      	movs	r0, r3
 801219a:	f7f7 fa7b 	bl	8009694 <pbuf_free>
  return;
 801219e:	e005      	b.n	80121ac <udp_input+0x298>
 80121a0:	e004      	b.n	80121ac <udp_input+0x298>
            goto chkerr;
 80121a2:	46c0      	nop			; (mov r8, r8)
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
              ("udp_input: UDP (or UDP Lite) datagram discarded due to failing checksum\n"));
  UDP_STATS_INC(udp.chkerr);
  UDP_STATS_INC(udp.drop);
  MIB2_STATS_INC(mib2.udpinerrors);
  pbuf_free(p);
 80121a4:	687b      	ldr	r3, [r7, #4]
 80121a6:	0018      	movs	r0, r3
 80121a8:	f7f7 fa74 	bl	8009694 <pbuf_free>
  PERF_STOP("udp_input");
#endif /* CHECKSUM_CHECK_UDP */
}
 80121ac:	46bd      	mov	sp, r7
 80121ae:	b00a      	add	sp, #40	; 0x28
 80121b0:	bdb0      	pop	{r4, r5, r7, pc}
 80121b2:	46c0      	nop			; (mov r8, r8)
 80121b4:	08020814 	.word	0x08020814
 80121b8:	080208b4 	.word	0x080208b4
 80121bc:	08020860 	.word	0x08020860
 80121c0:	080208cc 	.word	0x080208cc
 80121c4:	200014c4 	.word	0x200014c4
 80121c8:	20002b30 	.word	0x20002b30
 80121cc:	200014d4 	.word	0x200014d4
 80121d0:	200014d8 	.word	0x200014d8
 80121d4:	080208e8 	.word	0x080208e8

080121d8 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
           const ip_addr_t *dst_ip, u16_t dst_port)
{
 80121d8:	b590      	push	{r4, r7, lr}
 80121da:	b087      	sub	sp, #28
 80121dc:	af02      	add	r7, sp, #8
 80121de:	60f8      	str	r0, [r7, #12]
 80121e0:	60b9      	str	r1, [r7, #8]
 80121e2:	607a      	str	r2, [r7, #4]
 80121e4:	001a      	movs	r2, r3
 80121e6:	1cbb      	adds	r3, r7, #2
 80121e8:	801a      	strh	r2, [r3, #0]
#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
  return udp_sendto_chksum(pcb, p, dst_ip, dst_port, 0, 0);
 80121ea:	1cbb      	adds	r3, r7, #2
 80121ec:	881b      	ldrh	r3, [r3, #0]
 80121ee:	687a      	ldr	r2, [r7, #4]
 80121f0:	68b9      	ldr	r1, [r7, #8]
 80121f2:	68f8      	ldr	r0, [r7, #12]
 80121f4:	2400      	movs	r4, #0
 80121f6:	9401      	str	r4, [sp, #4]
 80121f8:	2400      	movs	r4, #0
 80121fa:	9400      	str	r4, [sp, #0]
 80121fc:	f000 f806 	bl	801220c <udp_sendto_chksum>
 8012200:	0003      	movs	r3, r0
}
 8012202:	0018      	movs	r0, r3
 8012204:	46bd      	mov	sp, r7
 8012206:	b005      	add	sp, #20
 8012208:	bd90      	pop	{r4, r7, pc}
	...

0801220c <udp_sendto_chksum>:
/** @ingroup udp_raw
 * Same as udp_sendto(), but with checksum */
err_t
udp_sendto_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
                  u16_t dst_port, u8_t have_chksum, u16_t chksum)
{
 801220c:	b590      	push	{r4, r7, lr}
 801220e:	b08b      	sub	sp, #44	; 0x2c
 8012210:	af04      	add	r7, sp, #16
 8012212:	60f8      	str	r0, [r7, #12]
 8012214:	60b9      	str	r1, [r7, #8]
 8012216:	607a      	str	r2, [r7, #4]
 8012218:	001a      	movs	r2, r3
 801221a:	1cbb      	adds	r3, r7, #2
 801221c:	801a      	strh	r2, [r3, #0]
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  struct netif *netif;

  LWIP_ERROR("udp_sendto: invalid pcb", pcb != NULL, return ERR_ARG);
 801221e:	68fb      	ldr	r3, [r7, #12]
 8012220:	2b00      	cmp	r3, #0
 8012222:	d106      	bne.n	8012232 <udp_sendto_chksum+0x26>
 8012224:	4b24      	ldr	r3, [pc, #144]	; (80122b8 <udp_sendto_chksum+0xac>)
 8012226:	0018      	movs	r0, r3
 8012228:	f7ef ffd0 	bl	80021cc <app_debug_rtt_raw>
 801222c:	2310      	movs	r3, #16
 801222e:	425b      	negs	r3, r3
 8012230:	e03e      	b.n	80122b0 <udp_sendto_chksum+0xa4>
  LWIP_ERROR("udp_sendto: invalid pbuf", p != NULL, return ERR_ARG);
 8012232:	68bb      	ldr	r3, [r7, #8]
 8012234:	2b00      	cmp	r3, #0
 8012236:	d106      	bne.n	8012246 <udp_sendto_chksum+0x3a>
 8012238:	4b20      	ldr	r3, [pc, #128]	; (80122bc <udp_sendto_chksum+0xb0>)
 801223a:	0018      	movs	r0, r3
 801223c:	f7ef ffc6 	bl	80021cc <app_debug_rtt_raw>
 8012240:	2310      	movs	r3, #16
 8012242:	425b      	negs	r3, r3
 8012244:	e034      	b.n	80122b0 <udp_sendto_chksum+0xa4>
  LWIP_ERROR("udp_sendto: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 8012246:	687b      	ldr	r3, [r7, #4]
 8012248:	2b00      	cmp	r3, #0
 801224a:	d106      	bne.n	801225a <udp_sendto_chksum+0x4e>
 801224c:	4b1c      	ldr	r3, [pc, #112]	; (80122c0 <udp_sendto_chksum+0xb4>)
 801224e:	0018      	movs	r0, r3
 8012250:	f7ef ffbc 	bl	80021cc <app_debug_rtt_raw>
 8012254:	2310      	movs	r3, #16
 8012256:	425b      	negs	r3, r3
 8012258:	e02a      	b.n	80122b0 <udp_sendto_chksum+0xa4>
    return ERR_VAL;
  }

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send\n"));

  if (pcb->netif_idx != NETIF_NO_INDEX) {
 801225a:	68fb      	ldr	r3, [r7, #12]
 801225c:	7a1b      	ldrb	r3, [r3, #8]
 801225e:	2b00      	cmp	r3, #0
 8012260:	d007      	beq.n	8012272 <udp_sendto_chksum+0x66>
    netif = netif_get_by_index(pcb->netif_idx);
 8012262:	68fb      	ldr	r3, [r7, #12]
 8012264:	7a1b      	ldrb	r3, [r3, #8]
 8012266:	0018      	movs	r0, r3
 8012268:	f7f6 fe1e 	bl	8008ea8 <netif_get_by_index>
 801226c:	0003      	movs	r3, r0
 801226e:	617b      	str	r3, [r7, #20]
 8012270:	e005      	b.n	801227e <udp_sendto_chksum+0x72>

    if (netif == NULL)
#endif /* LWIP_MULTICAST_TX_OPTIONS */
    {
      /* find the outgoing network interface for this packet */
      netif = ip_route(&pcb->local_ip, dst_ip);
 8012272:	687b      	ldr	r3, [r7, #4]
 8012274:	0018      	movs	r0, r3
 8012276:	f000 fe19 	bl	8012eac <ip4_route>
 801227a:	0003      	movs	r3, r0
 801227c:	617b      	str	r3, [r7, #20]
    }
  }

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
 801227e:	697b      	ldr	r3, [r7, #20]
 8012280:	2b00      	cmp	r3, #0
 8012282:	d102      	bne.n	801228a <udp_sendto_chksum+0x7e>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to "));
    ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, dst_ip);
    LWIP_DEBUGF(UDP_DEBUG, ("\n"));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
 8012284:	2304      	movs	r3, #4
 8012286:	425b      	negs	r3, r3
 8012288:	e012      	b.n	80122b0 <udp_sendto_chksum+0xa4>
  }
#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
  return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
 801228a:	1cbb      	adds	r3, r7, #2
 801228c:	881c      	ldrh	r4, [r3, #0]
 801228e:	687a      	ldr	r2, [r7, #4]
 8012290:	68b9      	ldr	r1, [r7, #8]
 8012292:	68f8      	ldr	r0, [r7, #12]
 8012294:	232c      	movs	r3, #44	; 0x2c
 8012296:	18fb      	adds	r3, r7, r3
 8012298:	881b      	ldrh	r3, [r3, #0]
 801229a:	9302      	str	r3, [sp, #8]
 801229c:	2328      	movs	r3, #40	; 0x28
 801229e:	18fb      	adds	r3, r7, r3
 80122a0:	781b      	ldrb	r3, [r3, #0]
 80122a2:	9301      	str	r3, [sp, #4]
 80122a4:	697b      	ldr	r3, [r7, #20]
 80122a6:	9300      	str	r3, [sp, #0]
 80122a8:	0023      	movs	r3, r4
 80122aa:	f000 f80b 	bl	80122c4 <udp_sendto_if_chksum>
 80122ae:	0003      	movs	r3, r0
#else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
}
 80122b0:	0018      	movs	r0, r3
 80122b2:	46bd      	mov	sp, r7
 80122b4:	b007      	add	sp, #28
 80122b6:	bd90      	pop	{r4, r7, pc}
 80122b8:	08020974 	.word	0x08020974
 80122bc:	0802098c 	.word	0x0802098c
 80122c0:	080209a8 	.word	0x080209a8

080122c4 <udp_sendto_if_chksum>:
/** Same as udp_sendto_if(), but with checksum */
err_t
udp_sendto_if_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
                     u16_t dst_port, struct netif *netif, u8_t have_chksum,
                     u16_t chksum)
{
 80122c4:	b590      	push	{r4, r7, lr}
 80122c6:	b08b      	sub	sp, #44	; 0x2c
 80122c8:	af04      	add	r7, sp, #16
 80122ca:	60f8      	str	r0, [r7, #12]
 80122cc:	60b9      	str	r1, [r7, #8]
 80122ce:	607a      	str	r2, [r7, #4]
 80122d0:	001a      	movs	r2, r3
 80122d2:	1cbb      	adds	r3, r7, #2
 80122d4:	801a      	strh	r2, [r3, #0]
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  const ip_addr_t *src_ip;

  LWIP_ERROR("udp_sendto_if: invalid pcb", pcb != NULL, return ERR_ARG);
 80122d6:	68fb      	ldr	r3, [r7, #12]
 80122d8:	2b00      	cmp	r3, #0
 80122da:	d106      	bne.n	80122ea <udp_sendto_if_chksum+0x26>
 80122dc:	4b2d      	ldr	r3, [pc, #180]	; (8012394 <udp_sendto_if_chksum+0xd0>)
 80122de:	0018      	movs	r0, r3
 80122e0:	f7ef ff74 	bl	80021cc <app_debug_rtt_raw>
 80122e4:	2310      	movs	r3, #16
 80122e6:	425b      	negs	r3, r3
 80122e8:	e04f      	b.n	801238a <udp_sendto_if_chksum+0xc6>
  LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
 80122ea:	68bb      	ldr	r3, [r7, #8]
 80122ec:	2b00      	cmp	r3, #0
 80122ee:	d106      	bne.n	80122fe <udp_sendto_if_chksum+0x3a>
 80122f0:	4b29      	ldr	r3, [pc, #164]	; (8012398 <udp_sendto_if_chksum+0xd4>)
 80122f2:	0018      	movs	r0, r3
 80122f4:	f7ef ff6a 	bl	80021cc <app_debug_rtt_raw>
 80122f8:	2310      	movs	r3, #16
 80122fa:	425b      	negs	r3, r3
 80122fc:	e045      	b.n	801238a <udp_sendto_if_chksum+0xc6>
  LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 80122fe:	687b      	ldr	r3, [r7, #4]
 8012300:	2b00      	cmp	r3, #0
 8012302:	d106      	bne.n	8012312 <udp_sendto_if_chksum+0x4e>
 8012304:	4b25      	ldr	r3, [pc, #148]	; (801239c <udp_sendto_if_chksum+0xd8>)
 8012306:	0018      	movs	r0, r3
 8012308:	f7ef ff60 	bl	80021cc <app_debug_rtt_raw>
 801230c:	2310      	movs	r3, #16
 801230e:	425b      	negs	r3, r3
 8012310:	e03b      	b.n	801238a <udp_sendto_if_chksum+0xc6>
  LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
 8012312:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012314:	2b00      	cmp	r3, #0
 8012316:	d106      	bne.n	8012326 <udp_sendto_if_chksum+0x62>
 8012318:	4b21      	ldr	r3, [pc, #132]	; (80123a0 <udp_sendto_if_chksum+0xdc>)
 801231a:	0018      	movs	r0, r3
 801231c:	f7ef ff56 	bl	80021cc <app_debug_rtt_raw>
 8012320:	2310      	movs	r3, #16
 8012322:	425b      	negs	r3, r3
 8012324:	e031      	b.n	801238a <udp_sendto_if_chksum+0xc6>
#endif /* LWIP_IPV6 */
#if LWIP_IPV4 && LWIP_IPV6
  else
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_IPV4
    if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 8012326:	68fb      	ldr	r3, [r7, #12]
 8012328:	2b00      	cmp	r3, #0
 801232a:	d009      	beq.n	8012340 <udp_sendto_if_chksum+0x7c>
 801232c:	68fb      	ldr	r3, [r7, #12]
 801232e:	681b      	ldr	r3, [r3, #0]
 8012330:	2b00      	cmp	r3, #0
 8012332:	d005      	beq.n	8012340 <udp_sendto_if_chksum+0x7c>
        ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
 8012334:	68fb      	ldr	r3, [r7, #12]
 8012336:	681b      	ldr	r3, [r3, #0]
 8012338:	22f0      	movs	r2, #240	; 0xf0
 801233a:	4013      	ands	r3, r2
    if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 801233c:	2be0      	cmp	r3, #224	; 0xe0
 801233e:	d103      	bne.n	8012348 <udp_sendto_if_chksum+0x84>
      /* if the local_ip is any or multicast
       * use the outgoing network interface IP address as source address */
      src_ip = netif_ip_addr4(netif);
 8012340:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012342:	3304      	adds	r3, #4
 8012344:	617b      	str	r3, [r7, #20]
 8012346:	e00b      	b.n	8012360 <udp_sendto_if_chksum+0x9c>
    } else {
      /* check if UDP PCB local IP address is correct
       * this could be an old address if netif->ip_addr has changed */
      if (!ip4_addr_cmp(ip_2_ip4(&(pcb->local_ip)), netif_ip4_addr(netif))) {
 8012348:	68fb      	ldr	r3, [r7, #12]
 801234a:	681a      	ldr	r2, [r3, #0]
 801234c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801234e:	3304      	adds	r3, #4
 8012350:	681b      	ldr	r3, [r3, #0]
 8012352:	429a      	cmp	r2, r3
 8012354:	d002      	beq.n	801235c <udp_sendto_if_chksum+0x98>
        /* local_ip doesn't match, drop the packet */
        return ERR_RTE;
 8012356:	2304      	movs	r3, #4
 8012358:	425b      	negs	r3, r3
 801235a:	e016      	b.n	801238a <udp_sendto_if_chksum+0xc6>
      }
      /* use UDP PCB local IP address as source address */
      src_ip = &pcb->local_ip;
 801235c:	68fb      	ldr	r3, [r7, #12]
 801235e:	617b      	str	r3, [r7, #20]
    }
#endif /* LWIP_IPV4 */
#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
  return udp_sendto_if_src_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum, src_ip);
 8012360:	1cbb      	adds	r3, r7, #2
 8012362:	881c      	ldrh	r4, [r3, #0]
 8012364:	687a      	ldr	r2, [r7, #4]
 8012366:	68b9      	ldr	r1, [r7, #8]
 8012368:	68f8      	ldr	r0, [r7, #12]
 801236a:	697b      	ldr	r3, [r7, #20]
 801236c:	9303      	str	r3, [sp, #12]
 801236e:	2330      	movs	r3, #48	; 0x30
 8012370:	18fb      	adds	r3, r7, r3
 8012372:	881b      	ldrh	r3, [r3, #0]
 8012374:	9302      	str	r3, [sp, #8]
 8012376:	232c      	movs	r3, #44	; 0x2c
 8012378:	18fb      	adds	r3, r7, r3
 801237a:	781b      	ldrb	r3, [r3, #0]
 801237c:	9301      	str	r3, [sp, #4]
 801237e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012380:	9300      	str	r3, [sp, #0]
 8012382:	0023      	movs	r3, r4
 8012384:	f000 f80e 	bl	80123a4 <udp_sendto_if_src_chksum>
 8012388:	0003      	movs	r3, r0
#else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  return udp_sendto_if_src(pcb, p, dst_ip, dst_port, netif, src_ip);
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
}
 801238a:	0018      	movs	r0, r3
 801238c:	46bd      	mov	sp, r7
 801238e:	b007      	add	sp, #28
 8012390:	bd90      	pop	{r4, r7, pc}
 8012392:	46c0      	nop			; (mov r8, r8)
 8012394:	080209c4 	.word	0x080209c4
 8012398:	080209e0 	.word	0x080209e0
 801239c:	080209fc 	.word	0x080209fc
 80123a0:	08020a1c 	.word	0x08020a1c

080123a4 <udp_sendto_if_src_chksum>:
/** Same as udp_sendto_if_src(), but with checksum */
err_t
udp_sendto_if_src_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
                         u16_t dst_port, struct netif *netif, u8_t have_chksum,
                         u16_t chksum, const ip_addr_t *src_ip)
{
 80123a4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80123a6:	b08f      	sub	sp, #60	; 0x3c
 80123a8:	af04      	add	r7, sp, #16
 80123aa:	60f8      	str	r0, [r7, #12]
 80123ac:	60b9      	str	r1, [r7, #8]
 80123ae:	607a      	str	r2, [r7, #4]
 80123b0:	001a      	movs	r2, r3
 80123b2:	1cbb      	adds	r3, r7, #2
 80123b4:	801a      	strh	r2, [r3, #0]
  u8_t ip_proto;
  u8_t ttl;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_sendto_if_src: invalid pcb", pcb != NULL, return ERR_ARG);
 80123b6:	68fb      	ldr	r3, [r7, #12]
 80123b8:	2b00      	cmp	r3, #0
 80123ba:	d106      	bne.n	80123ca <udp_sendto_if_src_chksum+0x26>
 80123bc:	4bb4      	ldr	r3, [pc, #720]	; (8012690 <udp_sendto_if_src_chksum+0x2ec>)
 80123be:	0018      	movs	r0, r3
 80123c0:	f7ef ff04 	bl	80021cc <app_debug_rtt_raw>
 80123c4:	2310      	movs	r3, #16
 80123c6:	425b      	negs	r3, r3
 80123c8:	e15d      	b.n	8012686 <udp_sendto_if_src_chksum+0x2e2>
  LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
 80123ca:	68bb      	ldr	r3, [r7, #8]
 80123cc:	2b00      	cmp	r3, #0
 80123ce:	d106      	bne.n	80123de <udp_sendto_if_src_chksum+0x3a>
 80123d0:	4bb0      	ldr	r3, [pc, #704]	; (8012694 <udp_sendto_if_src_chksum+0x2f0>)
 80123d2:	0018      	movs	r0, r3
 80123d4:	f7ef fefa 	bl	80021cc <app_debug_rtt_raw>
 80123d8:	2310      	movs	r3, #16
 80123da:	425b      	negs	r3, r3
 80123dc:	e153      	b.n	8012686 <udp_sendto_if_src_chksum+0x2e2>
  LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
 80123de:	687b      	ldr	r3, [r7, #4]
 80123e0:	2b00      	cmp	r3, #0
 80123e2:	d106      	bne.n	80123f2 <udp_sendto_if_src_chksum+0x4e>
 80123e4:	4bac      	ldr	r3, [pc, #688]	; (8012698 <udp_sendto_if_src_chksum+0x2f4>)
 80123e6:	0018      	movs	r0, r3
 80123e8:	f7ef fef0 	bl	80021cc <app_debug_rtt_raw>
 80123ec:	2310      	movs	r3, #16
 80123ee:	425b      	negs	r3, r3
 80123f0:	e149      	b.n	8012686 <udp_sendto_if_src_chksum+0x2e2>
  LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
 80123f2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80123f4:	2b00      	cmp	r3, #0
 80123f6:	d106      	bne.n	8012406 <udp_sendto_if_src_chksum+0x62>
 80123f8:	4ba8      	ldr	r3, [pc, #672]	; (801269c <udp_sendto_if_src_chksum+0x2f8>)
 80123fa:	0018      	movs	r0, r3
 80123fc:	f7ef fee6 	bl	80021cc <app_debug_rtt_raw>
 8012400:	2310      	movs	r3, #16
 8012402:	425b      	negs	r3, r3
 8012404:	e13f      	b.n	8012686 <udp_sendto_if_src_chksum+0x2e2>
  LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
 8012406:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012408:	2b00      	cmp	r3, #0
 801240a:	d106      	bne.n	801241a <udp_sendto_if_src_chksum+0x76>
 801240c:	4ba4      	ldr	r3, [pc, #656]	; (80126a0 <udp_sendto_if_src_chksum+0x2fc>)
 801240e:	0018      	movs	r0, r3
 8012410:	f7ef fedc 	bl	80021cc <app_debug_rtt_raw>
 8012414:	2310      	movs	r3, #16
 8012416:	425b      	negs	r3, r3
 8012418:	e135      	b.n	8012686 <udp_sendto_if_src_chksum+0x2e2>
    return ERR_VAL;
  }
#endif /* LWIP_IPV4 && IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
 801241a:	68fb      	ldr	r3, [r7, #12]
 801241c:	8adb      	ldrh	r3, [r3, #22]
 801241e:	2b00      	cmp	r3, #0
 8012420:	d113      	bne.n	801244a <udp_sendto_if_src_chksum+0xa6>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 8012422:	68f9      	ldr	r1, [r7, #12]
 8012424:	68fb      	ldr	r3, [r7, #12]
 8012426:	8ada      	ldrh	r2, [r3, #22]
 8012428:	251f      	movs	r5, #31
 801242a:	197c      	adds	r4, r7, r5
 801242c:	68fb      	ldr	r3, [r7, #12]
 801242e:	0018      	movs	r0, r3
 8012430:	f000 f942 	bl	80126b8 <udp_bind>
 8012434:	0003      	movs	r3, r0
 8012436:	7023      	strb	r3, [r4, #0]
    if (err != ERR_OK) {
 8012438:	197b      	adds	r3, r7, r5
 801243a:	781b      	ldrb	r3, [r3, #0]
 801243c:	b25b      	sxtb	r3, r3
 801243e:	2b00      	cmp	r3, #0
 8012440:	d003      	beq.n	801244a <udp_sendto_if_src_chksum+0xa6>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
      return err;
 8012442:	197b      	adds	r3, r7, r5
 8012444:	781b      	ldrb	r3, [r3, #0]
 8012446:	b25b      	sxtb	r3, r3
 8012448:	e11d      	b.n	8012686 <udp_sendto_if_src_chksum+0x2e2>
    }
  }

  /* packet too large to add a UDP header without causing an overflow? */
  if ((u16_t)(p->tot_len + UDP_HLEN) < p->tot_len) {
 801244a:	68bb      	ldr	r3, [r7, #8]
 801244c:	891b      	ldrh	r3, [r3, #8]
 801244e:	4a95      	ldr	r2, [pc, #596]	; (80126a4 <udp_sendto_if_src_chksum+0x300>)
 8012450:	4293      	cmp	r3, r2
 8012452:	d902      	bls.n	801245a <udp_sendto_if_src_chksum+0xb6>
    return ERR_MEM;
 8012454:	2301      	movs	r3, #1
 8012456:	425b      	negs	r3, r3
 8012458:	e115      	b.n	8012686 <udp_sendto_if_src_chksum+0x2e2>
  }
  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_add_header(p, UDP_HLEN)) {
 801245a:	68bb      	ldr	r3, [r7, #8]
 801245c:	2108      	movs	r1, #8
 801245e:	0018      	movs	r0, r3
 8012460:	f7f7 f830 	bl	80094c4 <pbuf_add_header>
 8012464:	1e03      	subs	r3, r0, #0
 8012466:	d019      	beq.n	801249c <udp_sendto_if_src_chksum+0xf8>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 8012468:	23a0      	movs	r3, #160	; 0xa0
 801246a:	009b      	lsls	r3, r3, #2
 801246c:	001a      	movs	r2, r3
 801246e:	2108      	movs	r1, #8
 8012470:	2024      	movs	r0, #36	; 0x24
 8012472:	f7f6 fd97 	bl	8008fa4 <pbuf_alloc>
 8012476:	0003      	movs	r3, r0
 8012478:	623b      	str	r3, [r7, #32]
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
 801247a:	6a3b      	ldr	r3, [r7, #32]
 801247c:	2b00      	cmp	r3, #0
 801247e:	d102      	bne.n	8012486 <udp_sendto_if_src_chksum+0xe2>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
 8012480:	2301      	movs	r3, #1
 8012482:	425b      	negs	r3, r3
 8012484:	e0ff      	b.n	8012686 <udp_sendto_if_src_chksum+0x2e2>
    }
    if (p->tot_len != 0) {
 8012486:	68bb      	ldr	r3, [r7, #8]
 8012488:	891b      	ldrh	r3, [r3, #8]
 801248a:	2b00      	cmp	r3, #0
 801248c:	d008      	beq.n	80124a0 <udp_sendto_if_src_chksum+0xfc>
      /* chain header q in front of given pbuf p (only if p contains data) */
      pbuf_chain(q, p);
 801248e:	68ba      	ldr	r2, [r7, #8]
 8012490:	6a3b      	ldr	r3, [r7, #32]
 8012492:	0011      	movs	r1, r2
 8012494:	0018      	movs	r0, r3
 8012496:	f7f7 fa31 	bl	80098fc <pbuf_chain>
 801249a:	e001      	b.n	80124a0 <udp_sendto_if_src_chksum+0xfc>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
 801249c:	68bb      	ldr	r3, [r7, #8]
 801249e:	623b      	str	r3, [r7, #32]
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
 80124a0:	6a3b      	ldr	r3, [r7, #32]
 80124a2:	895b      	ldrh	r3, [r3, #10]
 80124a4:	2b07      	cmp	r3, #7
 80124a6:	d805      	bhi.n	80124b4 <udp_sendto_if_src_chksum+0x110>
 80124a8:	4b7f      	ldr	r3, [pc, #508]	; (80126a8 <udp_sendto_if_src_chksum+0x304>)
 80124aa:	4a80      	ldr	r2, [pc, #512]	; (80126ac <udp_sendto_if_src_chksum+0x308>)
 80124ac:	4980      	ldr	r1, [pc, #512]	; (80126b0 <udp_sendto_if_src_chksum+0x30c>)
 80124ae:	4881      	ldr	r0, [pc, #516]	; (80126b4 <udp_sendto_if_src_chksum+0x310>)
 80124b0:	f7ef fe8c 	bl	80021cc <app_debug_rtt_raw>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
 80124b4:	6a3b      	ldr	r3, [r7, #32]
 80124b6:	685b      	ldr	r3, [r3, #4]
 80124b8:	61bb      	str	r3, [r7, #24]
  udphdr->src = lwip_htons(pcb->local_port);
 80124ba:	68fb      	ldr	r3, [r7, #12]
 80124bc:	8adb      	ldrh	r3, [r3, #22]
 80124be:	0018      	movs	r0, r3
 80124c0:	f7f4 f838 	bl	8006534 <lwip_htons>
 80124c4:	0003      	movs	r3, r0
 80124c6:	001a      	movs	r2, r3
 80124c8:	69bb      	ldr	r3, [r7, #24]
 80124ca:	21ff      	movs	r1, #255	; 0xff
 80124cc:	4011      	ands	r1, r2
 80124ce:	000c      	movs	r4, r1
 80124d0:	7819      	ldrb	r1, [r3, #0]
 80124d2:	2000      	movs	r0, #0
 80124d4:	4001      	ands	r1, r0
 80124d6:	1c08      	adds	r0, r1, #0
 80124d8:	1c21      	adds	r1, r4, #0
 80124da:	4301      	orrs	r1, r0
 80124dc:	7019      	strb	r1, [r3, #0]
 80124de:	0a12      	lsrs	r2, r2, #8
 80124e0:	b290      	uxth	r0, r2
 80124e2:	785a      	ldrb	r2, [r3, #1]
 80124e4:	2100      	movs	r1, #0
 80124e6:	400a      	ands	r2, r1
 80124e8:	1c11      	adds	r1, r2, #0
 80124ea:	1c02      	adds	r2, r0, #0
 80124ec:	430a      	orrs	r2, r1
 80124ee:	705a      	strb	r2, [r3, #1]
  udphdr->dest = lwip_htons(dst_port);
 80124f0:	1cbb      	adds	r3, r7, #2
 80124f2:	881b      	ldrh	r3, [r3, #0]
 80124f4:	0018      	movs	r0, r3
 80124f6:	f7f4 f81d 	bl	8006534 <lwip_htons>
 80124fa:	0003      	movs	r3, r0
 80124fc:	001a      	movs	r2, r3
 80124fe:	69bb      	ldr	r3, [r7, #24]
 8012500:	21ff      	movs	r1, #255	; 0xff
 8012502:	4011      	ands	r1, r2
 8012504:	000c      	movs	r4, r1
 8012506:	7899      	ldrb	r1, [r3, #2]
 8012508:	2000      	movs	r0, #0
 801250a:	4001      	ands	r1, r0
 801250c:	1c08      	adds	r0, r1, #0
 801250e:	1c21      	adds	r1, r4, #0
 8012510:	4301      	orrs	r1, r0
 8012512:	7099      	strb	r1, [r3, #2]
 8012514:	0a12      	lsrs	r2, r2, #8
 8012516:	b290      	uxth	r0, r2
 8012518:	78da      	ldrb	r2, [r3, #3]
 801251a:	2100      	movs	r1, #0
 801251c:	400a      	ands	r2, r1
 801251e:	1c11      	adds	r1, r2, #0
 8012520:	1c02      	adds	r2, r0, #0
 8012522:	430a      	orrs	r2, r1
 8012524:	70da      	strb	r2, [r3, #3]
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000;
 8012526:	69bb      	ldr	r3, [r7, #24]
 8012528:	799a      	ldrb	r2, [r3, #6]
 801252a:	2100      	movs	r1, #0
 801252c:	400a      	ands	r2, r1
 801252e:	719a      	strb	r2, [r3, #6]
 8012530:	79da      	ldrb	r2, [r3, #7]
 8012532:	2100      	movs	r1, #0
 8012534:	400a      	ands	r2, r1
 8012536:	71da      	strb	r2, [r3, #7]
    ip_proto = IP_PROTO_UDPLITE;
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = lwip_htons(q->tot_len);
 8012538:	6a3b      	ldr	r3, [r7, #32]
 801253a:	891b      	ldrh	r3, [r3, #8]
 801253c:	0018      	movs	r0, r3
 801253e:	f7f3 fff9 	bl	8006534 <lwip_htons>
 8012542:	0003      	movs	r3, r0
 8012544:	001a      	movs	r2, r3
 8012546:	69bb      	ldr	r3, [r7, #24]
 8012548:	21ff      	movs	r1, #255	; 0xff
 801254a:	4011      	ands	r1, r2
 801254c:	000c      	movs	r4, r1
 801254e:	7919      	ldrb	r1, [r3, #4]
 8012550:	2000      	movs	r0, #0
 8012552:	4001      	ands	r1, r0
 8012554:	1c08      	adds	r0, r1, #0
 8012556:	1c21      	adds	r1, r4, #0
 8012558:	4301      	orrs	r1, r0
 801255a:	7119      	strb	r1, [r3, #4]
 801255c:	0a12      	lsrs	r2, r2, #8
 801255e:	b290      	uxth	r0, r2
 8012560:	795a      	ldrb	r2, [r3, #5]
 8012562:	2100      	movs	r1, #0
 8012564:	400a      	ands	r2, r1
 8012566:	1c11      	adds	r1, r2, #0
 8012568:	1c02      	adds	r2, r0, #0
 801256a:	430a      	orrs	r2, r1
 801256c:	715a      	strb	r2, [r3, #5]
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_UDP) {
      /* Checksum is mandatory over IPv6. */
      if (IP_IS_V6(dst_ip) || (pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
 801256e:	68fb      	ldr	r3, [r7, #12]
 8012570:	7d1b      	ldrb	r3, [r3, #20]
 8012572:	001a      	movs	r2, r3
 8012574:	2301      	movs	r3, #1
 8012576:	4013      	ands	r3, r2
 8012578:	d150      	bne.n	801261c <udp_sendto_if_src_chksum+0x278>
        u16_t udpchksum;
#if LWIP_CHECKSUM_ON_COPY
        if (have_chksum) {
 801257a:	2344      	movs	r3, #68	; 0x44
 801257c:	18fb      	adds	r3, r7, r3
 801257e:	781b      	ldrb	r3, [r3, #0]
 8012580:	2b00      	cmp	r3, #0
 8012582:	d021      	beq.n	80125c8 <udp_sendto_if_src_chksum+0x224>
          u32_t acc;
          udpchksum = ip_chksum_pseudo_partial(q, IP_PROTO_UDP,
 8012584:	6a3b      	ldr	r3, [r7, #32]
 8012586:	891a      	ldrh	r2, [r3, #8]
 8012588:	2526      	movs	r5, #38	; 0x26
 801258a:	197c      	adds	r4, r7, r5
 801258c:	6a38      	ldr	r0, [r7, #32]
 801258e:	687b      	ldr	r3, [r7, #4]
 8012590:	9301      	str	r3, [sp, #4]
 8012592:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8012594:	9300      	str	r3, [sp, #0]
 8012596:	2308      	movs	r3, #8
 8012598:	2111      	movs	r1, #17
 801259a:	f7f5 fb8e 	bl	8007cba <ip_chksum_pseudo_partial>
 801259e:	0003      	movs	r3, r0
 80125a0:	8023      	strh	r3, [r4, #0]
                                               q->tot_len, UDP_HLEN, src_ip, dst_ip);
          acc = udpchksum + (u16_t)~(chksum);
 80125a2:	0028      	movs	r0, r5
 80125a4:	183b      	adds	r3, r7, r0
 80125a6:	881b      	ldrh	r3, [r3, #0]
 80125a8:	2248      	movs	r2, #72	; 0x48
 80125aa:	18ba      	adds	r2, r7, r2
 80125ac:	8812      	ldrh	r2, [r2, #0]
 80125ae:	43d2      	mvns	r2, r2
 80125b0:	b292      	uxth	r2, r2
 80125b2:	189b      	adds	r3, r3, r2
 80125b4:	617b      	str	r3, [r7, #20]
          udpchksum = FOLD_U32T(acc);
 80125b6:	697b      	ldr	r3, [r7, #20]
 80125b8:	0c1b      	lsrs	r3, r3, #16
 80125ba:	b299      	uxth	r1, r3
 80125bc:	697b      	ldr	r3, [r7, #20]
 80125be:	b29a      	uxth	r2, r3
 80125c0:	183b      	adds	r3, r7, r0
 80125c2:	188a      	adds	r2, r1, r2
 80125c4:	801a      	strh	r2, [r3, #0]
 80125c6:	e00d      	b.n	80125e4 <udp_sendto_if_src_chksum+0x240>
        } else
#endif /* LWIP_CHECKSUM_ON_COPY */
        {
          udpchksum = ip_chksum_pseudo(q, IP_PROTO_UDP, q->tot_len,
 80125c8:	6a3b      	ldr	r3, [r7, #32]
 80125ca:	891a      	ldrh	r2, [r3, #8]
 80125cc:	2326      	movs	r3, #38	; 0x26
 80125ce:	18fc      	adds	r4, r7, r3
 80125d0:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 80125d2:	6a38      	ldr	r0, [r7, #32]
 80125d4:	687b      	ldr	r3, [r7, #4]
 80125d6:	9300      	str	r3, [sp, #0]
 80125d8:	000b      	movs	r3, r1
 80125da:	2111      	movs	r1, #17
 80125dc:	f7f5 fa53 	bl	8007a86 <ip_chksum_pseudo>
 80125e0:	0003      	movs	r3, r0
 80125e2:	8023      	strh	r3, [r4, #0]
                                       src_ip, dst_ip);
        }

        /* chksum zero must become 0xffff, as zero means 'no checksum' */
        if (udpchksum == 0x0000) {
 80125e4:	2226      	movs	r2, #38	; 0x26
 80125e6:	18bb      	adds	r3, r7, r2
 80125e8:	881b      	ldrh	r3, [r3, #0]
 80125ea:	2b00      	cmp	r3, #0
 80125ec:	d103      	bne.n	80125f6 <udp_sendto_if_src_chksum+0x252>
          udpchksum = 0xffff;
 80125ee:	18bb      	adds	r3, r7, r2
 80125f0:	2201      	movs	r2, #1
 80125f2:	4252      	negs	r2, r2
 80125f4:	801a      	strh	r2, [r3, #0]
        }
        udphdr->chksum = udpchksum;
 80125f6:	69bb      	ldr	r3, [r7, #24]
 80125f8:	2226      	movs	r2, #38	; 0x26
 80125fa:	18ba      	adds	r2, r7, r2
 80125fc:	7814      	ldrb	r4, [r2, #0]
 80125fe:	7999      	ldrb	r1, [r3, #6]
 8012600:	2000      	movs	r0, #0
 8012602:	4001      	ands	r1, r0
 8012604:	1c08      	adds	r0, r1, #0
 8012606:	1c21      	adds	r1, r4, #0
 8012608:	4301      	orrs	r1, r0
 801260a:	7199      	strb	r1, [r3, #6]
 801260c:	7850      	ldrb	r0, [r2, #1]
 801260e:	79da      	ldrb	r2, [r3, #7]
 8012610:	2100      	movs	r1, #0
 8012612:	400a      	ands	r2, r1
 8012614:	1c11      	adds	r1, r2, #0
 8012616:	1c02      	adds	r2, r0, #0
 8012618:	430a      	orrs	r2, r1
 801261a:	71da      	strb	r2, [r3, #7]
      }
    }
#endif /* CHECKSUM_GEN_UDP */
    ip_proto = IP_PROTO_UDP;
 801261c:	2313      	movs	r3, #19
 801261e:	18fb      	adds	r3, r7, r3
 8012620:	2211      	movs	r2, #17
 8012622:	701a      	strb	r2, [r3, #0]

  /* Determine TTL to use */
#if LWIP_MULTICAST_TX_OPTIONS
  ttl = (ip_addr_ismulticast(dst_ip) ? udp_get_multicast_ttl(pcb) : pcb->ttl);
#else /* LWIP_MULTICAST_TX_OPTIONS */
  ttl = pcb->ttl;
 8012624:	2112      	movs	r1, #18
 8012626:	187b      	adds	r3, r7, r1
 8012628:	68fa      	ldr	r2, [r7, #12]
 801262a:	7ad2      	ldrb	r2, [r2, #11]
 801262c:	701a      	strb	r2, [r3, #0]
#endif /* LWIP_MULTICAST_TX_OPTIONS */

  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,0x%02"X16_F",)\n", (u16_t)ip_proto));
  /* output to IP */
  NETIF_SET_HINTS(netif, &(pcb->netif_hints));
 801262e:	68fb      	ldr	r3, [r7, #12]
 8012630:	330c      	adds	r3, #12
 8012632:	001a      	movs	r2, r3
 8012634:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012636:	639a      	str	r2, [r3, #56]	; 0x38
  err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
 8012638:	68fb      	ldr	r3, [r7, #12]
 801263a:	7a9b      	ldrb	r3, [r3, #10]
 801263c:	201f      	movs	r0, #31
 801263e:	183c      	adds	r4, r7, r0
 8012640:	187a      	adds	r2, r7, r1
 8012642:	7816      	ldrb	r6, [r2, #0]
 8012644:	687d      	ldr	r5, [r7, #4]
 8012646:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8012648:	6a38      	ldr	r0, [r7, #32]
 801264a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801264c:	9202      	str	r2, [sp, #8]
 801264e:	2213      	movs	r2, #19
 8012650:	18ba      	adds	r2, r7, r2
 8012652:	7812      	ldrb	r2, [r2, #0]
 8012654:	9201      	str	r2, [sp, #4]
 8012656:	9300      	str	r3, [sp, #0]
 8012658:	0033      	movs	r3, r6
 801265a:	002a      	movs	r2, r5
 801265c:	f000 fe58 	bl	8013310 <ip4_output_if_src>
 8012660:	0003      	movs	r3, r0
 8012662:	7023      	strb	r3, [r4, #0]
  NETIF_RESET_HINTS(netif);
 8012664:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8012666:	2200      	movs	r2, #0
 8012668:	639a      	str	r2, [r3, #56]	; 0x38

  /* @todo: must this be increased even if error occurred? */
  MIB2_STATS_INC(mib2.udpoutdatagrams);

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
 801266a:	6a3a      	ldr	r2, [r7, #32]
 801266c:	68bb      	ldr	r3, [r7, #8]
 801266e:	429a      	cmp	r2, r3
 8012670:	d005      	beq.n	801267e <udp_sendto_if_src_chksum+0x2da>
    /* free the header pbuf */
    pbuf_free(q);
 8012672:	6a3b      	ldr	r3, [r7, #32]
 8012674:	0018      	movs	r0, r3
 8012676:	f7f7 f80d 	bl	8009694 <pbuf_free>
    q = NULL;
 801267a:	2300      	movs	r3, #0
 801267c:	623b      	str	r3, [r7, #32]
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
 801267e:	231f      	movs	r3, #31
 8012680:	18fb      	adds	r3, r7, r3
 8012682:	781b      	ldrb	r3, [r3, #0]
 8012684:	b25b      	sxtb	r3, r3
}
 8012686:	0018      	movs	r0, r3
 8012688:	46bd      	mov	sp, r7
 801268a:	b00b      	add	sp, #44	; 0x2c
 801268c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801268e:	46c0      	nop			; (mov r8, r8)
 8012690:	08020a3c 	.word	0x08020a3c
 8012694:	08020a5c 	.word	0x08020a5c
 8012698:	08020a7c 	.word	0x08020a7c
 801269c:	08020aa0 	.word	0x08020aa0
 80126a0:	08020ac4 	.word	0x08020ac4
 80126a4:	0000fff7 	.word	0x0000fff7
 80126a8:	08020814 	.word	0x08020814
 80126ac:	0000030d 	.word	0x0000030d
 80126b0:	08020ae8 	.word	0x08020ae8
 80126b4:	08020860 	.word	0x08020860

080126b8 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
 80126b8:	b590      	push	{r4, r7, lr}
 80126ba:	b087      	sub	sp, #28
 80126bc:	af00      	add	r7, sp, #0
 80126be:	60f8      	str	r0, [r7, #12]
 80126c0:	60b9      	str	r1, [r7, #8]
 80126c2:	1dbb      	adds	r3, r7, #6
 80126c4:	801a      	strh	r2, [r3, #0]

  LWIP_ASSERT_CORE_LOCKED();

#if LWIP_IPV4
  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
 80126c6:	68bb      	ldr	r3, [r7, #8]
 80126c8:	2b00      	cmp	r3, #0
 80126ca:	d101      	bne.n	80126d0 <udp_bind+0x18>
    ipaddr = IP4_ADDR_ANY;
 80126cc:	4b43      	ldr	r3, [pc, #268]	; (80127dc <udp_bind+0x124>)
 80126ce:	60bb      	str	r3, [r7, #8]
  }
#else /* LWIP_IPV4 */
  LWIP_ERROR("udp_bind: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
#endif /* LWIP_IPV4 */

  LWIP_ERROR("udp_bind: invalid pcb", pcb != NULL, return ERR_ARG);
 80126d0:	68fb      	ldr	r3, [r7, #12]
 80126d2:	2b00      	cmp	r3, #0
 80126d4:	d106      	bne.n	80126e4 <udp_bind+0x2c>
 80126d6:	4b42      	ldr	r3, [pc, #264]	; (80127e0 <udp_bind+0x128>)
 80126d8:	0018      	movs	r0, r3
 80126da:	f7ef fd77 	bl	80021cc <app_debug_rtt_raw>
 80126de:	2310      	movs	r3, #16
 80126e0:	425b      	negs	r3, r3
 80126e2:	e077      	b.n	80127d4 <udp_bind+0x11c>

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
 80126e4:	2313      	movs	r3, #19
 80126e6:	18fb      	adds	r3, r7, r3
 80126e8:	2200      	movs	r2, #0
 80126ea:	701a      	strb	r2, [r3, #0]
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 80126ec:	4b3d      	ldr	r3, [pc, #244]	; (80127e4 <udp_bind+0x12c>)
 80126ee:	681b      	ldr	r3, [r3, #0]
 80126f0:	617b      	str	r3, [r7, #20]
 80126f2:	e00b      	b.n	801270c <udp_bind+0x54>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
 80126f4:	68fa      	ldr	r2, [r7, #12]
 80126f6:	697b      	ldr	r3, [r7, #20]
 80126f8:	429a      	cmp	r2, r3
 80126fa:	d104      	bne.n	8012706 <udp_bind+0x4e>
      rebind = 1;
 80126fc:	2313      	movs	r3, #19
 80126fe:	18fb      	adds	r3, r7, r3
 8012700:	2201      	movs	r2, #1
 8012702:	701a      	strb	r2, [r3, #0]
      break;
 8012704:	e005      	b.n	8012712 <udp_bind+0x5a>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8012706:	697b      	ldr	r3, [r7, #20]
 8012708:	691b      	ldr	r3, [r3, #16]
 801270a:	617b      	str	r3, [r7, #20]
 801270c:	697b      	ldr	r3, [r7, #20]
 801270e:	2b00      	cmp	r3, #0
 8012710:	d1f0      	bne.n	80126f4 <udp_bind+0x3c>
    ipaddr = &zoned_ipaddr;
  }
#endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */

  /* no port specified? */
  if (port == 0) {
 8012712:	1dbb      	adds	r3, r7, #6
 8012714:	881b      	ldrh	r3, [r3, #0]
 8012716:	2b00      	cmp	r3, #0
 8012718:	d10b      	bne.n	8012732 <udp_bind+0x7a>
    port = udp_new_port();
 801271a:	1dbc      	adds	r4, r7, #6
 801271c:	f7ff fb5a 	bl	8011dd4 <udp_new_port>
 8012720:	0003      	movs	r3, r0
 8012722:	8023      	strh	r3, [r4, #0]
    if (port == 0) {
 8012724:	1dbb      	adds	r3, r7, #6
 8012726:	881b      	ldrh	r3, [r3, #0]
 8012728:	2b00      	cmp	r3, #0
 801272a:	d139      	bne.n	80127a0 <udp_bind+0xe8>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
 801272c:	2308      	movs	r3, #8
 801272e:	425b      	negs	r3, r3
 8012730:	e050      	b.n	80127d4 <udp_bind+0x11c>
    }
  } else {
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8012732:	4b2c      	ldr	r3, [pc, #176]	; (80127e4 <udp_bind+0x12c>)
 8012734:	681b      	ldr	r3, [r3, #0]
 8012736:	617b      	str	r3, [r7, #20]
 8012738:	e02f      	b.n	801279a <udp_bind+0xe2>
      if (pcb != ipcb) {
 801273a:	68fa      	ldr	r2, [r7, #12]
 801273c:	697b      	ldr	r3, [r7, #20]
 801273e:	429a      	cmp	r2, r3
 8012740:	d028      	beq.n	8012794 <udp_bind+0xdc>
        /* By default, we don't allow to bind to a port that any other udp
           PCB is already bound to, unless *all* PCBs with that port have tha
           REUSEADDR flag set. */
#if SO_REUSE
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
 8012742:	68fb      	ldr	r3, [r7, #12]
 8012744:	7a5b      	ldrb	r3, [r3, #9]
 8012746:	001a      	movs	r2, r3
 8012748:	2304      	movs	r3, #4
 801274a:	4013      	ands	r3, r2
 801274c:	d005      	beq.n	801275a <udp_bind+0xa2>
            !ip_get_option(ipcb, SOF_REUSEADDR))
 801274e:	697b      	ldr	r3, [r7, #20]
 8012750:	7a5b      	ldrb	r3, [r3, #9]
 8012752:	001a      	movs	r2, r3
 8012754:	2304      	movs	r3, #4
 8012756:	4013      	ands	r3, r2
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
 8012758:	d11c      	bne.n	8012794 <udp_bind+0xdc>
#endif /* SO_REUSE */
        {
          /* port matches that of PCB in list and REUSEADDR not set -> reject */
          if ((ipcb->local_port == port) &&
 801275a:	697b      	ldr	r3, [r7, #20]
 801275c:	8adb      	ldrh	r3, [r3, #22]
 801275e:	1dba      	adds	r2, r7, #6
 8012760:	8812      	ldrh	r2, [r2, #0]
 8012762:	429a      	cmp	r2, r3
 8012764:	d116      	bne.n	8012794 <udp_bind+0xdc>
              (((IP_GET_TYPE(&ipcb->local_ip) == IP_GET_TYPE(ipaddr)) &&
              /* IP address matches or any IP used? */
              (ip_addr_cmp(&ipcb->local_ip, ipaddr) ||
 8012766:	697b      	ldr	r3, [r7, #20]
 8012768:	681a      	ldr	r2, [r3, #0]
 801276a:	68bb      	ldr	r3, [r7, #8]
 801276c:	681b      	ldr	r3, [r3, #0]
          if ((ipcb->local_port == port) &&
 801276e:	429a      	cmp	r2, r3
 8012770:	d00d      	beq.n	801278e <udp_bind+0xd6>
              (ip_addr_cmp(&ipcb->local_ip, ipaddr) ||
 8012772:	68bb      	ldr	r3, [r7, #8]
 8012774:	2b00      	cmp	r3, #0
 8012776:	d00a      	beq.n	801278e <udp_bind+0xd6>
              ip_addr_isany(ipaddr) ||
 8012778:	68bb      	ldr	r3, [r7, #8]
 801277a:	681b      	ldr	r3, [r3, #0]
 801277c:	2b00      	cmp	r3, #0
 801277e:	d006      	beq.n	801278e <udp_bind+0xd6>
              ip_addr_isany(&ipcb->local_ip))) ||
 8012780:	697b      	ldr	r3, [r7, #20]
              (IP_GET_TYPE(&ipcb->local_ip) == IPADDR_TYPE_ANY) ||
 8012782:	2b00      	cmp	r3, #0
 8012784:	d003      	beq.n	801278e <udp_bind+0xd6>
              ip_addr_isany(&ipcb->local_ip))) ||
 8012786:	697b      	ldr	r3, [r7, #20]
 8012788:	681b      	ldr	r3, [r3, #0]
 801278a:	2b00      	cmp	r3, #0
 801278c:	d102      	bne.n	8012794 <udp_bind+0xdc>
              (IP_GET_TYPE(ipaddr) == IPADDR_TYPE_ANY))) {
            /* other PCB already binds to this local IP and port */
            LWIP_DEBUGF(UDP_DEBUG,
                        ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
            return ERR_USE;
 801278e:	2308      	movs	r3, #8
 8012790:	425b      	negs	r3, r3
 8012792:	e01f      	b.n	80127d4 <udp_bind+0x11c>
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8012794:	697b      	ldr	r3, [r7, #20]
 8012796:	691b      	ldr	r3, [r3, #16]
 8012798:	617b      	str	r3, [r7, #20]
 801279a:	697b      	ldr	r3, [r7, #20]
 801279c:	2b00      	cmp	r3, #0
 801279e:	d1cc      	bne.n	801273a <udp_bind+0x82>
        }
      }
    }
  }

  ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
 80127a0:	68bb      	ldr	r3, [r7, #8]
 80127a2:	2b00      	cmp	r3, #0
 80127a4:	d002      	beq.n	80127ac <udp_bind+0xf4>
 80127a6:	68bb      	ldr	r3, [r7, #8]
 80127a8:	681a      	ldr	r2, [r3, #0]
 80127aa:	e000      	b.n	80127ae <udp_bind+0xf6>
 80127ac:	2200      	movs	r2, #0
 80127ae:	68fb      	ldr	r3, [r7, #12]
 80127b0:	601a      	str	r2, [r3, #0]

  pcb->local_port = port;
 80127b2:	68fb      	ldr	r3, [r7, #12]
 80127b4:	1dba      	adds	r2, r7, #6
 80127b6:	8812      	ldrh	r2, [r2, #0]
 80127b8:	82da      	strh	r2, [r3, #22]
  mib2_udp_bind(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
 80127ba:	2313      	movs	r3, #19
 80127bc:	18fb      	adds	r3, r7, r3
 80127be:	781b      	ldrb	r3, [r3, #0]
 80127c0:	2b00      	cmp	r3, #0
 80127c2:	d106      	bne.n	80127d2 <udp_bind+0x11a>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
 80127c4:	4b07      	ldr	r3, [pc, #28]	; (80127e4 <udp_bind+0x12c>)
 80127c6:	681a      	ldr	r2, [r3, #0]
 80127c8:	68fb      	ldr	r3, [r7, #12]
 80127ca:	611a      	str	r2, [r3, #16]
    udp_pcbs = pcb;
 80127cc:	4b05      	ldr	r3, [pc, #20]	; (80127e4 <udp_bind+0x12c>)
 80127ce:	68fa      	ldr	r2, [r7, #12]
 80127d0:	601a      	str	r2, [r3, #0]
  }
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("udp_bind: bound to "));
  ip_addr_debug_print_val(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, pcb->local_ip);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->local_port));
  return ERR_OK;
 80127d2:	2300      	movs	r3, #0
}
 80127d4:	0018      	movs	r0, r3
 80127d6:	46bd      	mov	sp, r7
 80127d8:	b007      	add	sp, #28
 80127da:	bd90      	pop	{r4, r7, pc}
 80127dc:	08021a50 	.word	0x08021a50
 80127e0:	08020b18 	.word	0x08020b18
 80127e4:	20002b30 	.word	0x20002b30

080127e8 <udp_recv>:
 * @param recv function pointer of the callback function
 * @param recv_arg additional argument to pass to the callback function
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
 80127e8:	b580      	push	{r7, lr}
 80127ea:	b084      	sub	sp, #16
 80127ec:	af00      	add	r7, sp, #0
 80127ee:	60f8      	str	r0, [r7, #12]
 80127f0:	60b9      	str	r1, [r7, #8]
 80127f2:	607a      	str	r2, [r7, #4]
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_recv: invalid pcb", pcb != NULL, return);
 80127f4:	68fb      	ldr	r3, [r7, #12]
 80127f6:	2b00      	cmp	r3, #0
 80127f8:	d104      	bne.n	8012804 <udp_recv+0x1c>
 80127fa:	4b07      	ldr	r3, [pc, #28]	; (8012818 <udp_recv+0x30>)
 80127fc:	0018      	movs	r0, r3
 80127fe:	f7ef fce5 	bl	80021cc <app_debug_rtt_raw>
 8012802:	e005      	b.n	8012810 <udp_recv+0x28>

  /* remember recv() callback and user data */
  pcb->recv = recv;
 8012804:	68fb      	ldr	r3, [r7, #12]
 8012806:	68ba      	ldr	r2, [r7, #8]
 8012808:	61da      	str	r2, [r3, #28]
  pcb->recv_arg = recv_arg;
 801280a:	68fb      	ldr	r3, [r7, #12]
 801280c:	687a      	ldr	r2, [r7, #4]
 801280e:	621a      	str	r2, [r3, #32]
}
 8012810:	46bd      	mov	sp, r7
 8012812:	b004      	add	sp, #16
 8012814:	bd80      	pop	{r7, pc}
 8012816:	46c0      	nop			; (mov r8, r8)
 8012818:	08020b84 	.word	0x08020b84

0801281c <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 801281c:	b580      	push	{r7, lr}
 801281e:	b084      	sub	sp, #16
 8012820:	af00      	add	r7, sp, #0
 8012822:	6078      	str	r0, [r7, #4]
  struct udp_pcb *pcb2;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_remove: invalid pcb", pcb != NULL, return);
 8012824:	687b      	ldr	r3, [r7, #4]
 8012826:	2b00      	cmp	r3, #0
 8012828:	d104      	bne.n	8012834 <udp_remove+0x18>
 801282a:	4b18      	ldr	r3, [pc, #96]	; (801288c <udp_remove+0x70>)
 801282c:	0018      	movs	r0, r3
 801282e:	f7ef fccd 	bl	80021cc <app_debug_rtt_raw>
 8012832:	e027      	b.n	8012884 <udp_remove+0x68>

  mib2_udp_unbind(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 8012834:	4b16      	ldr	r3, [pc, #88]	; (8012890 <udp_remove+0x74>)
 8012836:	681b      	ldr	r3, [r3, #0]
 8012838:	687a      	ldr	r2, [r7, #4]
 801283a:	429a      	cmp	r2, r3
 801283c:	d105      	bne.n	801284a <udp_remove+0x2e>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
 801283e:	4b14      	ldr	r3, [pc, #80]	; (8012890 <udp_remove+0x74>)
 8012840:	681b      	ldr	r3, [r3, #0]
 8012842:	691a      	ldr	r2, [r3, #16]
 8012844:	4b12      	ldr	r3, [pc, #72]	; (8012890 <udp_remove+0x74>)
 8012846:	601a      	str	r2, [r3, #0]
 8012848:	e017      	b.n	801287a <udp_remove+0x5e>
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 801284a:	4b11      	ldr	r3, [pc, #68]	; (8012890 <udp_remove+0x74>)
 801284c:	681b      	ldr	r3, [r3, #0]
 801284e:	60fb      	str	r3, [r7, #12]
 8012850:	e010      	b.n	8012874 <udp_remove+0x58>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 8012852:	68fb      	ldr	r3, [r7, #12]
 8012854:	691b      	ldr	r3, [r3, #16]
 8012856:	2b00      	cmp	r3, #0
 8012858:	d009      	beq.n	801286e <udp_remove+0x52>
 801285a:	68fb      	ldr	r3, [r7, #12]
 801285c:	691b      	ldr	r3, [r3, #16]
 801285e:	687a      	ldr	r2, [r7, #4]
 8012860:	429a      	cmp	r2, r3
 8012862:	d104      	bne.n	801286e <udp_remove+0x52>
        /* remove pcb from list */
        pcb2->next = pcb->next;
 8012864:	687b      	ldr	r3, [r7, #4]
 8012866:	691a      	ldr	r2, [r3, #16]
 8012868:	68fb      	ldr	r3, [r7, #12]
 801286a:	611a      	str	r2, [r3, #16]
        break;
 801286c:	e005      	b.n	801287a <udp_remove+0x5e>
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 801286e:	68fb      	ldr	r3, [r7, #12]
 8012870:	691b      	ldr	r3, [r3, #16]
 8012872:	60fb      	str	r3, [r7, #12]
 8012874:	68fb      	ldr	r3, [r7, #12]
 8012876:	2b00      	cmp	r3, #0
 8012878:	d1eb      	bne.n	8012852 <udp_remove+0x36>
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 801287a:	687b      	ldr	r3, [r7, #4]
 801287c:	0019      	movs	r1, r3
 801287e:	2000      	movs	r0, #0
 8012880:	f7f6 f812 	bl	80088a8 <memp_free>
}
 8012884:	46bd      	mov	sp, r7
 8012886:	b004      	add	sp, #16
 8012888:	bd80      	pop	{r7, pc}
 801288a:	46c0      	nop			; (mov r8, r8)
 801288c:	08020b9c 	.word	0x08020b9c
 8012890:	20002b30 	.word	0x20002b30

08012894 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
 8012894:	b580      	push	{r7, lr}
 8012896:	b082      	sub	sp, #8
 8012898:	af00      	add	r7, sp, #0
  struct udp_pcb *pcb;

  LWIP_ASSERT_CORE_LOCKED();

  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
 801289a:	2000      	movs	r0, #0
 801289c:	f7f5 ff94 	bl	80087c8 <memp_malloc>
 80128a0:	0003      	movs	r3, r0
 80128a2:	607b      	str	r3, [r7, #4]
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
 80128a4:	687b      	ldr	r3, [r7, #4]
 80128a6:	2b00      	cmp	r3, #0
 80128a8:	d008      	beq.n	80128bc <udp_new+0x28>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
 80128aa:	687b      	ldr	r3, [r7, #4]
 80128ac:	2224      	movs	r2, #36	; 0x24
 80128ae:	2100      	movs	r1, #0
 80128b0:	0018      	movs	r0, r3
 80128b2:	f009 ffbb 	bl	801c82c <memset>
    pcb->ttl = UDP_TTL;
 80128b6:	687b      	ldr	r3, [r7, #4]
 80128b8:	22ff      	movs	r2, #255	; 0xff
 80128ba:	72da      	strb	r2, [r3, #11]
#if LWIP_MULTICAST_TX_OPTIONS
    udp_set_multicast_ttl(pcb, UDP_TTL);
#endif /* LWIP_MULTICAST_TX_OPTIONS */
  }
  return pcb;
 80128bc:	687b      	ldr	r3, [r7, #4]
}
 80128be:	0018      	movs	r0, r3
 80128c0:	46bd      	mov	sp, r7
 80128c2:	b002      	add	sp, #8
 80128c4:	bd80      	pop	{r7, pc}

080128c6 <udp_new_ip_type>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new_ip_type(u8_t type)
{
 80128c6:	b580      	push	{r7, lr}
 80128c8:	b084      	sub	sp, #16
 80128ca:	af00      	add	r7, sp, #0
 80128cc:	0002      	movs	r2, r0
 80128ce:	1dfb      	adds	r3, r7, #7
 80128d0:	701a      	strb	r2, [r3, #0]
  struct udp_pcb *pcb;

  LWIP_ASSERT_CORE_LOCKED();

  pcb = udp_new();
 80128d2:	f7ff ffdf 	bl	8012894 <udp_new>
 80128d6:	0003      	movs	r3, r0
 80128d8:	60fb      	str	r3, [r7, #12]
    IP_SET_TYPE_VAL(pcb->remote_ip, type);
  }
#else
  LWIP_UNUSED_ARG(type);
#endif /* LWIP_IPV4 && LWIP_IPV6 */
  return pcb;
 80128da:	68fb      	ldr	r3, [r7, #12]
}
 80128dc:	0018      	movs	r0, r3
 80128de:	46bd      	mov	sp, r7
 80128e0:	b004      	add	sp, #16
 80128e2:	bd80      	pop	{r7, pc}

080128e4 <udp_netif_ip_addr_changed>:
 *
 * @param old_addr IP address of the netif before change
 * @param new_addr IP address of the netif after change
 */
void udp_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
 80128e4:	b580      	push	{r7, lr}
 80128e6:	b084      	sub	sp, #16
 80128e8:	af00      	add	r7, sp, #0
 80128ea:	6078      	str	r0, [r7, #4]
 80128ec:	6039      	str	r1, [r7, #0]
  struct udp_pcb *upcb;

  if (!ip_addr_isany(old_addr) && !ip_addr_isany(new_addr)) {
 80128ee:	687b      	ldr	r3, [r7, #4]
 80128f0:	2b00      	cmp	r3, #0
 80128f2:	d01e      	beq.n	8012932 <udp_netif_ip_addr_changed+0x4e>
 80128f4:	687b      	ldr	r3, [r7, #4]
 80128f6:	681b      	ldr	r3, [r3, #0]
 80128f8:	2b00      	cmp	r3, #0
 80128fa:	d01a      	beq.n	8012932 <udp_netif_ip_addr_changed+0x4e>
 80128fc:	683b      	ldr	r3, [r7, #0]
 80128fe:	2b00      	cmp	r3, #0
 8012900:	d017      	beq.n	8012932 <udp_netif_ip_addr_changed+0x4e>
 8012902:	683b      	ldr	r3, [r7, #0]
 8012904:	681b      	ldr	r3, [r3, #0]
 8012906:	2b00      	cmp	r3, #0
 8012908:	d013      	beq.n	8012932 <udp_netif_ip_addr_changed+0x4e>
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 801290a:	4b0c      	ldr	r3, [pc, #48]	; (801293c <udp_netif_ip_addr_changed+0x58>)
 801290c:	681b      	ldr	r3, [r3, #0]
 801290e:	60fb      	str	r3, [r7, #12]
 8012910:	e00c      	b.n	801292c <udp_netif_ip_addr_changed+0x48>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&upcb->local_ip, old_addr)) {
 8012912:	68fb      	ldr	r3, [r7, #12]
 8012914:	681a      	ldr	r2, [r3, #0]
 8012916:	687b      	ldr	r3, [r7, #4]
 8012918:	681b      	ldr	r3, [r3, #0]
 801291a:	429a      	cmp	r2, r3
 801291c:	d103      	bne.n	8012926 <udp_netif_ip_addr_changed+0x42>
        /* The PCB is bound to the old ipaddr and
         * is set to bound to the new one instead */
        ip_addr_copy(upcb->local_ip, *new_addr);
 801291e:	683b      	ldr	r3, [r7, #0]
 8012920:	681a      	ldr	r2, [r3, #0]
 8012922:	68fb      	ldr	r3, [r7, #12]
 8012924:	601a      	str	r2, [r3, #0]
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 8012926:	68fb      	ldr	r3, [r7, #12]
 8012928:	691b      	ldr	r3, [r3, #16]
 801292a:	60fb      	str	r3, [r7, #12]
 801292c:	68fb      	ldr	r3, [r7, #12]
 801292e:	2b00      	cmp	r3, #0
 8012930:	d1ef      	bne.n	8012912 <udp_netif_ip_addr_changed+0x2e>
      }
    }
  }
}
 8012932:	46c0      	nop			; (mov r8, r8)
 8012934:	46bd      	mov	sp, r7
 8012936:	b004      	add	sp, #16
 8012938:	bd80      	pop	{r7, pc}
 801293a:	46c0      	nop			; (mov r8, r8)
 801293c:	20002b30 	.word	0x20002b30

08012940 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the icmp header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
 8012940:	b590      	push	{r4, r7, lr}
 8012942:	b08f      	sub	sp, #60	; 0x3c
 8012944:	af04      	add	r7, sp, #16
 8012946:	6078      	str	r0, [r7, #4]
 8012948:	6039      	str	r1, [r7, #0]
  const ip4_addr_t *src;

  ICMP_STATS_INC(icmp.recv);
  MIB2_STATS_INC(mib2.icmpinmsgs);

  iphdr_in = ip4_current_header();
 801294a:	4bde      	ldr	r3, [pc, #888]	; (8012cc4 <icmp_input+0x384>)
 801294c:	689b      	ldr	r3, [r3, #8]
 801294e:	627b      	str	r3, [r7, #36]	; 0x24
  hlen = IPH_HL_BYTES(iphdr_in);
 8012950:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012952:	781b      	ldrb	r3, [r3, #0]
 8012954:	220f      	movs	r2, #15
 8012956:	4013      	ands	r3, r2
 8012958:	b2db      	uxtb	r3, r3
 801295a:	009b      	lsls	r3, r3, #2
 801295c:	b2da      	uxtb	r2, r3
 801295e:	2122      	movs	r1, #34	; 0x22
 8012960:	187b      	adds	r3, r7, r1
 8012962:	801a      	strh	r2, [r3, #0]
  if (hlen < IP_HLEN) {
 8012964:	187b      	adds	r3, r7, r1
 8012966:	881b      	ldrh	r3, [r3, #0]
 8012968:	2b13      	cmp	r3, #19
 801296a:	d800      	bhi.n	801296e <icmp_input+0x2e>
 801296c:	e1a5      	b.n	8012cba <icmp_input+0x37a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short IP header (%"S16_F" bytes) received\n", hlen));
    goto lenerr;
  }
  if (p->len < sizeof(u16_t) * 2) {
 801296e:	687b      	ldr	r3, [r7, #4]
 8012970:	895b      	ldrh	r3, [r3, #10]
 8012972:	2b03      	cmp	r3, #3
 8012974:	d800      	bhi.n	8012978 <icmp_input+0x38>
 8012976:	e1a2      	b.n	8012cbe <icmp_input+0x37e>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
 8012978:	687b      	ldr	r3, [r7, #4]
 801297a:	685a      	ldr	r2, [r3, #4]
 801297c:	2121      	movs	r1, #33	; 0x21
 801297e:	187b      	adds	r3, r7, r1
 8012980:	7812      	ldrb	r2, [r2, #0]
 8012982:	701a      	strb	r2, [r3, #0]
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload) + 1);
 8012984:	687b      	ldr	r3, [r7, #4]
 8012986:	685a      	ldr	r2, [r3, #4]
 8012988:	2320      	movs	r3, #32
 801298a:	18fb      	adds	r3, r7, r3
 801298c:	7852      	ldrb	r2, [r2, #1]
 801298e:	701a      	strb	r2, [r3, #0]
  /* if debug is enabled but debug statement below is somehow disabled: */
  LWIP_UNUSED_ARG(code);
#endif /* LWIP_DEBUG */
  switch (type) {
 8012990:	187b      	adds	r3, r7, r1
 8012992:	781b      	ldrb	r3, [r3, #0]
 8012994:	2b00      	cmp	r3, #0
 8012996:	d100      	bne.n	801299a <icmp_input+0x5a>
 8012998:	e187      	b.n	8012caa <icmp_input+0x36a>
 801299a:	2b08      	cmp	r3, #8
 801299c:	d000      	beq.n	80129a0 <icmp_input+0x60>
 801299e:	e187      	b.n	8012cb0 <icmp_input+0x370>
         (as obviously, an echo request has been sent, too). */
      MIB2_STATS_INC(mib2.icmpinechoreps);
      break;
    case ICMP_ECHO:
      MIB2_STATS_INC(mib2.icmpinechos);
      src = ip4_current_dest_addr();
 80129a0:	4bc9      	ldr	r3, [pc, #804]	; (8012cc8 <icmp_input+0x388>)
 80129a2:	61fb      	str	r3, [r7, #28]
      /* multicast destination address? */
      if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 80129a4:	4bc7      	ldr	r3, [pc, #796]	; (8012cc4 <icmp_input+0x384>)
 80129a6:	695b      	ldr	r3, [r3, #20]
 80129a8:	22f0      	movs	r2, #240	; 0xf0
 80129aa:	4013      	ands	r3, r2
 80129ac:	2be0      	cmp	r3, #224	; 0xe0
 80129ae:	d100      	bne.n	80129b2 <icmp_input+0x72>
 80129b0:	e19c      	b.n	8012cec <icmp_input+0x3ac>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast pings\n"));
        goto icmperr;
#endif /* LWIP_MULTICAST_PING */
      }
      /* broadcast destination address? */
      if (ip4_addr_isbroadcast(ip4_current_dest_addr(), ip_current_netif())) {
 80129b2:	4bc4      	ldr	r3, [pc, #784]	; (8012cc4 <icmp_input+0x384>)
 80129b4:	695a      	ldr	r2, [r3, #20]
 80129b6:	4bc3      	ldr	r3, [pc, #780]	; (8012cc4 <icmp_input+0x384>)
 80129b8:	681b      	ldr	r3, [r3, #0]
 80129ba:	0019      	movs	r1, r3
 80129bc:	0010      	movs	r0, r2
 80129be:	f000 fe9d 	bl	80136fc <ip4_addr_isbroadcast_u32>
 80129c2:	1e03      	subs	r3, r0, #0
 80129c4:	d000      	beq.n	80129c8 <icmp_input+0x88>
 80129c6:	e193      	b.n	8012cf0 <icmp_input+0x3b0>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to broadcast pings\n"));
        goto icmperr;
#endif /* LWIP_BROADCAST_PING */
      }
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
      if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
 80129c8:	687b      	ldr	r3, [r7, #4]
 80129ca:	891b      	ldrh	r3, [r3, #8]
 80129cc:	2b07      	cmp	r3, #7
 80129ce:	d800      	bhi.n	80129d2 <icmp_input+0x92>
 80129d0:	e186      	b.n	8012ce0 <icmp_input+0x3a0>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
        goto lenerr;
      }
#if CHECKSUM_CHECK_ICMP
      IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_ICMP) {
        if (inet_chksum_pbuf(p) != 0) {
 80129d2:	687b      	ldr	r3, [r7, #4]
 80129d4:	0018      	movs	r0, r3
 80129d6:	f7f5 f9aa 	bl	8007d2e <inet_chksum_pbuf>
 80129da:	1e03      	subs	r3, r0, #0
 80129dc:	d004      	beq.n	80129e8 <icmp_input+0xa8>
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
          pbuf_free(p);
 80129de:	687b      	ldr	r3, [r7, #4]
 80129e0:	0018      	movs	r0, r3
 80129e2:	f7f6 fe57 	bl	8009694 <pbuf_free>
          ICMP_STATS_INC(icmp.chkerr);
          MIB2_STATS_INC(mib2.icmpinerrors);
          return;
 80129e6:	e18d      	b.n	8012d04 <icmp_input+0x3c4>
        }
      }
#endif
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
      if (pbuf_add_header(p, hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN)) {
 80129e8:	2422      	movs	r4, #34	; 0x22
 80129ea:	193b      	adds	r3, r7, r4
 80129ec:	881b      	ldrh	r3, [r3, #0]
 80129ee:	3310      	adds	r3, #16
 80129f0:	001a      	movs	r2, r3
 80129f2:	687b      	ldr	r3, [r7, #4]
 80129f4:	0011      	movs	r1, r2
 80129f6:	0018      	movs	r0, r3
 80129f8:	f7f6 fd64 	bl	80094c4 <pbuf_add_header>
 80129fc:	1e03      	subs	r3, r0, #0
 80129fe:	d05a      	beq.n	8012ab6 <icmp_input+0x176>
        /* p is not big enough to contain link headers
         * allocate a new one and copy p into it
         */
        struct pbuf *r;
        u16_t alloc_len = (u16_t)(p->tot_len + hlen);
 8012a00:	687b      	ldr	r3, [r7, #4]
 8012a02:	8919      	ldrh	r1, [r3, #8]
 8012a04:	201a      	movs	r0, #26
 8012a06:	183b      	adds	r3, r7, r0
 8012a08:	193a      	adds	r2, r7, r4
 8012a0a:	8812      	ldrh	r2, [r2, #0]
 8012a0c:	188a      	adds	r2, r1, r2
 8012a0e:	801a      	strh	r2, [r3, #0]
        if (alloc_len < p->tot_len) {
 8012a10:	687b      	ldr	r3, [r7, #4]
 8012a12:	891b      	ldrh	r3, [r3, #8]
 8012a14:	183a      	adds	r2, r7, r0
 8012a16:	8812      	ldrh	r2, [r2, #0]
 8012a18:	429a      	cmp	r2, r3
 8012a1a:	d200      	bcs.n	8012a1e <icmp_input+0xde>
 8012a1c:	e16a      	b.n	8012cf4 <icmp_input+0x3b4>
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed (tot_len overflow)\n"));
          goto icmperr;
        }
        /* allocate new packet buffer with space for link headers */
        r = pbuf_alloc(PBUF_LINK, alloc_len, PBUF_RAM);
 8012a1e:	23a0      	movs	r3, #160	; 0xa0
 8012a20:	009a      	lsls	r2, r3, #2
 8012a22:	183b      	adds	r3, r7, r0
 8012a24:	881b      	ldrh	r3, [r3, #0]
 8012a26:	0019      	movs	r1, r3
 8012a28:	2010      	movs	r0, #16
 8012a2a:	f7f6 fabb 	bl	8008fa4 <pbuf_alloc>
 8012a2e:	0003      	movs	r3, r0
 8012a30:	617b      	str	r3, [r7, #20]
        if (r == NULL) {
 8012a32:	697b      	ldr	r3, [r7, #20]
 8012a34:	2b00      	cmp	r3, #0
 8012a36:	d100      	bne.n	8012a3a <icmp_input+0xfa>
 8012a38:	e15e      	b.n	8012cf8 <icmp_input+0x3b8>
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
          goto icmperr;
        }
        if (r->len < hlen + sizeof(struct icmp_echo_hdr)) {
 8012a3a:	697b      	ldr	r3, [r7, #20]
 8012a3c:	895b      	ldrh	r3, [r3, #10]
 8012a3e:	001a      	movs	r2, r3
 8012a40:	193b      	adds	r3, r7, r4
 8012a42:	881b      	ldrh	r3, [r3, #0]
 8012a44:	3308      	adds	r3, #8
 8012a46:	429a      	cmp	r2, r3
 8012a48:	d204      	bcs.n	8012a54 <icmp_input+0x114>
          LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("first pbuf cannot hold the ICMP header"));
          pbuf_free(r);
 8012a4a:	697b      	ldr	r3, [r7, #20]
 8012a4c:	0018      	movs	r0, r3
 8012a4e:	f7f6 fe21 	bl	8009694 <pbuf_free>
          goto icmperr;
 8012a52:	e152      	b.n	8012cfa <icmp_input+0x3ba>
        }
        /* copy the ip header */
        MEMCPY(r->payload, iphdr_in, hlen);
 8012a54:	697b      	ldr	r3, [r7, #20]
 8012a56:	6858      	ldr	r0, [r3, #4]
 8012a58:	2422      	movs	r4, #34	; 0x22
 8012a5a:	193b      	adds	r3, r7, r4
 8012a5c:	881a      	ldrh	r2, [r3, #0]
 8012a5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012a60:	0019      	movs	r1, r3
 8012a62:	f009 fec7 	bl	801c7f4 <memcpy>
        /* switch r->payload back to icmp header (cannot fail) */
        if (pbuf_remove_header(r, hlen)) {
 8012a66:	193b      	adds	r3, r7, r4
 8012a68:	881a      	ldrh	r2, [r3, #0]
 8012a6a:	697b      	ldr	r3, [r7, #20]
 8012a6c:	0011      	movs	r1, r2
 8012a6e:	0018      	movs	r0, r3
 8012a70:	f7f6 fd38 	bl	80094e4 <pbuf_remove_header>
 8012a74:	1e03      	subs	r3, r0, #0
 8012a76:	d00a      	beq.n	8012a8e <icmp_input+0x14e>
          LWIP_ASSERT("icmp_input: moving r->payload to icmp header failed\n", 0);
 8012a78:	4b94      	ldr	r3, [pc, #592]	; (8012ccc <icmp_input+0x38c>)
 8012a7a:	4995      	ldr	r1, [pc, #596]	; (8012cd0 <icmp_input+0x390>)
 8012a7c:	4895      	ldr	r0, [pc, #596]	; (8012cd4 <icmp_input+0x394>)
 8012a7e:	22b6      	movs	r2, #182	; 0xb6
 8012a80:	f7ef fba4 	bl	80021cc <app_debug_rtt_raw>
          pbuf_free(r);
 8012a84:	697b      	ldr	r3, [r7, #20]
 8012a86:	0018      	movs	r0, r3
 8012a88:	f7f6 fe04 	bl	8009694 <pbuf_free>
          goto icmperr;
 8012a8c:	e135      	b.n	8012cfa <icmp_input+0x3ba>
        }
        /* copy the rest of the packet without ip header */
        if (pbuf_copy(r, p) != ERR_OK) {
 8012a8e:	687a      	ldr	r2, [r7, #4]
 8012a90:	697b      	ldr	r3, [r7, #20]
 8012a92:	0011      	movs	r1, r2
 8012a94:	0018      	movs	r0, r3
 8012a96:	f7f6 ff9f 	bl	80099d8 <pbuf_copy>
 8012a9a:	1e03      	subs	r3, r0, #0
 8012a9c:	d004      	beq.n	8012aa8 <icmp_input+0x168>
          LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("icmp_input: copying to new pbuf failed"));
          pbuf_free(r);
 8012a9e:	697b      	ldr	r3, [r7, #20]
 8012aa0:	0018      	movs	r0, r3
 8012aa2:	f7f6 fdf7 	bl	8009694 <pbuf_free>
          goto icmperr;
 8012aa6:	e128      	b.n	8012cfa <icmp_input+0x3ba>
        }
        /* free the original p */
        pbuf_free(p);
 8012aa8:	687b      	ldr	r3, [r7, #4]
 8012aaa:	0018      	movs	r0, r3
 8012aac:	f7f6 fdf2 	bl	8009694 <pbuf_free>
        /* we now have an identical copy of p that has room for link headers */
        p = r;
 8012ab0:	697b      	ldr	r3, [r7, #20]
 8012ab2:	607b      	str	r3, [r7, #4]
 8012ab4:	e012      	b.n	8012adc <icmp_input+0x19c>
      } else {
        /* restore p->payload to point to icmp header (cannot fail) */
        if (pbuf_remove_header(p, hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN)) {
 8012ab6:	2322      	movs	r3, #34	; 0x22
 8012ab8:	18fb      	adds	r3, r7, r3
 8012aba:	881b      	ldrh	r3, [r3, #0]
 8012abc:	3310      	adds	r3, #16
 8012abe:	001a      	movs	r2, r3
 8012ac0:	687b      	ldr	r3, [r7, #4]
 8012ac2:	0011      	movs	r1, r2
 8012ac4:	0018      	movs	r0, r3
 8012ac6:	f7f6 fd0d 	bl	80094e4 <pbuf_remove_header>
 8012aca:	1e03      	subs	r3, r0, #0
 8012acc:	d006      	beq.n	8012adc <icmp_input+0x19c>
          LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
 8012ace:	4b7f      	ldr	r3, [pc, #508]	; (8012ccc <icmp_input+0x38c>)
 8012ad0:	4981      	ldr	r1, [pc, #516]	; (8012cd8 <icmp_input+0x398>)
 8012ad2:	4880      	ldr	r0, [pc, #512]	; (8012cd4 <icmp_input+0x394>)
 8012ad4:	22c7      	movs	r2, #199	; 0xc7
 8012ad6:	f7ef fb79 	bl	80021cc <app_debug_rtt_raw>
          goto icmperr;
 8012ada:	e10e      	b.n	8012cfa <icmp_input+0x3ba>
      }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
      /* At this point, all checks are OK. */
      /* We generate an answer by switching the dest and src ip addresses,
       * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
      iecho = (struct icmp_echo_hdr *)p->payload;
 8012adc:	687b      	ldr	r3, [r7, #4]
 8012ade:	685b      	ldr	r3, [r3, #4]
 8012ae0:	613b      	str	r3, [r7, #16]
      if (pbuf_add_header(p, hlen)) {
 8012ae2:	2322      	movs	r3, #34	; 0x22
 8012ae4:	18fb      	adds	r3, r7, r3
 8012ae6:	881a      	ldrh	r2, [r3, #0]
 8012ae8:	687b      	ldr	r3, [r7, #4]
 8012aea:	0011      	movs	r1, r2
 8012aec:	0018      	movs	r0, r3
 8012aee:	f7f6 fce9 	bl	80094c4 <pbuf_add_header>
 8012af2:	1e03      	subs	r3, r0, #0
 8012af4:	d000      	beq.n	8012af8 <icmp_input+0x1b8>
 8012af6:	e0da      	b.n	8012cae <icmp_input+0x36e>
        LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Can't move over header in packet"));
      } else {
        err_t ret;
        struct ip_hdr *iphdr = (struct ip_hdr *)p->payload;
 8012af8:	687b      	ldr	r3, [r7, #4]
 8012afa:	685b      	ldr	r3, [r3, #4]
 8012afc:	60fb      	str	r3, [r7, #12]
        ip4_addr_copy(iphdr->src, *src);
 8012afe:	69fb      	ldr	r3, [r7, #28]
 8012b00:	681a      	ldr	r2, [r3, #0]
 8012b02:	68fb      	ldr	r3, [r7, #12]
 8012b04:	21ff      	movs	r1, #255	; 0xff
 8012b06:	4011      	ands	r1, r2
 8012b08:	000c      	movs	r4, r1
 8012b0a:	7b19      	ldrb	r1, [r3, #12]
 8012b0c:	2000      	movs	r0, #0
 8012b0e:	4001      	ands	r1, r0
 8012b10:	1c08      	adds	r0, r1, #0
 8012b12:	1c21      	adds	r1, r4, #0
 8012b14:	4301      	orrs	r1, r0
 8012b16:	7319      	strb	r1, [r3, #12]
 8012b18:	0a11      	lsrs	r1, r2, #8
 8012b1a:	20ff      	movs	r0, #255	; 0xff
 8012b1c:	4001      	ands	r1, r0
 8012b1e:	000c      	movs	r4, r1
 8012b20:	7b59      	ldrb	r1, [r3, #13]
 8012b22:	2000      	movs	r0, #0
 8012b24:	4001      	ands	r1, r0
 8012b26:	1c08      	adds	r0, r1, #0
 8012b28:	1c21      	adds	r1, r4, #0
 8012b2a:	4301      	orrs	r1, r0
 8012b2c:	7359      	strb	r1, [r3, #13]
 8012b2e:	0c11      	lsrs	r1, r2, #16
 8012b30:	20ff      	movs	r0, #255	; 0xff
 8012b32:	4001      	ands	r1, r0
 8012b34:	000c      	movs	r4, r1
 8012b36:	7b99      	ldrb	r1, [r3, #14]
 8012b38:	2000      	movs	r0, #0
 8012b3a:	4001      	ands	r1, r0
 8012b3c:	1c08      	adds	r0, r1, #0
 8012b3e:	1c21      	adds	r1, r4, #0
 8012b40:	4301      	orrs	r1, r0
 8012b42:	7399      	strb	r1, [r3, #14]
 8012b44:	0e10      	lsrs	r0, r2, #24
 8012b46:	7bda      	ldrb	r2, [r3, #15]
 8012b48:	2100      	movs	r1, #0
 8012b4a:	400a      	ands	r2, r1
 8012b4c:	1c11      	adds	r1, r2, #0
 8012b4e:	1c02      	adds	r2, r0, #0
 8012b50:	430a      	orrs	r2, r1
 8012b52:	73da      	strb	r2, [r3, #15]
        ip4_addr_copy(iphdr->dest, *ip4_current_src_addr());
 8012b54:	4b5b      	ldr	r3, [pc, #364]	; (8012cc4 <icmp_input+0x384>)
 8012b56:	691a      	ldr	r2, [r3, #16]
 8012b58:	68fb      	ldr	r3, [r7, #12]
 8012b5a:	21ff      	movs	r1, #255	; 0xff
 8012b5c:	4011      	ands	r1, r2
 8012b5e:	000c      	movs	r4, r1
 8012b60:	7c19      	ldrb	r1, [r3, #16]
 8012b62:	2000      	movs	r0, #0
 8012b64:	4001      	ands	r1, r0
 8012b66:	1c08      	adds	r0, r1, #0
 8012b68:	1c21      	adds	r1, r4, #0
 8012b6a:	4301      	orrs	r1, r0
 8012b6c:	7419      	strb	r1, [r3, #16]
 8012b6e:	0a11      	lsrs	r1, r2, #8
 8012b70:	20ff      	movs	r0, #255	; 0xff
 8012b72:	4001      	ands	r1, r0
 8012b74:	000c      	movs	r4, r1
 8012b76:	7c59      	ldrb	r1, [r3, #17]
 8012b78:	2000      	movs	r0, #0
 8012b7a:	4001      	ands	r1, r0
 8012b7c:	1c08      	adds	r0, r1, #0
 8012b7e:	1c21      	adds	r1, r4, #0
 8012b80:	4301      	orrs	r1, r0
 8012b82:	7459      	strb	r1, [r3, #17]
 8012b84:	0c11      	lsrs	r1, r2, #16
 8012b86:	20ff      	movs	r0, #255	; 0xff
 8012b88:	4001      	ands	r1, r0
 8012b8a:	000c      	movs	r4, r1
 8012b8c:	7c99      	ldrb	r1, [r3, #18]
 8012b8e:	2000      	movs	r0, #0
 8012b90:	4001      	ands	r1, r0
 8012b92:	1c08      	adds	r0, r1, #0
 8012b94:	1c21      	adds	r1, r4, #0
 8012b96:	4301      	orrs	r1, r0
 8012b98:	7499      	strb	r1, [r3, #18]
 8012b9a:	0e10      	lsrs	r0, r2, #24
 8012b9c:	7cda      	ldrb	r2, [r3, #19]
 8012b9e:	2100      	movs	r1, #0
 8012ba0:	400a      	ands	r2, r1
 8012ba2:	1c11      	adds	r1, r2, #0
 8012ba4:	1c02      	adds	r2, r0, #0
 8012ba6:	430a      	orrs	r2, r1
 8012ba8:	74da      	strb	r2, [r3, #19]
        ICMPH_TYPE_SET(iecho, ICMP_ER);
 8012baa:	693b      	ldr	r3, [r7, #16]
 8012bac:	2200      	movs	r2, #0
 8012bae:	701a      	strb	r2, [r3, #0]
#if CHECKSUM_GEN_ICMP
        IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_GEN_ICMP) {
          /* adjust the checksum */
          if (iecho->chksum > PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
 8012bb0:	693b      	ldr	r3, [r7, #16]
 8012bb2:	789a      	ldrb	r2, [r3, #2]
 8012bb4:	78db      	ldrb	r3, [r3, #3]
 8012bb6:	021b      	lsls	r3, r3, #8
 8012bb8:	4313      	orrs	r3, r2
 8012bba:	b29b      	uxth	r3, r3
 8012bbc:	4a47      	ldr	r2, [pc, #284]	; (8012cdc <icmp_input+0x39c>)
 8012bbe:	4293      	cmp	r3, r2
 8012bc0:	d91c      	bls.n	8012bfc <icmp_input+0x2bc>
            iecho->chksum = (u16_t)(iecho->chksum + PP_HTONS((u16_t)(ICMP_ECHO << 8)) + 1);
 8012bc2:	693b      	ldr	r3, [r7, #16]
 8012bc4:	789a      	ldrb	r2, [r3, #2]
 8012bc6:	78db      	ldrb	r3, [r3, #3]
 8012bc8:	021b      	lsls	r3, r3, #8
 8012bca:	4313      	orrs	r3, r2
 8012bcc:	b29b      	uxth	r3, r3
 8012bce:	3309      	adds	r3, #9
 8012bd0:	b29a      	uxth	r2, r3
 8012bd2:	693b      	ldr	r3, [r7, #16]
 8012bd4:	21ff      	movs	r1, #255	; 0xff
 8012bd6:	4011      	ands	r1, r2
 8012bd8:	000c      	movs	r4, r1
 8012bda:	7899      	ldrb	r1, [r3, #2]
 8012bdc:	2000      	movs	r0, #0
 8012bde:	4001      	ands	r1, r0
 8012be0:	1c08      	adds	r0, r1, #0
 8012be2:	1c21      	adds	r1, r4, #0
 8012be4:	4301      	orrs	r1, r0
 8012be6:	7099      	strb	r1, [r3, #2]
 8012be8:	0a12      	lsrs	r2, r2, #8
 8012bea:	b290      	uxth	r0, r2
 8012bec:	78da      	ldrb	r2, [r3, #3]
 8012bee:	2100      	movs	r1, #0
 8012bf0:	400a      	ands	r2, r1
 8012bf2:	1c11      	adds	r1, r2, #0
 8012bf4:	1c02      	adds	r2, r0, #0
 8012bf6:	430a      	orrs	r2, r1
 8012bf8:	70da      	strb	r2, [r3, #3]
 8012bfa:	e01b      	b.n	8012c34 <icmp_input+0x2f4>
          } else {
            iecho->chksum = (u16_t)(iecho->chksum + PP_HTONS(ICMP_ECHO << 8));
 8012bfc:	693b      	ldr	r3, [r7, #16]
 8012bfe:	789a      	ldrb	r2, [r3, #2]
 8012c00:	78db      	ldrb	r3, [r3, #3]
 8012c02:	021b      	lsls	r3, r3, #8
 8012c04:	4313      	orrs	r3, r2
 8012c06:	b29b      	uxth	r3, r3
 8012c08:	3308      	adds	r3, #8
 8012c0a:	b29a      	uxth	r2, r3
 8012c0c:	693b      	ldr	r3, [r7, #16]
 8012c0e:	21ff      	movs	r1, #255	; 0xff
 8012c10:	4011      	ands	r1, r2
 8012c12:	000c      	movs	r4, r1
 8012c14:	7899      	ldrb	r1, [r3, #2]
 8012c16:	2000      	movs	r0, #0
 8012c18:	4001      	ands	r1, r0
 8012c1a:	1c08      	adds	r0, r1, #0
 8012c1c:	1c21      	adds	r1, r4, #0
 8012c1e:	4301      	orrs	r1, r0
 8012c20:	7099      	strb	r1, [r3, #2]
 8012c22:	0a12      	lsrs	r2, r2, #8
 8012c24:	b290      	uxth	r0, r2
 8012c26:	78da      	ldrb	r2, [r3, #3]
 8012c28:	2100      	movs	r1, #0
 8012c2a:	400a      	ands	r2, r1
 8012c2c:	1c11      	adds	r1, r2, #0
 8012c2e:	1c02      	adds	r2, r0, #0
 8012c30:	430a      	orrs	r2, r1
 8012c32:	70da      	strb	r2, [r3, #3]
#else /* CHECKSUM_GEN_ICMP */
        iecho->chksum = 0;
#endif /* CHECKSUM_GEN_ICMP */

        /* Set the correct TTL and recalculate the header checksum. */
        IPH_TTL_SET(iphdr, ICMP_TTL);
 8012c34:	68fb      	ldr	r3, [r7, #12]
 8012c36:	22ff      	movs	r2, #255	; 0xff
 8012c38:	721a      	strb	r2, [r3, #8]
        IPH_CHKSUM_SET(iphdr, 0);
 8012c3a:	68fb      	ldr	r3, [r7, #12]
 8012c3c:	7a9a      	ldrb	r2, [r3, #10]
 8012c3e:	2100      	movs	r1, #0
 8012c40:	400a      	ands	r2, r1
 8012c42:	729a      	strb	r2, [r3, #10]
 8012c44:	7ada      	ldrb	r2, [r3, #11]
 8012c46:	2100      	movs	r1, #0
 8012c48:	400a      	ands	r2, r1
 8012c4a:	72da      	strb	r2, [r3, #11]
#if CHECKSUM_GEN_IP
        IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_GEN_IP) {
          IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, hlen));
 8012c4c:	2322      	movs	r3, #34	; 0x22
 8012c4e:	18fb      	adds	r3, r7, r3
 8012c50:	881a      	ldrh	r2, [r3, #0]
 8012c52:	68fb      	ldr	r3, [r7, #12]
 8012c54:	0011      	movs	r1, r2
 8012c56:	0018      	movs	r0, r3
 8012c58:	f7f5 f854 	bl	8007d04 <inet_chksum>
 8012c5c:	0003      	movs	r3, r0
 8012c5e:	001a      	movs	r2, r3
 8012c60:	68fb      	ldr	r3, [r7, #12]
 8012c62:	21ff      	movs	r1, #255	; 0xff
 8012c64:	4011      	ands	r1, r2
 8012c66:	000c      	movs	r4, r1
 8012c68:	7a99      	ldrb	r1, [r3, #10]
 8012c6a:	2000      	movs	r0, #0
 8012c6c:	4001      	ands	r1, r0
 8012c6e:	1c08      	adds	r0, r1, #0
 8012c70:	1c21      	adds	r1, r4, #0
 8012c72:	4301      	orrs	r1, r0
 8012c74:	7299      	strb	r1, [r3, #10]
 8012c76:	0a12      	lsrs	r2, r2, #8
 8012c78:	b290      	uxth	r0, r2
 8012c7a:	7ada      	ldrb	r2, [r3, #11]
 8012c7c:	2100      	movs	r1, #0
 8012c7e:	400a      	ands	r2, r1
 8012c80:	1c11      	adds	r1, r2, #0
 8012c82:	1c02      	adds	r2, r0, #0
 8012c84:	430a      	orrs	r2, r1
 8012c86:	72da      	strb	r2, [r3, #11]
        MIB2_STATS_INC(mib2.icmpoutmsgs);
        /* increase number of echo replies attempted to send */
        MIB2_STATS_INC(mib2.icmpoutechoreps);

        /* send an ICMP packet */
        ret = ip4_output_if(p, src, LWIP_IP_HDRINCL,
 8012c88:	230b      	movs	r3, #11
 8012c8a:	18fc      	adds	r4, r7, r3
 8012c8c:	69f9      	ldr	r1, [r7, #28]
 8012c8e:	6878      	ldr	r0, [r7, #4]
 8012c90:	683b      	ldr	r3, [r7, #0]
 8012c92:	9302      	str	r3, [sp, #8]
 8012c94:	2301      	movs	r3, #1
 8012c96:	9301      	str	r3, [sp, #4]
 8012c98:	2300      	movs	r3, #0
 8012c9a:	9300      	str	r3, [sp, #0]
 8012c9c:	23ff      	movs	r3, #255	; 0xff
 8012c9e:	2200      	movs	r2, #0
 8012ca0:	f000 fb06 	bl	80132b0 <ip4_output_if>
 8012ca4:	0003      	movs	r3, r0
 8012ca6:	7023      	strb	r3, [r4, #0]
                            ICMP_TTL, 0, IP_PROTO_ICMP, inp);
        if (ret != ERR_OK) {
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %s\n", lwip_strerr(ret)));
        }
      }
      break;
 8012ca8:	e001      	b.n	8012cae <icmp_input+0x36e>
      break;
 8012caa:	46c0      	nop			; (mov r8, r8)
 8012cac:	e000      	b.n	8012cb0 <icmp_input+0x370>
      break;
 8012cae:	46c0      	nop			; (mov r8, r8)
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n",
                               (s16_t)type, (s16_t)code));
      ICMP_STATS_INC(icmp.proterr);
      ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
 8012cb0:	687b      	ldr	r3, [r7, #4]
 8012cb2:	0018      	movs	r0, r3
 8012cb4:	f7f6 fcee 	bl	8009694 <pbuf_free>
  return;
 8012cb8:	e024      	b.n	8012d04 <icmp_input+0x3c4>
    goto lenerr;
 8012cba:	46c0      	nop			; (mov r8, r8)
 8012cbc:	e011      	b.n	8012ce2 <icmp_input+0x3a2>
    goto lenerr;
 8012cbe:	46c0      	nop			; (mov r8, r8)
 8012cc0:	e00f      	b.n	8012ce2 <icmp_input+0x3a2>
 8012cc2:	46c0      	nop			; (mov r8, r8)
 8012cc4:	200014c4 	.word	0x200014c4
 8012cc8:	200014d8 	.word	0x200014d8
 8012ccc:	08020bb4 	.word	0x08020bb4
 8012cd0:	08020be0 	.word	0x08020be0
 8012cd4:	08020c18 	.word	0x08020c18
 8012cd8:	08020c44 	.word	0x08020c44
 8012cdc:	0000fff7 	.word	0x0000fff7
        goto lenerr;
 8012ce0:	46c0      	nop			; (mov r8, r8)
lenerr:
  pbuf_free(p);
 8012ce2:	687b      	ldr	r3, [r7, #4]
 8012ce4:	0018      	movs	r0, r3
 8012ce6:	f7f6 fcd5 	bl	8009694 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  MIB2_STATS_INC(mib2.icmpinerrors);
  return;
 8012cea:	e00b      	b.n	8012d04 <icmp_input+0x3c4>
        goto icmperr;
 8012cec:	46c0      	nop			; (mov r8, r8)
 8012cee:	e004      	b.n	8012cfa <icmp_input+0x3ba>
        goto icmperr;
 8012cf0:	46c0      	nop			; (mov r8, r8)
 8012cf2:	e002      	b.n	8012cfa <icmp_input+0x3ba>
          goto icmperr;
 8012cf4:	46c0      	nop			; (mov r8, r8)
 8012cf6:	e000      	b.n	8012cfa <icmp_input+0x3ba>
          goto icmperr;
 8012cf8:	46c0      	nop			; (mov r8, r8)
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN || !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
icmperr:
  pbuf_free(p);
 8012cfa:	687b      	ldr	r3, [r7, #4]
 8012cfc:	0018      	movs	r0, r3
 8012cfe:	f7f6 fcc9 	bl	8009694 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  MIB2_STATS_INC(mib2.icmpinerrors);
  return;
 8012d02:	46c0      	nop			; (mov r8, r8)
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN || !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
}
 8012d04:	46bd      	mov	sp, r7
 8012d06:	b00b      	add	sp, #44	; 0x2c
 8012d08:	bd90      	pop	{r4, r7, pc}
 8012d0a:	46c0      	nop			; (mov r8, r8)

08012d0c <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
 8012d0c:	b580      	push	{r7, lr}
 8012d0e:	b082      	sub	sp, #8
 8012d10:	af00      	add	r7, sp, #0
 8012d12:	6078      	str	r0, [r7, #4]
 8012d14:	000a      	movs	r2, r1
 8012d16:	1cfb      	adds	r3, r7, #3
 8012d18:	701a      	strb	r2, [r3, #0]
  MIB2_STATS_INC(mib2.icmpoutdestunreachs);
  icmp_send_response(p, ICMP_DUR, t);
 8012d1a:	1cfb      	adds	r3, r7, #3
 8012d1c:	781a      	ldrb	r2, [r3, #0]
 8012d1e:	687b      	ldr	r3, [r7, #4]
 8012d20:	2103      	movs	r1, #3
 8012d22:	0018      	movs	r0, r3
 8012d24:	f000 f804 	bl	8012d30 <icmp_send_response>
}
 8012d28:	46c0      	nop			; (mov r8, r8)
 8012d2a:	46bd      	mov	sp, r7
 8012d2c:	b002      	add	sp, #8
 8012d2e:	bd80      	pop	{r7, pc}

08012d30 <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
 8012d30:	b5b0      	push	{r4, r5, r7, lr}
 8012d32:	b08c      	sub	sp, #48	; 0x30
 8012d34:	af04      	add	r7, sp, #16
 8012d36:	6078      	str	r0, [r7, #4]
 8012d38:	0008      	movs	r0, r1
 8012d3a:	0011      	movs	r1, r2
 8012d3c:	1cfb      	adds	r3, r7, #3
 8012d3e:	1c02      	adds	r2, r0, #0
 8012d40:	701a      	strb	r2, [r3, #0]
 8012d42:	1cbb      	adds	r3, r7, #2
 8012d44:	1c0a      	adds	r2, r1, #0
 8012d46:	701a      	strb	r2, [r3, #0]

  /* increase number of messages attempted to send */
  MIB2_STATS_INC(mib2.icmpoutmsgs);

  /* Keep IP header + up to 8 bytes */
  response_pkt_len = IP_HLEN + ICMP_DEST_UNREACH_DATASIZE;
 8012d48:	211a      	movs	r1, #26
 8012d4a:	187b      	adds	r3, r7, r1
 8012d4c:	221c      	movs	r2, #28
 8012d4e:	801a      	strh	r2, [r3, #0]
  if (p->tot_len < response_pkt_len) {
 8012d50:	687b      	ldr	r3, [r7, #4]
 8012d52:	891b      	ldrh	r3, [r3, #8]
 8012d54:	187a      	adds	r2, r7, r1
 8012d56:	8812      	ldrh	r2, [r2, #0]
 8012d58:	429a      	cmp	r2, r3
 8012d5a:	d903      	bls.n	8012d64 <icmp_send_response+0x34>
    response_pkt_len = p->tot_len;
 8012d5c:	187b      	adds	r3, r7, r1
 8012d5e:	687a      	ldr	r2, [r7, #4]
 8012d60:	8912      	ldrh	r2, [r2, #8]
 8012d62:	801a      	strh	r2, [r3, #0]
  }

  /* ICMP header + part of original packet */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + response_pkt_len, PBUF_RAM);
 8012d64:	241a      	movs	r4, #26
 8012d66:	193b      	adds	r3, r7, r4
 8012d68:	881b      	ldrh	r3, [r3, #0]
 8012d6a:	3308      	adds	r3, #8
 8012d6c:	b29b      	uxth	r3, r3
 8012d6e:	22a0      	movs	r2, #160	; 0xa0
 8012d70:	0092      	lsls	r2, r2, #2
 8012d72:	0019      	movs	r1, r3
 8012d74:	2024      	movs	r0, #36	; 0x24
 8012d76:	f7f6 f915 	bl	8008fa4 <pbuf_alloc>
 8012d7a:	0003      	movs	r3, r0
 8012d7c:	617b      	str	r3, [r7, #20]
  if (q == NULL) {
 8012d7e:	697b      	ldr	r3, [r7, #20]
 8012d80:	2b00      	cmp	r3, #0
 8012d82:	d100      	bne.n	8012d86 <icmp_send_response+0x56>
 8012d84:	e087      	b.n	8012e96 <icmp_send_response+0x166>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    MIB2_STATS_INC(mib2.icmpouterrors);
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
 8012d86:	697b      	ldr	r3, [r7, #20]
 8012d88:	895b      	ldrh	r3, [r3, #10]
 8012d8a:	001a      	movs	r2, r3
 8012d8c:	193b      	adds	r3, r7, r4
 8012d8e:	881b      	ldrh	r3, [r3, #0]
 8012d90:	3308      	adds	r3, #8
 8012d92:	429a      	cmp	r2, r3
 8012d94:	d206      	bcs.n	8012da4 <icmp_send_response+0x74>
 8012d96:	4b42      	ldr	r3, [pc, #264]	; (8012ea0 <icmp_send_response+0x170>)
 8012d98:	22b7      	movs	r2, #183	; 0xb7
 8012d9a:	0052      	lsls	r2, r2, #1
 8012d9c:	4941      	ldr	r1, [pc, #260]	; (8012ea4 <icmp_send_response+0x174>)
 8012d9e:	4842      	ldr	r0, [pc, #264]	; (8012ea8 <icmp_send_response+0x178>)
 8012da0:	f7ef fa14 	bl	80021cc <app_debug_rtt_raw>
              (q->len >= (sizeof(struct icmp_echo_hdr) + response_pkt_len)));

  iphdr = (struct ip_hdr *)p->payload;
 8012da4:	687b      	ldr	r3, [r7, #4]
 8012da6:	685b      	ldr	r3, [r3, #4]
 8012da8:	613b      	str	r3, [r7, #16]
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->src);
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->dest);
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
 8012daa:	697b      	ldr	r3, [r7, #20]
 8012dac:	685b      	ldr	r3, [r3, #4]
 8012dae:	60fb      	str	r3, [r7, #12]
  icmphdr->type = type;
 8012db0:	68fb      	ldr	r3, [r7, #12]
 8012db2:	1cfa      	adds	r2, r7, #3
 8012db4:	7812      	ldrb	r2, [r2, #0]
 8012db6:	701a      	strb	r2, [r3, #0]
  icmphdr->code = code;
 8012db8:	68fb      	ldr	r3, [r7, #12]
 8012dba:	1cba      	adds	r2, r7, #2
 8012dbc:	7812      	ldrb	r2, [r2, #0]
 8012dbe:	705a      	strb	r2, [r3, #1]
  icmphdr->id = 0;
 8012dc0:	68fb      	ldr	r3, [r7, #12]
 8012dc2:	791a      	ldrb	r2, [r3, #4]
 8012dc4:	2100      	movs	r1, #0
 8012dc6:	400a      	ands	r2, r1
 8012dc8:	711a      	strb	r2, [r3, #4]
 8012dca:	795a      	ldrb	r2, [r3, #5]
 8012dcc:	2100      	movs	r1, #0
 8012dce:	400a      	ands	r2, r1
 8012dd0:	715a      	strb	r2, [r3, #5]
  icmphdr->seqno = 0;
 8012dd2:	68fb      	ldr	r3, [r7, #12]
 8012dd4:	799a      	ldrb	r2, [r3, #6]
 8012dd6:	2100      	movs	r1, #0
 8012dd8:	400a      	ands	r2, r1
 8012dda:	719a      	strb	r2, [r3, #6]
 8012ddc:	79da      	ldrb	r2, [r3, #7]
 8012dde:	2100      	movs	r1, #0
 8012de0:	400a      	ands	r2, r1
 8012de2:	71da      	strb	r2, [r3, #7]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 8012de4:	697b      	ldr	r3, [r7, #20]
 8012de6:	685b      	ldr	r3, [r3, #4]
 8012de8:	3308      	adds	r3, #8
 8012dea:	0018      	movs	r0, r3
 8012dec:	687b      	ldr	r3, [r7, #4]
 8012dee:	6859      	ldr	r1, [r3, #4]
 8012df0:	231a      	movs	r3, #26
 8012df2:	18fb      	adds	r3, r7, r3
 8012df4:	881b      	ldrh	r3, [r3, #0]
 8012df6:	001a      	movs	r2, r3
 8012df8:	f009 fcfc 	bl	801c7f4 <memcpy>
          response_pkt_len);

  ip4_addr_copy(iphdr_src, iphdr->src);
 8012dfc:	693b      	ldr	r3, [r7, #16]
 8012dfe:	7b1a      	ldrb	r2, [r3, #12]
 8012e00:	7b59      	ldrb	r1, [r3, #13]
 8012e02:	0209      	lsls	r1, r1, #8
 8012e04:	430a      	orrs	r2, r1
 8012e06:	7b99      	ldrb	r1, [r3, #14]
 8012e08:	0409      	lsls	r1, r1, #16
 8012e0a:	430a      	orrs	r2, r1
 8012e0c:	7bdb      	ldrb	r3, [r3, #15]
 8012e0e:	061b      	lsls	r3, r3, #24
 8012e10:	4313      	orrs	r3, r2
 8012e12:	60bb      	str	r3, [r7, #8]
    ip4_addr_t iphdr_dst;
    ip4_addr_copy(iphdr_dst, iphdr->dest);
    netif = ip4_route_src(&iphdr_dst, &iphdr_src);
  }
#else
  netif = ip4_route(&iphdr_src);
 8012e14:	2508      	movs	r5, #8
 8012e16:	197b      	adds	r3, r7, r5
 8012e18:	0018      	movs	r0, r3
 8012e1a:	f000 f847 	bl	8012eac <ip4_route>
 8012e1e:	0003      	movs	r3, r0
 8012e20:	61fb      	str	r3, [r7, #28]
#endif
  if (netif != NULL) {
 8012e22:	69fb      	ldr	r3, [r7, #28]
 8012e24:	2b00      	cmp	r3, #0
 8012e26:	d031      	beq.n	8012e8c <icmp_send_response+0x15c>
    /* calculate checksum */
    icmphdr->chksum = 0;
 8012e28:	68fb      	ldr	r3, [r7, #12]
 8012e2a:	789a      	ldrb	r2, [r3, #2]
 8012e2c:	2100      	movs	r1, #0
 8012e2e:	400a      	ands	r2, r1
 8012e30:	709a      	strb	r2, [r3, #2]
 8012e32:	78da      	ldrb	r2, [r3, #3]
 8012e34:	2100      	movs	r1, #0
 8012e36:	400a      	ands	r2, r1
 8012e38:	70da      	strb	r2, [r3, #3]
#if CHECKSUM_GEN_ICMP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_ICMP) {
      icmphdr->chksum = inet_chksum(icmphdr, q->len);
 8012e3a:	697b      	ldr	r3, [r7, #20]
 8012e3c:	895a      	ldrh	r2, [r3, #10]
 8012e3e:	68fb      	ldr	r3, [r7, #12]
 8012e40:	0011      	movs	r1, r2
 8012e42:	0018      	movs	r0, r3
 8012e44:	f7f4 ff5e 	bl	8007d04 <inet_chksum>
 8012e48:	0003      	movs	r3, r0
 8012e4a:	001a      	movs	r2, r3
 8012e4c:	68fb      	ldr	r3, [r7, #12]
 8012e4e:	21ff      	movs	r1, #255	; 0xff
 8012e50:	4011      	ands	r1, r2
 8012e52:	000c      	movs	r4, r1
 8012e54:	7899      	ldrb	r1, [r3, #2]
 8012e56:	2000      	movs	r0, #0
 8012e58:	4001      	ands	r1, r0
 8012e5a:	1c08      	adds	r0, r1, #0
 8012e5c:	1c21      	adds	r1, r4, #0
 8012e5e:	4301      	orrs	r1, r0
 8012e60:	7099      	strb	r1, [r3, #2]
 8012e62:	0a12      	lsrs	r2, r2, #8
 8012e64:	b290      	uxth	r0, r2
 8012e66:	78da      	ldrb	r2, [r3, #3]
 8012e68:	2100      	movs	r1, #0
 8012e6a:	400a      	ands	r2, r1
 8012e6c:	1c11      	adds	r1, r2, #0
 8012e6e:	1c02      	adds	r2, r0, #0
 8012e70:	430a      	orrs	r2, r1
 8012e72:	70da      	strb	r2, [r3, #3]
    }
#endif
    ICMP_STATS_INC(icmp.xmit);
    ip4_output_if(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP, netif);
 8012e74:	197a      	adds	r2, r7, r5
 8012e76:	6978      	ldr	r0, [r7, #20]
 8012e78:	69fb      	ldr	r3, [r7, #28]
 8012e7a:	9302      	str	r3, [sp, #8]
 8012e7c:	2301      	movs	r3, #1
 8012e7e:	9301      	str	r3, [sp, #4]
 8012e80:	2300      	movs	r3, #0
 8012e82:	9300      	str	r3, [sp, #0]
 8012e84:	23ff      	movs	r3, #255	; 0xff
 8012e86:	2100      	movs	r1, #0
 8012e88:	f000 fa12 	bl	80132b0 <ip4_output_if>
  }
  pbuf_free(q);
 8012e8c:	697b      	ldr	r3, [r7, #20]
 8012e8e:	0018      	movs	r0, r3
 8012e90:	f7f6 fc00 	bl	8009694 <pbuf_free>
 8012e94:	e000      	b.n	8012e98 <icmp_send_response+0x168>
    return;
 8012e96:	46c0      	nop			; (mov r8, r8)
}
 8012e98:	46bd      	mov	sp, r7
 8012e9a:	b008      	add	sp, #32
 8012e9c:	bdb0      	pop	{r4, r5, r7, pc}
 8012e9e:	46c0      	nop			; (mov r8, r8)
 8012ea0:	08020bb4 	.word	0x08020bb4
 8012ea4:	08020c78 	.word	0x08020c78
 8012ea8:	08020c18 	.word	0x08020c18

08012eac <ip4_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip4_route(const ip4_addr_t *dest)
{
 8012eac:	b580      	push	{r7, lr}
 8012eae:	b084      	sub	sp, #16
 8012eb0:	af00      	add	r7, sp, #0
 8012eb2:	6078      	str	r0, [r7, #4]

  /* bug #54569: in case LWIP_SINGLE_NETIF=1 and LWIP_DEBUGF() disabled, the following loop is optimized away */
  LWIP_UNUSED_ARG(dest);

  /* iterate through netifs */
  NETIF_FOREACH(netif) {
 8012eb4:	4b33      	ldr	r3, [pc, #204]	; (8012f84 <ip4_route+0xd8>)
 8012eb6:	681b      	ldr	r3, [r3, #0]
 8012eb8:	60fb      	str	r3, [r7, #12]
 8012eba:	e037      	b.n	8012f2c <ip4_route+0x80>
    /* is the netif up, does it have a link and a valid address? */
    if (netif_is_up(netif) && netif_is_link_up(netif) && !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 8012ebc:	68fb      	ldr	r3, [r7, #12]
 8012ebe:	2231      	movs	r2, #49	; 0x31
 8012ec0:	5c9b      	ldrb	r3, [r3, r2]
 8012ec2:	1c1a      	adds	r2, r3, #0
 8012ec4:	2301      	movs	r3, #1
 8012ec6:	4013      	ands	r3, r2
 8012ec8:	b2db      	uxtb	r3, r3
 8012eca:	2b00      	cmp	r3, #0
 8012ecc:	d02b      	beq.n	8012f26 <ip4_route+0x7a>
 8012ece:	68fb      	ldr	r3, [r7, #12]
 8012ed0:	2231      	movs	r2, #49	; 0x31
 8012ed2:	5c9b      	ldrb	r3, [r3, r2]
 8012ed4:	089b      	lsrs	r3, r3, #2
 8012ed6:	1c1a      	adds	r2, r3, #0
 8012ed8:	2301      	movs	r3, #1
 8012eda:	4013      	ands	r3, r2
 8012edc:	b2db      	uxtb	r3, r3
 8012ede:	2b00      	cmp	r3, #0
 8012ee0:	d021      	beq.n	8012f26 <ip4_route+0x7a>
 8012ee2:	68fb      	ldr	r3, [r7, #12]
 8012ee4:	3304      	adds	r3, #4
 8012ee6:	681b      	ldr	r3, [r3, #0]
 8012ee8:	2b00      	cmp	r3, #0
 8012eea:	d01c      	beq.n	8012f26 <ip4_route+0x7a>
      /* network mask matches? */
      if (ip4_addr_netcmp(dest, netif_ip4_addr(netif), netif_ip4_netmask(netif))) {
 8012eec:	687b      	ldr	r3, [r7, #4]
 8012eee:	681a      	ldr	r2, [r3, #0]
 8012ef0:	68fb      	ldr	r3, [r7, #12]
 8012ef2:	3304      	adds	r3, #4
 8012ef4:	681b      	ldr	r3, [r3, #0]
 8012ef6:	405a      	eors	r2, r3
 8012ef8:	68fb      	ldr	r3, [r7, #12]
 8012efa:	3308      	adds	r3, #8
 8012efc:	681b      	ldr	r3, [r3, #0]
 8012efe:	4013      	ands	r3, r2
 8012f00:	d101      	bne.n	8012f06 <ip4_route+0x5a>
        /* return netif on which to forward IP packet */
        return netif;
 8012f02:	68fb      	ldr	r3, [r7, #12]
 8012f04:	e039      	b.n	8012f7a <ip4_route+0xce>
      }
      /* gateway matches on a non broadcast interface? (i.e. peer in a point to point interface) */
      if (((netif->flags & NETIF_FLAG_BROADCAST) == 0) && ip4_addr_cmp(dest, netif_ip4_gw(netif))) {
 8012f06:	68fb      	ldr	r3, [r7, #12]
 8012f08:	2231      	movs	r2, #49	; 0x31
 8012f0a:	5c9b      	ldrb	r3, [r3, r2]
 8012f0c:	001a      	movs	r2, r3
 8012f0e:	2302      	movs	r3, #2
 8012f10:	4013      	ands	r3, r2
 8012f12:	d108      	bne.n	8012f26 <ip4_route+0x7a>
 8012f14:	687b      	ldr	r3, [r7, #4]
 8012f16:	681a      	ldr	r2, [r3, #0]
 8012f18:	68fb      	ldr	r3, [r7, #12]
 8012f1a:	330c      	adds	r3, #12
 8012f1c:	681b      	ldr	r3, [r3, #0]
 8012f1e:	429a      	cmp	r2, r3
 8012f20:	d101      	bne.n	8012f26 <ip4_route+0x7a>
        /* return netif on which to forward IP packet */
        return netif;
 8012f22:	68fb      	ldr	r3, [r7, #12]
 8012f24:	e029      	b.n	8012f7a <ip4_route+0xce>
  NETIF_FOREACH(netif) {
 8012f26:	68fb      	ldr	r3, [r7, #12]
 8012f28:	681b      	ldr	r3, [r3, #0]
 8012f2a:	60fb      	str	r3, [r7, #12]
 8012f2c:	68fb      	ldr	r3, [r7, #12]
 8012f2e:	2b00      	cmp	r3, #0
 8012f30:	d1c4      	bne.n	8012ebc <ip4_route+0x10>
    return netif;
  }
#endif
#endif /* !LWIP_SINGLE_NETIF */

  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
 8012f32:	4b15      	ldr	r3, [pc, #84]	; (8012f88 <ip4_route+0xdc>)
 8012f34:	681b      	ldr	r3, [r3, #0]
 8012f36:	2b00      	cmp	r3, #0
 8012f38:	d01b      	beq.n	8012f72 <ip4_route+0xc6>
 8012f3a:	4b13      	ldr	r3, [pc, #76]	; (8012f88 <ip4_route+0xdc>)
 8012f3c:	681b      	ldr	r3, [r3, #0]
 8012f3e:	2231      	movs	r2, #49	; 0x31
 8012f40:	5c9b      	ldrb	r3, [r3, r2]
 8012f42:	001a      	movs	r2, r3
 8012f44:	2301      	movs	r3, #1
 8012f46:	4013      	ands	r3, r2
 8012f48:	d013      	beq.n	8012f72 <ip4_route+0xc6>
 8012f4a:	4b0f      	ldr	r3, [pc, #60]	; (8012f88 <ip4_route+0xdc>)
 8012f4c:	681b      	ldr	r3, [r3, #0]
 8012f4e:	2231      	movs	r2, #49	; 0x31
 8012f50:	5c9b      	ldrb	r3, [r3, r2]
 8012f52:	001a      	movs	r2, r3
 8012f54:	2304      	movs	r3, #4
 8012f56:	4013      	ands	r3, r2
 8012f58:	d00b      	beq.n	8012f72 <ip4_route+0xc6>
      ip4_addr_isany_val(*netif_ip4_addr(netif_default)) || ip4_addr_isloopback(dest)) {
 8012f5a:	4b0b      	ldr	r3, [pc, #44]	; (8012f88 <ip4_route+0xdc>)
 8012f5c:	681b      	ldr	r3, [r3, #0]
 8012f5e:	3304      	adds	r3, #4
 8012f60:	681b      	ldr	r3, [r3, #0]
  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
 8012f62:	2b00      	cmp	r3, #0
 8012f64:	d005      	beq.n	8012f72 <ip4_route+0xc6>
      ip4_addr_isany_val(*netif_ip4_addr(netif_default)) || ip4_addr_isloopback(dest)) {
 8012f66:	687b      	ldr	r3, [r7, #4]
 8012f68:	681b      	ldr	r3, [r3, #0]
 8012f6a:	22ff      	movs	r2, #255	; 0xff
 8012f6c:	4013      	ands	r3, r2
 8012f6e:	2b7f      	cmp	r3, #127	; 0x7f
 8012f70:	d101      	bne.n	8012f76 <ip4_route+0xca>
       If this is not good enough for you, use LWIP_HOOK_IP4_ROUTE() */
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
                ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    MIB2_STATS_INC(mib2.ipoutnoroutes);
    return NULL;
 8012f72:	2300      	movs	r3, #0
 8012f74:	e001      	b.n	8012f7a <ip4_route+0xce>
  }

  return netif_default;
 8012f76:	4b04      	ldr	r3, [pc, #16]	; (8012f88 <ip4_route+0xdc>)
 8012f78:	681b      	ldr	r3, [r3, #0]
}
 8012f7a:	0018      	movs	r0, r3
 8012f7c:	46bd      	mov	sp, r7
 8012f7e:	b004      	add	sp, #16
 8012f80:	bd80      	pop	{r7, pc}
 8012f82:	46c0      	nop			; (mov r8, r8)
 8012f84:	20002b08 	.word	0x20002b08
 8012f88:	20002b0c 	.word	0x20002b0c

08012f8c <ip4_input_accept>:
#endif /* IP_FORWARD */

/** Return true if the current input packet should be accepted on this netif */
static int
ip4_input_accept(struct netif *netif)
{
 8012f8c:	b580      	push	{r7, lr}
 8012f8e:	b082      	sub	sp, #8
 8012f90:	af00      	add	r7, sp, #0
 8012f92:	6078      	str	r0, [r7, #4]
                         ip4_addr_get_u32(ip4_current_dest_addr()) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
                         ip4_addr_get_u32(netif_ip4_addr(netif)) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
                         ip4_addr_get_u32(ip4_current_dest_addr()) & ~ip4_addr_get_u32(netif_ip4_netmask(netif))));

  /* interface is up and configured? */
  if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
 8012f94:	687b      	ldr	r3, [r7, #4]
 8012f96:	2231      	movs	r2, #49	; 0x31
 8012f98:	5c9b      	ldrb	r3, [r3, r2]
 8012f9a:	1c1a      	adds	r2, r3, #0
 8012f9c:	2301      	movs	r3, #1
 8012f9e:	4013      	ands	r3, r2
 8012fa0:	b2db      	uxtb	r3, r3
 8012fa2:	2b00      	cmp	r3, #0
 8012fa4:	d016      	beq.n	8012fd4 <ip4_input_accept+0x48>
 8012fa6:	687b      	ldr	r3, [r7, #4]
 8012fa8:	3304      	adds	r3, #4
 8012faa:	681b      	ldr	r3, [r3, #0]
 8012fac:	2b00      	cmp	r3, #0
 8012fae:	d011      	beq.n	8012fd4 <ip4_input_accept+0x48>
    /* unicast to this interface address? */
    if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 8012fb0:	4b0b      	ldr	r3, [pc, #44]	; (8012fe0 <ip4_input_accept+0x54>)
 8012fb2:	695a      	ldr	r2, [r3, #20]
 8012fb4:	687b      	ldr	r3, [r7, #4]
 8012fb6:	3304      	adds	r3, #4
 8012fb8:	681b      	ldr	r3, [r3, #0]
 8012fba:	429a      	cmp	r2, r3
 8012fbc:	d008      	beq.n	8012fd0 <ip4_input_accept+0x44>
        /* or broadcast on this interface network address? */
        ip4_addr_isbroadcast(ip4_current_dest_addr(), netif)
 8012fbe:	4b08      	ldr	r3, [pc, #32]	; (8012fe0 <ip4_input_accept+0x54>)
 8012fc0:	695b      	ldr	r3, [r3, #20]
 8012fc2:	687a      	ldr	r2, [r7, #4]
 8012fc4:	0011      	movs	r1, r2
 8012fc6:	0018      	movs	r0, r3
 8012fc8:	f000 fb98 	bl	80136fc <ip4_addr_isbroadcast_u32>
 8012fcc:	1e03      	subs	r3, r0, #0
    if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 8012fce:	d001      	beq.n	8012fd4 <ip4_input_accept+0x48>
#endif /* LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF */
       ) {
      LWIP_DEBUGF(IP_DEBUG, ("ip4_input: packet accepted on interface %c%c\n",
                             netif->name[0], netif->name[1]));
      /* accept on this netif */
      return 1;
 8012fd0:	2301      	movs	r3, #1
 8012fd2:	e000      	b.n	8012fd6 <ip4_input_accept+0x4a>
      /* accept on this netif */
      return 1;
    }
#endif /* LWIP_AUTOIP */
  }
  return 0;
 8012fd4:	2300      	movs	r3, #0
}
 8012fd6:	0018      	movs	r0, r3
 8012fd8:	46bd      	mov	sp, r7
 8012fda:	b002      	add	sp, #8
 8012fdc:	bd80      	pop	{r7, pc}
 8012fde:	46c0      	nop			; (mov r8, r8)
 8012fe0:	200014c4 	.word	0x200014c4

08012fe4 <ip4_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip4_input(struct pbuf *p, struct netif *inp)
{
 8012fe4:	b5b0      	push	{r4, r5, r7, lr}
 8012fe6:	b086      	sub	sp, #24
 8012fe8:	af00      	add	r7, sp, #0
 8012fea:	6078      	str	r0, [r7, #4]
 8012fec:	6039      	str	r1, [r7, #0]

  IP_STATS_INC(ip.recv);
  MIB2_STATS_INC(mib2.ipinreceives);

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
 8012fee:	687b      	ldr	r3, [r7, #4]
 8012ff0:	685b      	ldr	r3, [r3, #4]
 8012ff2:	613b      	str	r3, [r7, #16]
  if (IPH_V(iphdr) != 4) {
 8012ff4:	693b      	ldr	r3, [r7, #16]
 8012ff6:	781b      	ldrb	r3, [r3, #0]
 8012ff8:	091b      	lsrs	r3, r3, #4
 8012ffa:	b2db      	uxtb	r3, r3
 8012ffc:	2b04      	cmp	r3, #4
 8012ffe:	d005      	beq.n	801300c <ip4_input+0x28>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", (u16_t)IPH_V(iphdr)));
    ip4_debug_print(p);
    pbuf_free(p);
 8013000:	687b      	ldr	r3, [r7, #4]
 8013002:	0018      	movs	r0, r3
 8013004:	f7f6 fb46 	bl	8009694 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    MIB2_STATS_INC(mib2.ipinhdrerrors);
    return ERR_OK;
 8013008:	2300      	movs	r3, #0
 801300a:	e147      	b.n	801329c <ip4_input+0x2b8>
    return ERR_OK;
  }
#endif

  /* obtain IP header length in bytes */
  iphdr_hlen = IPH_HL_BYTES(iphdr);
 801300c:	693b      	ldr	r3, [r7, #16]
 801300e:	781b      	ldrb	r3, [r3, #0]
 8013010:	220f      	movs	r2, #15
 8013012:	4013      	ands	r3, r2
 8013014:	b2db      	uxtb	r3, r3
 8013016:	009b      	lsls	r3, r3, #2
 8013018:	b2da      	uxtb	r2, r3
 801301a:	2316      	movs	r3, #22
 801301c:	18fb      	adds	r3, r7, r3
 801301e:	801a      	strh	r2, [r3, #0]
  /* obtain ip length in bytes */
  iphdr_len = lwip_ntohs(IPH_LEN(iphdr));
 8013020:	693b      	ldr	r3, [r7, #16]
 8013022:	789a      	ldrb	r2, [r3, #2]
 8013024:	78db      	ldrb	r3, [r3, #3]
 8013026:	021b      	lsls	r3, r3, #8
 8013028:	4313      	orrs	r3, r2
 801302a:	b29b      	uxth	r3, r3
 801302c:	2514      	movs	r5, #20
 801302e:	197c      	adds	r4, r7, r5
 8013030:	0018      	movs	r0, r3
 8013032:	f7f3 fa7f 	bl	8006534 <lwip_htons>
 8013036:	0003      	movs	r3, r0
 8013038:	8023      	strh	r3, [r4, #0]

  /* Trim pbuf. This is especially required for packets < 60 bytes. */
  if (iphdr_len < p->tot_len) {
 801303a:	687b      	ldr	r3, [r7, #4]
 801303c:	891b      	ldrh	r3, [r3, #8]
 801303e:	197a      	adds	r2, r7, r5
 8013040:	8812      	ldrh	r2, [r2, #0]
 8013042:	429a      	cmp	r2, r3
 8013044:	d206      	bcs.n	8013054 <ip4_input+0x70>
    pbuf_realloc(p, iphdr_len);
 8013046:	197b      	adds	r3, r7, r5
 8013048:	881a      	ldrh	r2, [r3, #0]
 801304a:	687b      	ldr	r3, [r7, #4]
 801304c:	0011      	movs	r1, r2
 801304e:	0018      	movs	r0, r3
 8013050:	f7f6 f926 	bl	80092a0 <pbuf_realloc>
  }

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len) || (iphdr_hlen < IP_HLEN)) {
 8013054:	687b      	ldr	r3, [r7, #4]
 8013056:	895b      	ldrh	r3, [r3, #10]
 8013058:	2116      	movs	r1, #22
 801305a:	187a      	adds	r2, r7, r1
 801305c:	8812      	ldrh	r2, [r2, #0]
 801305e:	429a      	cmp	r2, r3
 8013060:	d80a      	bhi.n	8013078 <ip4_input+0x94>
 8013062:	687b      	ldr	r3, [r7, #4]
 8013064:	891b      	ldrh	r3, [r3, #8]
 8013066:	2214      	movs	r2, #20
 8013068:	18ba      	adds	r2, r7, r2
 801306a:	8812      	ldrh	r2, [r2, #0]
 801306c:	429a      	cmp	r2, r3
 801306e:	d803      	bhi.n	8013078 <ip4_input+0x94>
 8013070:	187b      	adds	r3, r7, r1
 8013072:	881b      	ldrh	r3, [r3, #0]
 8013074:	2b13      	cmp	r3, #19
 8013076:	d805      	bhi.n	8013084 <ip4_input+0xa0>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
                   iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
 8013078:	687b      	ldr	r3, [r7, #4]
 801307a:	0018      	movs	r0, r3
 801307c:	f7f6 fb0a 	bl	8009694 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    MIB2_STATS_INC(mib2.ipindiscards);
    return ERR_OK;
 8013080:	2300      	movs	r3, #0
 8013082:	e10b      	b.n	801329c <ip4_input+0x2b8>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_IP) {
    if (inet_chksum(iphdr, iphdr_hlen) != 0) {
 8013084:	2316      	movs	r3, #22
 8013086:	18fb      	adds	r3, r7, r3
 8013088:	881a      	ldrh	r2, [r3, #0]
 801308a:	693b      	ldr	r3, [r7, #16]
 801308c:	0011      	movs	r1, r2
 801308e:	0018      	movs	r0, r3
 8013090:	f7f4 fe38 	bl	8007d04 <inet_chksum>
 8013094:	1e03      	subs	r3, r0, #0
 8013096:	d005      	beq.n	80130a4 <ip4_input+0xc0>

      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
      ip4_debug_print(p);
      pbuf_free(p);
 8013098:	687b      	ldr	r3, [r7, #4]
 801309a:	0018      	movs	r0, r3
 801309c:	f7f6 fafa 	bl	8009694 <pbuf_free>
      IP_STATS_INC(ip.chkerr);
      IP_STATS_INC(ip.drop);
      MIB2_STATS_INC(mib2.ipinhdrerrors);
      return ERR_OK;
 80130a0:	2300      	movs	r3, #0
 80130a2:	e0fb      	b.n	801329c <ip4_input+0x2b8>
    }
  }
#endif

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr->dest);
 80130a4:	693b      	ldr	r3, [r7, #16]
 80130a6:	7c1a      	ldrb	r2, [r3, #16]
 80130a8:	7c59      	ldrb	r1, [r3, #17]
 80130aa:	0209      	lsls	r1, r1, #8
 80130ac:	430a      	orrs	r2, r1
 80130ae:	7c99      	ldrb	r1, [r3, #18]
 80130b0:	0409      	lsls	r1, r1, #16
 80130b2:	430a      	orrs	r2, r1
 80130b4:	7cdb      	ldrb	r3, [r3, #19]
 80130b6:	061b      	lsls	r3, r3, #24
 80130b8:	4313      	orrs	r3, r2
 80130ba:	001a      	movs	r2, r3
 80130bc:	4b79      	ldr	r3, [pc, #484]	; (80132a4 <ip4_input+0x2c0>)
 80130be:	615a      	str	r2, [r3, #20]
  ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr->src);
 80130c0:	693b      	ldr	r3, [r7, #16]
 80130c2:	7b1a      	ldrb	r2, [r3, #12]
 80130c4:	7b59      	ldrb	r1, [r3, #13]
 80130c6:	0209      	lsls	r1, r1, #8
 80130c8:	430a      	orrs	r2, r1
 80130ca:	7b99      	ldrb	r1, [r3, #14]
 80130cc:	0409      	lsls	r1, r1, #16
 80130ce:	430a      	orrs	r2, r1
 80130d0:	7bdb      	ldrb	r3, [r3, #15]
 80130d2:	061b      	lsls	r3, r3, #24
 80130d4:	4313      	orrs	r3, r2
 80130d6:	001a      	movs	r2, r3
 80130d8:	4b72      	ldr	r3, [pc, #456]	; (80132a4 <ip4_input+0x2c0>)
 80130da:	611a      	str	r2, [r3, #16]

  /* match packet against an interface, i.e. is this packet for us? */
  if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 80130dc:	4b71      	ldr	r3, [pc, #452]	; (80132a4 <ip4_input+0x2c0>)
 80130de:	695b      	ldr	r3, [r3, #20]
 80130e0:	22f0      	movs	r2, #240	; 0xf0
 80130e2:	4013      	ands	r3, r2
 80130e4:	2be0      	cmp	r3, #224	; 0xe0
 80130e6:	d113      	bne.n	8013110 <ip4_input+0x12c>
      netif = inp;
    } else {
      netif = NULL;
    }
#else /* LWIP_IGMP */
    if ((netif_is_up(inp)) && (!ip4_addr_isany_val(*netif_ip4_addr(inp)))) {
 80130e8:	683b      	ldr	r3, [r7, #0]
 80130ea:	2231      	movs	r2, #49	; 0x31
 80130ec:	5c9b      	ldrb	r3, [r3, r2]
 80130ee:	1c1a      	adds	r2, r3, #0
 80130f0:	2301      	movs	r3, #1
 80130f2:	4013      	ands	r3, r2
 80130f4:	b2db      	uxtb	r3, r3
 80130f6:	2b00      	cmp	r3, #0
 80130f8:	d007      	beq.n	801310a <ip4_input+0x126>
 80130fa:	683b      	ldr	r3, [r7, #0]
 80130fc:	3304      	adds	r3, #4
 80130fe:	681b      	ldr	r3, [r3, #0]
 8013100:	2b00      	cmp	r3, #0
 8013102:	d002      	beq.n	801310a <ip4_input+0x126>
      netif = inp;
 8013104:	683b      	ldr	r3, [r7, #0]
 8013106:	60fb      	str	r3, [r7, #12]
 8013108:	e02b      	b.n	8013162 <ip4_input+0x17e>
    } else {
      netif = NULL;
 801310a:	2300      	movs	r3, #0
 801310c:	60fb      	str	r3, [r7, #12]
 801310e:	e028      	b.n	8013162 <ip4_input+0x17e>
    }
#endif /* LWIP_IGMP */
  } else {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs. */
    if (ip4_input_accept(inp)) {
 8013110:	683b      	ldr	r3, [r7, #0]
 8013112:	0018      	movs	r0, r3
 8013114:	f7ff ff3a 	bl	8012f8c <ip4_input_accept>
 8013118:	1e03      	subs	r3, r0, #0
 801311a:	d002      	beq.n	8013122 <ip4_input+0x13e>
      netif = inp;
 801311c:	683b      	ldr	r3, [r7, #0]
 801311e:	60fb      	str	r3, [r7, #12]
 8013120:	e01f      	b.n	8013162 <ip4_input+0x17e>
    } else {
      netif = NULL;
 8013122:	2300      	movs	r3, #0
 8013124:	60fb      	str	r3, [r7, #12]
#if !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF
      /* Packets sent to the loopback address must not be accepted on an
       * interface that does not have the loopback address assigned to it,
       * unless a non-loopback interface is used for loopback traffic. */
      if (!ip4_addr_isloopback(ip4_current_dest_addr()))
 8013126:	4b5f      	ldr	r3, [pc, #380]	; (80132a4 <ip4_input+0x2c0>)
 8013128:	695b      	ldr	r3, [r3, #20]
 801312a:	22ff      	movs	r2, #255	; 0xff
 801312c:	4013      	ands	r3, r2
 801312e:	2b7f      	cmp	r3, #127	; 0x7f
 8013130:	d017      	beq.n	8013162 <ip4_input+0x17e>
#endif /* !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF */
      {
#if !LWIP_SINGLE_NETIF
        NETIF_FOREACH(netif) {
 8013132:	4b5d      	ldr	r3, [pc, #372]	; (80132a8 <ip4_input+0x2c4>)
 8013134:	681b      	ldr	r3, [r3, #0]
 8013136:	60fb      	str	r3, [r7, #12]
 8013138:	e00e      	b.n	8013158 <ip4_input+0x174>
          if (netif == inp) {
 801313a:	68fa      	ldr	r2, [r7, #12]
 801313c:	683b      	ldr	r3, [r7, #0]
 801313e:	429a      	cmp	r2, r3
 8013140:	d006      	beq.n	8013150 <ip4_input+0x16c>
            /* we checked that before already */
            continue;
          }
          if (ip4_input_accept(netif)) {
 8013142:	68fb      	ldr	r3, [r7, #12]
 8013144:	0018      	movs	r0, r3
 8013146:	f7ff ff21 	bl	8012f8c <ip4_input_accept>
 801314a:	1e03      	subs	r3, r0, #0
 801314c:	d108      	bne.n	8013160 <ip4_input+0x17c>
 801314e:	e000      	b.n	8013152 <ip4_input+0x16e>
            continue;
 8013150:	46c0      	nop			; (mov r8, r8)
        NETIF_FOREACH(netif) {
 8013152:	68fb      	ldr	r3, [r7, #12]
 8013154:	681b      	ldr	r3, [r3, #0]
 8013156:	60fb      	str	r3, [r7, #12]
 8013158:	68fb      	ldr	r3, [r7, #12]
 801315a:	2b00      	cmp	r3, #0
 801315c:	d1ed      	bne.n	801313a <ip4_input+0x156>
 801315e:	e000      	b.n	8013162 <ip4_input+0x17e>
            break;
 8013160:	46c0      	nop			; (mov r8, r8)
      && !ip4_addr_isany_val(*ip4_current_src_addr())
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
     )
#endif /* LWIP_IGMP || IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
 8013162:	4b50      	ldr	r3, [pc, #320]	; (80132a4 <ip4_input+0x2c0>)
 8013164:	691b      	ldr	r3, [r3, #16]
 8013166:	683a      	ldr	r2, [r7, #0]
 8013168:	0011      	movs	r1, r2
 801316a:	0018      	movs	r0, r3
 801316c:	f000 fac6 	bl	80136fc <ip4_addr_isbroadcast_u32>
 8013170:	1e03      	subs	r3, r0, #0
 8013172:	d105      	bne.n	8013180 <ip4_input+0x19c>
        (ip4_addr_ismulticast(ip4_current_src_addr()))) {
 8013174:	4b4b      	ldr	r3, [pc, #300]	; (80132a4 <ip4_input+0x2c0>)
 8013176:	691b      	ldr	r3, [r3, #16]
 8013178:	22f0      	movs	r2, #240	; 0xf0
 801317a:	4013      	ands	r3, r2
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
 801317c:	2be0      	cmp	r3, #224	; 0xe0
 801317e:	d105      	bne.n	801318c <ip4_input+0x1a8>
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip4_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
 8013180:	687b      	ldr	r3, [r7, #4]
 8013182:	0018      	movs	r0, r3
 8013184:	f7f6 fa86 	bl	8009694 <pbuf_free>
      IP_STATS_INC(ip.drop);
      MIB2_STATS_INC(mib2.ipinaddrerrors);
      MIB2_STATS_INC(mib2.ipindiscards);
      return ERR_OK;
 8013188:	2300      	movs	r3, #0
 801318a:	e087      	b.n	801329c <ip4_input+0x2b8>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
 801318c:	68fb      	ldr	r3, [r7, #12]
 801318e:	2b00      	cmp	r3, #0
 8013190:	d105      	bne.n	801319e <ip4_input+0x1ba>
    {
      IP_STATS_INC(ip.drop);
      MIB2_STATS_INC(mib2.ipinaddrerrors);
      MIB2_STATS_INC(mib2.ipindiscards);
    }
    pbuf_free(p);
 8013192:	687b      	ldr	r3, [r7, #4]
 8013194:	0018      	movs	r0, r3
 8013196:	f7f6 fa7d 	bl	8009694 <pbuf_free>
    return ERR_OK;
 801319a:	2300      	movs	r3, #0
 801319c:	e07e      	b.n	801329c <ip4_input+0x2b8>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
 801319e:	693b      	ldr	r3, [r7, #16]
 80131a0:	799a      	ldrb	r2, [r3, #6]
 80131a2:	79db      	ldrb	r3, [r3, #7]
 80131a4:	021b      	lsls	r3, r3, #8
 80131a6:	4313      	orrs	r3, r2
 80131a8:	b29b      	uxth	r3, r3
 80131aa:	001a      	movs	r2, r3
 80131ac:	4b3f      	ldr	r3, [pc, #252]	; (80132ac <ip4_input+0x2c8>)
 80131ae:	4013      	ands	r3, r2
 80131b0:	d005      	beq.n	80131be <ip4_input+0x1da>
    if (p == NULL) {
      return ERR_OK;
    }
    iphdr = (const struct ip_hdr *)p->payload;
#else /* IP_REASSEMBLY == 0, no packet fragment reassembly code present */
    pbuf_free(p);
 80131b2:	687b      	ldr	r3, [r7, #4]
 80131b4:	0018      	movs	r0, r3
 80131b6:	f7f6 fa6d 	bl	8009694 <pbuf_free>
                lwip_ntohs(IPH_OFFSET(iphdr))));
    IP_STATS_INC(ip.opterr);
    IP_STATS_INC(ip.drop);
    /* unsupported protocol feature */
    MIB2_STATS_INC(mib2.ipinunknownprotos);
    return ERR_OK;
 80131ba:	2300      	movs	r3, #0
 80131bc:	e06e      	b.n	801329c <ip4_input+0x2b8>
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip4_input: \n"));
  ip4_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip4_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  ip_data.current_netif = netif;
 80131be:	4b39      	ldr	r3, [pc, #228]	; (80132a4 <ip4_input+0x2c0>)
 80131c0:	68fa      	ldr	r2, [r7, #12]
 80131c2:	601a      	str	r2, [r3, #0]
  ip_data.current_input_netif = inp;
 80131c4:	4b37      	ldr	r3, [pc, #220]	; (80132a4 <ip4_input+0x2c0>)
 80131c6:	683a      	ldr	r2, [r7, #0]
 80131c8:	605a      	str	r2, [r3, #4]
  ip_data.current_ip4_header = iphdr;
 80131ca:	4b36      	ldr	r3, [pc, #216]	; (80132a4 <ip4_input+0x2c0>)
 80131cc:	693a      	ldr	r2, [r7, #16]
 80131ce:	609a      	str	r2, [r3, #8]
  ip_data.current_ip_header_tot_len = IPH_HL_BYTES(iphdr);
 80131d0:	693b      	ldr	r3, [r7, #16]
 80131d2:	781b      	ldrb	r3, [r3, #0]
 80131d4:	220f      	movs	r2, #15
 80131d6:	4013      	ands	r3, r2
 80131d8:	b2db      	uxtb	r3, r3
 80131da:	009b      	lsls	r3, r3, #2
 80131dc:	b2db      	uxtb	r3, r3
 80131de:	b29a      	uxth	r2, r3
 80131e0:	4b30      	ldr	r3, [pc, #192]	; (80132a4 <ip4_input+0x2c0>)
 80131e2:	819a      	strh	r2, [r3, #12]
  /* raw input did not eat the packet? */
  raw_status = raw_input(p, inp);
  if (raw_status != RAW_INPUT_EATEN)
#endif /* LWIP_RAW */
  {
    pbuf_remove_header(p, iphdr_hlen); /* Move to payload, no check necessary. */
 80131e4:	2316      	movs	r3, #22
 80131e6:	18fb      	adds	r3, r7, r3
 80131e8:	881a      	ldrh	r2, [r3, #0]
 80131ea:	687b      	ldr	r3, [r7, #4]
 80131ec:	0011      	movs	r1, r2
 80131ee:	0018      	movs	r0, r3
 80131f0:	f7f6 f978 	bl	80094e4 <pbuf_remove_header>

    switch (IPH_PROTO(iphdr)) {
 80131f4:	693b      	ldr	r3, [r7, #16]
 80131f6:	7a5b      	ldrb	r3, [r3, #9]
 80131f8:	2b11      	cmp	r3, #17
 80131fa:	d005      	beq.n	8013208 <ip4_input+0x224>
 80131fc:	dc19      	bgt.n	8013232 <ip4_input+0x24e>
 80131fe:	2b01      	cmp	r3, #1
 8013200:	d010      	beq.n	8013224 <ip4_input+0x240>
 8013202:	2b06      	cmp	r3, #6
 8013204:	d007      	beq.n	8013216 <ip4_input+0x232>
 8013206:	e014      	b.n	8013232 <ip4_input+0x24e>
      case IP_PROTO_UDP:
#if LWIP_UDPLITE
      case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
        MIB2_STATS_INC(mib2.ipindelivers);
        udp_input(p, inp);
 8013208:	683a      	ldr	r2, [r7, #0]
 801320a:	687b      	ldr	r3, [r7, #4]
 801320c:	0011      	movs	r1, r2
 801320e:	0018      	movs	r0, r3
 8013210:	f7fe fe80 	bl	8011f14 <udp_input>
        break;
 8013214:	e02f      	b.n	8013276 <ip4_input+0x292>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case IP_PROTO_TCP:
        MIB2_STATS_INC(mib2.ipindelivers);
        tcp_input(p, inp);
 8013216:	683a      	ldr	r2, [r7, #0]
 8013218:	687b      	ldr	r3, [r7, #4]
 801321a:	0011      	movs	r1, r2
 801321c:	0018      	movs	r0, r3
 801321e:	f7f8 ff67 	bl	800c0f0 <tcp_input>
        break;
 8013222:	e028      	b.n	8013276 <ip4_input+0x292>
#endif /* LWIP_TCP */
#if LWIP_ICMP
      case IP_PROTO_ICMP:
        MIB2_STATS_INC(mib2.ipindelivers);
        icmp_input(p, inp);
 8013224:	683a      	ldr	r2, [r7, #0]
 8013226:	687b      	ldr	r3, [r7, #4]
 8013228:	0011      	movs	r1, r2
 801322a:	0018      	movs	r0, r3
 801322c:	f7ff fb88 	bl	8012940 <icmp_input>
        break;
 8013230:	e021      	b.n	8013276 <ip4_input+0x292>
        } else
#endif /* LWIP_RAW */
        {
#if LWIP_ICMP
          /* send ICMP destination protocol unreachable unless is was a broadcast */
          if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
 8013232:	4b1c      	ldr	r3, [pc, #112]	; (80132a4 <ip4_input+0x2c0>)
 8013234:	695b      	ldr	r3, [r3, #20]
 8013236:	68fa      	ldr	r2, [r7, #12]
 8013238:	0011      	movs	r1, r2
 801323a:	0018      	movs	r0, r3
 801323c:	f000 fa5e 	bl	80136fc <ip4_addr_isbroadcast_u32>
 8013240:	1e03      	subs	r3, r0, #0
 8013242:	d113      	bne.n	801326c <ip4_input+0x288>
              !ip4_addr_ismulticast(ip4_current_dest_addr())) {
 8013244:	4b17      	ldr	r3, [pc, #92]	; (80132a4 <ip4_input+0x2c0>)
 8013246:	695b      	ldr	r3, [r3, #20]
 8013248:	22f0      	movs	r2, #240	; 0xf0
 801324a:	4013      	ands	r3, r2
          if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
 801324c:	2be0      	cmp	r3, #224	; 0xe0
 801324e:	d00d      	beq.n	801326c <ip4_input+0x288>
            pbuf_header_force(p, (s16_t)iphdr_hlen); /* Move to ip header, no check necessary. */
 8013250:	2316      	movs	r3, #22
 8013252:	18fb      	adds	r3, r7, r3
 8013254:	2200      	movs	r2, #0
 8013256:	5e9a      	ldrsh	r2, [r3, r2]
 8013258:	687b      	ldr	r3, [r7, #4]
 801325a:	0011      	movs	r1, r2
 801325c:	0018      	movs	r0, r3
 801325e:	f7f6 f9c2 	bl	80095e6 <pbuf_header_force>
            icmp_dest_unreach(p, ICMP_DUR_PROTO);
 8013262:	687b      	ldr	r3, [r7, #4]
 8013264:	2102      	movs	r1, #2
 8013266:	0018      	movs	r0, r3
 8013268:	f7ff fd50 	bl	8012d0c <icmp_dest_unreach>

          IP_STATS_INC(ip.proterr);
          IP_STATS_INC(ip.drop);
          MIB2_STATS_INC(mib2.ipinunknownprotos);
        }
        pbuf_free(p);
 801326c:	687b      	ldr	r3, [r7, #4]
 801326e:	0018      	movs	r0, r3
 8013270:	f7f6 fa10 	bl	8009694 <pbuf_free>
        break;
 8013274:	46c0      	nop			; (mov r8, r8)
    }
  }

  /* @todo: this is not really necessary... */
  ip_data.current_netif = NULL;
 8013276:	4b0b      	ldr	r3, [pc, #44]	; (80132a4 <ip4_input+0x2c0>)
 8013278:	2200      	movs	r2, #0
 801327a:	601a      	str	r2, [r3, #0]
  ip_data.current_input_netif = NULL;
 801327c:	4b09      	ldr	r3, [pc, #36]	; (80132a4 <ip4_input+0x2c0>)
 801327e:	2200      	movs	r2, #0
 8013280:	605a      	str	r2, [r3, #4]
  ip_data.current_ip4_header = NULL;
 8013282:	4b08      	ldr	r3, [pc, #32]	; (80132a4 <ip4_input+0x2c0>)
 8013284:	2200      	movs	r2, #0
 8013286:	609a      	str	r2, [r3, #8]
  ip_data.current_ip_header_tot_len = 0;
 8013288:	4b06      	ldr	r3, [pc, #24]	; (80132a4 <ip4_input+0x2c0>)
 801328a:	2200      	movs	r2, #0
 801328c:	819a      	strh	r2, [r3, #12]
  ip4_addr_set_any(ip4_current_src_addr());
 801328e:	4b05      	ldr	r3, [pc, #20]	; (80132a4 <ip4_input+0x2c0>)
 8013290:	2200      	movs	r2, #0
 8013292:	611a      	str	r2, [r3, #16]
  ip4_addr_set_any(ip4_current_dest_addr());
 8013294:	4b03      	ldr	r3, [pc, #12]	; (80132a4 <ip4_input+0x2c0>)
 8013296:	2200      	movs	r2, #0
 8013298:	615a      	str	r2, [r3, #20]

  return ERR_OK;
 801329a:	2300      	movs	r3, #0
}
 801329c:	0018      	movs	r0, r3
 801329e:	46bd      	mov	sp, r7
 80132a0:	b006      	add	sp, #24
 80132a2:	bdb0      	pop	{r4, r5, r7, pc}
 80132a4:	200014c4 	.word	0x200014c4
 80132a8:	20002b08 	.word	0x20002b08
 80132ac:	0000ff3f 	.word	0x0000ff3f

080132b0 <ip4_output_if>:
 */
err_t
ip4_output_if(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
              u8_t ttl, u8_t tos,
              u8_t proto, struct netif *netif)
{
 80132b0:	b590      	push	{r4, r7, lr}
 80132b2:	b08b      	sub	sp, #44	; 0x2c
 80132b4:	af04      	add	r7, sp, #16
 80132b6:	60f8      	str	r0, [r7, #12]
 80132b8:	60b9      	str	r1, [r7, #8]
 80132ba:	607a      	str	r2, [r7, #4]
 80132bc:	001a      	movs	r2, r3
 80132be:	1cfb      	adds	r3, r7, #3
 80132c0:	701a      	strb	r2, [r3, #0]
ip4_output_if_opt(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
                  u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
                  u16_t optlen)
{
#endif /* IP_OPTIONS_SEND */
  const ip4_addr_t *src_used = src;
 80132c2:	68bb      	ldr	r3, [r7, #8]
 80132c4:	617b      	str	r3, [r7, #20]
  if (dest != LWIP_IP_HDRINCL) {
 80132c6:	687b      	ldr	r3, [r7, #4]
 80132c8:	2b00      	cmp	r3, #0
 80132ca:	d009      	beq.n	80132e0 <ip4_output_if+0x30>
    if (ip4_addr_isany(src)) {
 80132cc:	68bb      	ldr	r3, [r7, #8]
 80132ce:	2b00      	cmp	r3, #0
 80132d0:	d003      	beq.n	80132da <ip4_output_if+0x2a>
 80132d2:	68bb      	ldr	r3, [r7, #8]
 80132d4:	681b      	ldr	r3, [r3, #0]
 80132d6:	2b00      	cmp	r3, #0
 80132d8:	d102      	bne.n	80132e0 <ip4_output_if+0x30>
      src_used = netif_ip4_addr(netif);
 80132da:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80132dc:	3304      	adds	r3, #4
 80132de:	617b      	str	r3, [r7, #20]

#if IP_OPTIONS_SEND
  return ip4_output_if_opt_src(p, src_used, dest, ttl, tos, proto, netif,
                               ip_options, optlen);
#else /* IP_OPTIONS_SEND */
  return ip4_output_if_src(p, src_used, dest, ttl, tos, proto, netif);
 80132e0:	1cfb      	adds	r3, r7, #3
 80132e2:	781c      	ldrb	r4, [r3, #0]
 80132e4:	687a      	ldr	r2, [r7, #4]
 80132e6:	6979      	ldr	r1, [r7, #20]
 80132e8:	68f8      	ldr	r0, [r7, #12]
 80132ea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80132ec:	9302      	str	r3, [sp, #8]
 80132ee:	232c      	movs	r3, #44	; 0x2c
 80132f0:	18fb      	adds	r3, r7, r3
 80132f2:	781b      	ldrb	r3, [r3, #0]
 80132f4:	9301      	str	r3, [sp, #4]
 80132f6:	2328      	movs	r3, #40	; 0x28
 80132f8:	18fb      	adds	r3, r7, r3
 80132fa:	781b      	ldrb	r3, [r3, #0]
 80132fc:	9300      	str	r3, [sp, #0]
 80132fe:	0023      	movs	r3, r4
 8013300:	f000 f806 	bl	8013310 <ip4_output_if_src>
 8013304:	0003      	movs	r3, r0
#endif /* IP_OPTIONS_SEND */
}
 8013306:	0018      	movs	r0, r3
 8013308:	46bd      	mov	sp, r7
 801330a:	b007      	add	sp, #28
 801330c:	bd90      	pop	{r4, r7, pc}
	...

08013310 <ip4_output_if_src>:
 */
err_t
ip4_output_if_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
                  u8_t ttl, u8_t tos,
                  u8_t proto, struct netif *netif)
{
 8013310:	b590      	push	{r4, r7, lr}
 8013312:	b089      	sub	sp, #36	; 0x24
 8013314:	af00      	add	r7, sp, #0
 8013316:	60f8      	str	r0, [r7, #12]
 8013318:	60b9      	str	r1, [r7, #8]
 801331a:	607a      	str	r2, [r7, #4]
 801331c:	001a      	movs	r2, r3
 801331e:	1cfb      	adds	r3, r7, #3
 8013320:	701a      	strb	r2, [r3, #0]
{
#endif /* IP_OPTIONS_SEND */
  struct ip_hdr *iphdr;
  ip4_addr_t dest_addr;
#if CHECKSUM_GEN_IP_INLINE
  u32_t chk_sum = 0;
 8013322:	2300      	movs	r3, #0
 8013324:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
 8013326:	68fb      	ldr	r3, [r7, #12]
 8013328:	7b9b      	ldrb	r3, [r3, #14]
 801332a:	2b01      	cmp	r3, #1
 801332c:	d006      	beq.n	801333c <ip4_output_if_src+0x2c>
 801332e:	4bde      	ldr	r3, [pc, #888]	; (80136a8 <ip4_output_if_src+0x398>)
 8013330:	22d5      	movs	r2, #213	; 0xd5
 8013332:	0092      	lsls	r2, r2, #2
 8013334:	49dd      	ldr	r1, [pc, #884]	; (80136ac <ip4_output_if_src+0x39c>)
 8013336:	48de      	ldr	r0, [pc, #888]	; (80136b0 <ip4_output_if_src+0x3a0>)
 8013338:	f7ee ff48 	bl	80021cc <app_debug_rtt_raw>

  MIB2_STATS_INC(mib2.ipoutrequests);

  /* Should the IP header be generated or is it already included in p? */
  if (dest != LWIP_IP_HDRINCL) {
 801333c:	687b      	ldr	r3, [r7, #4]
 801333e:	2b00      	cmp	r3, #0
 8013340:	d100      	bne.n	8013344 <ip4_output_if_src+0x34>
 8013342:	e1aa      	b.n	801369a <ip4_output_if_src+0x38a>
    u16_t ip_hlen = IP_HLEN;
 8013344:	2316      	movs	r3, #22
 8013346:	18fb      	adds	r3, r7, r3
 8013348:	2214      	movs	r2, #20
 801334a:	801a      	strh	r2, [r3, #0]
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_add_header(p, IP_HLEN)) {
 801334c:	68fb      	ldr	r3, [r7, #12]
 801334e:	2114      	movs	r1, #20
 8013350:	0018      	movs	r0, r3
 8013352:	f7f6 f8b7 	bl	80094c4 <pbuf_add_header>
 8013356:	1e03      	subs	r3, r0, #0
 8013358:	d002      	beq.n	8013360 <ip4_output_if_src+0x50>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      MIB2_STATS_INC(mib2.ipoutdiscards);
      return ERR_BUF;
 801335a:	2302      	movs	r3, #2
 801335c:	425b      	negs	r3, r3
 801335e:	e1c8      	b.n	80136f2 <ip4_output_if_src+0x3e2>
    }

    iphdr = (struct ip_hdr *)p->payload;
 8013360:	68fb      	ldr	r3, [r7, #12]
 8013362:	685b      	ldr	r3, [r3, #4]
 8013364:	61bb      	str	r3, [r7, #24]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
 8013366:	68fb      	ldr	r3, [r7, #12]
 8013368:	895b      	ldrh	r3, [r3, #10]
 801336a:	2b13      	cmp	r3, #19
 801336c:	d806      	bhi.n	801337c <ip4_output_if_src+0x6c>
 801336e:	4bce      	ldr	r3, [pc, #824]	; (80136a8 <ip4_output_if_src+0x398>)
 8013370:	22e2      	movs	r2, #226	; 0xe2
 8013372:	0092      	lsls	r2, r2, #2
 8013374:	49cf      	ldr	r1, [pc, #828]	; (80136b4 <ip4_output_if_src+0x3a4>)
 8013376:	48ce      	ldr	r0, [pc, #824]	; (80136b0 <ip4_output_if_src+0x3a0>)
 8013378:	f7ee ff28 	bl	80021cc <app_debug_rtt_raw>
                (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
 801337c:	69bb      	ldr	r3, [r7, #24]
 801337e:	1cfa      	adds	r2, r7, #3
 8013380:	7812      	ldrb	r2, [r2, #0]
 8013382:	721a      	strb	r2, [r3, #8]
    IPH_PROTO_SET(iphdr, proto);
 8013384:	69bb      	ldr	r3, [r7, #24]
 8013386:	2134      	movs	r1, #52	; 0x34
 8013388:	187a      	adds	r2, r7, r1
 801338a:	7812      	ldrb	r2, [r2, #0]
 801338c:	725a      	strb	r2, [r3, #9]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(proto | (ttl << 8));
 801338e:	187b      	adds	r3, r7, r1
 8013390:	781a      	ldrb	r2, [r3, #0]
 8013392:	1cfb      	adds	r3, r7, #3
 8013394:	781b      	ldrb	r3, [r3, #0]
 8013396:	021b      	lsls	r3, r3, #8
 8013398:	4313      	orrs	r3, r2
 801339a:	021b      	lsls	r3, r3, #8
 801339c:	b21a      	sxth	r2, r3
 801339e:	187b      	adds	r3, r7, r1
 80133a0:	7819      	ldrb	r1, [r3, #0]
 80133a2:	1cfb      	adds	r3, r7, #3
 80133a4:	781b      	ldrb	r3, [r3, #0]
 80133a6:	021b      	lsls	r3, r3, #8
 80133a8:	430b      	orrs	r3, r1
 80133aa:	121b      	asrs	r3, r3, #8
 80133ac:	b21b      	sxth	r3, r3
 80133ae:	21ff      	movs	r1, #255	; 0xff
 80133b0:	400b      	ands	r3, r1
 80133b2:	b21b      	sxth	r3, r3
 80133b4:	4313      	orrs	r3, r2
 80133b6:	b21b      	sxth	r3, r3
 80133b8:	b29b      	uxth	r3, r3
 80133ba:	001a      	movs	r2, r3
 80133bc:	69fb      	ldr	r3, [r7, #28]
 80133be:	189b      	adds	r3, r3, r2
 80133c0:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip4_addr_copy(iphdr->dest, *dest);
 80133c2:	687b      	ldr	r3, [r7, #4]
 80133c4:	681a      	ldr	r2, [r3, #0]
 80133c6:	69bb      	ldr	r3, [r7, #24]
 80133c8:	21ff      	movs	r1, #255	; 0xff
 80133ca:	4011      	ands	r1, r2
 80133cc:	000c      	movs	r4, r1
 80133ce:	7c19      	ldrb	r1, [r3, #16]
 80133d0:	2000      	movs	r0, #0
 80133d2:	4001      	ands	r1, r0
 80133d4:	1c08      	adds	r0, r1, #0
 80133d6:	1c21      	adds	r1, r4, #0
 80133d8:	4301      	orrs	r1, r0
 80133da:	7419      	strb	r1, [r3, #16]
 80133dc:	0a11      	lsrs	r1, r2, #8
 80133de:	20ff      	movs	r0, #255	; 0xff
 80133e0:	4001      	ands	r1, r0
 80133e2:	000c      	movs	r4, r1
 80133e4:	7c59      	ldrb	r1, [r3, #17]
 80133e6:	2000      	movs	r0, #0
 80133e8:	4001      	ands	r1, r0
 80133ea:	1c08      	adds	r0, r1, #0
 80133ec:	1c21      	adds	r1, r4, #0
 80133ee:	4301      	orrs	r1, r0
 80133f0:	7459      	strb	r1, [r3, #17]
 80133f2:	0c11      	lsrs	r1, r2, #16
 80133f4:	20ff      	movs	r0, #255	; 0xff
 80133f6:	4001      	ands	r1, r0
 80133f8:	000c      	movs	r4, r1
 80133fa:	7c99      	ldrb	r1, [r3, #18]
 80133fc:	2000      	movs	r0, #0
 80133fe:	4001      	ands	r1, r0
 8013400:	1c08      	adds	r0, r1, #0
 8013402:	1c21      	adds	r1, r4, #0
 8013404:	4301      	orrs	r1, r0
 8013406:	7499      	strb	r1, [r3, #18]
 8013408:	0e10      	lsrs	r0, r2, #24
 801340a:	7cda      	ldrb	r2, [r3, #19]
 801340c:	2100      	movs	r1, #0
 801340e:	400a      	ands	r2, r1
 8013410:	1c11      	adds	r1, r2, #0
 8013412:	1c02      	adds	r2, r0, #0
 8013414:	430a      	orrs	r2, r1
 8013416:	74da      	strb	r2, [r3, #19]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
 8013418:	69bb      	ldr	r3, [r7, #24]
 801341a:	7c1a      	ldrb	r2, [r3, #16]
 801341c:	7c59      	ldrb	r1, [r3, #17]
 801341e:	0209      	lsls	r1, r1, #8
 8013420:	430a      	orrs	r2, r1
 8013422:	7c99      	ldrb	r1, [r3, #18]
 8013424:	0409      	lsls	r1, r1, #16
 8013426:	430a      	orrs	r2, r1
 8013428:	7cdb      	ldrb	r3, [r3, #19]
 801342a:	061b      	lsls	r3, r3, #24
 801342c:	4313      	orrs	r3, r2
 801342e:	041b      	lsls	r3, r3, #16
 8013430:	0c1b      	lsrs	r3, r3, #16
 8013432:	69fa      	ldr	r2, [r7, #28]
 8013434:	18d3      	adds	r3, r2, r3
 8013436:	61fb      	str	r3, [r7, #28]
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
 8013438:	69bb      	ldr	r3, [r7, #24]
 801343a:	7c1a      	ldrb	r2, [r3, #16]
 801343c:	7c59      	ldrb	r1, [r3, #17]
 801343e:	0209      	lsls	r1, r1, #8
 8013440:	430a      	orrs	r2, r1
 8013442:	7c99      	ldrb	r1, [r3, #18]
 8013444:	0409      	lsls	r1, r1, #16
 8013446:	430a      	orrs	r2, r1
 8013448:	7cdb      	ldrb	r3, [r3, #19]
 801344a:	061b      	lsls	r3, r3, #24
 801344c:	4313      	orrs	r3, r2
 801344e:	0c1b      	lsrs	r3, r3, #16
 8013450:	69fa      	ldr	r2, [r7, #28]
 8013452:	18d3      	adds	r3, r2, r3
 8013454:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 8013456:	2316      	movs	r3, #22
 8013458:	18fb      	adds	r3, r7, r3
 801345a:	881b      	ldrh	r3, [r3, #0]
 801345c:	089b      	lsrs	r3, r3, #2
 801345e:	b29b      	uxth	r3, r3
 8013460:	b2db      	uxtb	r3, r3
 8013462:	2240      	movs	r2, #64	; 0x40
 8013464:	4313      	orrs	r3, r2
 8013466:	b2da      	uxtb	r2, r3
 8013468:	69bb      	ldr	r3, [r7, #24]
 801346a:	701a      	strb	r2, [r3, #0]
    IPH_TOS_SET(iphdr, tos);
 801346c:	69ba      	ldr	r2, [r7, #24]
 801346e:	2130      	movs	r1, #48	; 0x30
 8013470:	187b      	adds	r3, r7, r1
 8013472:	781b      	ldrb	r3, [r3, #0]
 8013474:	7053      	strb	r3, [r2, #1]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(tos | (iphdr->_v_hl << 8));
 8013476:	187b      	adds	r3, r7, r1
 8013478:	781a      	ldrb	r2, [r3, #0]
 801347a:	69bb      	ldr	r3, [r7, #24]
 801347c:	781b      	ldrb	r3, [r3, #0]
 801347e:	021b      	lsls	r3, r3, #8
 8013480:	4313      	orrs	r3, r2
 8013482:	021b      	lsls	r3, r3, #8
 8013484:	b21a      	sxth	r2, r3
 8013486:	187b      	adds	r3, r7, r1
 8013488:	7819      	ldrb	r1, [r3, #0]
 801348a:	69bb      	ldr	r3, [r7, #24]
 801348c:	781b      	ldrb	r3, [r3, #0]
 801348e:	021b      	lsls	r3, r3, #8
 8013490:	430b      	orrs	r3, r1
 8013492:	121b      	asrs	r3, r3, #8
 8013494:	b21b      	sxth	r3, r3
 8013496:	21ff      	movs	r1, #255	; 0xff
 8013498:	400b      	ands	r3, r1
 801349a:	b21b      	sxth	r3, r3
 801349c:	4313      	orrs	r3, r2
 801349e:	b21b      	sxth	r3, r3
 80134a0:	b29b      	uxth	r3, r3
 80134a2:	001a      	movs	r2, r3
 80134a4:	69fb      	ldr	r3, [r7, #28]
 80134a6:	189b      	adds	r3, r3, r2
 80134a8:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, lwip_htons(p->tot_len));
 80134aa:	68fb      	ldr	r3, [r7, #12]
 80134ac:	891b      	ldrh	r3, [r3, #8]
 80134ae:	0018      	movs	r0, r3
 80134b0:	f7f3 f840 	bl	8006534 <lwip_htons>
 80134b4:	0003      	movs	r3, r0
 80134b6:	001a      	movs	r2, r3
 80134b8:	69bb      	ldr	r3, [r7, #24]
 80134ba:	21ff      	movs	r1, #255	; 0xff
 80134bc:	4011      	ands	r1, r2
 80134be:	000c      	movs	r4, r1
 80134c0:	7899      	ldrb	r1, [r3, #2]
 80134c2:	2000      	movs	r0, #0
 80134c4:	4001      	ands	r1, r0
 80134c6:	1c08      	adds	r0, r1, #0
 80134c8:	1c21      	adds	r1, r4, #0
 80134ca:	4301      	orrs	r1, r0
 80134cc:	7099      	strb	r1, [r3, #2]
 80134ce:	0a12      	lsrs	r2, r2, #8
 80134d0:	b290      	uxth	r0, r2
 80134d2:	78da      	ldrb	r2, [r3, #3]
 80134d4:	2100      	movs	r1, #0
 80134d6:	400a      	ands	r2, r1
 80134d8:	1c11      	adds	r1, r2, #0
 80134da:	1c02      	adds	r2, r0, #0
 80134dc:	430a      	orrs	r2, r1
 80134de:	70da      	strb	r2, [r3, #3]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
 80134e0:	69bb      	ldr	r3, [r7, #24]
 80134e2:	789a      	ldrb	r2, [r3, #2]
 80134e4:	78db      	ldrb	r3, [r3, #3]
 80134e6:	021b      	lsls	r3, r3, #8
 80134e8:	4313      	orrs	r3, r2
 80134ea:	b29b      	uxth	r3, r3
 80134ec:	001a      	movs	r2, r3
 80134ee:	69fb      	ldr	r3, [r7, #28]
 80134f0:	189b      	adds	r3, r3, r2
 80134f2:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 80134f4:	69bb      	ldr	r3, [r7, #24]
 80134f6:	799a      	ldrb	r2, [r3, #6]
 80134f8:	2100      	movs	r1, #0
 80134fa:	400a      	ands	r2, r1
 80134fc:	719a      	strb	r2, [r3, #6]
 80134fe:	79da      	ldrb	r2, [r3, #7]
 8013500:	2100      	movs	r1, #0
 8013502:	400a      	ands	r2, r1
 8013504:	71da      	strb	r2, [r3, #7]
    IPH_ID_SET(iphdr, lwip_htons(ip_id));
 8013506:	4b6c      	ldr	r3, [pc, #432]	; (80136b8 <ip4_output_if_src+0x3a8>)
 8013508:	881b      	ldrh	r3, [r3, #0]
 801350a:	0018      	movs	r0, r3
 801350c:	f7f3 f812 	bl	8006534 <lwip_htons>
 8013510:	0003      	movs	r3, r0
 8013512:	001a      	movs	r2, r3
 8013514:	69bb      	ldr	r3, [r7, #24]
 8013516:	21ff      	movs	r1, #255	; 0xff
 8013518:	4011      	ands	r1, r2
 801351a:	000c      	movs	r4, r1
 801351c:	7919      	ldrb	r1, [r3, #4]
 801351e:	2000      	movs	r0, #0
 8013520:	4001      	ands	r1, r0
 8013522:	1c08      	adds	r0, r1, #0
 8013524:	1c21      	adds	r1, r4, #0
 8013526:	4301      	orrs	r1, r0
 8013528:	7119      	strb	r1, [r3, #4]
 801352a:	0a12      	lsrs	r2, r2, #8
 801352c:	b290      	uxth	r0, r2
 801352e:	795a      	ldrb	r2, [r3, #5]
 8013530:	2100      	movs	r1, #0
 8013532:	400a      	ands	r2, r1
 8013534:	1c11      	adds	r1, r2, #0
 8013536:	1c02      	adds	r2, r0, #0
 8013538:	430a      	orrs	r2, r1
 801353a:	715a      	strb	r2, [r3, #5]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
 801353c:	69bb      	ldr	r3, [r7, #24]
 801353e:	791a      	ldrb	r2, [r3, #4]
 8013540:	795b      	ldrb	r3, [r3, #5]
 8013542:	021b      	lsls	r3, r3, #8
 8013544:	4313      	orrs	r3, r2
 8013546:	b29b      	uxth	r3, r3
 8013548:	001a      	movs	r2, r3
 801354a:	69fb      	ldr	r3, [r7, #28]
 801354c:	189b      	adds	r3, r3, r2
 801354e:	61fb      	str	r3, [r7, #28]
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 8013550:	4b59      	ldr	r3, [pc, #356]	; (80136b8 <ip4_output_if_src+0x3a8>)
 8013552:	881b      	ldrh	r3, [r3, #0]
 8013554:	3301      	adds	r3, #1
 8013556:	b29a      	uxth	r2, r3
 8013558:	4b57      	ldr	r3, [pc, #348]	; (80136b8 <ip4_output_if_src+0x3a8>)
 801355a:	801a      	strh	r2, [r3, #0]

    if (src == NULL) {
 801355c:	68bb      	ldr	r3, [r7, #8]
 801355e:	2b00      	cmp	r3, #0
 8013560:	d12b      	bne.n	80135ba <ip4_output_if_src+0x2aa>
      ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY4);
 8013562:	4b56      	ldr	r3, [pc, #344]	; (80136bc <ip4_output_if_src+0x3ac>)
 8013564:	681a      	ldr	r2, [r3, #0]
 8013566:	69bb      	ldr	r3, [r7, #24]
 8013568:	21ff      	movs	r1, #255	; 0xff
 801356a:	4011      	ands	r1, r2
 801356c:	000c      	movs	r4, r1
 801356e:	7b19      	ldrb	r1, [r3, #12]
 8013570:	2000      	movs	r0, #0
 8013572:	4001      	ands	r1, r0
 8013574:	1c08      	adds	r0, r1, #0
 8013576:	1c21      	adds	r1, r4, #0
 8013578:	4301      	orrs	r1, r0
 801357a:	7319      	strb	r1, [r3, #12]
 801357c:	0a11      	lsrs	r1, r2, #8
 801357e:	20ff      	movs	r0, #255	; 0xff
 8013580:	4001      	ands	r1, r0
 8013582:	000c      	movs	r4, r1
 8013584:	7b59      	ldrb	r1, [r3, #13]
 8013586:	2000      	movs	r0, #0
 8013588:	4001      	ands	r1, r0
 801358a:	1c08      	adds	r0, r1, #0
 801358c:	1c21      	adds	r1, r4, #0
 801358e:	4301      	orrs	r1, r0
 8013590:	7359      	strb	r1, [r3, #13]
 8013592:	0c11      	lsrs	r1, r2, #16
 8013594:	20ff      	movs	r0, #255	; 0xff
 8013596:	4001      	ands	r1, r0
 8013598:	000c      	movs	r4, r1
 801359a:	7b99      	ldrb	r1, [r3, #14]
 801359c:	2000      	movs	r0, #0
 801359e:	4001      	ands	r1, r0
 80135a0:	1c08      	adds	r0, r1, #0
 80135a2:	1c21      	adds	r1, r4, #0
 80135a4:	4301      	orrs	r1, r0
 80135a6:	7399      	strb	r1, [r3, #14]
 80135a8:	0e10      	lsrs	r0, r2, #24
 80135aa:	7bda      	ldrb	r2, [r3, #15]
 80135ac:	2100      	movs	r1, #0
 80135ae:	400a      	ands	r2, r1
 80135b0:	1c11      	adds	r1, r2, #0
 80135b2:	1c02      	adds	r2, r0, #0
 80135b4:	430a      	orrs	r2, r1
 80135b6:	73da      	strb	r2, [r3, #15]
 80135b8:	e02a      	b.n	8013610 <ip4_output_if_src+0x300>
    } else {
      /* src cannot be NULL here */
      ip4_addr_copy(iphdr->src, *src);
 80135ba:	68bb      	ldr	r3, [r7, #8]
 80135bc:	681a      	ldr	r2, [r3, #0]
 80135be:	69bb      	ldr	r3, [r7, #24]
 80135c0:	21ff      	movs	r1, #255	; 0xff
 80135c2:	4011      	ands	r1, r2
 80135c4:	000c      	movs	r4, r1
 80135c6:	7b19      	ldrb	r1, [r3, #12]
 80135c8:	2000      	movs	r0, #0
 80135ca:	4001      	ands	r1, r0
 80135cc:	1c08      	adds	r0, r1, #0
 80135ce:	1c21      	adds	r1, r4, #0
 80135d0:	4301      	orrs	r1, r0
 80135d2:	7319      	strb	r1, [r3, #12]
 80135d4:	0a11      	lsrs	r1, r2, #8
 80135d6:	20ff      	movs	r0, #255	; 0xff
 80135d8:	4001      	ands	r1, r0
 80135da:	000c      	movs	r4, r1
 80135dc:	7b59      	ldrb	r1, [r3, #13]
 80135de:	2000      	movs	r0, #0
 80135e0:	4001      	ands	r1, r0
 80135e2:	1c08      	adds	r0, r1, #0
 80135e4:	1c21      	adds	r1, r4, #0
 80135e6:	4301      	orrs	r1, r0
 80135e8:	7359      	strb	r1, [r3, #13]
 80135ea:	0c11      	lsrs	r1, r2, #16
 80135ec:	20ff      	movs	r0, #255	; 0xff
 80135ee:	4001      	ands	r1, r0
 80135f0:	000c      	movs	r4, r1
 80135f2:	7b99      	ldrb	r1, [r3, #14]
 80135f4:	2000      	movs	r0, #0
 80135f6:	4001      	ands	r1, r0
 80135f8:	1c08      	adds	r0, r1, #0
 80135fa:	1c21      	adds	r1, r4, #0
 80135fc:	4301      	orrs	r1, r0
 80135fe:	7399      	strb	r1, [r3, #14]
 8013600:	0e10      	lsrs	r0, r2, #24
 8013602:	7bda      	ldrb	r2, [r3, #15]
 8013604:	2100      	movs	r1, #0
 8013606:	400a      	ands	r2, r1
 8013608:	1c11      	adds	r1, r2, #0
 801360a:	1c02      	adds	r2, r0, #0
 801360c:	430a      	orrs	r2, r1
 801360e:	73da      	strb	r2, [r3, #15]
    }

#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
 8013610:	69bb      	ldr	r3, [r7, #24]
 8013612:	7b1a      	ldrb	r2, [r3, #12]
 8013614:	7b59      	ldrb	r1, [r3, #13]
 8013616:	0209      	lsls	r1, r1, #8
 8013618:	430a      	orrs	r2, r1
 801361a:	7b99      	ldrb	r1, [r3, #14]
 801361c:	0409      	lsls	r1, r1, #16
 801361e:	430a      	orrs	r2, r1
 8013620:	7bdb      	ldrb	r3, [r3, #15]
 8013622:	061b      	lsls	r3, r3, #24
 8013624:	4313      	orrs	r3, r2
 8013626:	041b      	lsls	r3, r3, #16
 8013628:	0c1b      	lsrs	r3, r3, #16
 801362a:	69fa      	ldr	r2, [r7, #28]
 801362c:	18d3      	adds	r3, r2, r3
 801362e:	61fb      	str	r3, [r7, #28]
    chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
 8013630:	69bb      	ldr	r3, [r7, #24]
 8013632:	7b1a      	ldrb	r2, [r3, #12]
 8013634:	7b59      	ldrb	r1, [r3, #13]
 8013636:	0209      	lsls	r1, r1, #8
 8013638:	430a      	orrs	r2, r1
 801363a:	7b99      	ldrb	r1, [r3, #14]
 801363c:	0409      	lsls	r1, r1, #16
 801363e:	430a      	orrs	r2, r1
 8013640:	7bdb      	ldrb	r3, [r3, #15]
 8013642:	061b      	lsls	r3, r3, #24
 8013644:	4313      	orrs	r3, r2
 8013646:	0c1b      	lsrs	r3, r3, #16
 8013648:	69fa      	ldr	r2, [r7, #28]
 801364a:	18d3      	adds	r3, r2, r3
 801364c:	61fb      	str	r3, [r7, #28]
    chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
 801364e:	69fb      	ldr	r3, [r7, #28]
 8013650:	0c1a      	lsrs	r2, r3, #16
 8013652:	69fb      	ldr	r3, [r7, #28]
 8013654:	041b      	lsls	r3, r3, #16
 8013656:	0c1b      	lsrs	r3, r3, #16
 8013658:	18d3      	adds	r3, r2, r3
 801365a:	61fb      	str	r3, [r7, #28]
    chk_sum = (chk_sum >> 16) + chk_sum;
 801365c:	69fb      	ldr	r3, [r7, #28]
 801365e:	0c1b      	lsrs	r3, r3, #16
 8013660:	69fa      	ldr	r2, [r7, #28]
 8013662:	18d3      	adds	r3, r2, r3
 8013664:	61fb      	str	r3, [r7, #28]
    chk_sum = ~chk_sum;
 8013666:	69fb      	ldr	r3, [r7, #28]
 8013668:	43db      	mvns	r3, r3
 801366a:	61fb      	str	r3, [r7, #28]
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP) {
      iphdr->_chksum = (u16_t)chk_sum; /* network order */
 801366c:	69fb      	ldr	r3, [r7, #28]
 801366e:	b29a      	uxth	r2, r3
 8013670:	69bb      	ldr	r3, [r7, #24]
 8013672:	21ff      	movs	r1, #255	; 0xff
 8013674:	4011      	ands	r1, r2
 8013676:	000c      	movs	r4, r1
 8013678:	7a99      	ldrb	r1, [r3, #10]
 801367a:	2000      	movs	r0, #0
 801367c:	4001      	ands	r1, r0
 801367e:	1c08      	adds	r0, r1, #0
 8013680:	1c21      	adds	r1, r4, #0
 8013682:	4301      	orrs	r1, r0
 8013684:	7299      	strb	r1, [r3, #10]
 8013686:	0a12      	lsrs	r2, r2, #8
 8013688:	b290      	uxth	r0, r2
 801368a:	7ada      	ldrb	r2, [r3, #11]
 801368c:	2100      	movs	r1, #0
 801368e:	400a      	ands	r2, r1
 8013690:	1c11      	adds	r1, r2, #0
 8013692:	1c02      	adds	r2, r0, #0
 8013694:	430a      	orrs	r2, r1
 8013696:	72da      	strb	r2, [r3, #11]
 8013698:	e024      	b.n	80136e4 <ip4_output_if_src+0x3d4>
    }
#endif /* CHECKSUM_GEN_IP */
#endif /* CHECKSUM_GEN_IP_INLINE */
  } else {
    /* IP header already included in p */
    if (p->len < IP_HLEN) {
 801369a:	68fb      	ldr	r3, [r7, #12]
 801369c:	895b      	ldrh	r3, [r3, #10]
 801369e:	2b13      	cmp	r3, #19
 80136a0:	d80e      	bhi.n	80136c0 <ip4_output_if_src+0x3b0>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: LWIP_IP_HDRINCL but pbuf is too short\n"));
      IP_STATS_INC(ip.err);
      MIB2_STATS_INC(mib2.ipoutdiscards);
      return ERR_BUF;
 80136a2:	2302      	movs	r3, #2
 80136a4:	425b      	negs	r3, r3
 80136a6:	e024      	b.n	80136f2 <ip4_output_if_src+0x3e2>
 80136a8:	08020ca4 	.word	0x08020ca4
 80136ac:	08020cd0 	.word	0x08020cd0
 80136b0:	08020cdc 	.word	0x08020cdc
 80136b4:	08020d08 	.word	0x08020d08
 80136b8:	200013a0 	.word	0x200013a0
 80136bc:	08021a50 	.word	0x08021a50
    }
    iphdr = (struct ip_hdr *)p->payload;
 80136c0:	68fb      	ldr	r3, [r7, #12]
 80136c2:	685b      	ldr	r3, [r3, #4]
 80136c4:	61bb      	str	r3, [r7, #24]
    ip4_addr_copy(dest_addr, iphdr->dest);
 80136c6:	69bb      	ldr	r3, [r7, #24]
 80136c8:	7c1a      	ldrb	r2, [r3, #16]
 80136ca:	7c59      	ldrb	r1, [r3, #17]
 80136cc:	0209      	lsls	r1, r1, #8
 80136ce:	430a      	orrs	r2, r1
 80136d0:	7c99      	ldrb	r1, [r3, #18]
 80136d2:	0409      	lsls	r1, r1, #16
 80136d4:	430a      	orrs	r2, r1
 80136d6:	7cdb      	ldrb	r3, [r3, #19]
 80136d8:	061b      	lsls	r3, r3, #24
 80136da:	4313      	orrs	r3, r2
 80136dc:	613b      	str	r3, [r7, #16]
    dest = &dest_addr;
 80136de:	2310      	movs	r3, #16
 80136e0:	18fb      	adds	r3, r7, r3
 80136e2:	607b      	str	r3, [r7, #4]
    return ip4_frag(p, netif, dest);
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: call netif->output()\n"));
  return netif->output(netif, p, dest);
 80136e4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80136e6:	695b      	ldr	r3, [r3, #20]
 80136e8:	687a      	ldr	r2, [r7, #4]
 80136ea:	68f9      	ldr	r1, [r7, #12]
 80136ec:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 80136ee:	4798      	blx	r3
 80136f0:	0003      	movs	r3, r0
}
 80136f2:	0018      	movs	r0, r3
 80136f4:	46bd      	mov	sp, r7
 80136f6:	b009      	add	sp, #36	; 0x24
 80136f8:	bd90      	pop	{r4, r7, pc}
 80136fa:	46c0      	nop			; (mov r8, r8)

080136fc <ip4_addr_isbroadcast_u32>:
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t
ip4_addr_isbroadcast_u32(u32_t addr, const struct netif *netif)
{
 80136fc:	b580      	push	{r7, lr}
 80136fe:	b084      	sub	sp, #16
 8013700:	af00      	add	r7, sp, #0
 8013702:	6078      	str	r0, [r7, #4]
 8013704:	6039      	str	r1, [r7, #0]
  ip4_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);
 8013706:	687b      	ldr	r3, [r7, #4]
 8013708:	60fb      	str	r3, [r7, #12]

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
 801370a:	687b      	ldr	r3, [r7, #4]
 801370c:	3301      	adds	r3, #1
 801370e:	d002      	beq.n	8013716 <ip4_addr_isbroadcast_u32+0x1a>
 8013710:	687b      	ldr	r3, [r7, #4]
 8013712:	2b00      	cmp	r3, #0
 8013714:	d101      	bne.n	801371a <ip4_addr_isbroadcast_u32+0x1e>
      (addr == IPADDR_ANY)) {
    return 1;
 8013716:	2301      	movs	r3, #1
 8013718:	e029      	b.n	801376e <ip4_addr_isbroadcast_u32+0x72>
    /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
 801371a:	683b      	ldr	r3, [r7, #0]
 801371c:	2231      	movs	r2, #49	; 0x31
 801371e:	5c9b      	ldrb	r3, [r3, r2]
 8013720:	001a      	movs	r2, r3
 8013722:	2302      	movs	r3, #2
 8013724:	4013      	ands	r3, r2
 8013726:	d101      	bne.n	801372c <ip4_addr_isbroadcast_u32+0x30>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
 8013728:	2300      	movs	r3, #0
 801372a:	e020      	b.n	801376e <ip4_addr_isbroadcast_u32+0x72>
    /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(netif_ip4_addr(netif))) {
 801372c:	683b      	ldr	r3, [r7, #0]
 801372e:	3304      	adds	r3, #4
 8013730:	681b      	ldr	r3, [r3, #0]
 8013732:	687a      	ldr	r2, [r7, #4]
 8013734:	429a      	cmp	r2, r3
 8013736:	d101      	bne.n	801373c <ip4_addr_isbroadcast_u32+0x40>
    return 0;
 8013738:	2300      	movs	r3, #0
 801373a:	e018      	b.n	801376e <ip4_addr_isbroadcast_u32+0x72>
    /*  on the same (sub) network... */
  } else if (ip4_addr_netcmp(&ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif))
 801373c:	68fa      	ldr	r2, [r7, #12]
 801373e:	683b      	ldr	r3, [r7, #0]
 8013740:	3304      	adds	r3, #4
 8013742:	681b      	ldr	r3, [r3, #0]
 8013744:	405a      	eors	r2, r3
 8013746:	683b      	ldr	r3, [r7, #0]
 8013748:	3308      	adds	r3, #8
 801374a:	681b      	ldr	r3, [r3, #0]
 801374c:	4013      	ands	r3, r2
 801374e:	d10d      	bne.n	801376c <ip4_addr_isbroadcast_u32+0x70>
             /* ...and host identifier bits are all ones? =>... */
             && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
 8013750:	683b      	ldr	r3, [r7, #0]
 8013752:	3308      	adds	r3, #8
 8013754:	681b      	ldr	r3, [r3, #0]
 8013756:	43db      	mvns	r3, r3
 8013758:	687a      	ldr	r2, [r7, #4]
 801375a:	401a      	ands	r2, r3
                 (IPADDR_BROADCAST & ~ip4_addr_get_u32(netif_ip4_netmask(netif))))) {
 801375c:	683b      	ldr	r3, [r7, #0]
 801375e:	3308      	adds	r3, #8
 8013760:	681b      	ldr	r3, [r3, #0]
 8013762:	43db      	mvns	r3, r3
             && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
 8013764:	429a      	cmp	r2, r3
 8013766:	d101      	bne.n	801376c <ip4_addr_isbroadcast_u32+0x70>
    /* => network broadcast address */
    return 1;
 8013768:	2301      	movs	r3, #1
 801376a:	e000      	b.n	801376e <ip4_addr_isbroadcast_u32+0x72>
  } else {
    return 0;
 801376c:	2300      	movs	r3, #0
  }
}
 801376e:	0018      	movs	r0, r3
 8013770:	46bd      	mov	sp, r7
 8013772:	b004      	add	sp, #16
 8013774:	bd80      	pop	{r7, pc}
	...

08013778 <ip4addr_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
ip4addr_aton(const char *cp, ip4_addr_t *addr)
{
 8013778:	b580      	push	{r7, lr}
 801377a:	b08a      	sub	sp, #40	; 0x28
 801377c:	af00      	add	r7, sp, #0
 801377e:	6078      	str	r0, [r7, #4]
 8013780:	6039      	str	r1, [r7, #0]
  u32_t val;
  u8_t base;
  char c;
  u32_t parts[4];
  u32_t *pp = parts;
 8013782:	230c      	movs	r3, #12
 8013784:	18fb      	adds	r3, r7, r3
 8013786:	61fb      	str	r3, [r7, #28]

  c = *cp;
 8013788:	2322      	movs	r3, #34	; 0x22
 801378a:	18fb      	adds	r3, r7, r3
 801378c:	687a      	ldr	r2, [r7, #4]
 801378e:	7812      	ldrb	r2, [r2, #0]
 8013790:	701a      	strb	r2, [r3, #0]
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!lwip_isdigit(c)) {
 8013792:	2322      	movs	r3, #34	; 0x22
 8013794:	18fb      	adds	r3, r7, r3
 8013796:	781b      	ldrb	r3, [r3, #0]
 8013798:	1c5a      	adds	r2, r3, #1
 801379a:	4b9d      	ldr	r3, [pc, #628]	; (8013a10 <ip4addr_aton+0x298>)
 801379c:	18d3      	adds	r3, r2, r3
 801379e:	781b      	ldrb	r3, [r3, #0]
 80137a0:	001a      	movs	r2, r3
 80137a2:	2304      	movs	r3, #4
 80137a4:	4013      	ands	r3, r2
 80137a6:	d101      	bne.n	80137ac <ip4addr_aton+0x34>
      return 0;
 80137a8:	2300      	movs	r3, #0
 80137aa:	e12d      	b.n	8013a08 <ip4addr_aton+0x290>
    }
    val = 0;
 80137ac:	2300      	movs	r3, #0
 80137ae:	627b      	str	r3, [r7, #36]	; 0x24
    base = 10;
 80137b0:	2323      	movs	r3, #35	; 0x23
 80137b2:	18fb      	adds	r3, r7, r3
 80137b4:	220a      	movs	r2, #10
 80137b6:	701a      	strb	r2, [r3, #0]
    if (c == '0') {
 80137b8:	2222      	movs	r2, #34	; 0x22
 80137ba:	18bb      	adds	r3, r7, r2
 80137bc:	781b      	ldrb	r3, [r3, #0]
 80137be:	2b30      	cmp	r3, #48	; 0x30
 80137c0:	d121      	bne.n	8013806 <ip4addr_aton+0x8e>
      c = *++cp;
 80137c2:	687b      	ldr	r3, [r7, #4]
 80137c4:	3301      	adds	r3, #1
 80137c6:	607b      	str	r3, [r7, #4]
 80137c8:	0011      	movs	r1, r2
 80137ca:	18bb      	adds	r3, r7, r2
 80137cc:	687a      	ldr	r2, [r7, #4]
 80137ce:	7812      	ldrb	r2, [r2, #0]
 80137d0:	701a      	strb	r2, [r3, #0]
      if (c == 'x' || c == 'X') {
 80137d2:	000a      	movs	r2, r1
 80137d4:	18bb      	adds	r3, r7, r2
 80137d6:	781b      	ldrb	r3, [r3, #0]
 80137d8:	2b78      	cmp	r3, #120	; 0x78
 80137da:	d003      	beq.n	80137e4 <ip4addr_aton+0x6c>
 80137dc:	18bb      	adds	r3, r7, r2
 80137de:	781b      	ldrb	r3, [r3, #0]
 80137e0:	2b58      	cmp	r3, #88	; 0x58
 80137e2:	d10c      	bne.n	80137fe <ip4addr_aton+0x86>
        base = 16;
 80137e4:	2323      	movs	r3, #35	; 0x23
 80137e6:	18fb      	adds	r3, r7, r3
 80137e8:	2210      	movs	r2, #16
 80137ea:	701a      	strb	r2, [r3, #0]
        c = *++cp;
 80137ec:	687b      	ldr	r3, [r7, #4]
 80137ee:	3301      	adds	r3, #1
 80137f0:	607b      	str	r3, [r7, #4]
 80137f2:	2322      	movs	r3, #34	; 0x22
 80137f4:	18fb      	adds	r3, r7, r3
 80137f6:	687a      	ldr	r2, [r7, #4]
 80137f8:	7812      	ldrb	r2, [r2, #0]
 80137fa:	701a      	strb	r2, [r3, #0]
 80137fc:	e003      	b.n	8013806 <ip4addr_aton+0x8e>
      } else {
        base = 8;
 80137fe:	2323      	movs	r3, #35	; 0x23
 8013800:	18fb      	adds	r3, r7, r3
 8013802:	2208      	movs	r2, #8
 8013804:	701a      	strb	r2, [r3, #0]
      }
    }
    for (;;) {
      if (lwip_isdigit(c)) {
 8013806:	2122      	movs	r1, #34	; 0x22
 8013808:	187b      	adds	r3, r7, r1
 801380a:	781b      	ldrb	r3, [r3, #0]
 801380c:	1c5a      	adds	r2, r3, #1
 801380e:	4b80      	ldr	r3, [pc, #512]	; (8013a10 <ip4addr_aton+0x298>)
 8013810:	18d3      	adds	r3, r2, r3
 8013812:	781b      	ldrb	r3, [r3, #0]
 8013814:	001a      	movs	r2, r3
 8013816:	2304      	movs	r3, #4
 8013818:	4013      	ands	r3, r2
 801381a:	d01c      	beq.n	8013856 <ip4addr_aton+0xde>
        if((base == 8) && ((u32_t)(c - '0') >= 8))
 801381c:	2323      	movs	r3, #35	; 0x23
 801381e:	18fb      	adds	r3, r7, r3
 8013820:	781b      	ldrb	r3, [r3, #0]
 8013822:	2b08      	cmp	r3, #8
 8013824:	d104      	bne.n	8013830 <ip4addr_aton+0xb8>
 8013826:	187b      	adds	r3, r7, r1
 8013828:	781b      	ldrb	r3, [r3, #0]
 801382a:	3b30      	subs	r3, #48	; 0x30
 801382c:	2b07      	cmp	r3, #7
 801382e:	d843      	bhi.n	80138b8 <ip4addr_aton+0x140>
          break;
        val = (val * base) + (u32_t)(c - '0');
 8013830:	2323      	movs	r3, #35	; 0x23
 8013832:	18fb      	adds	r3, r7, r3
 8013834:	781b      	ldrb	r3, [r3, #0]
 8013836:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013838:	435a      	muls	r2, r3
 801383a:	2122      	movs	r1, #34	; 0x22
 801383c:	187b      	adds	r3, r7, r1
 801383e:	781b      	ldrb	r3, [r3, #0]
 8013840:	18d3      	adds	r3, r2, r3
 8013842:	3b30      	subs	r3, #48	; 0x30
 8013844:	627b      	str	r3, [r7, #36]	; 0x24
        c = *++cp;
 8013846:	687b      	ldr	r3, [r7, #4]
 8013848:	3301      	adds	r3, #1
 801384a:	607b      	str	r3, [r7, #4]
 801384c:	187b      	adds	r3, r7, r1
 801384e:	687a      	ldr	r2, [r7, #4]
 8013850:	7812      	ldrb	r2, [r2, #0]
 8013852:	701a      	strb	r2, [r3, #0]
 8013854:	e7d7      	b.n	8013806 <ip4addr_aton+0x8e>
      } else if (base == 16 && lwip_isxdigit(c)) {
 8013856:	2323      	movs	r3, #35	; 0x23
 8013858:	18fb      	adds	r3, r7, r3
 801385a:	781b      	ldrb	r3, [r3, #0]
 801385c:	2b10      	cmp	r3, #16
 801385e:	d12c      	bne.n	80138ba <ip4addr_aton+0x142>
 8013860:	2122      	movs	r1, #34	; 0x22
 8013862:	187b      	adds	r3, r7, r1
 8013864:	781b      	ldrb	r3, [r3, #0]
 8013866:	1c5a      	adds	r2, r3, #1
 8013868:	4b69      	ldr	r3, [pc, #420]	; (8013a10 <ip4addr_aton+0x298>)
 801386a:	18d3      	adds	r3, r2, r3
 801386c:	781b      	ldrb	r3, [r3, #0]
 801386e:	001a      	movs	r2, r3
 8013870:	2344      	movs	r3, #68	; 0x44
 8013872:	4013      	ands	r3, r2
 8013874:	d021      	beq.n	80138ba <ip4addr_aton+0x142>
        val = (val << 4) | (u32_t)(c + 10 - (lwip_islower(c) ? 'a' : 'A'));
 8013876:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013878:	011a      	lsls	r2, r3, #4
 801387a:	0008      	movs	r0, r1
 801387c:	187b      	adds	r3, r7, r1
 801387e:	781b      	ldrb	r3, [r3, #0]
 8013880:	330a      	adds	r3, #10
 8013882:	0019      	movs	r1, r3
 8013884:	183b      	adds	r3, r7, r0
 8013886:	781b      	ldrb	r3, [r3, #0]
 8013888:	1c58      	adds	r0, r3, #1
 801388a:	4b61      	ldr	r3, [pc, #388]	; (8013a10 <ip4addr_aton+0x298>)
 801388c:	18c3      	adds	r3, r0, r3
 801388e:	781b      	ldrb	r3, [r3, #0]
 8013890:	0018      	movs	r0, r3
 8013892:	2303      	movs	r3, #3
 8013894:	4003      	ands	r3, r0
 8013896:	2b02      	cmp	r3, #2
 8013898:	d101      	bne.n	801389e <ip4addr_aton+0x126>
 801389a:	2361      	movs	r3, #97	; 0x61
 801389c:	e000      	b.n	80138a0 <ip4addr_aton+0x128>
 801389e:	2341      	movs	r3, #65	; 0x41
 80138a0:	1acb      	subs	r3, r1, r3
 80138a2:	4313      	orrs	r3, r2
 80138a4:	627b      	str	r3, [r7, #36]	; 0x24
        c = *++cp;
 80138a6:	687b      	ldr	r3, [r7, #4]
 80138a8:	3301      	adds	r3, #1
 80138aa:	607b      	str	r3, [r7, #4]
 80138ac:	2322      	movs	r3, #34	; 0x22
 80138ae:	18fb      	adds	r3, r7, r3
 80138b0:	687a      	ldr	r2, [r7, #4]
 80138b2:	7812      	ldrb	r2, [r2, #0]
 80138b4:	701a      	strb	r2, [r3, #0]
      if (lwip_isdigit(c)) {
 80138b6:	e7a6      	b.n	8013806 <ip4addr_aton+0x8e>
          break;
 80138b8:	46c0      	nop			; (mov r8, r8)
      } else {
        break;
      }
    }
    if (c == '.') {
 80138ba:	2322      	movs	r3, #34	; 0x22
 80138bc:	18fb      	adds	r3, r7, r3
 80138be:	781b      	ldrb	r3, [r3, #0]
 80138c0:	2b2e      	cmp	r3, #46	; 0x2e
 80138c2:	d115      	bne.n	80138f0 <ip4addr_aton+0x178>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3) {
 80138c4:	230c      	movs	r3, #12
 80138c6:	18fb      	adds	r3, r7, r3
 80138c8:	330c      	adds	r3, #12
 80138ca:	69fa      	ldr	r2, [r7, #28]
 80138cc:	429a      	cmp	r2, r3
 80138ce:	d301      	bcc.n	80138d4 <ip4addr_aton+0x15c>
        return 0;
 80138d0:	2300      	movs	r3, #0
 80138d2:	e099      	b.n	8013a08 <ip4addr_aton+0x290>
      }
      *pp++ = val;
 80138d4:	69fb      	ldr	r3, [r7, #28]
 80138d6:	1d1a      	adds	r2, r3, #4
 80138d8:	61fa      	str	r2, [r7, #28]
 80138da:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80138dc:	601a      	str	r2, [r3, #0]
      c = *++cp;
 80138de:	687b      	ldr	r3, [r7, #4]
 80138e0:	3301      	adds	r3, #1
 80138e2:	607b      	str	r3, [r7, #4]
 80138e4:	2322      	movs	r3, #34	; 0x22
 80138e6:	18fb      	adds	r3, r7, r3
 80138e8:	687a      	ldr	r2, [r7, #4]
 80138ea:	7812      	ldrb	r2, [r2, #0]
 80138ec:	701a      	strb	r2, [r3, #0]
    if (!lwip_isdigit(c)) {
 80138ee:	e750      	b.n	8013792 <ip4addr_aton+0x1a>
    } else {
      break;
 80138f0:	46c0      	nop			; (mov r8, r8)
    }
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && !lwip_isspace(c)) {
 80138f2:	2222      	movs	r2, #34	; 0x22
 80138f4:	18bb      	adds	r3, r7, r2
 80138f6:	781b      	ldrb	r3, [r3, #0]
 80138f8:	2b00      	cmp	r3, #0
 80138fa:	d00b      	beq.n	8013914 <ip4addr_aton+0x19c>
 80138fc:	18bb      	adds	r3, r7, r2
 80138fe:	781b      	ldrb	r3, [r3, #0]
 8013900:	1c5a      	adds	r2, r3, #1
 8013902:	4b43      	ldr	r3, [pc, #268]	; (8013a10 <ip4addr_aton+0x298>)
 8013904:	18d3      	adds	r3, r2, r3
 8013906:	781b      	ldrb	r3, [r3, #0]
 8013908:	001a      	movs	r2, r3
 801390a:	2308      	movs	r3, #8
 801390c:	4013      	ands	r3, r2
 801390e:	d101      	bne.n	8013914 <ip4addr_aton+0x19c>
    return 0;
 8013910:	2300      	movs	r3, #0
 8013912:	e079      	b.n	8013a08 <ip4addr_aton+0x290>
  }
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  switch (pp - parts + 1) {
 8013914:	230c      	movs	r3, #12
 8013916:	18fb      	adds	r3, r7, r3
 8013918:	69fa      	ldr	r2, [r7, #28]
 801391a:	1ad3      	subs	r3, r2, r3
 801391c:	109b      	asrs	r3, r3, #2
 801391e:	3301      	adds	r3, #1
 8013920:	2b04      	cmp	r3, #4
 8013922:	d85e      	bhi.n	80139e2 <ip4addr_aton+0x26a>
 8013924:	009a      	lsls	r2, r3, #2
 8013926:	4b3b      	ldr	r3, [pc, #236]	; (8013a14 <ip4addr_aton+0x29c>)
 8013928:	18d3      	adds	r3, r2, r3
 801392a:	681b      	ldr	r3, [r3, #0]
 801392c:	469f      	mov	pc, r3

    case 0:
      return 0;       /* initial nondigit */
 801392e:	2300      	movs	r3, #0
 8013930:	e06a      	b.n	8013a08 <ip4addr_aton+0x290>

    case 1:             /* a -- 32 bits */
      break;

    case 2:             /* a.b -- 8.24 bits */
      if (val > 0xffffffUL) {
 8013932:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013934:	2380      	movs	r3, #128	; 0x80
 8013936:	045b      	lsls	r3, r3, #17
 8013938:	429a      	cmp	r2, r3
 801393a:	d301      	bcc.n	8013940 <ip4addr_aton+0x1c8>
        return 0;
 801393c:	2300      	movs	r3, #0
 801393e:	e063      	b.n	8013a08 <ip4addr_aton+0x290>
      }
      if (parts[0] > 0xff) {
 8013940:	230c      	movs	r3, #12
 8013942:	18fb      	adds	r3, r7, r3
 8013944:	681b      	ldr	r3, [r3, #0]
 8013946:	2bff      	cmp	r3, #255	; 0xff
 8013948:	d901      	bls.n	801394e <ip4addr_aton+0x1d6>
        return 0;
 801394a:	2300      	movs	r3, #0
 801394c:	e05c      	b.n	8013a08 <ip4addr_aton+0x290>
      }
      val |= parts[0] << 24;
 801394e:	230c      	movs	r3, #12
 8013950:	18fb      	adds	r3, r7, r3
 8013952:	681b      	ldr	r3, [r3, #0]
 8013954:	061b      	lsls	r3, r3, #24
 8013956:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013958:	4313      	orrs	r3, r2
 801395a:	627b      	str	r3, [r7, #36]	; 0x24
      break;
 801395c:	e049      	b.n	80139f2 <ip4addr_aton+0x27a>

    case 3:             /* a.b.c -- 8.8.16 bits */
      if (val > 0xffff) {
 801395e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013960:	2380      	movs	r3, #128	; 0x80
 8013962:	025b      	lsls	r3, r3, #9
 8013964:	429a      	cmp	r2, r3
 8013966:	d301      	bcc.n	801396c <ip4addr_aton+0x1f4>
        return 0;
 8013968:	2300      	movs	r3, #0
 801396a:	e04d      	b.n	8013a08 <ip4addr_aton+0x290>
      }
      if ((parts[0] > 0xff) || (parts[1] > 0xff)) {
 801396c:	220c      	movs	r2, #12
 801396e:	18bb      	adds	r3, r7, r2
 8013970:	681b      	ldr	r3, [r3, #0]
 8013972:	2bff      	cmp	r3, #255	; 0xff
 8013974:	d803      	bhi.n	801397e <ip4addr_aton+0x206>
 8013976:	18bb      	adds	r3, r7, r2
 8013978:	685b      	ldr	r3, [r3, #4]
 801397a:	2bff      	cmp	r3, #255	; 0xff
 801397c:	d901      	bls.n	8013982 <ip4addr_aton+0x20a>
        return 0;
 801397e:	2300      	movs	r3, #0
 8013980:	e042      	b.n	8013a08 <ip4addr_aton+0x290>
      }
      val |= (parts[0] << 24) | (parts[1] << 16);
 8013982:	210c      	movs	r1, #12
 8013984:	187b      	adds	r3, r7, r1
 8013986:	681b      	ldr	r3, [r3, #0]
 8013988:	061a      	lsls	r2, r3, #24
 801398a:	187b      	adds	r3, r7, r1
 801398c:	685b      	ldr	r3, [r3, #4]
 801398e:	041b      	lsls	r3, r3, #16
 8013990:	4313      	orrs	r3, r2
 8013992:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8013994:	4313      	orrs	r3, r2
 8013996:	627b      	str	r3, [r7, #36]	; 0x24
      break;
 8013998:	e02b      	b.n	80139f2 <ip4addr_aton+0x27a>

    case 4:             /* a.b.c.d -- 8.8.8.8 bits */
      if (val > 0xff) {
 801399a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801399c:	2bff      	cmp	r3, #255	; 0xff
 801399e:	d901      	bls.n	80139a4 <ip4addr_aton+0x22c>
        return 0;
 80139a0:	2300      	movs	r3, #0
 80139a2:	e031      	b.n	8013a08 <ip4addr_aton+0x290>
      }
      if ((parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff)) {
 80139a4:	220c      	movs	r2, #12
 80139a6:	18bb      	adds	r3, r7, r2
 80139a8:	681b      	ldr	r3, [r3, #0]
 80139aa:	2bff      	cmp	r3, #255	; 0xff
 80139ac:	d807      	bhi.n	80139be <ip4addr_aton+0x246>
 80139ae:	18bb      	adds	r3, r7, r2
 80139b0:	685b      	ldr	r3, [r3, #4]
 80139b2:	2bff      	cmp	r3, #255	; 0xff
 80139b4:	d803      	bhi.n	80139be <ip4addr_aton+0x246>
 80139b6:	18bb      	adds	r3, r7, r2
 80139b8:	689b      	ldr	r3, [r3, #8]
 80139ba:	2bff      	cmp	r3, #255	; 0xff
 80139bc:	d901      	bls.n	80139c2 <ip4addr_aton+0x24a>
        return 0;
 80139be:	2300      	movs	r3, #0
 80139c0:	e022      	b.n	8013a08 <ip4addr_aton+0x290>
      }
      val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
 80139c2:	210c      	movs	r1, #12
 80139c4:	187b      	adds	r3, r7, r1
 80139c6:	681b      	ldr	r3, [r3, #0]
 80139c8:	061a      	lsls	r2, r3, #24
 80139ca:	187b      	adds	r3, r7, r1
 80139cc:	685b      	ldr	r3, [r3, #4]
 80139ce:	041b      	lsls	r3, r3, #16
 80139d0:	431a      	orrs	r2, r3
 80139d2:	187b      	adds	r3, r7, r1
 80139d4:	689b      	ldr	r3, [r3, #8]
 80139d6:	021b      	lsls	r3, r3, #8
 80139d8:	4313      	orrs	r3, r2
 80139da:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80139dc:	4313      	orrs	r3, r2
 80139de:	627b      	str	r3, [r7, #36]	; 0x24
      break;
 80139e0:	e007      	b.n	80139f2 <ip4addr_aton+0x27a>
    default:
      LWIP_ASSERT("unhandled", 0);
 80139e2:	4b0d      	ldr	r3, [pc, #52]	; (8013a18 <ip4addr_aton+0x2a0>)
 80139e4:	490d      	ldr	r1, [pc, #52]	; (8013a1c <ip4addr_aton+0x2a4>)
 80139e6:	480e      	ldr	r0, [pc, #56]	; (8013a20 <ip4addr_aton+0x2a8>)
 80139e8:	22fb      	movs	r2, #251	; 0xfb
 80139ea:	f7ee fbef 	bl	80021cc <app_debug_rtt_raw>
      break;
 80139ee:	e000      	b.n	80139f2 <ip4addr_aton+0x27a>
      break;
 80139f0:	46c0      	nop			; (mov r8, r8)
  }
  if (addr) {
 80139f2:	683b      	ldr	r3, [r7, #0]
 80139f4:	2b00      	cmp	r3, #0
 80139f6:	d006      	beq.n	8013a06 <ip4addr_aton+0x28e>
    ip4_addr_set_u32(addr, lwip_htonl(val));
 80139f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80139fa:	0018      	movs	r0, r3
 80139fc:	f7f2 fdb0 	bl	8006560 <lwip_htonl>
 8013a00:	0002      	movs	r2, r0
 8013a02:	683b      	ldr	r3, [r7, #0]
 8013a04:	601a      	str	r2, [r3, #0]
  }
  return 1;
 8013a06:	2301      	movs	r3, #1
}
 8013a08:	0018      	movs	r0, r3
 8013a0a:	46bd      	mov	sp, r7
 8013a0c:	b00a      	add	sp, #40	; 0x28
 8013a0e:	bd80      	pop	{r7, pc}
 8013a10:	0802202c 	.word	0x0802202c
 8013a14:	08021a58 	.word	0x08021a58
 8013a18:	08020d38 	.word	0x08020d38
 8013a1c:	08020d68 	.word	0x08020d68
 8013a20:	08020d74 	.word	0x08020d74

08013a24 <ip4addr_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         representation of addr
 */
char *
ip4addr_ntoa(const ip4_addr_t *addr)
{
 8013a24:	b580      	push	{r7, lr}
 8013a26:	b082      	sub	sp, #8
 8013a28:	af00      	add	r7, sp, #0
 8013a2a:	6078      	str	r0, [r7, #4]
  static char str[IP4ADDR_STRLEN_MAX];
  return ip4addr_ntoa_r(addr, str, IP4ADDR_STRLEN_MAX);
 8013a2c:	4905      	ldr	r1, [pc, #20]	; (8013a44 <ip4addr_ntoa+0x20>)
 8013a2e:	687b      	ldr	r3, [r7, #4]
 8013a30:	2210      	movs	r2, #16
 8013a32:	0018      	movs	r0, r3
 8013a34:	f000 f808 	bl	8013a48 <ip4addr_ntoa_r>
 8013a38:	0003      	movs	r3, r0
}
 8013a3a:	0018      	movs	r0, r3
 8013a3c:	46bd      	mov	sp, r7
 8013a3e:	b002      	add	sp, #8
 8013a40:	bd80      	pop	{r7, pc}
 8013a42:	46c0      	nop			; (mov r8, r8)
 8013a44:	200013a4 	.word	0x200013a4

08013a48 <ip4addr_ntoa_r>:
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *
ip4addr_ntoa_r(const ip4_addr_t *addr, char *buf, int buflen)
{
 8013a48:	b5b0      	push	{r4, r5, r7, lr}
 8013a4a:	b08c      	sub	sp, #48	; 0x30
 8013a4c:	af00      	add	r7, sp, #0
 8013a4e:	60f8      	str	r0, [r7, #12]
 8013a50:	60b9      	str	r1, [r7, #8]
 8013a52:	607a      	str	r2, [r7, #4]
  char *rp;
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;
  int len = 0;
 8013a54:	2300      	movs	r3, #0
 8013a56:	623b      	str	r3, [r7, #32]

  s_addr = ip4_addr_get_u32(addr);
 8013a58:	68fb      	ldr	r3, [r7, #12]
 8013a5a:	681b      	ldr	r3, [r3, #0]
 8013a5c:	61bb      	str	r3, [r7, #24]

  rp = buf;
 8013a5e:	68bb      	ldr	r3, [r7, #8]
 8013a60:	62fb      	str	r3, [r7, #44]	; 0x2c
  ap = (u8_t *)&s_addr;
 8013a62:	2318      	movs	r3, #24
 8013a64:	18fb      	adds	r3, r7, r3
 8013a66:	62bb      	str	r3, [r7, #40]	; 0x28
  for (n = 0; n < 4; n++) {
 8013a68:	2327      	movs	r3, #39	; 0x27
 8013a6a:	18fb      	adds	r3, r7, r3
 8013a6c:	2200      	movs	r2, #0
 8013a6e:	701a      	strb	r2, [r3, #0]
 8013a70:	e05a      	b.n	8013b28 <ip4addr_ntoa_r+0xe0>
    i = 0;
 8013a72:	2326      	movs	r3, #38	; 0x26
 8013a74:	18fb      	adds	r3, r7, r3
 8013a76:	2200      	movs	r2, #0
 8013a78:	701a      	strb	r2, [r3, #0]
    do {
      rem = *ap % (u8_t)10;
 8013a7a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013a7c:	781b      	ldrb	r3, [r3, #0]
 8013a7e:	251f      	movs	r5, #31
 8013a80:	197c      	adds	r4, r7, r5
 8013a82:	210a      	movs	r1, #10
 8013a84:	0018      	movs	r0, r3
 8013a86:	f7ec fbd7 	bl	8000238 <__aeabi_uidivmod>
 8013a8a:	000b      	movs	r3, r1
 8013a8c:	7023      	strb	r3, [r4, #0]
      *ap /= (u8_t)10;
 8013a8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013a90:	781b      	ldrb	r3, [r3, #0]
 8013a92:	210a      	movs	r1, #10
 8013a94:	0018      	movs	r0, r3
 8013a96:	f7ec fb49 	bl	800012c <__udivsi3>
 8013a9a:	0003      	movs	r3, r0
 8013a9c:	b2da      	uxtb	r2, r3
 8013a9e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013aa0:	701a      	strb	r2, [r3, #0]
      inv[i++] = (char)('0' + rem);
 8013aa2:	2226      	movs	r2, #38	; 0x26
 8013aa4:	18bb      	adds	r3, r7, r2
 8013aa6:	781b      	ldrb	r3, [r3, #0]
 8013aa8:	18ba      	adds	r2, r7, r2
 8013aaa:	1c59      	adds	r1, r3, #1
 8013aac:	7011      	strb	r1, [r2, #0]
 8013aae:	001a      	movs	r2, r3
 8013ab0:	197b      	adds	r3, r7, r5
 8013ab2:	781b      	ldrb	r3, [r3, #0]
 8013ab4:	3330      	adds	r3, #48	; 0x30
 8013ab6:	b2d9      	uxtb	r1, r3
 8013ab8:	2314      	movs	r3, #20
 8013aba:	18fb      	adds	r3, r7, r3
 8013abc:	5499      	strb	r1, [r3, r2]
    } while (*ap);
 8013abe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013ac0:	781b      	ldrb	r3, [r3, #0]
 8013ac2:	2b00      	cmp	r3, #0
 8013ac4:	d1d9      	bne.n	8013a7a <ip4addr_ntoa_r+0x32>
    while (i--) {
 8013ac6:	e011      	b.n	8013aec <ip4addr_ntoa_r+0xa4>
      if (len++ >= buflen) {
 8013ac8:	6a3b      	ldr	r3, [r7, #32]
 8013aca:	1c5a      	adds	r2, r3, #1
 8013acc:	623a      	str	r2, [r7, #32]
 8013ace:	687a      	ldr	r2, [r7, #4]
 8013ad0:	429a      	cmp	r2, r3
 8013ad2:	dc01      	bgt.n	8013ad8 <ip4addr_ntoa_r+0x90>
        return NULL;
 8013ad4:	2300      	movs	r3, #0
 8013ad6:	e033      	b.n	8013b40 <ip4addr_ntoa_r+0xf8>
      }
      *rp++ = inv[i];
 8013ad8:	2326      	movs	r3, #38	; 0x26
 8013ada:	18fb      	adds	r3, r7, r3
 8013adc:	781a      	ldrb	r2, [r3, #0]
 8013ade:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013ae0:	1c59      	adds	r1, r3, #1
 8013ae2:	62f9      	str	r1, [r7, #44]	; 0x2c
 8013ae4:	2114      	movs	r1, #20
 8013ae6:	1879      	adds	r1, r7, r1
 8013ae8:	5c8a      	ldrb	r2, [r1, r2]
 8013aea:	701a      	strb	r2, [r3, #0]
    while (i--) {
 8013aec:	2226      	movs	r2, #38	; 0x26
 8013aee:	18bb      	adds	r3, r7, r2
 8013af0:	781b      	ldrb	r3, [r3, #0]
 8013af2:	18ba      	adds	r2, r7, r2
 8013af4:	1e59      	subs	r1, r3, #1
 8013af6:	7011      	strb	r1, [r2, #0]
 8013af8:	2b00      	cmp	r3, #0
 8013afa:	d1e5      	bne.n	8013ac8 <ip4addr_ntoa_r+0x80>
    }
    if (len++ >= buflen) {
 8013afc:	6a3b      	ldr	r3, [r7, #32]
 8013afe:	1c5a      	adds	r2, r3, #1
 8013b00:	623a      	str	r2, [r7, #32]
 8013b02:	687a      	ldr	r2, [r7, #4]
 8013b04:	429a      	cmp	r2, r3
 8013b06:	dc01      	bgt.n	8013b0c <ip4addr_ntoa_r+0xc4>
      return NULL;
 8013b08:	2300      	movs	r3, #0
 8013b0a:	e019      	b.n	8013b40 <ip4addr_ntoa_r+0xf8>
    }
    *rp++ = '.';
 8013b0c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013b0e:	1c5a      	adds	r2, r3, #1
 8013b10:	62fa      	str	r2, [r7, #44]	; 0x2c
 8013b12:	222e      	movs	r2, #46	; 0x2e
 8013b14:	701a      	strb	r2, [r3, #0]
    ap++;
 8013b16:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8013b18:	3301      	adds	r3, #1
 8013b1a:	62bb      	str	r3, [r7, #40]	; 0x28
  for (n = 0; n < 4; n++) {
 8013b1c:	2127      	movs	r1, #39	; 0x27
 8013b1e:	187b      	adds	r3, r7, r1
 8013b20:	781a      	ldrb	r2, [r3, #0]
 8013b22:	187b      	adds	r3, r7, r1
 8013b24:	3201      	adds	r2, #1
 8013b26:	701a      	strb	r2, [r3, #0]
 8013b28:	2327      	movs	r3, #39	; 0x27
 8013b2a:	18fb      	adds	r3, r7, r3
 8013b2c:	781b      	ldrb	r3, [r3, #0]
 8013b2e:	2b03      	cmp	r3, #3
 8013b30:	d99f      	bls.n	8013a72 <ip4addr_ntoa_r+0x2a>
  }
  *--rp = 0;
 8013b32:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013b34:	3b01      	subs	r3, #1
 8013b36:	62fb      	str	r3, [r7, #44]	; 0x2c
 8013b38:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013b3a:	2200      	movs	r2, #0
 8013b3c:	701a      	strb	r2, [r3, #0]
  return buf;
 8013b3e:	68bb      	ldr	r3, [r7, #8]
}
 8013b40:	0018      	movs	r0, r3
 8013b42:	46bd      	mov	sp, r7
 8013b44:	b00c      	add	sp, #48	; 0x30
 8013b46:	bdb0      	pop	{r4, r5, r7, pc}

08013b48 <link_required>:
#endif

/*
 * An Open on LCP has requested a change from Dead to Establish phase.
 */
void link_required(ppp_pcb *pcb) {
 8013b48:	b580      	push	{r7, lr}
 8013b4a:	b082      	sub	sp, #8
 8013b4c:	af00      	add	r7, sp, #0
 8013b4e:	6078      	str	r0, [r7, #4]
    LWIP_UNUSED_ARG(pcb);
}
 8013b50:	46c0      	nop			; (mov r8, r8)
 8013b52:	46bd      	mov	sp, r7
 8013b54:	b002      	add	sp, #8
 8013b56:	bd80      	pop	{r7, pc}

08013b58 <link_terminated>:

/*
 * LCP has terminated the link; go to the Dead phase and take the
 * physical layer down.
 */
void link_terminated(ppp_pcb *pcb) {
 8013b58:	b580      	push	{r7, lr}
 8013b5a:	b082      	sub	sp, #8
 8013b5c:	af00      	add	r7, sp, #0
 8013b5e:	6078      	str	r0, [r7, #4]
    if (pcb->phase == PPP_PHASE_DEAD
 8013b60:	687b      	ldr	r3, [r7, #4]
 8013b62:	2224      	movs	r2, #36	; 0x24
 8013b64:	5c9b      	ldrb	r3, [r3, r2]
 8013b66:	2b00      	cmp	r3, #0
 8013b68:	d011      	beq.n	8013b8e <link_terminated+0x36>
#ifdef HAVE_MULTILINK
    || pcb->phase == PPP_PHASE_MASTER
#endif /* HAVE_MULTILINK */
    )
	return;
    new_phase(pcb, PPP_PHASE_DISCONNECT);
 8013b6a:	687b      	ldr	r3, [r7, #4]
 8013b6c:	210c      	movs	r1, #12
 8013b6e:	0018      	movs	r0, r3
 8013b70:	f006 f837 	bl	8019be2 <new_phase>
    }
    session_end(devnam);
#endif /* UNUSED */

    if (!doing_multilink) {
	ppp_notice("Connection terminated.");
 8013b74:	4b08      	ldr	r3, [pc, #32]	; (8013b98 <link_terminated+0x40>)
 8013b76:	0018      	movs	r0, r3
 8013b78:	f007 fb05 	bl	801b186 <ppp_notice>
	print_link_stats();
#endif /* PPP_STATS_SUPPORT */
    } else
	ppp_notice("Link terminated.");

    lcp_lowerdown(pcb);
 8013b7c:	687b      	ldr	r3, [r7, #4]
 8013b7e:	0018      	movs	r0, r3
 8013b80:	f003 fcfc 	bl	801757c <lcp_lowerdown>

    ppp_link_terminated(pcb);
 8013b84:	687b      	ldr	r3, [r7, #4]
 8013b86:	0018      	movs	r0, r3
 8013b88:	f006 f81b 	bl	8019bc2 <ppp_link_terminated>
 8013b8c:	e000      	b.n	8013b90 <link_terminated+0x38>
	return;
 8013b8e:	46c0      	nop			; (mov r8, r8)
	else
	    mp_bundle_terminated();
    } else
	new_phase(pcb, PPP_PHASE_DEAD);
#endif
}
 8013b90:	46bd      	mov	sp, r7
 8013b92:	b002      	add	sp, #8
 8013b94:	bd80      	pop	{r7, pc}
 8013b96:	46c0      	nop			; (mov r8, r8)
 8013b98:	08020da0 	.word	0x08020da0

08013b9c <link_down>:

/*
 * LCP has gone down; it will either die or try to re-establish.
 */
void link_down(ppp_pcb *pcb) {
 8013b9c:	b580      	push	{r7, lr}
 8013b9e:	b082      	sub	sp, #8
 8013ba0:	af00      	add	r7, sp, #0
 8013ba2:	6078      	str	r0, [r7, #4]
#if PPP_NOTIFY
    notify(link_down_notifier, 0);
#endif /* PPP_NOTIFY */

    if (!doing_multilink) {
	upper_layers_down(pcb);
 8013ba4:	687b      	ldr	r3, [r7, #4]
 8013ba6:	0018      	movs	r0, r3
 8013ba8:	f000 f80e 	bl	8013bc8 <upper_layers_down>
	if (pcb->phase != PPP_PHASE_DEAD
 8013bac:	687b      	ldr	r3, [r7, #4]
 8013bae:	2224      	movs	r2, #36	; 0x24
 8013bb0:	5c9b      	ldrb	r3, [r3, r2]
 8013bb2:	2b00      	cmp	r3, #0
 8013bb4:	d004      	beq.n	8013bc0 <link_down+0x24>
#ifdef HAVE_MULTILINK
	&& pcb->phase != PPP_PHASE_MASTER
#endif /* HAVE_MULTILINK */
	)
	    new_phase(pcb, PPP_PHASE_ESTABLISH);
 8013bb6:	687b      	ldr	r3, [r7, #4]
 8013bb8:	2106      	movs	r1, #6
 8013bba:	0018      	movs	r0, r3
 8013bbc:	f006 f811 	bl	8019be2 <new_phase>
    }
    /* XXX if doing_multilink, should do something to stop
       network-layer traffic on the link */
}
 8013bc0:	46c0      	nop			; (mov r8, r8)
 8013bc2:	46bd      	mov	sp, r7
 8013bc4:	b002      	add	sp, #8
 8013bc6:	bd80      	pop	{r7, pc}

08013bc8 <upper_layers_down>:

void upper_layers_down(ppp_pcb *pcb) {
 8013bc8:	b580      	push	{r7, lr}
 8013bca:	b084      	sub	sp, #16
 8013bcc:	af00      	add	r7, sp, #0
 8013bce:	6078      	str	r0, [r7, #4]
    int i;
    const struct protent *protp;

    for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 8013bd0:	2300      	movs	r3, #0
 8013bd2:	60fb      	str	r3, [r7, #12]
 8013bd4:	e01f      	b.n	8013c16 <upper_layers_down+0x4e>
        if (protp->protocol != PPP_LCP && protp->lowerdown != NULL)
 8013bd6:	68bb      	ldr	r3, [r7, #8]
 8013bd8:	881b      	ldrh	r3, [r3, #0]
 8013bda:	4a19      	ldr	r2, [pc, #100]	; (8013c40 <upper_layers_down+0x78>)
 8013bdc:	4293      	cmp	r3, r2
 8013bde:	d008      	beq.n	8013bf2 <upper_layers_down+0x2a>
 8013be0:	68bb      	ldr	r3, [r7, #8]
 8013be2:	695b      	ldr	r3, [r3, #20]
 8013be4:	2b00      	cmp	r3, #0
 8013be6:	d004      	beq.n	8013bf2 <upper_layers_down+0x2a>
	    (*protp->lowerdown)(pcb);
 8013be8:	68bb      	ldr	r3, [r7, #8]
 8013bea:	695b      	ldr	r3, [r3, #20]
 8013bec:	687a      	ldr	r2, [r7, #4]
 8013bee:	0010      	movs	r0, r2
 8013bf0:	4798      	blx	r3
        if (protp->protocol < 0xC000 && protp->close != NULL)
 8013bf2:	68bb      	ldr	r3, [r7, #8]
 8013bf4:	881b      	ldrh	r3, [r3, #0]
 8013bf6:	4a13      	ldr	r2, [pc, #76]	; (8013c44 <upper_layers_down+0x7c>)
 8013bf8:	4293      	cmp	r3, r2
 8013bfa:	d809      	bhi.n	8013c10 <upper_layers_down+0x48>
 8013bfc:	68bb      	ldr	r3, [r7, #8]
 8013bfe:	69db      	ldr	r3, [r3, #28]
 8013c00:	2b00      	cmp	r3, #0
 8013c02:	d005      	beq.n	8013c10 <upper_layers_down+0x48>
	    (*protp->close)(pcb, "LCP down");
 8013c04:	68bb      	ldr	r3, [r7, #8]
 8013c06:	69db      	ldr	r3, [r3, #28]
 8013c08:	490f      	ldr	r1, [pc, #60]	; (8013c48 <upper_layers_down+0x80>)
 8013c0a:	687a      	ldr	r2, [r7, #4]
 8013c0c:	0010      	movs	r0, r2
 8013c0e:	4798      	blx	r3
    for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 8013c10:	68fb      	ldr	r3, [r7, #12]
 8013c12:	3301      	adds	r3, #1
 8013c14:	60fb      	str	r3, [r7, #12]
 8013c16:	4b0d      	ldr	r3, [pc, #52]	; (8013c4c <upper_layers_down+0x84>)
 8013c18:	68fa      	ldr	r2, [r7, #12]
 8013c1a:	0092      	lsls	r2, r2, #2
 8013c1c:	58d3      	ldr	r3, [r2, r3]
 8013c1e:	60bb      	str	r3, [r7, #8]
 8013c20:	68bb      	ldr	r3, [r7, #8]
 8013c22:	2b00      	cmp	r3, #0
 8013c24:	d1d7      	bne.n	8013bd6 <upper_layers_down+0xe>
    }
    pcb->num_np_open = 0;
 8013c26:	687b      	ldr	r3, [r7, #4]
 8013c28:	22d8      	movs	r2, #216	; 0xd8
 8013c2a:	2100      	movs	r1, #0
 8013c2c:	5499      	strb	r1, [r3, r2]
    pcb->num_np_up = 0;
 8013c2e:	687b      	ldr	r3, [r7, #4]
 8013c30:	22d9      	movs	r2, #217	; 0xd9
 8013c32:	2100      	movs	r1, #0
 8013c34:	5499      	strb	r1, [r3, r2]
}
 8013c36:	46c0      	nop			; (mov r8, r8)
 8013c38:	46bd      	mov	sp, r7
 8013c3a:	b004      	add	sp, #16
 8013c3c:	bd80      	pop	{r7, pc}
 8013c3e:	46c0      	nop			; (mov r8, r8)
 8013c40:	0000c021 	.word	0x0000c021
 8013c44:	0000bfff 	.word	0x0000bfff
 8013c48:	08020db8 	.word	0x08020db8
 8013c4c:	08021cbc 	.word	0x08021cbc

08013c50 <link_established>:

/*
 * The link is established.
 * Proceed to the Dead, Authenticate or Network phase as appropriate.
 */
void link_established(ppp_pcb *pcb) {
 8013c50:	b580      	push	{r7, lr}
 8013c52:	b084      	sub	sp, #16
 8013c54:	af00      	add	r7, sp, #0
 8013c56:	6078      	str	r0, [r7, #4]

    /*
     * Tell higher-level protocols that LCP is up.
     */
    if (!doing_multilink) {
	for (i = 0; (protp = protocols[i]) != NULL; ++i)
 8013c58:	2300      	movs	r3, #0
 8013c5a:	60fb      	str	r3, [r7, #12]
 8013c5c:	e010      	b.n	8013c80 <link_established+0x30>
	    if (protp->protocol != PPP_LCP
 8013c5e:	68bb      	ldr	r3, [r7, #8]
 8013c60:	881b      	ldrh	r3, [r3, #0]
 8013c62:	4a0f      	ldr	r2, [pc, #60]	; (8013ca0 <link_established+0x50>)
 8013c64:	4293      	cmp	r3, r2
 8013c66:	d008      	beq.n	8013c7a <link_established+0x2a>
		&& protp->lowerup != NULL)
 8013c68:	68bb      	ldr	r3, [r7, #8]
 8013c6a:	691b      	ldr	r3, [r3, #16]
 8013c6c:	2b00      	cmp	r3, #0
 8013c6e:	d004      	beq.n	8013c7a <link_established+0x2a>
		(*protp->lowerup)(pcb);
 8013c70:	68bb      	ldr	r3, [r7, #8]
 8013c72:	691b      	ldr	r3, [r3, #16]
 8013c74:	687a      	ldr	r2, [r7, #4]
 8013c76:	0010      	movs	r0, r2
 8013c78:	4798      	blx	r3
	for (i = 0; (protp = protocols[i]) != NULL; ++i)
 8013c7a:	68fb      	ldr	r3, [r7, #12]
 8013c7c:	3301      	adds	r3, #1
 8013c7e:	60fb      	str	r3, [r7, #12]
 8013c80:	4b08      	ldr	r3, [pc, #32]	; (8013ca4 <link_established+0x54>)
 8013c82:	68fa      	ldr	r2, [r7, #12]
 8013c84:	0092      	lsls	r2, r2, #2
 8013c86:	58d3      	ldr	r3, [r2, r3]
 8013c88:	60bb      	str	r3, [r7, #8]
 8013c8a:	68bb      	ldr	r3, [r7, #8]
 8013c8c:	2b00      	cmp	r3, #0
 8013c8e:	d1e6      	bne.n	8013c5e <link_established+0xe>
    pcb->auth_pending = auth;
    pcb->auth_done = 0;

    if (!auth)
#endif /* PPP_AUTH_SUPPORT */
	network_phase(pcb);
 8013c90:	687b      	ldr	r3, [r7, #4]
 8013c92:	0018      	movs	r0, r3
 8013c94:	f000 f808 	bl	8013ca8 <network_phase>
}
 8013c98:	46c0      	nop			; (mov r8, r8)
 8013c9a:	46bd      	mov	sp, r7
 8013c9c:	b004      	add	sp, #16
 8013c9e:	bd80      	pop	{r7, pc}
 8013ca0:	0000c021 	.word	0x0000c021
 8013ca4:	08021cbc 	.word	0x08021cbc

08013ca8 <network_phase>:

/*
 * Proceed to the network phase.
 */
static void network_phase(ppp_pcb *pcb) {
 8013ca8:	b580      	push	{r7, lr}
 8013caa:	b082      	sub	sp, #8
 8013cac:	af00      	add	r7, sp, #0
 8013cae:	6078      	str	r0, [r7, #4]
	options_from_list(extra_options, 1);
	free_wordlist(extra_options);
	extra_options = 0;
    }
#endif /* PPP_OPTIONS */
    start_networks(pcb);
 8013cb0:	687b      	ldr	r3, [r7, #4]
 8013cb2:	0018      	movs	r0, r3
 8013cb4:	f000 f804 	bl	8013cc0 <start_networks>
}
 8013cb8:	46c0      	nop			; (mov r8, r8)
 8013cba:	46bd      	mov	sp, r7
 8013cbc:	b002      	add	sp, #8
 8013cbe:	bd80      	pop	{r7, pc}

08013cc0 <start_networks>:

void start_networks(ppp_pcb *pcb) {
 8013cc0:	b580      	push	{r7, lr}
 8013cc2:	b082      	sub	sp, #8
 8013cc4:	af00      	add	r7, sp, #0
 8013cc6:	6078      	str	r0, [r7, #4]
#if CCP_SUPPORT || ECP_SUPPORT
    int i;
    const struct protent *protp;
#endif /* CCP_SUPPORT || ECP_SUPPORT */

    new_phase(pcb, PPP_PHASE_NETWORK);
 8013cc8:	687b      	ldr	r3, [r7, #4]
 8013cca:	2109      	movs	r1, #9
 8013ccc:	0018      	movs	r0, r3
 8013cce:	f005 ff88 	bl	8019be2 <new_phase>
#endif /* ECP_SUPPORT */
#if MPPE_SUPPORT
        && !pcb->ccp_gotoptions.mppe
#endif /* MPPE_SUPPORT */
        )
	continue_networks(pcb);
 8013cd2:	687b      	ldr	r3, [r7, #4]
 8013cd4:	0018      	movs	r0, r3
 8013cd6:	f000 f805 	bl	8013ce4 <continue_networks>
}
 8013cda:	46c0      	nop			; (mov r8, r8)
 8013cdc:	46bd      	mov	sp, r7
 8013cde:	b002      	add	sp, #8
 8013ce0:	bd80      	pop	{r7, pc}
	...

08013ce4 <continue_networks>:

void continue_networks(ppp_pcb *pcb) {
 8013ce4:	b580      	push	{r7, lr}
 8013ce6:	b084      	sub	sp, #16
 8013ce8:	af00      	add	r7, sp, #0
 8013cea:	6078      	str	r0, [r7, #4]
    const struct protent *protp;

    /*
     * Start the "real" network protocols.
     */
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
 8013cec:	2300      	movs	r3, #0
 8013cee:	60fb      	str	r3, [r7, #12]
 8013cf0:	e018      	b.n	8013d24 <continue_networks+0x40>
	if (protp->protocol < 0xC000
 8013cf2:	68bb      	ldr	r3, [r7, #8]
 8013cf4:	881b      	ldrh	r3, [r3, #0]
 8013cf6:	4a17      	ldr	r2, [pc, #92]	; (8013d54 <continue_networks+0x70>)
 8013cf8:	4293      	cmp	r3, r2
 8013cfa:	d810      	bhi.n	8013d1e <continue_networks+0x3a>
	    && protp->protocol != PPP_CCP
#endif /* CCP_SUPPORT */
#if ECP_SUPPORT
	    && protp->protocol != PPP_ECP
#endif /* ECP_SUPPORT */
	    && protp->open != NULL) {
 8013cfc:	68bb      	ldr	r3, [r7, #8]
 8013cfe:	699b      	ldr	r3, [r3, #24]
 8013d00:	2b00      	cmp	r3, #0
 8013d02:	d00c      	beq.n	8013d1e <continue_networks+0x3a>
	    (*protp->open)(pcb);
 8013d04:	68bb      	ldr	r3, [r7, #8]
 8013d06:	699b      	ldr	r3, [r3, #24]
 8013d08:	687a      	ldr	r2, [r7, #4]
 8013d0a:	0010      	movs	r0, r2
 8013d0c:	4798      	blx	r3
	    ++pcb->num_np_open;
 8013d0e:	687b      	ldr	r3, [r7, #4]
 8013d10:	22d8      	movs	r2, #216	; 0xd8
 8013d12:	5c9b      	ldrb	r3, [r3, r2]
 8013d14:	3301      	adds	r3, #1
 8013d16:	b2d9      	uxtb	r1, r3
 8013d18:	687b      	ldr	r3, [r7, #4]
 8013d1a:	22d8      	movs	r2, #216	; 0xd8
 8013d1c:	5499      	strb	r1, [r3, r2]
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
 8013d1e:	68fb      	ldr	r3, [r7, #12]
 8013d20:	3301      	adds	r3, #1
 8013d22:	60fb      	str	r3, [r7, #12]
 8013d24:	4b0c      	ldr	r3, [pc, #48]	; (8013d58 <continue_networks+0x74>)
 8013d26:	68fa      	ldr	r2, [r7, #12]
 8013d28:	0092      	lsls	r2, r2, #2
 8013d2a:	58d3      	ldr	r3, [r2, r3]
 8013d2c:	60bb      	str	r3, [r7, #8]
 8013d2e:	68bb      	ldr	r3, [r7, #8]
 8013d30:	2b00      	cmp	r3, #0
 8013d32:	d1de      	bne.n	8013cf2 <continue_networks+0xe>
	}

    if (pcb->num_np_open == 0)
 8013d34:	687b      	ldr	r3, [r7, #4]
 8013d36:	22d8      	movs	r2, #216	; 0xd8
 8013d38:	5c9b      	ldrb	r3, [r3, r2]
 8013d3a:	2b00      	cmp	r3, #0
 8013d3c:	d105      	bne.n	8013d4a <continue_networks+0x66>
	/* nothing to do */
	lcp_close(pcb, "No network protocols running");
 8013d3e:	4a07      	ldr	r2, [pc, #28]	; (8013d5c <continue_networks+0x78>)
 8013d40:	687b      	ldr	r3, [r7, #4]
 8013d42:	0011      	movs	r1, r2
 8013d44:	0018      	movs	r0, r3
 8013d46:	f003 fb75 	bl	8017434 <lcp_close>
}
 8013d4a:	46c0      	nop			; (mov r8, r8)
 8013d4c:	46bd      	mov	sp, r7
 8013d4e:	b004      	add	sp, #16
 8013d50:	bd80      	pop	{r7, pc}
 8013d52:	46c0      	nop			; (mov r8, r8)
 8013d54:	0000bfff 	.word	0x0000bfff
 8013d58:	08021cbc 	.word	0x08021cbc
 8013d5c:	08020dc4 	.word	0x08020dc4

08013d60 <np_up>:


/*
 * np_up - a network protocol has come up.
 */
void np_up(ppp_pcb *pcb, int proto) {
 8013d60:	b580      	push	{r7, lr}
 8013d62:	b082      	sub	sp, #8
 8013d64:	af00      	add	r7, sp, #0
 8013d66:	6078      	str	r0, [r7, #4]
 8013d68:	6039      	str	r1, [r7, #0]
#if PPP_IDLETIMELIMIT
    int tlim;
#endif /* PPP_IDLETIMELIMIT */
    LWIP_UNUSED_ARG(proto);

    if (pcb->num_np_up == 0) {
 8013d6a:	687b      	ldr	r3, [r7, #4]
 8013d6c:	22d9      	movs	r2, #217	; 0xd9
 8013d6e:	5c9b      	ldrb	r3, [r3, r2]
 8013d70:	2b00      	cmp	r3, #0
 8013d72:	d104      	bne.n	8013d7e <np_up+0x1e>
	/*
	 * At this point we consider that the link has come up successfully.
	 */
	new_phase(pcb, PPP_PHASE_RUNNING);
 8013d74:	687b      	ldr	r3, [r7, #4]
 8013d76:	210a      	movs	r1, #10
 8013d78:	0018      	movs	r0, r3
 8013d7a:	f005 ff32 	bl	8019be2 <new_phase>
	 */
	if (updetach && !nodetach)
	    detach();
#endif /* Unused */
    }
    ++pcb->num_np_up;
 8013d7e:	687b      	ldr	r3, [r7, #4]
 8013d80:	22d9      	movs	r2, #217	; 0xd9
 8013d82:	5c9b      	ldrb	r3, [r3, r2]
 8013d84:	3301      	adds	r3, #1
 8013d86:	b2d9      	uxtb	r1, r3
 8013d88:	687b      	ldr	r3, [r7, #4]
 8013d8a:	22d9      	movs	r2, #217	; 0xd9
 8013d8c:	5499      	strb	r1, [r3, r2]
}
 8013d8e:	46c0      	nop			; (mov r8, r8)
 8013d90:	46bd      	mov	sp, r7
 8013d92:	b002      	add	sp, #8
 8013d94:	bd80      	pop	{r7, pc}

08013d96 <np_down>:

/*
 * np_down - a network protocol has gone down.
 */
void np_down(ppp_pcb *pcb, int proto) {
 8013d96:	b580      	push	{r7, lr}
 8013d98:	b082      	sub	sp, #8
 8013d9a:	af00      	add	r7, sp, #0
 8013d9c:	6078      	str	r0, [r7, #4]
 8013d9e:	6039      	str	r1, [r7, #0]
    LWIP_UNUSED_ARG(proto);
    if (--pcb->num_np_up == 0) {
 8013da0:	687b      	ldr	r3, [r7, #4]
 8013da2:	22d9      	movs	r2, #217	; 0xd9
 8013da4:	5c9b      	ldrb	r3, [r3, r2]
 8013da6:	3b01      	subs	r3, #1
 8013da8:	b2d9      	uxtb	r1, r3
 8013daa:	687b      	ldr	r3, [r7, #4]
 8013dac:	22d9      	movs	r2, #217	; 0xd9
 8013dae:	5499      	strb	r1, [r3, r2]
 8013db0:	687b      	ldr	r3, [r7, #4]
 8013db2:	22d9      	movs	r2, #217	; 0xd9
 8013db4:	5c9b      	ldrb	r3, [r3, r2]
 8013db6:	2b00      	cmp	r3, #0
 8013db8:	d104      	bne.n	8013dc4 <np_down+0x2e>
	UNTIMEOUT(connect_time_expired, NULL);
#endif /* PPP_MAXCONNECT */
#ifdef MAXOCTETS
	UNTIMEOUT(check_maxoctets, NULL);
#endif
	new_phase(pcb, PPP_PHASE_NETWORK);
 8013dba:	687b      	ldr	r3, [r7, #4]
 8013dbc:	2109      	movs	r1, #9
 8013dbe:	0018      	movs	r0, r3
 8013dc0:	f005 ff0f 	bl	8019be2 <new_phase>
    }
}
 8013dc4:	46c0      	nop			; (mov r8, r8)
 8013dc6:	46bd      	mov	sp, r7
 8013dc8:	b002      	add	sp, #8
 8013dca:	bd80      	pop	{r7, pc}

08013dcc <np_finished>:

/*
 * np_finished - a network protocol has finished using the link.
 */
void np_finished(ppp_pcb *pcb, int proto) {
 8013dcc:	b580      	push	{r7, lr}
 8013dce:	b082      	sub	sp, #8
 8013dd0:	af00      	add	r7, sp, #0
 8013dd2:	6078      	str	r0, [r7, #4]
 8013dd4:	6039      	str	r1, [r7, #0]
    LWIP_UNUSED_ARG(proto);
    if (--pcb->num_np_open <= 0) {
 8013dd6:	687b      	ldr	r3, [r7, #4]
 8013dd8:	22d8      	movs	r2, #216	; 0xd8
 8013dda:	5c9b      	ldrb	r3, [r3, r2]
 8013ddc:	3b01      	subs	r3, #1
 8013dde:	b2d9      	uxtb	r1, r3
 8013de0:	687b      	ldr	r3, [r7, #4]
 8013de2:	22d8      	movs	r2, #216	; 0xd8
 8013de4:	5499      	strb	r1, [r3, r2]
 8013de6:	687b      	ldr	r3, [r7, #4]
 8013de8:	22d8      	movs	r2, #216	; 0xd8
 8013dea:	5c9b      	ldrb	r3, [r3, r2]
 8013dec:	2b00      	cmp	r3, #0
 8013dee:	d105      	bne.n	8013dfc <np_finished+0x30>
	/* no further use for the link: shut up shop. */
	lcp_close(pcb, "No network protocols running");
 8013df0:	4a04      	ldr	r2, [pc, #16]	; (8013e04 <np_finished+0x38>)
 8013df2:	687b      	ldr	r3, [r7, #4]
 8013df4:	0011      	movs	r1, r2
 8013df6:	0018      	movs	r0, r3
 8013df8:	f003 fb1c 	bl	8017434 <lcp_close>
    }
}
 8013dfc:	46c0      	nop			; (mov r8, r8)
 8013dfe:	46bd      	mov	sp, r7
 8013e00:	b002      	add	sp, #8
 8013e02:	bd80      	pop	{r7, pc}
 8013e04:	08020dc4 	.word	0x08020dc4

08013e08 <fsm_init>:
/*
 * fsm_init - Initialize fsm.
 *
 * Initialize fsm state.
 */
void fsm_init(fsm *f) {
 8013e08:	b580      	push	{r7, lr}
 8013e0a:	b084      	sub	sp, #16
 8013e0c:	af00      	add	r7, sp, #0
 8013e0e:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8013e10:	687b      	ldr	r3, [r7, #4]
 8013e12:	681b      	ldr	r3, [r3, #0]
 8013e14:	60fb      	str	r3, [r7, #12]
    f->state = PPP_FSM_INITIAL;
 8013e16:	687b      	ldr	r3, [r7, #4]
 8013e18:	2200      	movs	r2, #0
 8013e1a:	741a      	strb	r2, [r3, #16]
    f->flags = 0;
 8013e1c:	687b      	ldr	r3, [r7, #4]
 8013e1e:	2200      	movs	r2, #0
 8013e20:	745a      	strb	r2, [r3, #17]
    f->id = 0;				/* XXX Start with random id? */
 8013e22:	687b      	ldr	r3, [r7, #4]
 8013e24:	2200      	movs	r2, #0
 8013e26:	749a      	strb	r2, [r3, #18]
    f->maxnakloops = pcb->settings.fsm_max_nak_loops;
 8013e28:	68fb      	ldr	r3, [r7, #12]
 8013e2a:	79da      	ldrb	r2, [r3, #7]
 8013e2c:	687b      	ldr	r3, [r7, #4]
 8013e2e:	75da      	strb	r2, [r3, #23]
    f->term_reason_len = 0;
 8013e30:	687b      	ldr	r3, [r7, #4]
 8013e32:	2200      	movs	r2, #0
 8013e34:	761a      	strb	r2, [r3, #24]
}
 8013e36:	46c0      	nop			; (mov r8, r8)
 8013e38:	46bd      	mov	sp, r7
 8013e3a:	b004      	add	sp, #16
 8013e3c:	bd80      	pop	{r7, pc}

08013e3e <fsm_lowerup>:


/*
 * fsm_lowerup - The lower layer is up.
 */
void fsm_lowerup(fsm *f) {
 8013e3e:	b580      	push	{r7, lr}
 8013e40:	b082      	sub	sp, #8
 8013e42:	af00      	add	r7, sp, #0
 8013e44:	6078      	str	r0, [r7, #4]
    switch( f->state ){
 8013e46:	687b      	ldr	r3, [r7, #4]
 8013e48:	7c1b      	ldrb	r3, [r3, #16]
 8013e4a:	2b00      	cmp	r3, #0
 8013e4c:	d002      	beq.n	8013e54 <fsm_lowerup+0x16>
 8013e4e:	2b01      	cmp	r3, #1
 8013e50:	d004      	beq.n	8013e5c <fsm_lowerup+0x1e>

    default:
	FSMDEBUG(("%s: Up event in state %d!", PROTO_NAME(f), f->state));
	/* no break */
    }
}
 8013e52:	e016      	b.n	8013e82 <fsm_lowerup+0x44>
	f->state = PPP_FSM_CLOSED;
 8013e54:	687b      	ldr	r3, [r7, #4]
 8013e56:	2202      	movs	r2, #2
 8013e58:	741a      	strb	r2, [r3, #16]
	break;
 8013e5a:	e012      	b.n	8013e82 <fsm_lowerup+0x44>
	if( f->flags & OPT_SILENT )
 8013e5c:	687b      	ldr	r3, [r7, #4]
 8013e5e:	7c5b      	ldrb	r3, [r3, #17]
 8013e60:	001a      	movs	r2, r3
 8013e62:	2304      	movs	r3, #4
 8013e64:	4013      	ands	r3, r2
 8013e66:	d003      	beq.n	8013e70 <fsm_lowerup+0x32>
	    f->state = PPP_FSM_STOPPED;
 8013e68:	687b      	ldr	r3, [r7, #4]
 8013e6a:	2203      	movs	r2, #3
 8013e6c:	741a      	strb	r2, [r3, #16]
	break;
 8013e6e:	e007      	b.n	8013e80 <fsm_lowerup+0x42>
	    fsm_sconfreq(f, 0);
 8013e70:	687b      	ldr	r3, [r7, #4]
 8013e72:	2100      	movs	r1, #0
 8013e74:	0018      	movs	r0, r3
 8013e76:	f000 fded 	bl	8014a54 <fsm_sconfreq>
	    f->state = PPP_FSM_REQSENT;
 8013e7a:	687b      	ldr	r3, [r7, #4]
 8013e7c:	2206      	movs	r2, #6
 8013e7e:	741a      	strb	r2, [r3, #16]
	break;
 8013e80:	46c0      	nop			; (mov r8, r8)
}
 8013e82:	46c0      	nop			; (mov r8, r8)
 8013e84:	46bd      	mov	sp, r7
 8013e86:	b002      	add	sp, #8
 8013e88:	bd80      	pop	{r7, pc}
	...

08013e8c <fsm_lowerdown>:
/*
 * fsm_lowerdown - The lower layer is down.
 *
 * Cancel all timeouts and inform upper layers.
 */
void fsm_lowerdown(fsm *f) {
 8013e8c:	b580      	push	{r7, lr}
 8013e8e:	b082      	sub	sp, #8
 8013e90:	af00      	add	r7, sp, #0
 8013e92:	6078      	str	r0, [r7, #4]
    switch( f->state ){
 8013e94:	687b      	ldr	r3, [r7, #4]
 8013e96:	7c1b      	ldrb	r3, [r3, #16]
 8013e98:	2b09      	cmp	r3, #9
 8013e9a:	d83b      	bhi.n	8013f14 <fsm_lowerdown+0x88>
 8013e9c:	009a      	lsls	r2, r3, #2
 8013e9e:	4b1f      	ldr	r3, [pc, #124]	; (8013f1c <fsm_lowerdown+0x90>)
 8013ea0:	18d3      	adds	r3, r2, r3
 8013ea2:	681b      	ldr	r3, [r3, #0]
 8013ea4:	469f      	mov	pc, r3
    case PPP_FSM_CLOSED:
	f->state = PPP_FSM_INITIAL;
 8013ea6:	687b      	ldr	r3, [r7, #4]
 8013ea8:	2200      	movs	r2, #0
 8013eaa:	741a      	strb	r2, [r3, #16]
	break;
 8013eac:	e032      	b.n	8013f14 <fsm_lowerdown+0x88>

    case PPP_FSM_STOPPED:
	f->state = PPP_FSM_STARTING;
 8013eae:	687b      	ldr	r3, [r7, #4]
 8013eb0:	2201      	movs	r2, #1
 8013eb2:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->starting )
 8013eb4:	687b      	ldr	r3, [r7, #4]
 8013eb6:	685b      	ldr	r3, [r3, #4]
 8013eb8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013eba:	2b00      	cmp	r3, #0
 8013ebc:	d029      	beq.n	8013f12 <fsm_lowerdown+0x86>
	    (*f->callbacks->starting)(f);
 8013ebe:	687b      	ldr	r3, [r7, #4]
 8013ec0:	685b      	ldr	r3, [r3, #4]
 8013ec2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013ec4:	687a      	ldr	r2, [r7, #4]
 8013ec6:	0010      	movs	r0, r2
 8013ec8:	4798      	blx	r3
	break;
 8013eca:	e022      	b.n	8013f12 <fsm_lowerdown+0x86>

    case PPP_FSM_CLOSING:
	f->state = PPP_FSM_INITIAL;
 8013ecc:	687b      	ldr	r3, [r7, #4]
 8013ece:	2200      	movs	r2, #0
 8013ed0:	741a      	strb	r2, [r3, #16]
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8013ed2:	687a      	ldr	r2, [r7, #4]
 8013ed4:	4b12      	ldr	r3, [pc, #72]	; (8013f20 <fsm_lowerdown+0x94>)
 8013ed6:	0011      	movs	r1, r2
 8013ed8:	0018      	movs	r0, r3
 8013eda:	f7fd fee5 	bl	8011ca8 <sys_untimeout>
	break;
 8013ede:	e019      	b.n	8013f14 <fsm_lowerdown+0x88>

    case PPP_FSM_STOPPING:
    case PPP_FSM_REQSENT:
    case PPP_FSM_ACKRCVD:
    case PPP_FSM_ACKSENT:
	f->state = PPP_FSM_STARTING;
 8013ee0:	687b      	ldr	r3, [r7, #4]
 8013ee2:	2201      	movs	r2, #1
 8013ee4:	741a      	strb	r2, [r3, #16]
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8013ee6:	687a      	ldr	r2, [r7, #4]
 8013ee8:	4b0d      	ldr	r3, [pc, #52]	; (8013f20 <fsm_lowerdown+0x94>)
 8013eea:	0011      	movs	r1, r2
 8013eec:	0018      	movs	r0, r3
 8013eee:	f7fd fedb 	bl	8011ca8 <sys_untimeout>
	break;
 8013ef2:	e00f      	b.n	8013f14 <fsm_lowerdown+0x88>

    case PPP_FSM_OPENED:
	if( f->callbacks->down )
 8013ef4:	687b      	ldr	r3, [r7, #4]
 8013ef6:	685b      	ldr	r3, [r3, #4]
 8013ef8:	6a1b      	ldr	r3, [r3, #32]
 8013efa:	2b00      	cmp	r3, #0
 8013efc:	d005      	beq.n	8013f0a <fsm_lowerdown+0x7e>
	    (*f->callbacks->down)(f);
 8013efe:	687b      	ldr	r3, [r7, #4]
 8013f00:	685b      	ldr	r3, [r3, #4]
 8013f02:	6a1b      	ldr	r3, [r3, #32]
 8013f04:	687a      	ldr	r2, [r7, #4]
 8013f06:	0010      	movs	r0, r2
 8013f08:	4798      	blx	r3
	f->state = PPP_FSM_STARTING;
 8013f0a:	687b      	ldr	r3, [r7, #4]
 8013f0c:	2201      	movs	r2, #1
 8013f0e:	741a      	strb	r2, [r3, #16]
	break;
 8013f10:	e000      	b.n	8013f14 <fsm_lowerdown+0x88>
	break;
 8013f12:	46c0      	nop			; (mov r8, r8)

    default:
	FSMDEBUG(("%s: Down event in state %d!", PROTO_NAME(f), f->state));
	/* no break */
    }
}
 8013f14:	46c0      	nop			; (mov r8, r8)
 8013f16:	46bd      	mov	sp, r7
 8013f18:	b002      	add	sp, #8
 8013f1a:	bd80      	pop	{r7, pc}
 8013f1c:	08021a6c 	.word	0x08021a6c
 8013f20:	08014131 	.word	0x08014131

08013f24 <fsm_open>:


/*
 * fsm_open - Link is allowed to come up.
 */
void fsm_open(fsm *f) {
 8013f24:	b580      	push	{r7, lr}
 8013f26:	b082      	sub	sp, #8
 8013f28:	af00      	add	r7, sp, #0
 8013f2a:	6078      	str	r0, [r7, #4]
    switch( f->state ){
 8013f2c:	687b      	ldr	r3, [r7, #4]
 8013f2e:	7c1b      	ldrb	r3, [r3, #16]
 8013f30:	2b09      	cmp	r3, #9
 8013f32:	d838      	bhi.n	8013fa6 <fsm_open+0x82>
 8013f34:	009a      	lsls	r2, r3, #2
 8013f36:	4b20      	ldr	r3, [pc, #128]	; (8013fb8 <fsm_open+0x94>)
 8013f38:	18d3      	adds	r3, r2, r3
 8013f3a:	681b      	ldr	r3, [r3, #0]
 8013f3c:	469f      	mov	pc, r3
    case PPP_FSM_INITIAL:
	f->state = PPP_FSM_STARTING;
 8013f3e:	687b      	ldr	r3, [r7, #4]
 8013f40:	2201      	movs	r2, #1
 8013f42:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->starting )
 8013f44:	687b      	ldr	r3, [r7, #4]
 8013f46:	685b      	ldr	r3, [r3, #4]
 8013f48:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013f4a:	2b00      	cmp	r3, #0
 8013f4c:	d02d      	beq.n	8013faa <fsm_open+0x86>
	    (*f->callbacks->starting)(f);
 8013f4e:	687b      	ldr	r3, [r7, #4]
 8013f50:	685b      	ldr	r3, [r3, #4]
 8013f52:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013f54:	687a      	ldr	r2, [r7, #4]
 8013f56:	0010      	movs	r0, r2
 8013f58:	4798      	blx	r3
	break;
 8013f5a:	e026      	b.n	8013faa <fsm_open+0x86>

    case PPP_FSM_CLOSED:
	if( f->flags & OPT_SILENT )
 8013f5c:	687b      	ldr	r3, [r7, #4]
 8013f5e:	7c5b      	ldrb	r3, [r3, #17]
 8013f60:	001a      	movs	r2, r3
 8013f62:	2304      	movs	r3, #4
 8013f64:	4013      	ands	r3, r2
 8013f66:	d003      	beq.n	8013f70 <fsm_open+0x4c>
	    f->state = PPP_FSM_STOPPED;
 8013f68:	687b      	ldr	r3, [r7, #4]
 8013f6a:	2203      	movs	r2, #3
 8013f6c:	741a      	strb	r2, [r3, #16]
	else {
	    /* Send an initial configure-request */
	    fsm_sconfreq(f, 0);
	    f->state = PPP_FSM_REQSENT;
	}
	break;
 8013f6e:	e01f      	b.n	8013fb0 <fsm_open+0x8c>
	    fsm_sconfreq(f, 0);
 8013f70:	687b      	ldr	r3, [r7, #4]
 8013f72:	2100      	movs	r1, #0
 8013f74:	0018      	movs	r0, r3
 8013f76:	f000 fd6d 	bl	8014a54 <fsm_sconfreq>
	    f->state = PPP_FSM_REQSENT;
 8013f7a:	687b      	ldr	r3, [r7, #4]
 8013f7c:	2206      	movs	r2, #6
 8013f7e:	741a      	strb	r2, [r3, #16]
	break;
 8013f80:	e016      	b.n	8013fb0 <fsm_open+0x8c>

    case PPP_FSM_CLOSING:
	f->state = PPP_FSM_STOPPING;
 8013f82:	687b      	ldr	r3, [r7, #4]
 8013f84:	2205      	movs	r2, #5
 8013f86:	741a      	strb	r2, [r3, #16]
	/* fall through */
	/* no break */
    case PPP_FSM_STOPPED:
    case PPP_FSM_OPENED:
	if( f->flags & OPT_RESTART ){
 8013f88:	687b      	ldr	r3, [r7, #4]
 8013f8a:	7c5b      	ldrb	r3, [r3, #17]
 8013f8c:	001a      	movs	r2, r3
 8013f8e:	2302      	movs	r3, #2
 8013f90:	4013      	ands	r3, r2
 8013f92:	d00c      	beq.n	8013fae <fsm_open+0x8a>
	    fsm_lowerdown(f);
 8013f94:	687b      	ldr	r3, [r7, #4]
 8013f96:	0018      	movs	r0, r3
 8013f98:	f7ff ff78 	bl	8013e8c <fsm_lowerdown>
	    fsm_lowerup(f);
 8013f9c:	687b      	ldr	r3, [r7, #4]
 8013f9e:	0018      	movs	r0, r3
 8013fa0:	f7ff ff4d 	bl	8013e3e <fsm_lowerup>
	}
	break;
 8013fa4:	e003      	b.n	8013fae <fsm_open+0x8a>
    default:
	break;
 8013fa6:	46c0      	nop			; (mov r8, r8)
 8013fa8:	e002      	b.n	8013fb0 <fsm_open+0x8c>
	break;
 8013faa:	46c0      	nop			; (mov r8, r8)
 8013fac:	e000      	b.n	8013fb0 <fsm_open+0x8c>
	break;
 8013fae:	46c0      	nop			; (mov r8, r8)
    }
}
 8013fb0:	46c0      	nop			; (mov r8, r8)
 8013fb2:	46bd      	mov	sp, r7
 8013fb4:	b002      	add	sp, #8
 8013fb6:	bd80      	pop	{r7, pc}
 8013fb8:	08021a94 	.word	0x08021a94

08013fbc <terminate_layer>:
 * terminate_layer - Start process of shutting down the FSM
 *
 * Cancel any timeout running, notify upper layers we're done, and
 * send a terminate-request message as configured.
 */
static void terminate_layer(fsm *f, int nextstate) {
 8013fbc:	b580      	push	{r7, lr}
 8013fbe:	b086      	sub	sp, #24
 8013fc0:	af02      	add	r7, sp, #8
 8013fc2:	6078      	str	r0, [r7, #4]
 8013fc4:	6039      	str	r1, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 8013fc6:	687b      	ldr	r3, [r7, #4]
 8013fc8:	681b      	ldr	r3, [r3, #0]
 8013fca:	60fb      	str	r3, [r7, #12]

    if( f->state != PPP_FSM_OPENED )
 8013fcc:	687b      	ldr	r3, [r7, #4]
 8013fce:	7c1b      	ldrb	r3, [r3, #16]
 8013fd0:	2b09      	cmp	r3, #9
 8013fd2:	d006      	beq.n	8013fe2 <terminate_layer+0x26>
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8013fd4:	687a      	ldr	r2, [r7, #4]
 8013fd6:	4b33      	ldr	r3, [pc, #204]	; (80140a4 <terminate_layer+0xe8>)
 8013fd8:	0011      	movs	r1, r2
 8013fda:	0018      	movs	r0, r3
 8013fdc:	f7fd fe64 	bl	8011ca8 <sys_untimeout>
 8013fe0:	e00a      	b.n	8013ff8 <terminate_layer+0x3c>
    else if( f->callbacks->down )
 8013fe2:	687b      	ldr	r3, [r7, #4]
 8013fe4:	685b      	ldr	r3, [r3, #4]
 8013fe6:	6a1b      	ldr	r3, [r3, #32]
 8013fe8:	2b00      	cmp	r3, #0
 8013fea:	d005      	beq.n	8013ff8 <terminate_layer+0x3c>
	(*f->callbacks->down)(f);	/* Inform upper layers we're down */
 8013fec:	687b      	ldr	r3, [r7, #4]
 8013fee:	685b      	ldr	r3, [r3, #4]
 8013ff0:	6a1b      	ldr	r3, [r3, #32]
 8013ff2:	687a      	ldr	r2, [r7, #4]
 8013ff4:	0010      	movs	r0, r2
 8013ff6:	4798      	blx	r3

    /* Init restart counter and send Terminate-Request */
    f->retransmits = pcb->settings.fsm_max_term_transmits;
 8013ff8:	68fb      	ldr	r3, [r7, #12]
 8013ffa:	799a      	ldrb	r2, [r3, #6]
 8013ffc:	687b      	ldr	r3, [r7, #4]
 8013ffe:	751a      	strb	r2, [r3, #20]
    fsm_sdata(f, TERMREQ, f->reqid = ++f->id,
 8014000:	687b      	ldr	r3, [r7, #4]
 8014002:	7c9b      	ldrb	r3, [r3, #18]
 8014004:	3301      	adds	r3, #1
 8014006:	b2da      	uxtb	r2, r3
 8014008:	687b      	ldr	r3, [r7, #4]
 801400a:	749a      	strb	r2, [r3, #18]
 801400c:	687b      	ldr	r3, [r7, #4]
 801400e:	7c9a      	ldrb	r2, [r3, #18]
 8014010:	687b      	ldr	r3, [r7, #4]
 8014012:	74da      	strb	r2, [r3, #19]
 8014014:	687b      	ldr	r3, [r7, #4]
 8014016:	7cda      	ldrb	r2, [r3, #19]
	      (const u_char *) f->term_reason, f->term_reason_len);
 8014018:	687b      	ldr	r3, [r7, #4]
 801401a:	6899      	ldr	r1, [r3, #8]
 801401c:	687b      	ldr	r3, [r7, #4]
 801401e:	7e1b      	ldrb	r3, [r3, #24]
    fsm_sdata(f, TERMREQ, f->reqid = ++f->id,
 8014020:	6878      	ldr	r0, [r7, #4]
 8014022:	9300      	str	r3, [sp, #0]
 8014024:	000b      	movs	r3, r1
 8014026:	2105      	movs	r1, #5
 8014028:	f000 fe0a 	bl	8014c40 <fsm_sdata>

    if (f->retransmits == 0) {
 801402c:	687b      	ldr	r3, [r7, #4]
 801402e:	7d1b      	ldrb	r3, [r3, #20]
 8014030:	2b00      	cmp	r3, #0
 8014032:	d113      	bne.n	801405c <terminate_layer+0xa0>
	/*
	 * User asked for no terminate requests at all; just close it.
	 * We've already fired off one Terminate-Request just to be nice
	 * to the peer, but we're not going to wait for a reply.
	 */
	f->state = nextstate == PPP_FSM_CLOSING ? PPP_FSM_CLOSED : PPP_FSM_STOPPED;
 8014034:	683b      	ldr	r3, [r7, #0]
 8014036:	2b04      	cmp	r3, #4
 8014038:	d101      	bne.n	801403e <terminate_layer+0x82>
 801403a:	2202      	movs	r2, #2
 801403c:	e000      	b.n	8014040 <terminate_layer+0x84>
 801403e:	2203      	movs	r2, #3
 8014040:	687b      	ldr	r3, [r7, #4]
 8014042:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->finished )
 8014044:	687b      	ldr	r3, [r7, #4]
 8014046:	685b      	ldr	r3, [r3, #4]
 8014048:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801404a:	2b00      	cmp	r3, #0
 801404c:	d026      	beq.n	801409c <terminate_layer+0xe0>
	    (*f->callbacks->finished)(f);
 801404e:	687b      	ldr	r3, [r7, #4]
 8014050:	685b      	ldr	r3, [r3, #4]
 8014052:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014054:	687a      	ldr	r2, [r7, #4]
 8014056:	0010      	movs	r0, r2
 8014058:	4798      	blx	r3
	return;
 801405a:	e01f      	b.n	801409c <terminate_layer+0xe0>
    }

    TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
 801405c:	687a      	ldr	r2, [r7, #4]
 801405e:	4b11      	ldr	r3, [pc, #68]	; (80140a4 <terminate_layer+0xe8>)
 8014060:	0011      	movs	r1, r2
 8014062:	0018      	movs	r0, r3
 8014064:	f7fd fe20 	bl	8011ca8 <sys_untimeout>
 8014068:	68fb      	ldr	r3, [r7, #12]
 801406a:	791b      	ldrb	r3, [r3, #4]
 801406c:	001a      	movs	r2, r3
 801406e:	0013      	movs	r3, r2
 8014070:	015b      	lsls	r3, r3, #5
 8014072:	1a9b      	subs	r3, r3, r2
 8014074:	009b      	lsls	r3, r3, #2
 8014076:	189b      	adds	r3, r3, r2
 8014078:	00db      	lsls	r3, r3, #3
 801407a:	0018      	movs	r0, r3
 801407c:	687a      	ldr	r2, [r7, #4]
 801407e:	4b09      	ldr	r3, [pc, #36]	; (80140a4 <terminate_layer+0xe8>)
 8014080:	0019      	movs	r1, r3
 8014082:	f7fd fde9 	bl	8011c58 <sys_timeout>
    --f->retransmits;
 8014086:	687b      	ldr	r3, [r7, #4]
 8014088:	7d1b      	ldrb	r3, [r3, #20]
 801408a:	3b01      	subs	r3, #1
 801408c:	b2da      	uxtb	r2, r3
 801408e:	687b      	ldr	r3, [r7, #4]
 8014090:	751a      	strb	r2, [r3, #20]

    f->state = nextstate;
 8014092:	683b      	ldr	r3, [r7, #0]
 8014094:	b2da      	uxtb	r2, r3
 8014096:	687b      	ldr	r3, [r7, #4]
 8014098:	741a      	strb	r2, [r3, #16]
 801409a:	e000      	b.n	801409e <terminate_layer+0xe2>
	return;
 801409c:	46c0      	nop			; (mov r8, r8)
}
 801409e:	46bd      	mov	sp, r7
 80140a0:	b004      	add	sp, #16
 80140a2:	bd80      	pop	{r7, pc}
 80140a4:	08014131 	.word	0x08014131

080140a8 <fsm_close>:
 * fsm_close - Start closing connection.
 *
 * Cancel timeouts and either initiate close or possibly go directly to
 * the PPP_FSM_CLOSED state.
 */
void fsm_close(fsm *f, const char *reason) {
 80140a8:	b580      	push	{r7, lr}
 80140aa:	b082      	sub	sp, #8
 80140ac:	af00      	add	r7, sp, #0
 80140ae:	6078      	str	r0, [r7, #4]
 80140b0:	6039      	str	r1, [r7, #0]
    f->term_reason = reason;
 80140b2:	687b      	ldr	r3, [r7, #4]
 80140b4:	683a      	ldr	r2, [r7, #0]
 80140b6:	609a      	str	r2, [r3, #8]
    f->term_reason_len = (reason == NULL? 0: (u8_t)LWIP_MIN(strlen(reason), 0xFF) );
 80140b8:	683b      	ldr	r3, [r7, #0]
 80140ba:	2b00      	cmp	r3, #0
 80140bc:	d00f      	beq.n	80140de <fsm_close+0x36>
 80140be:	683b      	ldr	r3, [r7, #0]
 80140c0:	0018      	movs	r0, r3
 80140c2:	f7ec f821 	bl	8000108 <strlen>
 80140c6:	0003      	movs	r3, r0
 80140c8:	2bfe      	cmp	r3, #254	; 0xfe
 80140ca:	d806      	bhi.n	80140da <fsm_close+0x32>
 80140cc:	683b      	ldr	r3, [r7, #0]
 80140ce:	0018      	movs	r0, r3
 80140d0:	f7ec f81a 	bl	8000108 <strlen>
 80140d4:	0003      	movs	r3, r0
 80140d6:	b2db      	uxtb	r3, r3
 80140d8:	e002      	b.n	80140e0 <fsm_close+0x38>
 80140da:	23ff      	movs	r3, #255	; 0xff
 80140dc:	e000      	b.n	80140e0 <fsm_close+0x38>
 80140de:	2300      	movs	r3, #0
 80140e0:	687a      	ldr	r2, [r7, #4]
 80140e2:	7613      	strb	r3, [r2, #24]
    switch( f->state ){
 80140e4:	687b      	ldr	r3, [r7, #4]
 80140e6:	7c1b      	ldrb	r3, [r3, #16]
 80140e8:	2b09      	cmp	r3, #9
 80140ea:	dc1b      	bgt.n	8014124 <fsm_close+0x7c>
 80140ec:	2b06      	cmp	r3, #6
 80140ee:	da13      	bge.n	8014118 <fsm_close+0x70>
 80140f0:	2b05      	cmp	r3, #5
 80140f2:	d00d      	beq.n	8014110 <fsm_close+0x68>
 80140f4:	dc16      	bgt.n	8014124 <fsm_close+0x7c>
 80140f6:	2b01      	cmp	r3, #1
 80140f8:	d002      	beq.n	8014100 <fsm_close+0x58>
 80140fa:	2b03      	cmp	r3, #3
 80140fc:	d004      	beq.n	8014108 <fsm_close+0x60>
    case PPP_FSM_ACKSENT:
    case PPP_FSM_OPENED:
	terminate_layer(f, PPP_FSM_CLOSING);
	break;
    default:
	break;
 80140fe:	e011      	b.n	8014124 <fsm_close+0x7c>
	f->state = PPP_FSM_INITIAL;
 8014100:	687b      	ldr	r3, [r7, #4]
 8014102:	2200      	movs	r2, #0
 8014104:	741a      	strb	r2, [r3, #16]
	break;
 8014106:	e00e      	b.n	8014126 <fsm_close+0x7e>
	f->state = PPP_FSM_CLOSED;
 8014108:	687b      	ldr	r3, [r7, #4]
 801410a:	2202      	movs	r2, #2
 801410c:	741a      	strb	r2, [r3, #16]
	break;
 801410e:	e00a      	b.n	8014126 <fsm_close+0x7e>
	f->state = PPP_FSM_CLOSING;
 8014110:	687b      	ldr	r3, [r7, #4]
 8014112:	2204      	movs	r2, #4
 8014114:	741a      	strb	r2, [r3, #16]
	break;
 8014116:	e006      	b.n	8014126 <fsm_close+0x7e>
	terminate_layer(f, PPP_FSM_CLOSING);
 8014118:	687b      	ldr	r3, [r7, #4]
 801411a:	2104      	movs	r1, #4
 801411c:	0018      	movs	r0, r3
 801411e:	f7ff ff4d 	bl	8013fbc <terminate_layer>
	break;
 8014122:	e000      	b.n	8014126 <fsm_close+0x7e>
	break;
 8014124:	46c0      	nop			; (mov r8, r8)
    }
}
 8014126:	46c0      	nop			; (mov r8, r8)
 8014128:	46bd      	mov	sp, r7
 801412a:	b002      	add	sp, #8
 801412c:	bd80      	pop	{r7, pc}
	...

08014130 <fsm_timeout>:


/*
 * fsm_timeout - Timeout expired.
 */
static void fsm_timeout(void *arg) {
 8014130:	b580      	push	{r7, lr}
 8014132:	b086      	sub	sp, #24
 8014134:	af02      	add	r7, sp, #8
 8014136:	6078      	str	r0, [r7, #4]
    fsm *f = (fsm *) arg;
 8014138:	687b      	ldr	r3, [r7, #4]
 801413a:	60fb      	str	r3, [r7, #12]
    ppp_pcb *pcb = f->pcb;
 801413c:	68fb      	ldr	r3, [r7, #12]
 801413e:	681b      	ldr	r3, [r3, #0]
 8014140:	60bb      	str	r3, [r7, #8]

    switch (f->state) {
 8014142:	68fb      	ldr	r3, [r7, #12]
 8014144:	7c1b      	ldrb	r3, [r3, #16]
 8014146:	2b05      	cmp	r3, #5
 8014148:	dc02      	bgt.n	8014150 <fsm_timeout+0x20>
 801414a:	2b04      	cmp	r3, #4
 801414c:	da05      	bge.n	801415a <fsm_timeout+0x2a>

    default:
	FSMDEBUG(("%s: Timeout event in state %d!", PROTO_NAME(f), f->state));
	/* no break */
    }
}
 801414e:	e08c      	b.n	801426a <fsm_timeout+0x13a>
 8014150:	3b06      	subs	r3, #6
    switch (f->state) {
 8014152:	2b02      	cmp	r3, #2
 8014154:	d900      	bls.n	8014158 <fsm_timeout+0x28>
 8014156:	e088      	b.n	801426a <fsm_timeout+0x13a>
 8014158:	e04b      	b.n	80141f2 <fsm_timeout+0xc2>
	if( f->retransmits <= 0 ){
 801415a:	68fb      	ldr	r3, [r7, #12]
 801415c:	7d1b      	ldrb	r3, [r3, #20]
 801415e:	2b00      	cmp	r3, #0
 8014160:	d115      	bne.n	801418e <fsm_timeout+0x5e>
	    f->state = (f->state == PPP_FSM_CLOSING)? PPP_FSM_CLOSED: PPP_FSM_STOPPED;
 8014162:	68fb      	ldr	r3, [r7, #12]
 8014164:	7c1b      	ldrb	r3, [r3, #16]
 8014166:	2b04      	cmp	r3, #4
 8014168:	d101      	bne.n	801416e <fsm_timeout+0x3e>
 801416a:	2202      	movs	r2, #2
 801416c:	e000      	b.n	8014170 <fsm_timeout+0x40>
 801416e:	2203      	movs	r2, #3
 8014170:	68fb      	ldr	r3, [r7, #12]
 8014172:	741a      	strb	r2, [r3, #16]
	    if( f->callbacks->finished )
 8014174:	68fb      	ldr	r3, [r7, #12]
 8014176:	685b      	ldr	r3, [r3, #4]
 8014178:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801417a:	2b00      	cmp	r3, #0
 801417c:	d100      	bne.n	8014180 <fsm_timeout+0x50>
 801417e:	e071      	b.n	8014264 <fsm_timeout+0x134>
		(*f->callbacks->finished)(f);
 8014180:	68fb      	ldr	r3, [r7, #12]
 8014182:	685b      	ldr	r3, [r3, #4]
 8014184:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014186:	68fa      	ldr	r2, [r7, #12]
 8014188:	0010      	movs	r0, r2
 801418a:	4798      	blx	r3
	break;
 801418c:	e06a      	b.n	8014264 <fsm_timeout+0x134>
	    fsm_sdata(f, TERMREQ, f->reqid = ++f->id,
 801418e:	68fb      	ldr	r3, [r7, #12]
 8014190:	7c9b      	ldrb	r3, [r3, #18]
 8014192:	3301      	adds	r3, #1
 8014194:	b2da      	uxtb	r2, r3
 8014196:	68fb      	ldr	r3, [r7, #12]
 8014198:	749a      	strb	r2, [r3, #18]
 801419a:	68fb      	ldr	r3, [r7, #12]
 801419c:	7c9a      	ldrb	r2, [r3, #18]
 801419e:	68fb      	ldr	r3, [r7, #12]
 80141a0:	74da      	strb	r2, [r3, #19]
 80141a2:	68fb      	ldr	r3, [r7, #12]
 80141a4:	7cda      	ldrb	r2, [r3, #19]
		      (const u_char *) f->term_reason, f->term_reason_len);
 80141a6:	68fb      	ldr	r3, [r7, #12]
 80141a8:	6899      	ldr	r1, [r3, #8]
 80141aa:	68fb      	ldr	r3, [r7, #12]
 80141ac:	7e1b      	ldrb	r3, [r3, #24]
	    fsm_sdata(f, TERMREQ, f->reqid = ++f->id,
 80141ae:	68f8      	ldr	r0, [r7, #12]
 80141b0:	9300      	str	r3, [sp, #0]
 80141b2:	000b      	movs	r3, r1
 80141b4:	2105      	movs	r1, #5
 80141b6:	f000 fd43 	bl	8014c40 <fsm_sdata>
	    TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
 80141ba:	68fa      	ldr	r2, [r7, #12]
 80141bc:	4b2d      	ldr	r3, [pc, #180]	; (8014274 <fsm_timeout+0x144>)
 80141be:	0011      	movs	r1, r2
 80141c0:	0018      	movs	r0, r3
 80141c2:	f7fd fd71 	bl	8011ca8 <sys_untimeout>
 80141c6:	68bb      	ldr	r3, [r7, #8]
 80141c8:	791b      	ldrb	r3, [r3, #4]
 80141ca:	001a      	movs	r2, r3
 80141cc:	0013      	movs	r3, r2
 80141ce:	015b      	lsls	r3, r3, #5
 80141d0:	1a9b      	subs	r3, r3, r2
 80141d2:	009b      	lsls	r3, r3, #2
 80141d4:	189b      	adds	r3, r3, r2
 80141d6:	00db      	lsls	r3, r3, #3
 80141d8:	0018      	movs	r0, r3
 80141da:	68fa      	ldr	r2, [r7, #12]
 80141dc:	4b25      	ldr	r3, [pc, #148]	; (8014274 <fsm_timeout+0x144>)
 80141de:	0019      	movs	r1, r3
 80141e0:	f7fd fd3a 	bl	8011c58 <sys_timeout>
	    --f->retransmits;
 80141e4:	68fb      	ldr	r3, [r7, #12]
 80141e6:	7d1b      	ldrb	r3, [r3, #20]
 80141e8:	3b01      	subs	r3, #1
 80141ea:	b2da      	uxtb	r2, r3
 80141ec:	68fb      	ldr	r3, [r7, #12]
 80141ee:	751a      	strb	r2, [r3, #20]
	break;
 80141f0:	e038      	b.n	8014264 <fsm_timeout+0x134>
	if (f->retransmits <= 0) {
 80141f2:	68fb      	ldr	r3, [r7, #12]
 80141f4:	7d1b      	ldrb	r3, [r3, #20]
 80141f6:	2b00      	cmp	r3, #0
 80141f8:	d11c      	bne.n	8014234 <fsm_timeout+0x104>
	    ppp_warn("%s: timeout sending Config-Requests", PROTO_NAME(f));
 80141fa:	68fb      	ldr	r3, [r7, #12]
 80141fc:	685b      	ldr	r3, [r3, #4]
 80141fe:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8014200:	4b1d      	ldr	r3, [pc, #116]	; (8014278 <fsm_timeout+0x148>)
 8014202:	0011      	movs	r1, r2
 8014204:	0018      	movs	r0, r3
 8014206:	f006 ffaa 	bl	801b15e <ppp_warn>
	    f->state = PPP_FSM_STOPPED;
 801420a:	68fb      	ldr	r3, [r7, #12]
 801420c:	2203      	movs	r2, #3
 801420e:	741a      	strb	r2, [r3, #16]
	    if( (f->flags & OPT_PASSIVE) == 0 && f->callbacks->finished )
 8014210:	68fb      	ldr	r3, [r7, #12]
 8014212:	7c5b      	ldrb	r3, [r3, #17]
 8014214:	001a      	movs	r2, r3
 8014216:	2301      	movs	r3, #1
 8014218:	4013      	ands	r3, r2
 801421a:	d125      	bne.n	8014268 <fsm_timeout+0x138>
 801421c:	68fb      	ldr	r3, [r7, #12]
 801421e:	685b      	ldr	r3, [r3, #4]
 8014220:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014222:	2b00      	cmp	r3, #0
 8014224:	d020      	beq.n	8014268 <fsm_timeout+0x138>
		(*f->callbacks->finished)(f);
 8014226:	68fb      	ldr	r3, [r7, #12]
 8014228:	685b      	ldr	r3, [r3, #4]
 801422a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801422c:	68fa      	ldr	r2, [r7, #12]
 801422e:	0010      	movs	r0, r2
 8014230:	4798      	blx	r3
	break;
 8014232:	e019      	b.n	8014268 <fsm_timeout+0x138>
	    if (f->callbacks->retransmit)
 8014234:	68fb      	ldr	r3, [r7, #12]
 8014236:	685b      	ldr	r3, [r3, #4]
 8014238:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801423a:	2b00      	cmp	r3, #0
 801423c:	d005      	beq.n	801424a <fsm_timeout+0x11a>
		(*f->callbacks->retransmit)(f);
 801423e:	68fb      	ldr	r3, [r7, #12]
 8014240:	685b      	ldr	r3, [r3, #4]
 8014242:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8014244:	68fa      	ldr	r2, [r7, #12]
 8014246:	0010      	movs	r0, r2
 8014248:	4798      	blx	r3
	    fsm_sconfreq(f, 1);		/* Re-send Configure-Request */
 801424a:	68fb      	ldr	r3, [r7, #12]
 801424c:	2101      	movs	r1, #1
 801424e:	0018      	movs	r0, r3
 8014250:	f000 fc00 	bl	8014a54 <fsm_sconfreq>
	    if( f->state == PPP_FSM_ACKRCVD )
 8014254:	68fb      	ldr	r3, [r7, #12]
 8014256:	7c1b      	ldrb	r3, [r3, #16]
 8014258:	2b07      	cmp	r3, #7
 801425a:	d105      	bne.n	8014268 <fsm_timeout+0x138>
		f->state = PPP_FSM_REQSENT;
 801425c:	68fb      	ldr	r3, [r7, #12]
 801425e:	2206      	movs	r2, #6
 8014260:	741a      	strb	r2, [r3, #16]
	break;
 8014262:	e001      	b.n	8014268 <fsm_timeout+0x138>
	break;
 8014264:	46c0      	nop			; (mov r8, r8)
 8014266:	e000      	b.n	801426a <fsm_timeout+0x13a>
	break;
 8014268:	46c0      	nop			; (mov r8, r8)
}
 801426a:	46c0      	nop			; (mov r8, r8)
 801426c:	46bd      	mov	sp, r7
 801426e:	b004      	add	sp, #16
 8014270:	bd80      	pop	{r7, pc}
 8014272:	46c0      	nop			; (mov r8, r8)
 8014274:	08014131 	.word	0x08014131
 8014278:	08020de4 	.word	0x08020de4

0801427c <fsm_input>:


/*
 * fsm_input - Input packet.
 */
void fsm_input(fsm *f, u_char *inpacket, int l) {
 801427c:	b5b0      	push	{r4, r5, r7, lr}
 801427e:	b08a      	sub	sp, #40	; 0x28
 8014280:	af02      	add	r7, sp, #8
 8014282:	60f8      	str	r0, [r7, #12]
 8014284:	60b9      	str	r1, [r7, #8]
 8014286:	607a      	str	r2, [r7, #4]

    /*
     * Parse header (code, id and length).
     * If packet too short, drop it.
     */
    inp = inpacket;
 8014288:	68bb      	ldr	r3, [r7, #8]
 801428a:	61fb      	str	r3, [r7, #28]
    if (l < HEADERLEN) {
 801428c:	687b      	ldr	r3, [r7, #4]
 801428e:	2b03      	cmp	r3, #3
 8014290:	dc00      	bgt.n	8014294 <fsm_input+0x18>
 8014292:	e097      	b.n	80143c4 <fsm_input+0x148>
	FSMDEBUG(("fsm_input(%x): Rcvd short header.", f->protocol));
	return;
    }
    GETCHAR(code, inp);
 8014294:	69fb      	ldr	r3, [r7, #28]
 8014296:	1c5a      	adds	r2, r3, #1
 8014298:	61fa      	str	r2, [r7, #28]
 801429a:	211b      	movs	r1, #27
 801429c:	187a      	adds	r2, r7, r1
 801429e:	781b      	ldrb	r3, [r3, #0]
 80142a0:	7013      	strb	r3, [r2, #0]
    GETCHAR(id, inp);
 80142a2:	69fb      	ldr	r3, [r7, #28]
 80142a4:	1c5a      	adds	r2, r3, #1
 80142a6:	61fa      	str	r2, [r7, #28]
 80142a8:	221a      	movs	r2, #26
 80142aa:	18ba      	adds	r2, r7, r2
 80142ac:	781b      	ldrb	r3, [r3, #0]
 80142ae:	7013      	strb	r3, [r2, #0]
    GETSHORT(len, inp);
 80142b0:	69fb      	ldr	r3, [r7, #28]
 80142b2:	1c5a      	adds	r2, r3, #1
 80142b4:	61fa      	str	r2, [r7, #28]
 80142b6:	781b      	ldrb	r3, [r3, #0]
 80142b8:	021b      	lsls	r3, r3, #8
 80142ba:	617b      	str	r3, [r7, #20]
 80142bc:	69fb      	ldr	r3, [r7, #28]
 80142be:	1c5a      	adds	r2, r3, #1
 80142c0:	61fa      	str	r2, [r7, #28]
 80142c2:	781b      	ldrb	r3, [r3, #0]
 80142c4:	001a      	movs	r2, r3
 80142c6:	697b      	ldr	r3, [r7, #20]
 80142c8:	4313      	orrs	r3, r2
 80142ca:	617b      	str	r3, [r7, #20]
    if (len < HEADERLEN) {
 80142cc:	697b      	ldr	r3, [r7, #20]
 80142ce:	2b03      	cmp	r3, #3
 80142d0:	dc00      	bgt.n	80142d4 <fsm_input+0x58>
 80142d2:	e079      	b.n	80143c8 <fsm_input+0x14c>
	FSMDEBUG(("fsm_input(%x): Rcvd illegal length.", f->protocol));
	return;
    }
    if (len > l) {
 80142d4:	697a      	ldr	r2, [r7, #20]
 80142d6:	687b      	ldr	r3, [r7, #4]
 80142d8:	429a      	cmp	r2, r3
 80142da:	dd00      	ble.n	80142de <fsm_input+0x62>
 80142dc:	e076      	b.n	80143cc <fsm_input+0x150>
	FSMDEBUG(("fsm_input(%x): Rcvd short packet.", f->protocol));
	return;
    }
    len -= HEADERLEN;		/* subtract header length */
 80142de:	697b      	ldr	r3, [r7, #20]
 80142e0:	3b04      	subs	r3, #4
 80142e2:	617b      	str	r3, [r7, #20]

    if( f->state == PPP_FSM_INITIAL || f->state == PPP_FSM_STARTING ){
 80142e4:	68fb      	ldr	r3, [r7, #12]
 80142e6:	7c1b      	ldrb	r3, [r3, #16]
 80142e8:	2b00      	cmp	r3, #0
 80142ea:	d100      	bne.n	80142ee <fsm_input+0x72>
 80142ec:	e070      	b.n	80143d0 <fsm_input+0x154>
 80142ee:	68fb      	ldr	r3, [r7, #12]
 80142f0:	7c1b      	ldrb	r3, [r3, #16]
 80142f2:	2b01      	cmp	r3, #1
 80142f4:	d06c      	beq.n	80143d0 <fsm_input+0x154>
    }

    /*
     * Action depends on code.
     */
    switch (code) {
 80142f6:	187b      	adds	r3, r7, r1
 80142f8:	781b      	ldrb	r3, [r3, #0]
 80142fa:	2b07      	cmp	r3, #7
 80142fc:	d83a      	bhi.n	8014374 <fsm_input+0xf8>
 80142fe:	009a      	lsls	r2, r3, #2
 8014300:	4b36      	ldr	r3, [pc, #216]	; (80143dc <fsm_input+0x160>)
 8014302:	18d3      	adds	r3, r2, r3
 8014304:	681b      	ldr	r3, [r3, #0]
 8014306:	469f      	mov	pc, r3
    case CONFREQ:
	fsm_rconfreq(f, id, inp, len);
 8014308:	697c      	ldr	r4, [r7, #20]
 801430a:	69fa      	ldr	r2, [r7, #28]
 801430c:	231a      	movs	r3, #26
 801430e:	18fb      	adds	r3, r7, r3
 8014310:	7819      	ldrb	r1, [r3, #0]
 8014312:	68f8      	ldr	r0, [r7, #12]
 8014314:	0023      	movs	r3, r4
 8014316:	f000 f863 	bl	80143e0 <fsm_rconfreq>
	break;
 801431a:	e05c      	b.n	80143d6 <fsm_input+0x15a>
    
    case CONFACK:
	fsm_rconfack(f, id, inp, len);
 801431c:	231a      	movs	r3, #26
 801431e:	18fb      	adds	r3, r7, r3
 8014320:	7819      	ldrb	r1, [r3, #0]
 8014322:	697b      	ldr	r3, [r7, #20]
 8014324:	69fa      	ldr	r2, [r7, #28]
 8014326:	68f8      	ldr	r0, [r7, #12]
 8014328:	f000 f904 	bl	8014534 <fsm_rconfack>
	break;
 801432c:	e053      	b.n	80143d6 <fsm_input+0x15a>
    
    case CONFNAK:
    case CONFREJ:
	fsm_rconfnakrej(f, code, id, inp, len);
 801432e:	231b      	movs	r3, #27
 8014330:	18fb      	adds	r3, r7, r3
 8014332:	7819      	ldrb	r1, [r3, #0]
 8014334:	231a      	movs	r3, #26
 8014336:	18fb      	adds	r3, r7, r3
 8014338:	781a      	ldrb	r2, [r3, #0]
 801433a:	69fc      	ldr	r4, [r7, #28]
 801433c:	68f8      	ldr	r0, [r7, #12]
 801433e:	697b      	ldr	r3, [r7, #20]
 8014340:	9300      	str	r3, [sp, #0]
 8014342:	0023      	movs	r3, r4
 8014344:	f000 f996 	bl	8014674 <fsm_rconfnakrej>
	break;
 8014348:	e045      	b.n	80143d6 <fsm_input+0x15a>
    
    case TERMREQ:
	fsm_rtermreq(f, id, inp, len);
 801434a:	231a      	movs	r3, #26
 801434c:	18fb      	adds	r3, r7, r3
 801434e:	7819      	ldrb	r1, [r3, #0]
 8014350:	697b      	ldr	r3, [r7, #20]
 8014352:	69fa      	ldr	r2, [r7, #28]
 8014354:	68f8      	ldr	r0, [r7, #12]
 8014356:	f000 fa41 	bl	80147dc <fsm_rtermreq>
	break;
 801435a:	e03c      	b.n	80143d6 <fsm_input+0x15a>
    
    case TERMACK:
	fsm_rtermack(f);
 801435c:	68fb      	ldr	r3, [r7, #12]
 801435e:	0018      	movs	r0, r3
 8014360:	f000 faa2 	bl	80148a8 <fsm_rtermack>
	break;
 8014364:	e037      	b.n	80143d6 <fsm_input+0x15a>
    
    case CODEREJ:
	fsm_rcoderej(f, inp, len);
 8014366:	697a      	ldr	r2, [r7, #20]
 8014368:	69f9      	ldr	r1, [r7, #28]
 801436a:	68fb      	ldr	r3, [r7, #12]
 801436c:	0018      	movs	r0, r3
 801436e:	f000 faf9 	bl	8014964 <fsm_rcoderej>
	break;
 8014372:	e030      	b.n	80143d6 <fsm_input+0x15a>
    
    default:
	if( !f->callbacks->extcode
 8014374:	68fb      	ldr	r3, [r7, #12]
 8014376:	685b      	ldr	r3, [r3, #4]
 8014378:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801437a:	2b00      	cmp	r3, #0
 801437c:	d010      	beq.n	80143a0 <fsm_input+0x124>
	   || !(*f->callbacks->extcode)(f, code, id, inp, len) )
 801437e:	68fb      	ldr	r3, [r7, #12]
 8014380:	685b      	ldr	r3, [r3, #4]
 8014382:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 8014384:	231b      	movs	r3, #27
 8014386:	18fb      	adds	r3, r7, r3
 8014388:	7819      	ldrb	r1, [r3, #0]
 801438a:	231a      	movs	r3, #26
 801438c:	18fb      	adds	r3, r7, r3
 801438e:	781a      	ldrb	r2, [r3, #0]
 8014390:	69fd      	ldr	r5, [r7, #28]
 8014392:	68f8      	ldr	r0, [r7, #12]
 8014394:	697b      	ldr	r3, [r7, #20]
 8014396:	9300      	str	r3, [sp, #0]
 8014398:	002b      	movs	r3, r5
 801439a:	47a0      	blx	r4
 801439c:	1e03      	subs	r3, r0, #0
 801439e:	d119      	bne.n	80143d4 <fsm_input+0x158>
	    fsm_sdata(f, CODEREJ, ++f->id, inpacket, len + HEADERLEN);
 80143a0:	68fb      	ldr	r3, [r7, #12]
 80143a2:	7c9b      	ldrb	r3, [r3, #18]
 80143a4:	3301      	adds	r3, #1
 80143a6:	b2da      	uxtb	r2, r3
 80143a8:	68fb      	ldr	r3, [r7, #12]
 80143aa:	749a      	strb	r2, [r3, #18]
 80143ac:	68fb      	ldr	r3, [r7, #12]
 80143ae:	7c9a      	ldrb	r2, [r3, #18]
 80143b0:	697b      	ldr	r3, [r7, #20]
 80143b2:	3304      	adds	r3, #4
 80143b4:	68b9      	ldr	r1, [r7, #8]
 80143b6:	68f8      	ldr	r0, [r7, #12]
 80143b8:	9300      	str	r3, [sp, #0]
 80143ba:	000b      	movs	r3, r1
 80143bc:	2107      	movs	r1, #7
 80143be:	f000 fc3f 	bl	8014c40 <fsm_sdata>
	break;
 80143c2:	e007      	b.n	80143d4 <fsm_input+0x158>
	return;
 80143c4:	46c0      	nop			; (mov r8, r8)
 80143c6:	e006      	b.n	80143d6 <fsm_input+0x15a>
	return;
 80143c8:	46c0      	nop			; (mov r8, r8)
 80143ca:	e004      	b.n	80143d6 <fsm_input+0x15a>
	return;
 80143cc:	46c0      	nop			; (mov r8, r8)
 80143ce:	e002      	b.n	80143d6 <fsm_input+0x15a>
	return;
 80143d0:	46c0      	nop			; (mov r8, r8)
 80143d2:	e000      	b.n	80143d6 <fsm_input+0x15a>
	break;
 80143d4:	46c0      	nop			; (mov r8, r8)
    }
}
 80143d6:	46bd      	mov	sp, r7
 80143d8:	b008      	add	sp, #32
 80143da:	bdb0      	pop	{r4, r5, r7, pc}
 80143dc:	08021abc 	.word	0x08021abc

080143e0 <fsm_rconfreq>:


/*
 * fsm_rconfreq - Receive Configure-Request.
 */
static void fsm_rconfreq(fsm *f, u_char id, u_char *inp, int len) {
 80143e0:	b590      	push	{r4, r7, lr}
 80143e2:	b089      	sub	sp, #36	; 0x24
 80143e4:	af02      	add	r7, sp, #8
 80143e6:	60f8      	str	r0, [r7, #12]
 80143e8:	607a      	str	r2, [r7, #4]
 80143ea:	603b      	str	r3, [r7, #0]
 80143ec:	230b      	movs	r3, #11
 80143ee:	18fb      	adds	r3, r7, r3
 80143f0:	1c0a      	adds	r2, r1, #0
 80143f2:	701a      	strb	r2, [r3, #0]
    int code, reject_if_disagree;

    switch( f->state ){
 80143f4:	68fb      	ldr	r3, [r7, #12]
 80143f6:	7c1b      	ldrb	r3, [r3, #16]
 80143f8:	2b09      	cmp	r3, #9
 80143fa:	d015      	beq.n	8014428 <fsm_rconfreq+0x48>
 80143fc:	dc31      	bgt.n	8014462 <fsm_rconfreq+0x82>
 80143fe:	2b05      	cmp	r3, #5
 8014400:	dc2f      	bgt.n	8014462 <fsm_rconfreq+0x82>
 8014402:	2b04      	cmp	r3, #4
 8014404:	db00      	blt.n	8014408 <fsm_rconfreq+0x28>
 8014406:	e08e      	b.n	8014526 <fsm_rconfreq+0x146>
 8014408:	2b02      	cmp	r3, #2
 801440a:	d002      	beq.n	8014412 <fsm_rconfreq+0x32>
 801440c:	2b03      	cmp	r3, #3
 801440e:	d01f      	beq.n	8014450 <fsm_rconfreq+0x70>
	/* Negotiation started by our peer */
	fsm_sconfreq(f, 0);		/* Send initial Configure-Request */
	f->state = PPP_FSM_REQSENT;
	break;
    default:
	break;
 8014410:	e027      	b.n	8014462 <fsm_rconfreq+0x82>
	fsm_sdata(f, TERMACK, id, NULL, 0);
 8014412:	230b      	movs	r3, #11
 8014414:	18fb      	adds	r3, r7, r3
 8014416:	781a      	ldrb	r2, [r3, #0]
 8014418:	68f8      	ldr	r0, [r7, #12]
 801441a:	2300      	movs	r3, #0
 801441c:	9300      	str	r3, [sp, #0]
 801441e:	2300      	movs	r3, #0
 8014420:	2106      	movs	r1, #6
 8014422:	f000 fc0d 	bl	8014c40 <fsm_sdata>
	return;
 8014426:	e07f      	b.n	8014528 <fsm_rconfreq+0x148>
	if( f->callbacks->down )
 8014428:	68fb      	ldr	r3, [r7, #12]
 801442a:	685b      	ldr	r3, [r3, #4]
 801442c:	6a1b      	ldr	r3, [r3, #32]
 801442e:	2b00      	cmp	r3, #0
 8014430:	d005      	beq.n	801443e <fsm_rconfreq+0x5e>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
 8014432:	68fb      	ldr	r3, [r7, #12]
 8014434:	685b      	ldr	r3, [r3, #4]
 8014436:	6a1b      	ldr	r3, [r3, #32]
 8014438:	68fa      	ldr	r2, [r7, #12]
 801443a:	0010      	movs	r0, r2
 801443c:	4798      	blx	r3
	fsm_sconfreq(f, 0);		/* Send initial Configure-Request */
 801443e:	68fb      	ldr	r3, [r7, #12]
 8014440:	2100      	movs	r1, #0
 8014442:	0018      	movs	r0, r3
 8014444:	f000 fb06 	bl	8014a54 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 8014448:	68fb      	ldr	r3, [r7, #12]
 801444a:	2206      	movs	r2, #6
 801444c:	741a      	strb	r2, [r3, #16]
	break;
 801444e:	e009      	b.n	8014464 <fsm_rconfreq+0x84>
	fsm_sconfreq(f, 0);		/* Send initial Configure-Request */
 8014450:	68fb      	ldr	r3, [r7, #12]
 8014452:	2100      	movs	r1, #0
 8014454:	0018      	movs	r0, r3
 8014456:	f000 fafd 	bl	8014a54 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 801445a:	68fb      	ldr	r3, [r7, #12]
 801445c:	2206      	movs	r2, #6
 801445e:	741a      	strb	r2, [r3, #16]
	break;
 8014460:	e000      	b.n	8014464 <fsm_rconfreq+0x84>
	break;
 8014462:	46c0      	nop			; (mov r8, r8)

    /*
     * Pass the requested configuration options
     * to protocol-specific code for checking.
     */
    if (f->callbacks->reqci){		/* Check CI */
 8014464:	68fb      	ldr	r3, [r7, #12]
 8014466:	685b      	ldr	r3, [r3, #4]
 8014468:	699b      	ldr	r3, [r3, #24]
 801446a:	2b00      	cmp	r3, #0
 801446c:	d013      	beq.n	8014496 <fsm_rconfreq+0xb6>
	reject_if_disagree = (f->nakloops >= f->maxnakloops);
 801446e:	68fb      	ldr	r3, [r7, #12]
 8014470:	7d59      	ldrb	r1, [r3, #21]
 8014472:	68fb      	ldr	r3, [r7, #12]
 8014474:	7dda      	ldrb	r2, [r3, #23]
 8014476:	2300      	movs	r3, #0
 8014478:	4291      	cmp	r1, r2
 801447a:	415b      	adcs	r3, r3
 801447c:	b2db      	uxtb	r3, r3
 801447e:	613b      	str	r3, [r7, #16]
	code = (*f->callbacks->reqci)(f, inp, &len, reject_if_disagree);
 8014480:	68fb      	ldr	r3, [r7, #12]
 8014482:	685b      	ldr	r3, [r3, #4]
 8014484:	699c      	ldr	r4, [r3, #24]
 8014486:	693b      	ldr	r3, [r7, #16]
 8014488:	003a      	movs	r2, r7
 801448a:	6879      	ldr	r1, [r7, #4]
 801448c:	68f8      	ldr	r0, [r7, #12]
 801448e:	47a0      	blx	r4
 8014490:	0003      	movs	r3, r0
 8014492:	617b      	str	r3, [r7, #20]
 8014494:	e007      	b.n	80144a6 <fsm_rconfreq+0xc6>
    } else if (len)
 8014496:	683b      	ldr	r3, [r7, #0]
 8014498:	2b00      	cmp	r3, #0
 801449a:	d002      	beq.n	80144a2 <fsm_rconfreq+0xc2>
	code = CONFREJ;			/* Reject all CI */
 801449c:	2304      	movs	r3, #4
 801449e:	617b      	str	r3, [r7, #20]
 80144a0:	e001      	b.n	80144a6 <fsm_rconfreq+0xc6>
    else
	code = CONFACK;
 80144a2:	2302      	movs	r3, #2
 80144a4:	617b      	str	r3, [r7, #20]

    /* send the Ack, Nak or Rej to the peer */
    fsm_sdata(f, code, id, inp, len);
 80144a6:	697b      	ldr	r3, [r7, #20]
 80144a8:	b2d9      	uxtb	r1, r3
 80144aa:	683b      	ldr	r3, [r7, #0]
 80144ac:	687c      	ldr	r4, [r7, #4]
 80144ae:	220b      	movs	r2, #11
 80144b0:	18ba      	adds	r2, r7, r2
 80144b2:	7812      	ldrb	r2, [r2, #0]
 80144b4:	68f8      	ldr	r0, [r7, #12]
 80144b6:	9300      	str	r3, [sp, #0]
 80144b8:	0023      	movs	r3, r4
 80144ba:	f000 fbc1 	bl	8014c40 <fsm_sdata>

    if (code == CONFACK) {
 80144be:	697b      	ldr	r3, [r7, #20]
 80144c0:	2b02      	cmp	r3, #2
 80144c2:	d11f      	bne.n	8014504 <fsm_rconfreq+0x124>
	if (f->state == PPP_FSM_ACKRCVD) {
 80144c4:	68fb      	ldr	r3, [r7, #12]
 80144c6:	7c1b      	ldrb	r3, [r3, #16]
 80144c8:	2b07      	cmp	r3, #7
 80144ca:	d114      	bne.n	80144f6 <fsm_rconfreq+0x116>
	    UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 80144cc:	68fa      	ldr	r2, [r7, #12]
 80144ce:	4b18      	ldr	r3, [pc, #96]	; (8014530 <fsm_rconfreq+0x150>)
 80144d0:	0011      	movs	r1, r2
 80144d2:	0018      	movs	r0, r3
 80144d4:	f7fd fbe8 	bl	8011ca8 <sys_untimeout>
	    f->state = PPP_FSM_OPENED;
 80144d8:	68fb      	ldr	r3, [r7, #12]
 80144da:	2209      	movs	r2, #9
 80144dc:	741a      	strb	r2, [r3, #16]
	    if (f->callbacks->up)
 80144de:	68fb      	ldr	r3, [r7, #12]
 80144e0:	685b      	ldr	r3, [r3, #4]
 80144e2:	69db      	ldr	r3, [r3, #28]
 80144e4:	2b00      	cmp	r3, #0
 80144e6:	d009      	beq.n	80144fc <fsm_rconfreq+0x11c>
		(*f->callbacks->up)(f);	/* Inform upper layers */
 80144e8:	68fb      	ldr	r3, [r7, #12]
 80144ea:	685b      	ldr	r3, [r3, #4]
 80144ec:	69db      	ldr	r3, [r3, #28]
 80144ee:	68fa      	ldr	r2, [r7, #12]
 80144f0:	0010      	movs	r0, r2
 80144f2:	4798      	blx	r3
 80144f4:	e002      	b.n	80144fc <fsm_rconfreq+0x11c>
	} else
	    f->state = PPP_FSM_ACKSENT;
 80144f6:	68fb      	ldr	r3, [r7, #12]
 80144f8:	2208      	movs	r2, #8
 80144fa:	741a      	strb	r2, [r3, #16]
	f->nakloops = 0;
 80144fc:	68fb      	ldr	r3, [r7, #12]
 80144fe:	2200      	movs	r2, #0
 8014500:	755a      	strb	r2, [r3, #21]
 8014502:	e011      	b.n	8014528 <fsm_rconfreq+0x148>

    } else {
	/* we sent CONFACK or CONFREJ */
	if (f->state != PPP_FSM_ACKRCVD)
 8014504:	68fb      	ldr	r3, [r7, #12]
 8014506:	7c1b      	ldrb	r3, [r3, #16]
 8014508:	2b07      	cmp	r3, #7
 801450a:	d002      	beq.n	8014512 <fsm_rconfreq+0x132>
	    f->state = PPP_FSM_REQSENT;
 801450c:	68fb      	ldr	r3, [r7, #12]
 801450e:	2206      	movs	r2, #6
 8014510:	741a      	strb	r2, [r3, #16]
	if( code == CONFNAK )
 8014512:	697b      	ldr	r3, [r7, #20]
 8014514:	2b03      	cmp	r3, #3
 8014516:	d107      	bne.n	8014528 <fsm_rconfreq+0x148>
	    ++f->nakloops;
 8014518:	68fb      	ldr	r3, [r7, #12]
 801451a:	7d5b      	ldrb	r3, [r3, #21]
 801451c:	3301      	adds	r3, #1
 801451e:	b2da      	uxtb	r2, r3
 8014520:	68fb      	ldr	r3, [r7, #12]
 8014522:	755a      	strb	r2, [r3, #21]
 8014524:	e000      	b.n	8014528 <fsm_rconfreq+0x148>
	return;
 8014526:	46c0      	nop			; (mov r8, r8)
    }
}
 8014528:	46bd      	mov	sp, r7
 801452a:	b007      	add	sp, #28
 801452c:	bd90      	pop	{r4, r7, pc}
 801452e:	46c0      	nop			; (mov r8, r8)
 8014530:	08014131 	.word	0x08014131

08014534 <fsm_rconfack>:


/*
 * fsm_rconfack - Receive Configure-Ack.
 */
static void fsm_rconfack(fsm *f, int id, u_char *inp, int len) {
 8014534:	b580      	push	{r7, lr}
 8014536:	b088      	sub	sp, #32
 8014538:	af02      	add	r7, sp, #8
 801453a:	60f8      	str	r0, [r7, #12]
 801453c:	60b9      	str	r1, [r7, #8]
 801453e:	607a      	str	r2, [r7, #4]
 8014540:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 8014542:	68fb      	ldr	r3, [r7, #12]
 8014544:	681b      	ldr	r3, [r3, #0]
 8014546:	617b      	str	r3, [r7, #20]

    if (id != f->reqid || f->seen_ack)		/* Expected id? */
 8014548:	68fb      	ldr	r3, [r7, #12]
 801454a:	7cdb      	ldrb	r3, [r3, #19]
 801454c:	001a      	movs	r2, r3
 801454e:	68bb      	ldr	r3, [r7, #8]
 8014550:	4293      	cmp	r3, r2
 8014552:	d000      	beq.n	8014556 <fsm_rconfack+0x22>
 8014554:	e07f      	b.n	8014656 <fsm_rconfack+0x122>
 8014556:	68fb      	ldr	r3, [r7, #12]
 8014558:	7b1b      	ldrb	r3, [r3, #12]
 801455a:	2b00      	cmp	r3, #0
 801455c:	d000      	beq.n	8014560 <fsm_rconfack+0x2c>
 801455e:	e07a      	b.n	8014656 <fsm_rconfack+0x122>
	return;					/* Nope, toss... */
    if( !(f->callbacks->ackci? (*f->callbacks->ackci)(f, inp, len):
 8014560:	68fb      	ldr	r3, [r7, #12]
 8014562:	685b      	ldr	r3, [r3, #4]
 8014564:	68db      	ldr	r3, [r3, #12]
 8014566:	2b00      	cmp	r3, #0
 8014568:	d00b      	beq.n	8014582 <fsm_rconfack+0x4e>
 801456a:	68fb      	ldr	r3, [r7, #12]
 801456c:	685b      	ldr	r3, [r3, #4]
 801456e:	68db      	ldr	r3, [r3, #12]
 8014570:	683a      	ldr	r2, [r7, #0]
 8014572:	6879      	ldr	r1, [r7, #4]
 8014574:	68f8      	ldr	r0, [r7, #12]
 8014576:	4798      	blx	r3
 8014578:	0003      	movs	r3, r0
 801457a:	425a      	negs	r2, r3
 801457c:	4153      	adcs	r3, r2
 801457e:	b2db      	uxtb	r3, r3
 8014580:	e003      	b.n	801458a <fsm_rconfack+0x56>
 8014582:	683b      	ldr	r3, [r7, #0]
 8014584:	1e5a      	subs	r2, r3, #1
 8014586:	4193      	sbcs	r3, r2
 8014588:	b2db      	uxtb	r3, r3
 801458a:	2b00      	cmp	r3, #0
 801458c:	d006      	beq.n	801459c <fsm_rconfack+0x68>
	  (len == 0)) ){
	/* Ack is bad - ignore it */
	ppp_error("Received bad configure-ack: %P", inp, len);
 801458e:	683a      	ldr	r2, [r7, #0]
 8014590:	6879      	ldr	r1, [r7, #4]
 8014592:	4b35      	ldr	r3, [pc, #212]	; (8014668 <fsm_rconfack+0x134>)
 8014594:	0018      	movs	r0, r3
 8014596:	f006 fdce 	bl	801b136 <ppp_error>
	return;
 801459a:	e061      	b.n	8014660 <fsm_rconfack+0x12c>
    }
    f->seen_ack = 1;
 801459c:	68fb      	ldr	r3, [r7, #12]
 801459e:	2201      	movs	r2, #1
 80145a0:	731a      	strb	r2, [r3, #12]
    f->rnakloops = 0;
 80145a2:	68fb      	ldr	r3, [r7, #12]
 80145a4:	2200      	movs	r2, #0
 80145a6:	759a      	strb	r2, [r3, #22]

    switch (f->state) {
 80145a8:	68fb      	ldr	r3, [r7, #12]
 80145aa:	7c1b      	ldrb	r3, [r3, #16]
 80145ac:	2b09      	cmp	r3, #9
 80145ae:	d854      	bhi.n	801465a <fsm_rconfack+0x126>
 80145b0:	009a      	lsls	r2, r3, #2
 80145b2:	4b2e      	ldr	r3, [pc, #184]	; (801466c <fsm_rconfack+0x138>)
 80145b4:	18d3      	adds	r3, r2, r3
 80145b6:	681b      	ldr	r3, [r3, #0]
 80145b8:	469f      	mov	pc, r3
    case PPP_FSM_CLOSED:
    case PPP_FSM_STOPPED:
	fsm_sdata(f, TERMACK, id, NULL, 0);
 80145ba:	68bb      	ldr	r3, [r7, #8]
 80145bc:	b2da      	uxtb	r2, r3
 80145be:	68f8      	ldr	r0, [r7, #12]
 80145c0:	2300      	movs	r3, #0
 80145c2:	9300      	str	r3, [sp, #0]
 80145c4:	2300      	movs	r3, #0
 80145c6:	2106      	movs	r1, #6
 80145c8:	f000 fb3a 	bl	8014c40 <fsm_sdata>
	break;
 80145cc:	e048      	b.n	8014660 <fsm_rconfack+0x12c>

    case PPP_FSM_REQSENT:
	f->state = PPP_FSM_ACKRCVD;
 80145ce:	68fb      	ldr	r3, [r7, #12]
 80145d0:	2207      	movs	r2, #7
 80145d2:	741a      	strb	r2, [r3, #16]
	f->retransmits = pcb->settings.fsm_max_conf_req_transmits;
 80145d4:	697b      	ldr	r3, [r7, #20]
 80145d6:	795a      	ldrb	r2, [r3, #5]
 80145d8:	68fb      	ldr	r3, [r7, #12]
 80145da:	751a      	strb	r2, [r3, #20]
	break;
 80145dc:	e040      	b.n	8014660 <fsm_rconfack+0x12c>

    case PPP_FSM_ACKRCVD:
	/* Huh? an extra valid Ack? oh well... */
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 80145de:	68fa      	ldr	r2, [r7, #12]
 80145e0:	4b23      	ldr	r3, [pc, #140]	; (8014670 <fsm_rconfack+0x13c>)
 80145e2:	0011      	movs	r1, r2
 80145e4:	0018      	movs	r0, r3
 80145e6:	f7fd fb5f 	bl	8011ca8 <sys_untimeout>
	fsm_sconfreq(f, 0);
 80145ea:	68fb      	ldr	r3, [r7, #12]
 80145ec:	2100      	movs	r1, #0
 80145ee:	0018      	movs	r0, r3
 80145f0:	f000 fa30 	bl	8014a54 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 80145f4:	68fb      	ldr	r3, [r7, #12]
 80145f6:	2206      	movs	r2, #6
 80145f8:	741a      	strb	r2, [r3, #16]
	break;
 80145fa:	e031      	b.n	8014660 <fsm_rconfack+0x12c>

    case PPP_FSM_ACKSENT:
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 80145fc:	68fa      	ldr	r2, [r7, #12]
 80145fe:	4b1c      	ldr	r3, [pc, #112]	; (8014670 <fsm_rconfack+0x13c>)
 8014600:	0011      	movs	r1, r2
 8014602:	0018      	movs	r0, r3
 8014604:	f7fd fb50 	bl	8011ca8 <sys_untimeout>
	f->state = PPP_FSM_OPENED;
 8014608:	68fb      	ldr	r3, [r7, #12]
 801460a:	2209      	movs	r2, #9
 801460c:	741a      	strb	r2, [r3, #16]
	f->retransmits = pcb->settings.fsm_max_conf_req_transmits;
 801460e:	697b      	ldr	r3, [r7, #20]
 8014610:	795a      	ldrb	r2, [r3, #5]
 8014612:	68fb      	ldr	r3, [r7, #12]
 8014614:	751a      	strb	r2, [r3, #20]
	if (f->callbacks->up)
 8014616:	68fb      	ldr	r3, [r7, #12]
 8014618:	685b      	ldr	r3, [r3, #4]
 801461a:	69db      	ldr	r3, [r3, #28]
 801461c:	2b00      	cmp	r3, #0
 801461e:	d01e      	beq.n	801465e <fsm_rconfack+0x12a>
	    (*f->callbacks->up)(f);	/* Inform upper layers */
 8014620:	68fb      	ldr	r3, [r7, #12]
 8014622:	685b      	ldr	r3, [r3, #4]
 8014624:	69db      	ldr	r3, [r3, #28]
 8014626:	68fa      	ldr	r2, [r7, #12]
 8014628:	0010      	movs	r0, r2
 801462a:	4798      	blx	r3
	break;
 801462c:	e017      	b.n	801465e <fsm_rconfack+0x12a>

    case PPP_FSM_OPENED:
	/* Go down and restart negotiation */
	if (f->callbacks->down)
 801462e:	68fb      	ldr	r3, [r7, #12]
 8014630:	685b      	ldr	r3, [r3, #4]
 8014632:	6a1b      	ldr	r3, [r3, #32]
 8014634:	2b00      	cmp	r3, #0
 8014636:	d005      	beq.n	8014644 <fsm_rconfack+0x110>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
 8014638:	68fb      	ldr	r3, [r7, #12]
 801463a:	685b      	ldr	r3, [r3, #4]
 801463c:	6a1b      	ldr	r3, [r3, #32]
 801463e:	68fa      	ldr	r2, [r7, #12]
 8014640:	0010      	movs	r0, r2
 8014642:	4798      	blx	r3
	fsm_sconfreq(f, 0);		/* Send initial Configure-Request */
 8014644:	68fb      	ldr	r3, [r7, #12]
 8014646:	2100      	movs	r1, #0
 8014648:	0018      	movs	r0, r3
 801464a:	f000 fa03 	bl	8014a54 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 801464e:	68fb      	ldr	r3, [r7, #12]
 8014650:	2206      	movs	r2, #6
 8014652:	741a      	strb	r2, [r3, #16]
	break;
 8014654:	e004      	b.n	8014660 <fsm_rconfack+0x12c>
	return;					/* Nope, toss... */
 8014656:	46c0      	nop			; (mov r8, r8)
 8014658:	e002      	b.n	8014660 <fsm_rconfack+0x12c>
    default:
	break;
 801465a:	46c0      	nop			; (mov r8, r8)
 801465c:	e000      	b.n	8014660 <fsm_rconfack+0x12c>
	break;
 801465e:	46c0      	nop			; (mov r8, r8)
    }
}
 8014660:	46bd      	mov	sp, r7
 8014662:	b006      	add	sp, #24
 8014664:	bd80      	pop	{r7, pc}
 8014666:	46c0      	nop			; (mov r8, r8)
 8014668:	08020e08 	.word	0x08020e08
 801466c:	08021adc 	.word	0x08021adc
 8014670:	08014131 	.word	0x08014131

08014674 <fsm_rconfnakrej>:


/*
 * fsm_rconfnakrej - Receive Configure-Nak or Configure-Reject.
 */
static void fsm_rconfnakrej(fsm *f, int code, int id, u_char *inp, int len) {
 8014674:	b590      	push	{r4, r7, lr}
 8014676:	b089      	sub	sp, #36	; 0x24
 8014678:	af02      	add	r7, sp, #8
 801467a:	60f8      	str	r0, [r7, #12]
 801467c:	60b9      	str	r1, [r7, #8]
 801467e:	607a      	str	r2, [r7, #4]
 8014680:	603b      	str	r3, [r7, #0]
    int ret;
    int treat_as_reject;

    if (id != f->reqid || f->seen_ack)	/* Expected id? */
 8014682:	68fb      	ldr	r3, [r7, #12]
 8014684:	7cdb      	ldrb	r3, [r3, #19]
 8014686:	001a      	movs	r2, r3
 8014688:	687b      	ldr	r3, [r7, #4]
 801468a:	4293      	cmp	r3, r2
 801468c:	d000      	beq.n	8014690 <fsm_rconfnakrej+0x1c>
 801468e:	e096      	b.n	80147be <fsm_rconfnakrej+0x14a>
 8014690:	68fb      	ldr	r3, [r7, #12]
 8014692:	7b1b      	ldrb	r3, [r3, #12]
 8014694:	2b00      	cmp	r3, #0
 8014696:	d000      	beq.n	801469a <fsm_rconfnakrej+0x26>
 8014698:	e091      	b.n	80147be <fsm_rconfnakrej+0x14a>
	return;				/* Nope, toss... */

    if (code == CONFNAK) {
 801469a:	68bb      	ldr	r3, [r7, #8]
 801469c:	2b03      	cmp	r3, #3
 801469e:	d127      	bne.n	80146f0 <fsm_rconfnakrej+0x7c>
	++f->rnakloops;
 80146a0:	68fb      	ldr	r3, [r7, #12]
 80146a2:	7d9b      	ldrb	r3, [r3, #22]
 80146a4:	3301      	adds	r3, #1
 80146a6:	b2da      	uxtb	r2, r3
 80146a8:	68fb      	ldr	r3, [r7, #12]
 80146aa:	759a      	strb	r2, [r3, #22]
	treat_as_reject = (f->rnakloops >= f->maxnakloops);
 80146ac:	68fb      	ldr	r3, [r7, #12]
 80146ae:	7d99      	ldrb	r1, [r3, #22]
 80146b0:	68fb      	ldr	r3, [r7, #12]
 80146b2:	7dda      	ldrb	r2, [r3, #23]
 80146b4:	2300      	movs	r3, #0
 80146b6:	4291      	cmp	r1, r2
 80146b8:	415b      	adcs	r3, r3
 80146ba:	b2db      	uxtb	r3, r3
 80146bc:	613b      	str	r3, [r7, #16]
	if (f->callbacks->nakci == NULL
 80146be:	68fb      	ldr	r3, [r7, #12]
 80146c0:	685b      	ldr	r3, [r3, #4]
 80146c2:	691b      	ldr	r3, [r3, #16]
 80146c4:	2b00      	cmp	r3, #0
 80146c6:	d00c      	beq.n	80146e2 <fsm_rconfnakrej+0x6e>
	    || !(ret = f->callbacks->nakci(f, inp, len, treat_as_reject))) {
 80146c8:	68fb      	ldr	r3, [r7, #12]
 80146ca:	685b      	ldr	r3, [r3, #4]
 80146cc:	691c      	ldr	r4, [r3, #16]
 80146ce:	693b      	ldr	r3, [r7, #16]
 80146d0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80146d2:	6839      	ldr	r1, [r7, #0]
 80146d4:	68f8      	ldr	r0, [r7, #12]
 80146d6:	47a0      	blx	r4
 80146d8:	0003      	movs	r3, r0
 80146da:	617b      	str	r3, [r7, #20]
 80146dc:	697b      	ldr	r3, [r7, #20]
 80146de:	2b00      	cmp	r3, #0
 80146e0:	d121      	bne.n	8014726 <fsm_rconfnakrej+0xb2>
	    ppp_error("Received bad configure-nak: %P", inp, len);
 80146e2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80146e4:	6839      	ldr	r1, [r7, #0]
 80146e6:	4b39      	ldr	r3, [pc, #228]	; (80147cc <fsm_rconfnakrej+0x158>)
 80146e8:	0018      	movs	r0, r3
 80146ea:	f006 fd24 	bl	801b136 <ppp_error>
	    return;
 80146ee:	e069      	b.n	80147c4 <fsm_rconfnakrej+0x150>
	}
    } else {
	f->rnakloops = 0;
 80146f0:	68fb      	ldr	r3, [r7, #12]
 80146f2:	2200      	movs	r2, #0
 80146f4:	759a      	strb	r2, [r3, #22]
	if (f->callbacks->rejci == NULL
 80146f6:	68fb      	ldr	r3, [r7, #12]
 80146f8:	685b      	ldr	r3, [r3, #4]
 80146fa:	695b      	ldr	r3, [r3, #20]
 80146fc:	2b00      	cmp	r3, #0
 80146fe:	d00b      	beq.n	8014718 <fsm_rconfnakrej+0xa4>
	    || !(ret = f->callbacks->rejci(f, inp, len))) {
 8014700:	68fb      	ldr	r3, [r7, #12]
 8014702:	685b      	ldr	r3, [r3, #4]
 8014704:	695b      	ldr	r3, [r3, #20]
 8014706:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014708:	6839      	ldr	r1, [r7, #0]
 801470a:	68f8      	ldr	r0, [r7, #12]
 801470c:	4798      	blx	r3
 801470e:	0003      	movs	r3, r0
 8014710:	617b      	str	r3, [r7, #20]
 8014712:	697b      	ldr	r3, [r7, #20]
 8014714:	2b00      	cmp	r3, #0
 8014716:	d106      	bne.n	8014726 <fsm_rconfnakrej+0xb2>
	    ppp_error("Received bad configure-rej: %P", inp, len);
 8014718:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801471a:	6839      	ldr	r1, [r7, #0]
 801471c:	4b2c      	ldr	r3, [pc, #176]	; (80147d0 <fsm_rconfnakrej+0x15c>)
 801471e:	0018      	movs	r0, r3
 8014720:	f006 fd09 	bl	801b136 <ppp_error>
	    return;
 8014724:	e04e      	b.n	80147c4 <fsm_rconfnakrej+0x150>
	}
    }

    f->seen_ack = 1;
 8014726:	68fb      	ldr	r3, [r7, #12]
 8014728:	2201      	movs	r2, #1
 801472a:	731a      	strb	r2, [r3, #12]

    switch (f->state) {
 801472c:	68fb      	ldr	r3, [r7, #12]
 801472e:	7c1b      	ldrb	r3, [r3, #16]
 8014730:	2b09      	cmp	r3, #9
 8014732:	d846      	bhi.n	80147c2 <fsm_rconfnakrej+0x14e>
 8014734:	009a      	lsls	r2, r3, #2
 8014736:	4b27      	ldr	r3, [pc, #156]	; (80147d4 <fsm_rconfnakrej+0x160>)
 8014738:	18d3      	adds	r3, r2, r3
 801473a:	681b      	ldr	r3, [r3, #0]
 801473c:	469f      	mov	pc, r3
    case PPP_FSM_CLOSED:
    case PPP_FSM_STOPPED:
	fsm_sdata(f, TERMACK, id, NULL, 0);
 801473e:	687b      	ldr	r3, [r7, #4]
 8014740:	b2da      	uxtb	r2, r3
 8014742:	68f8      	ldr	r0, [r7, #12]
 8014744:	2300      	movs	r3, #0
 8014746:	9300      	str	r3, [sp, #0]
 8014748:	2300      	movs	r3, #0
 801474a:	2106      	movs	r1, #6
 801474c:	f000 fa78 	bl	8014c40 <fsm_sdata>
	break;
 8014750:	e038      	b.n	80147c4 <fsm_rconfnakrej+0x150>

    case PPP_FSM_REQSENT:
    case PPP_FSM_ACKSENT:
	/* They didn't agree to what we wanted - try another request */
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8014752:	68fa      	ldr	r2, [r7, #12]
 8014754:	4b20      	ldr	r3, [pc, #128]	; (80147d8 <fsm_rconfnakrej+0x164>)
 8014756:	0011      	movs	r1, r2
 8014758:	0018      	movs	r0, r3
 801475a:	f7fd faa5 	bl	8011ca8 <sys_untimeout>
	if (ret < 0)
 801475e:	697b      	ldr	r3, [r7, #20]
 8014760:	2b00      	cmp	r3, #0
 8014762:	da03      	bge.n	801476c <fsm_rconfnakrej+0xf8>
	    f->state = PPP_FSM_STOPPED;		/* kludge for stopping CCP */
 8014764:	68fb      	ldr	r3, [r7, #12]
 8014766:	2203      	movs	r2, #3
 8014768:	741a      	strb	r2, [r3, #16]
	else
	    fsm_sconfreq(f, 0);		/* Send Configure-Request */
	break;
 801476a:	e02b      	b.n	80147c4 <fsm_rconfnakrej+0x150>
	    fsm_sconfreq(f, 0);		/* Send Configure-Request */
 801476c:	68fb      	ldr	r3, [r7, #12]
 801476e:	2100      	movs	r1, #0
 8014770:	0018      	movs	r0, r3
 8014772:	f000 f96f 	bl	8014a54 <fsm_sconfreq>
	break;
 8014776:	e025      	b.n	80147c4 <fsm_rconfnakrej+0x150>

    case PPP_FSM_ACKRCVD:
	/* Got a Nak/reject when we had already had an Ack?? oh well... */
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8014778:	68fa      	ldr	r2, [r7, #12]
 801477a:	4b17      	ldr	r3, [pc, #92]	; (80147d8 <fsm_rconfnakrej+0x164>)
 801477c:	0011      	movs	r1, r2
 801477e:	0018      	movs	r0, r3
 8014780:	f7fd fa92 	bl	8011ca8 <sys_untimeout>
	fsm_sconfreq(f, 0);
 8014784:	68fb      	ldr	r3, [r7, #12]
 8014786:	2100      	movs	r1, #0
 8014788:	0018      	movs	r0, r3
 801478a:	f000 f963 	bl	8014a54 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 801478e:	68fb      	ldr	r3, [r7, #12]
 8014790:	2206      	movs	r2, #6
 8014792:	741a      	strb	r2, [r3, #16]
	break;
 8014794:	e016      	b.n	80147c4 <fsm_rconfnakrej+0x150>

    case PPP_FSM_OPENED:
	/* Go down and restart negotiation */
	if (f->callbacks->down)
 8014796:	68fb      	ldr	r3, [r7, #12]
 8014798:	685b      	ldr	r3, [r3, #4]
 801479a:	6a1b      	ldr	r3, [r3, #32]
 801479c:	2b00      	cmp	r3, #0
 801479e:	d005      	beq.n	80147ac <fsm_rconfnakrej+0x138>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
 80147a0:	68fb      	ldr	r3, [r7, #12]
 80147a2:	685b      	ldr	r3, [r3, #4]
 80147a4:	6a1b      	ldr	r3, [r3, #32]
 80147a6:	68fa      	ldr	r2, [r7, #12]
 80147a8:	0010      	movs	r0, r2
 80147aa:	4798      	blx	r3
	fsm_sconfreq(f, 0);		/* Send initial Configure-Request */
 80147ac:	68fb      	ldr	r3, [r7, #12]
 80147ae:	2100      	movs	r1, #0
 80147b0:	0018      	movs	r0, r3
 80147b2:	f000 f94f 	bl	8014a54 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 80147b6:	68fb      	ldr	r3, [r7, #12]
 80147b8:	2206      	movs	r2, #6
 80147ba:	741a      	strb	r2, [r3, #16]
	break;
 80147bc:	e002      	b.n	80147c4 <fsm_rconfnakrej+0x150>
	return;				/* Nope, toss... */
 80147be:	46c0      	nop			; (mov r8, r8)
 80147c0:	e000      	b.n	80147c4 <fsm_rconfnakrej+0x150>
    default:
	break;
 80147c2:	46c0      	nop			; (mov r8, r8)
    }
}
 80147c4:	46bd      	mov	sp, r7
 80147c6:	b007      	add	sp, #28
 80147c8:	bd90      	pop	{r4, r7, pc}
 80147ca:	46c0      	nop			; (mov r8, r8)
 80147cc:	08020e28 	.word	0x08020e28
 80147d0:	08020e48 	.word	0x08020e48
 80147d4:	08021b04 	.word	0x08021b04
 80147d8:	08014131 	.word	0x08014131

080147dc <fsm_rtermreq>:


/*
 * fsm_rtermreq - Receive Terminate-Req.
 */
static void fsm_rtermreq(fsm *f, int id, u_char *p, int len) {
 80147dc:	b580      	push	{r7, lr}
 80147de:	b088      	sub	sp, #32
 80147e0:	af02      	add	r7, sp, #8
 80147e2:	60f8      	str	r0, [r7, #12]
 80147e4:	60b9      	str	r1, [r7, #8]
 80147e6:	607a      	str	r2, [r7, #4]
 80147e8:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 80147ea:	68fb      	ldr	r3, [r7, #12]
 80147ec:	681b      	ldr	r3, [r3, #0]
 80147ee:	617b      	str	r3, [r7, #20]

    switch (f->state) {
 80147f0:	68fb      	ldr	r3, [r7, #12]
 80147f2:	7c1b      	ldrb	r3, [r3, #16]
 80147f4:	2b08      	cmp	r3, #8
 80147f6:	dc02      	bgt.n	80147fe <fsm_rtermreq+0x22>
 80147f8:	2b07      	cmp	r3, #7
 80147fa:	da03      	bge.n	8014804 <fsm_rtermreq+0x28>
	if (f->callbacks->down)
	    (*f->callbacks->down)(f);	/* Inform upper layers */
	TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
	break;
    default:
	break;
 80147fc:	e041      	b.n	8014882 <fsm_rtermreq+0xa6>
    switch (f->state) {
 80147fe:	2b09      	cmp	r3, #9
 8014800:	d004      	beq.n	801480c <fsm_rtermreq+0x30>
	break;
 8014802:	e03e      	b.n	8014882 <fsm_rtermreq+0xa6>
	f->state = PPP_FSM_REQSENT;		/* Start over but keep trying */
 8014804:	68fb      	ldr	r3, [r7, #12]
 8014806:	2206      	movs	r2, #6
 8014808:	741a      	strb	r2, [r3, #16]
	break;
 801480a:	e03a      	b.n	8014882 <fsm_rtermreq+0xa6>
	if (len > 0) {
 801480c:	683b      	ldr	r3, [r7, #0]
 801480e:	2b00      	cmp	r3, #0
 8014810:	dd08      	ble.n	8014824 <fsm_rtermreq+0x48>
	    ppp_info("%s terminated by peer (%0.*v)", PROTO_NAME(f), len, p);
 8014812:	68fb      	ldr	r3, [r7, #12]
 8014814:	685b      	ldr	r3, [r3, #4]
 8014816:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8014818:	687b      	ldr	r3, [r7, #4]
 801481a:	683a      	ldr	r2, [r7, #0]
 801481c:	481f      	ldr	r0, [pc, #124]	; (801489c <fsm_rtermreq+0xc0>)
 801481e:	f006 fcc6 	bl	801b1ae <ppp_info>
 8014822:	e007      	b.n	8014834 <fsm_rtermreq+0x58>
	    ppp_info("%s terminated by peer", PROTO_NAME(f));
 8014824:	68fb      	ldr	r3, [r7, #12]
 8014826:	685b      	ldr	r3, [r3, #4]
 8014828:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 801482a:	4b1d      	ldr	r3, [pc, #116]	; (80148a0 <fsm_rtermreq+0xc4>)
 801482c:	0011      	movs	r1, r2
 801482e:	0018      	movs	r0, r3
 8014830:	f006 fcbd 	bl	801b1ae <ppp_info>
	f->retransmits = 0;
 8014834:	68fb      	ldr	r3, [r7, #12]
 8014836:	2200      	movs	r2, #0
 8014838:	751a      	strb	r2, [r3, #20]
	f->state = PPP_FSM_STOPPING;
 801483a:	68fb      	ldr	r3, [r7, #12]
 801483c:	2205      	movs	r2, #5
 801483e:	741a      	strb	r2, [r3, #16]
	if (f->callbacks->down)
 8014840:	68fb      	ldr	r3, [r7, #12]
 8014842:	685b      	ldr	r3, [r3, #4]
 8014844:	6a1b      	ldr	r3, [r3, #32]
 8014846:	2b00      	cmp	r3, #0
 8014848:	d005      	beq.n	8014856 <fsm_rtermreq+0x7a>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
 801484a:	68fb      	ldr	r3, [r7, #12]
 801484c:	685b      	ldr	r3, [r3, #4]
 801484e:	6a1b      	ldr	r3, [r3, #32]
 8014850:	68fa      	ldr	r2, [r7, #12]
 8014852:	0010      	movs	r0, r2
 8014854:	4798      	blx	r3
	TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
 8014856:	68fa      	ldr	r2, [r7, #12]
 8014858:	4b12      	ldr	r3, [pc, #72]	; (80148a4 <fsm_rtermreq+0xc8>)
 801485a:	0011      	movs	r1, r2
 801485c:	0018      	movs	r0, r3
 801485e:	f7fd fa23 	bl	8011ca8 <sys_untimeout>
 8014862:	697b      	ldr	r3, [r7, #20]
 8014864:	791b      	ldrb	r3, [r3, #4]
 8014866:	001a      	movs	r2, r3
 8014868:	0013      	movs	r3, r2
 801486a:	015b      	lsls	r3, r3, #5
 801486c:	1a9b      	subs	r3, r3, r2
 801486e:	009b      	lsls	r3, r3, #2
 8014870:	189b      	adds	r3, r3, r2
 8014872:	00db      	lsls	r3, r3, #3
 8014874:	0018      	movs	r0, r3
 8014876:	68fa      	ldr	r2, [r7, #12]
 8014878:	4b0a      	ldr	r3, [pc, #40]	; (80148a4 <fsm_rtermreq+0xc8>)
 801487a:	0019      	movs	r1, r3
 801487c:	f7fd f9ec 	bl	8011c58 <sys_timeout>
	break;
 8014880:	46c0      	nop			; (mov r8, r8)
    }

    fsm_sdata(f, TERMACK, id, NULL, 0);
 8014882:	68bb      	ldr	r3, [r7, #8]
 8014884:	b2da      	uxtb	r2, r3
 8014886:	68f8      	ldr	r0, [r7, #12]
 8014888:	2300      	movs	r3, #0
 801488a:	9300      	str	r3, [sp, #0]
 801488c:	2300      	movs	r3, #0
 801488e:	2106      	movs	r1, #6
 8014890:	f000 f9d6 	bl	8014c40 <fsm_sdata>
}
 8014894:	46c0      	nop			; (mov r8, r8)
 8014896:	46bd      	mov	sp, r7
 8014898:	b006      	add	sp, #24
 801489a:	bd80      	pop	{r7, pc}
 801489c:	08020e68 	.word	0x08020e68
 80148a0:	08020e88 	.word	0x08020e88
 80148a4:	08014131 	.word	0x08014131

080148a8 <fsm_rtermack>:


/*
 * fsm_rtermack - Receive Terminate-Ack.
 */
static void fsm_rtermack(fsm *f) {
 80148a8:	b580      	push	{r7, lr}
 80148aa:	b082      	sub	sp, #8
 80148ac:	af00      	add	r7, sp, #0
 80148ae:	6078      	str	r0, [r7, #4]
    switch (f->state) {
 80148b0:	687b      	ldr	r3, [r7, #4]
 80148b2:	7c1b      	ldrb	r3, [r3, #16]
 80148b4:	2b09      	cmp	r3, #9
 80148b6:	d036      	beq.n	8014926 <fsm_rtermack+0x7e>
 80148b8:	dc49      	bgt.n	801494e <fsm_rtermack+0xa6>
 80148ba:	2b07      	cmp	r3, #7
 80148bc:	d02f      	beq.n	801491e <fsm_rtermack+0x76>
 80148be:	dc46      	bgt.n	801494e <fsm_rtermack+0xa6>
 80148c0:	2b04      	cmp	r3, #4
 80148c2:	d002      	beq.n	80148ca <fsm_rtermack+0x22>
 80148c4:	2b05      	cmp	r3, #5
 80148c6:	d015      	beq.n	80148f4 <fsm_rtermack+0x4c>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
	fsm_sconfreq(f, 0);
	f->state = PPP_FSM_REQSENT;
	break;
    default:
	break;
 80148c8:	e041      	b.n	801494e <fsm_rtermack+0xa6>
	UNTIMEOUT(fsm_timeout, f);
 80148ca:	687a      	ldr	r2, [r7, #4]
 80148cc:	4b24      	ldr	r3, [pc, #144]	; (8014960 <fsm_rtermack+0xb8>)
 80148ce:	0011      	movs	r1, r2
 80148d0:	0018      	movs	r0, r3
 80148d2:	f7fd f9e9 	bl	8011ca8 <sys_untimeout>
	f->state = PPP_FSM_CLOSED;
 80148d6:	687b      	ldr	r3, [r7, #4]
 80148d8:	2202      	movs	r2, #2
 80148da:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->finished )
 80148dc:	687b      	ldr	r3, [r7, #4]
 80148de:	685b      	ldr	r3, [r3, #4]
 80148e0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80148e2:	2b00      	cmp	r3, #0
 80148e4:	d035      	beq.n	8014952 <fsm_rtermack+0xaa>
	    (*f->callbacks->finished)(f);
 80148e6:	687b      	ldr	r3, [r7, #4]
 80148e8:	685b      	ldr	r3, [r3, #4]
 80148ea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80148ec:	687a      	ldr	r2, [r7, #4]
 80148ee:	0010      	movs	r0, r2
 80148f0:	4798      	blx	r3
	break;
 80148f2:	e02e      	b.n	8014952 <fsm_rtermack+0xaa>
	UNTIMEOUT(fsm_timeout, f);
 80148f4:	687a      	ldr	r2, [r7, #4]
 80148f6:	4b1a      	ldr	r3, [pc, #104]	; (8014960 <fsm_rtermack+0xb8>)
 80148f8:	0011      	movs	r1, r2
 80148fa:	0018      	movs	r0, r3
 80148fc:	f7fd f9d4 	bl	8011ca8 <sys_untimeout>
	f->state = PPP_FSM_STOPPED;
 8014900:	687b      	ldr	r3, [r7, #4]
 8014902:	2203      	movs	r2, #3
 8014904:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->finished )
 8014906:	687b      	ldr	r3, [r7, #4]
 8014908:	685b      	ldr	r3, [r3, #4]
 801490a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801490c:	2b00      	cmp	r3, #0
 801490e:	d022      	beq.n	8014956 <fsm_rtermack+0xae>
	    (*f->callbacks->finished)(f);
 8014910:	687b      	ldr	r3, [r7, #4]
 8014912:	685b      	ldr	r3, [r3, #4]
 8014914:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014916:	687a      	ldr	r2, [r7, #4]
 8014918:	0010      	movs	r0, r2
 801491a:	4798      	blx	r3
	break;
 801491c:	e01b      	b.n	8014956 <fsm_rtermack+0xae>
	f->state = PPP_FSM_REQSENT;
 801491e:	687b      	ldr	r3, [r7, #4]
 8014920:	2206      	movs	r2, #6
 8014922:	741a      	strb	r2, [r3, #16]
	break;
 8014924:	e018      	b.n	8014958 <fsm_rtermack+0xb0>
	if (f->callbacks->down)
 8014926:	687b      	ldr	r3, [r7, #4]
 8014928:	685b      	ldr	r3, [r3, #4]
 801492a:	6a1b      	ldr	r3, [r3, #32]
 801492c:	2b00      	cmp	r3, #0
 801492e:	d005      	beq.n	801493c <fsm_rtermack+0x94>
	    (*f->callbacks->down)(f);	/* Inform upper layers */
 8014930:	687b      	ldr	r3, [r7, #4]
 8014932:	685b      	ldr	r3, [r3, #4]
 8014934:	6a1b      	ldr	r3, [r3, #32]
 8014936:	687a      	ldr	r2, [r7, #4]
 8014938:	0010      	movs	r0, r2
 801493a:	4798      	blx	r3
	fsm_sconfreq(f, 0);
 801493c:	687b      	ldr	r3, [r7, #4]
 801493e:	2100      	movs	r1, #0
 8014940:	0018      	movs	r0, r3
 8014942:	f000 f887 	bl	8014a54 <fsm_sconfreq>
	f->state = PPP_FSM_REQSENT;
 8014946:	687b      	ldr	r3, [r7, #4]
 8014948:	2206      	movs	r2, #6
 801494a:	741a      	strb	r2, [r3, #16]
	break;
 801494c:	e004      	b.n	8014958 <fsm_rtermack+0xb0>
	break;
 801494e:	46c0      	nop			; (mov r8, r8)
 8014950:	e002      	b.n	8014958 <fsm_rtermack+0xb0>
	break;
 8014952:	46c0      	nop			; (mov r8, r8)
 8014954:	e000      	b.n	8014958 <fsm_rtermack+0xb0>
	break;
 8014956:	46c0      	nop			; (mov r8, r8)
    }
}
 8014958:	46c0      	nop			; (mov r8, r8)
 801495a:	46bd      	mov	sp, r7
 801495c:	b002      	add	sp, #8
 801495e:	bd80      	pop	{r7, pc}
 8014960:	08014131 	.word	0x08014131

08014964 <fsm_rcoderej>:


/*
 * fsm_rcoderej - Receive an Code-Reject.
 */
static void fsm_rcoderej(fsm *f, u_char *inp, int len) {
 8014964:	b590      	push	{r4, r7, lr}
 8014966:	b087      	sub	sp, #28
 8014968:	af00      	add	r7, sp, #0
 801496a:	60f8      	str	r0, [r7, #12]
 801496c:	60b9      	str	r1, [r7, #8]
 801496e:	607a      	str	r2, [r7, #4]
    u_char code, id;

    if (len < HEADERLEN) {
 8014970:	687b      	ldr	r3, [r7, #4]
 8014972:	2b03      	cmp	r3, #3
 8014974:	dd1f      	ble.n	80149b6 <fsm_rcoderej+0x52>
	FSMDEBUG(("fsm_rcoderej: Rcvd short Code-Reject packet!"));
	return;
    }
    GETCHAR(code, inp);
 8014976:	68bb      	ldr	r3, [r7, #8]
 8014978:	1c5a      	adds	r2, r3, #1
 801497a:	60ba      	str	r2, [r7, #8]
 801497c:	2017      	movs	r0, #23
 801497e:	183a      	adds	r2, r7, r0
 8014980:	781b      	ldrb	r3, [r3, #0]
 8014982:	7013      	strb	r3, [r2, #0]
    GETCHAR(id, inp);
 8014984:	68bb      	ldr	r3, [r7, #8]
 8014986:	1c5a      	adds	r2, r3, #1
 8014988:	60ba      	str	r2, [r7, #8]
 801498a:	2416      	movs	r4, #22
 801498c:	193a      	adds	r2, r7, r4
 801498e:	781b      	ldrb	r3, [r3, #0]
 8014990:	7013      	strb	r3, [r2, #0]
    ppp_warn("%s: Rcvd Code-Reject for code %d, id %d", PROTO_NAME(f), code, id);
 8014992:	68fb      	ldr	r3, [r7, #12]
 8014994:	685b      	ldr	r3, [r3, #4]
 8014996:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8014998:	183b      	adds	r3, r7, r0
 801499a:	781a      	ldrb	r2, [r3, #0]
 801499c:	193b      	adds	r3, r7, r4
 801499e:	781b      	ldrb	r3, [r3, #0]
 80149a0:	4807      	ldr	r0, [pc, #28]	; (80149c0 <fsm_rcoderej+0x5c>)
 80149a2:	f006 fbdc 	bl	801b15e <ppp_warn>

    if( f->state == PPP_FSM_ACKRCVD )
 80149a6:	68fb      	ldr	r3, [r7, #12]
 80149a8:	7c1b      	ldrb	r3, [r3, #16]
 80149aa:	2b07      	cmp	r3, #7
 80149ac:	d104      	bne.n	80149b8 <fsm_rcoderej+0x54>
	f->state = PPP_FSM_REQSENT;
 80149ae:	68fb      	ldr	r3, [r7, #12]
 80149b0:	2206      	movs	r2, #6
 80149b2:	741a      	strb	r2, [r3, #16]
 80149b4:	e000      	b.n	80149b8 <fsm_rcoderej+0x54>
	return;
 80149b6:	46c0      	nop			; (mov r8, r8)
}
 80149b8:	46bd      	mov	sp, r7
 80149ba:	b007      	add	sp, #28
 80149bc:	bd90      	pop	{r4, r7, pc}
 80149be:	46c0      	nop			; (mov r8, r8)
 80149c0:	08020ea0 	.word	0x08020ea0

080149c4 <fsm_protreject>:
/*
 * fsm_protreject - Peer doesn't speak this protocol.
 *
 * Treat this as a catastrophic error (RXJ-).
 */
void fsm_protreject(fsm *f) {
 80149c4:	b580      	push	{r7, lr}
 80149c6:	b082      	sub	sp, #8
 80149c8:	af00      	add	r7, sp, #0
 80149ca:	6078      	str	r0, [r7, #4]
    switch( f->state ){
 80149cc:	687b      	ldr	r3, [r7, #4]
 80149ce:	7c1b      	ldrb	r3, [r3, #16]
 80149d0:	2b09      	cmp	r3, #9
 80149d2:	d837      	bhi.n	8014a44 <fsm_protreject+0x80>
 80149d4:	009a      	lsls	r2, r3, #2
 80149d6:	4b1d      	ldr	r3, [pc, #116]	; (8014a4c <fsm_protreject+0x88>)
 80149d8:	18d3      	adds	r3, r2, r3
 80149da:	681b      	ldr	r3, [r3, #0]
 80149dc:	469f      	mov	pc, r3
    case PPP_FSM_CLOSING:
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 80149de:	687a      	ldr	r2, [r7, #4]
 80149e0:	4b1b      	ldr	r3, [pc, #108]	; (8014a50 <fsm_protreject+0x8c>)
 80149e2:	0011      	movs	r1, r2
 80149e4:	0018      	movs	r0, r3
 80149e6:	f7fd f95f 	bl	8011ca8 <sys_untimeout>
	/* fall through */
	/* no break */
    case PPP_FSM_CLOSED:
	f->state = PPP_FSM_CLOSED;
 80149ea:	687b      	ldr	r3, [r7, #4]
 80149ec:	2202      	movs	r2, #2
 80149ee:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->finished )
 80149f0:	687b      	ldr	r3, [r7, #4]
 80149f2:	685b      	ldr	r3, [r3, #4]
 80149f4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80149f6:	2b00      	cmp	r3, #0
 80149f8:	d021      	beq.n	8014a3e <fsm_protreject+0x7a>
	    (*f->callbacks->finished)(f);
 80149fa:	687b      	ldr	r3, [r7, #4]
 80149fc:	685b      	ldr	r3, [r3, #4]
 80149fe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014a00:	687a      	ldr	r2, [r7, #4]
 8014a02:	0010      	movs	r0, r2
 8014a04:	4798      	blx	r3
	break;
 8014a06:	e01a      	b.n	8014a3e <fsm_protreject+0x7a>

    case PPP_FSM_STOPPING:
    case PPP_FSM_REQSENT:
    case PPP_FSM_ACKRCVD:
    case PPP_FSM_ACKSENT:
	UNTIMEOUT(fsm_timeout, f);	/* Cancel timeout */
 8014a08:	687a      	ldr	r2, [r7, #4]
 8014a0a:	4b11      	ldr	r3, [pc, #68]	; (8014a50 <fsm_protreject+0x8c>)
 8014a0c:	0011      	movs	r1, r2
 8014a0e:	0018      	movs	r0, r3
 8014a10:	f7fd f94a 	bl	8011ca8 <sys_untimeout>
	/* fall through */
	/* no break */
    case PPP_FSM_STOPPED:
	f->state = PPP_FSM_STOPPED;
 8014a14:	687b      	ldr	r3, [r7, #4]
 8014a16:	2203      	movs	r2, #3
 8014a18:	741a      	strb	r2, [r3, #16]
	if( f->callbacks->finished )
 8014a1a:	687b      	ldr	r3, [r7, #4]
 8014a1c:	685b      	ldr	r3, [r3, #4]
 8014a1e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014a20:	2b00      	cmp	r3, #0
 8014a22:	d00e      	beq.n	8014a42 <fsm_protreject+0x7e>
	    (*f->callbacks->finished)(f);
 8014a24:	687b      	ldr	r3, [r7, #4]
 8014a26:	685b      	ldr	r3, [r3, #4]
 8014a28:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014a2a:	687a      	ldr	r2, [r7, #4]
 8014a2c:	0010      	movs	r0, r2
 8014a2e:	4798      	blx	r3
	break;
 8014a30:	e007      	b.n	8014a42 <fsm_protreject+0x7e>

    case PPP_FSM_OPENED:
	terminate_layer(f, PPP_FSM_STOPPING);
 8014a32:	687b      	ldr	r3, [r7, #4]
 8014a34:	2105      	movs	r1, #5
 8014a36:	0018      	movs	r0, r3
 8014a38:	f7ff fac0 	bl	8013fbc <terminate_layer>
	break;
 8014a3c:	e002      	b.n	8014a44 <fsm_protreject+0x80>
	break;
 8014a3e:	46c0      	nop			; (mov r8, r8)
 8014a40:	e000      	b.n	8014a44 <fsm_protreject+0x80>
	break;
 8014a42:	46c0      	nop			; (mov r8, r8)
    default:
	FSMDEBUG(("%s: Protocol-reject event in state %d!",
		  PROTO_NAME(f), f->state));
	/* no break */
    }
}
 8014a44:	46c0      	nop			; (mov r8, r8)
 8014a46:	46bd      	mov	sp, r7
 8014a48:	b002      	add	sp, #8
 8014a4a:	bd80      	pop	{r7, pc}
 8014a4c:	08021b2c 	.word	0x08021b2c
 8014a50:	08014131 	.word	0x08014131

08014a54 <fsm_sconfreq>:


/*
 * fsm_sconfreq - Send a Configure-Request.
 */
static void fsm_sconfreq(fsm *f, int retransmit) {
 8014a54:	b580      	push	{r7, lr}
 8014a56:	b086      	sub	sp, #24
 8014a58:	af00      	add	r7, sp, #0
 8014a5a:	6078      	str	r0, [r7, #4]
 8014a5c:	6039      	str	r1, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 8014a5e:	687b      	ldr	r3, [r7, #4]
 8014a60:	681b      	ldr	r3, [r3, #0]
 8014a62:	617b      	str	r3, [r7, #20]
    struct pbuf *p;
    u_char *outp;
    int cilen;

    if( f->state != PPP_FSM_REQSENT && f->state != PPP_FSM_ACKRCVD && f->state != PPP_FSM_ACKSENT ){
 8014a64:	687b      	ldr	r3, [r7, #4]
 8014a66:	7c1b      	ldrb	r3, [r3, #16]
 8014a68:	2b06      	cmp	r3, #6
 8014a6a:	d018      	beq.n	8014a9e <fsm_sconfreq+0x4a>
 8014a6c:	687b      	ldr	r3, [r7, #4]
 8014a6e:	7c1b      	ldrb	r3, [r3, #16]
 8014a70:	2b07      	cmp	r3, #7
 8014a72:	d014      	beq.n	8014a9e <fsm_sconfreq+0x4a>
 8014a74:	687b      	ldr	r3, [r7, #4]
 8014a76:	7c1b      	ldrb	r3, [r3, #16]
 8014a78:	2b08      	cmp	r3, #8
 8014a7a:	d010      	beq.n	8014a9e <fsm_sconfreq+0x4a>
	/* Not currently negotiating - reset options */
	if( f->callbacks->resetci )
 8014a7c:	687b      	ldr	r3, [r7, #4]
 8014a7e:	685b      	ldr	r3, [r3, #4]
 8014a80:	681b      	ldr	r3, [r3, #0]
 8014a82:	2b00      	cmp	r3, #0
 8014a84:	d005      	beq.n	8014a92 <fsm_sconfreq+0x3e>
	    (*f->callbacks->resetci)(f);
 8014a86:	687b      	ldr	r3, [r7, #4]
 8014a88:	685b      	ldr	r3, [r3, #4]
 8014a8a:	681b      	ldr	r3, [r3, #0]
 8014a8c:	687a      	ldr	r2, [r7, #4]
 8014a8e:	0010      	movs	r0, r2
 8014a90:	4798      	blx	r3
	f->nakloops = 0;
 8014a92:	687b      	ldr	r3, [r7, #4]
 8014a94:	2200      	movs	r2, #0
 8014a96:	755a      	strb	r2, [r3, #21]
	f->rnakloops = 0;
 8014a98:	687b      	ldr	r3, [r7, #4]
 8014a9a:	2200      	movs	r2, #0
 8014a9c:	759a      	strb	r2, [r3, #22]
    }

    if( !retransmit ){
 8014a9e:	683b      	ldr	r3, [r7, #0]
 8014aa0:	2b00      	cmp	r3, #0
 8014aa2:	d10d      	bne.n	8014ac0 <fsm_sconfreq+0x6c>
	/* New request - reset retransmission counter, use new ID */
	f->retransmits = pcb->settings.fsm_max_conf_req_transmits;
 8014aa4:	697b      	ldr	r3, [r7, #20]
 8014aa6:	795a      	ldrb	r2, [r3, #5]
 8014aa8:	687b      	ldr	r3, [r7, #4]
 8014aaa:	751a      	strb	r2, [r3, #20]
	f->reqid = ++f->id;
 8014aac:	687b      	ldr	r3, [r7, #4]
 8014aae:	7c9b      	ldrb	r3, [r3, #18]
 8014ab0:	3301      	adds	r3, #1
 8014ab2:	b2da      	uxtb	r2, r3
 8014ab4:	687b      	ldr	r3, [r7, #4]
 8014ab6:	749a      	strb	r2, [r3, #18]
 8014ab8:	687b      	ldr	r3, [r7, #4]
 8014aba:	7c9a      	ldrb	r2, [r3, #18]
 8014abc:	687b      	ldr	r3, [r7, #4]
 8014abe:	74da      	strb	r2, [r3, #19]
    }

    f->seen_ack = 0;
 8014ac0:	687b      	ldr	r3, [r7, #4]
 8014ac2:	2200      	movs	r2, #0
 8014ac4:	731a      	strb	r2, [r3, #12]

    /*
     * Make up the request packet
     */
    if( f->callbacks->cilen && f->callbacks->addci ){
 8014ac6:	687b      	ldr	r3, [r7, #4]
 8014ac8:	685b      	ldr	r3, [r3, #4]
 8014aca:	685b      	ldr	r3, [r3, #4]
 8014acc:	2b00      	cmp	r3, #0
 8014ace:	d019      	beq.n	8014b04 <fsm_sconfreq+0xb0>
 8014ad0:	687b      	ldr	r3, [r7, #4]
 8014ad2:	685b      	ldr	r3, [r3, #4]
 8014ad4:	689b      	ldr	r3, [r3, #8]
 8014ad6:	2b00      	cmp	r3, #0
 8014ad8:	d014      	beq.n	8014b04 <fsm_sconfreq+0xb0>
	cilen = (*f->callbacks->cilen)(f);
 8014ada:	687b      	ldr	r3, [r7, #4]
 8014adc:	685b      	ldr	r3, [r3, #4]
 8014ade:	685b      	ldr	r3, [r3, #4]
 8014ae0:	687a      	ldr	r2, [r7, #4]
 8014ae2:	0010      	movs	r0, r2
 8014ae4:	4798      	blx	r3
 8014ae6:	0003      	movs	r3, r0
 8014ae8:	60bb      	str	r3, [r7, #8]
	if( cilen > pcb->peer_mru - HEADERLEN )
 8014aea:	697b      	ldr	r3, [r7, #20]
 8014aec:	22d4      	movs	r2, #212	; 0xd4
 8014aee:	5a9b      	ldrh	r3, [r3, r2]
 8014af0:	1eda      	subs	r2, r3, #3
 8014af2:	68bb      	ldr	r3, [r7, #8]
 8014af4:	429a      	cmp	r2, r3
 8014af6:	dc07      	bgt.n	8014b08 <fsm_sconfreq+0xb4>
	    cilen = pcb->peer_mru - HEADERLEN;
 8014af8:	697b      	ldr	r3, [r7, #20]
 8014afa:	22d4      	movs	r2, #212	; 0xd4
 8014afc:	5a9b      	ldrh	r3, [r3, r2]
 8014afe:	3b04      	subs	r3, #4
 8014b00:	60bb      	str	r3, [r7, #8]
	if( cilen > pcb->peer_mru - HEADERLEN )
 8014b02:	e001      	b.n	8014b08 <fsm_sconfreq+0xb4>
    } else
	cilen = 0;
 8014b04:	2300      	movs	r3, #0
 8014b06:	60bb      	str	r3, [r7, #8]

    p = pbuf_alloc(PBUF_RAW, (u16_t)(cilen + HEADERLEN + PPP_HDRLEN), PPP_CTRL_PBUF_TYPE);
 8014b08:	68bb      	ldr	r3, [r7, #8]
 8014b0a:	b29b      	uxth	r3, r3
 8014b0c:	3308      	adds	r3, #8
 8014b0e:	b29b      	uxth	r3, r3
 8014b10:	22c1      	movs	r2, #193	; 0xc1
 8014b12:	0052      	lsls	r2, r2, #1
 8014b14:	0019      	movs	r1, r3
 8014b16:	2000      	movs	r0, #0
 8014b18:	f7f4 fa44 	bl	8008fa4 <pbuf_alloc>
 8014b1c:	0003      	movs	r3, r0
 8014b1e:	613b      	str	r3, [r7, #16]
    if(NULL == p)
 8014b20:	693b      	ldr	r3, [r7, #16]
 8014b22:	2b00      	cmp	r3, #0
 8014b24:	d100      	bne.n	8014b28 <fsm_sconfreq+0xd4>
 8014b26:	e07c      	b.n	8014c22 <fsm_sconfreq+0x1ce>
        return;
    if(p->tot_len != p->len) {
 8014b28:	693b      	ldr	r3, [r7, #16]
 8014b2a:	891a      	ldrh	r2, [r3, #8]
 8014b2c:	693b      	ldr	r3, [r7, #16]
 8014b2e:	895b      	ldrh	r3, [r3, #10]
 8014b30:	429a      	cmp	r2, r3
 8014b32:	d004      	beq.n	8014b3e <fsm_sconfreq+0xea>
        pbuf_free(p);
 8014b34:	693b      	ldr	r3, [r7, #16]
 8014b36:	0018      	movs	r0, r3
 8014b38:	f7f4 fdac 	bl	8009694 <pbuf_free>
        return;
 8014b3c:	e072      	b.n	8014c24 <fsm_sconfreq+0x1d0>
    }

    /* send the request to our peer */
    outp = (u_char*)p->payload;
 8014b3e:	693b      	ldr	r3, [r7, #16]
 8014b40:	685b      	ldr	r3, [r3, #4]
 8014b42:	60fb      	str	r3, [r7, #12]
    MAKEHEADER(outp, f->protocol);
 8014b44:	68fb      	ldr	r3, [r7, #12]
 8014b46:	1c5a      	adds	r2, r3, #1
 8014b48:	60fa      	str	r2, [r7, #12]
 8014b4a:	22ff      	movs	r2, #255	; 0xff
 8014b4c:	701a      	strb	r2, [r3, #0]
 8014b4e:	68fb      	ldr	r3, [r7, #12]
 8014b50:	1c5a      	adds	r2, r3, #1
 8014b52:	60fa      	str	r2, [r7, #12]
 8014b54:	2203      	movs	r2, #3
 8014b56:	701a      	strb	r2, [r3, #0]
 8014b58:	687b      	ldr	r3, [r7, #4]
 8014b5a:	89db      	ldrh	r3, [r3, #14]
 8014b5c:	0a1b      	lsrs	r3, r3, #8
 8014b5e:	b299      	uxth	r1, r3
 8014b60:	68fb      	ldr	r3, [r7, #12]
 8014b62:	1c5a      	adds	r2, r3, #1
 8014b64:	60fa      	str	r2, [r7, #12]
 8014b66:	b2ca      	uxtb	r2, r1
 8014b68:	701a      	strb	r2, [r3, #0]
 8014b6a:	687b      	ldr	r3, [r7, #4]
 8014b6c:	89d9      	ldrh	r1, [r3, #14]
 8014b6e:	68fb      	ldr	r3, [r7, #12]
 8014b70:	1c5a      	adds	r2, r3, #1
 8014b72:	60fa      	str	r2, [r7, #12]
 8014b74:	b2ca      	uxtb	r2, r1
 8014b76:	701a      	strb	r2, [r3, #0]
    PUTCHAR(CONFREQ, outp);
 8014b78:	68fb      	ldr	r3, [r7, #12]
 8014b7a:	1c5a      	adds	r2, r3, #1
 8014b7c:	60fa      	str	r2, [r7, #12]
 8014b7e:	2201      	movs	r2, #1
 8014b80:	701a      	strb	r2, [r3, #0]
    PUTCHAR(f->reqid, outp);
 8014b82:	68fb      	ldr	r3, [r7, #12]
 8014b84:	1c5a      	adds	r2, r3, #1
 8014b86:	60fa      	str	r2, [r7, #12]
 8014b88:	687a      	ldr	r2, [r7, #4]
 8014b8a:	7cd2      	ldrb	r2, [r2, #19]
 8014b8c:	701a      	strb	r2, [r3, #0]
    PUTSHORT(cilen + HEADERLEN, outp);
 8014b8e:	68bb      	ldr	r3, [r7, #8]
 8014b90:	3304      	adds	r3, #4
 8014b92:	1219      	asrs	r1, r3, #8
 8014b94:	68fb      	ldr	r3, [r7, #12]
 8014b96:	1c5a      	adds	r2, r3, #1
 8014b98:	60fa      	str	r2, [r7, #12]
 8014b9a:	b2ca      	uxtb	r2, r1
 8014b9c:	701a      	strb	r2, [r3, #0]
 8014b9e:	68bb      	ldr	r3, [r7, #8]
 8014ba0:	b2da      	uxtb	r2, r3
 8014ba2:	68fb      	ldr	r3, [r7, #12]
 8014ba4:	1c59      	adds	r1, r3, #1
 8014ba6:	60f9      	str	r1, [r7, #12]
 8014ba8:	3204      	adds	r2, #4
 8014baa:	b2d2      	uxtb	r2, r2
 8014bac:	701a      	strb	r2, [r3, #0]
    if (cilen != 0) {
 8014bae:	68bb      	ldr	r3, [r7, #8]
 8014bb0:	2b00      	cmp	r3, #0
 8014bb2:	d014      	beq.n	8014bde <fsm_sconfreq+0x18a>
	(*f->callbacks->addci)(f, outp, &cilen);
 8014bb4:	687b      	ldr	r3, [r7, #4]
 8014bb6:	685b      	ldr	r3, [r3, #4]
 8014bb8:	689b      	ldr	r3, [r3, #8]
 8014bba:	2208      	movs	r2, #8
 8014bbc:	18ba      	adds	r2, r7, r2
 8014bbe:	68f9      	ldr	r1, [r7, #12]
 8014bc0:	6878      	ldr	r0, [r7, #4]
 8014bc2:	4798      	blx	r3
	LWIP_ASSERT("cilen == p->len - HEADERLEN - PPP_HDRLEN", cilen == p->len - HEADERLEN - PPP_HDRLEN);
 8014bc4:	693b      	ldr	r3, [r7, #16]
 8014bc6:	895b      	ldrh	r3, [r3, #10]
 8014bc8:	3b08      	subs	r3, #8
 8014bca:	001a      	movs	r2, r3
 8014bcc:	68bb      	ldr	r3, [r7, #8]
 8014bce:	429a      	cmp	r2, r3
 8014bd0:	d005      	beq.n	8014bde <fsm_sconfreq+0x18a>
 8014bd2:	4b16      	ldr	r3, [pc, #88]	; (8014c2c <fsm_sconfreq+0x1d8>)
 8014bd4:	4a16      	ldr	r2, [pc, #88]	; (8014c30 <fsm_sconfreq+0x1dc>)
 8014bd6:	4917      	ldr	r1, [pc, #92]	; (8014c34 <fsm_sconfreq+0x1e0>)
 8014bd8:	4817      	ldr	r0, [pc, #92]	; (8014c38 <fsm_sconfreq+0x1e4>)
 8014bda:	f7ed faf7 	bl	80021cc <app_debug_rtt_raw>
    }

    ppp_write(pcb, p);
 8014bde:	693a      	ldr	r2, [r7, #16]
 8014be0:	697b      	ldr	r3, [r7, #20]
 8014be2:	0011      	movs	r1, r2
 8014be4:	0018      	movs	r0, r3
 8014be6:	f004 ffd9 	bl	8019b9c <ppp_write>

    /* start the retransmit timer */
    --f->retransmits;
 8014bea:	687b      	ldr	r3, [r7, #4]
 8014bec:	7d1b      	ldrb	r3, [r3, #20]
 8014bee:	3b01      	subs	r3, #1
 8014bf0:	b2da      	uxtb	r2, r3
 8014bf2:	687b      	ldr	r3, [r7, #4]
 8014bf4:	751a      	strb	r2, [r3, #20]
    TIMEOUT(fsm_timeout, f, pcb->settings.fsm_timeout_time);
 8014bf6:	687a      	ldr	r2, [r7, #4]
 8014bf8:	4b10      	ldr	r3, [pc, #64]	; (8014c3c <fsm_sconfreq+0x1e8>)
 8014bfa:	0011      	movs	r1, r2
 8014bfc:	0018      	movs	r0, r3
 8014bfe:	f7fd f853 	bl	8011ca8 <sys_untimeout>
 8014c02:	697b      	ldr	r3, [r7, #20]
 8014c04:	791b      	ldrb	r3, [r3, #4]
 8014c06:	001a      	movs	r2, r3
 8014c08:	0013      	movs	r3, r2
 8014c0a:	015b      	lsls	r3, r3, #5
 8014c0c:	1a9b      	subs	r3, r3, r2
 8014c0e:	009b      	lsls	r3, r3, #2
 8014c10:	189b      	adds	r3, r3, r2
 8014c12:	00db      	lsls	r3, r3, #3
 8014c14:	0018      	movs	r0, r3
 8014c16:	687a      	ldr	r2, [r7, #4]
 8014c18:	4b08      	ldr	r3, [pc, #32]	; (8014c3c <fsm_sconfreq+0x1e8>)
 8014c1a:	0019      	movs	r1, r3
 8014c1c:	f7fd f81c 	bl	8011c58 <sys_timeout>
 8014c20:	e000      	b.n	8014c24 <fsm_sconfreq+0x1d0>
        return;
 8014c22:	46c0      	nop			; (mov r8, r8)
}
 8014c24:	46bd      	mov	sp, r7
 8014c26:	b006      	add	sp, #24
 8014c28:	bd80      	pop	{r7, pc}
 8014c2a:	46c0      	nop			; (mov r8, r8)
 8014c2c:	08020ec8 	.word	0x08020ec8
 8014c30:	000002f2 	.word	0x000002f2
 8014c34:	08020ef4 	.word	0x08020ef4
 8014c38:	08020f20 	.word	0x08020f20
 8014c3c:	08014131 	.word	0x08014131

08014c40 <fsm_sdata>:
/*
 * fsm_sdata - Send some data.
 *
 * Used for all packets sent to our peer by this module.
 */
void fsm_sdata(fsm *f, u_char code, u_char id, const u_char *data, int datalen) {
 8014c40:	b580      	push	{r7, lr}
 8014c42:	b088      	sub	sp, #32
 8014c44:	af00      	add	r7, sp, #0
 8014c46:	60f8      	str	r0, [r7, #12]
 8014c48:	0008      	movs	r0, r1
 8014c4a:	0011      	movs	r1, r2
 8014c4c:	607b      	str	r3, [r7, #4]
 8014c4e:	230b      	movs	r3, #11
 8014c50:	18fb      	adds	r3, r7, r3
 8014c52:	1c02      	adds	r2, r0, #0
 8014c54:	701a      	strb	r2, [r3, #0]
 8014c56:	230a      	movs	r3, #10
 8014c58:	18fb      	adds	r3, r7, r3
 8014c5a:	1c0a      	adds	r2, r1, #0
 8014c5c:	701a      	strb	r2, [r3, #0]
    ppp_pcb *pcb = f->pcb;
 8014c5e:	68fb      	ldr	r3, [r7, #12]
 8014c60:	681b      	ldr	r3, [r3, #0]
 8014c62:	61fb      	str	r3, [r7, #28]
    struct pbuf *p;
    u_char *outp;
    int outlen;

    /* Adjust length to be smaller than MTU */
    if (datalen > pcb->peer_mru - HEADERLEN)
 8014c64:	69fb      	ldr	r3, [r7, #28]
 8014c66:	22d4      	movs	r2, #212	; 0xd4
 8014c68:	5a9b      	ldrh	r3, [r3, r2]
 8014c6a:	3b03      	subs	r3, #3
 8014c6c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014c6e:	429a      	cmp	r2, r3
 8014c70:	db04      	blt.n	8014c7c <fsm_sdata+0x3c>
	datalen = pcb->peer_mru - HEADERLEN;
 8014c72:	69fb      	ldr	r3, [r7, #28]
 8014c74:	22d4      	movs	r2, #212	; 0xd4
 8014c76:	5a9b      	ldrh	r3, [r3, r2]
 8014c78:	3b04      	subs	r3, #4
 8014c7a:	62bb      	str	r3, [r7, #40]	; 0x28
    outlen = datalen + HEADERLEN;
 8014c7c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014c7e:	3304      	adds	r3, #4
 8014c80:	61bb      	str	r3, [r7, #24]

    p = pbuf_alloc(PBUF_RAW, (u16_t)(outlen + PPP_HDRLEN), PPP_CTRL_PBUF_TYPE);
 8014c82:	69bb      	ldr	r3, [r7, #24]
 8014c84:	b29b      	uxth	r3, r3
 8014c86:	3304      	adds	r3, #4
 8014c88:	b29b      	uxth	r3, r3
 8014c8a:	22c1      	movs	r2, #193	; 0xc1
 8014c8c:	0052      	lsls	r2, r2, #1
 8014c8e:	0019      	movs	r1, r3
 8014c90:	2000      	movs	r0, #0
 8014c92:	f7f4 f987 	bl	8008fa4 <pbuf_alloc>
 8014c96:	0003      	movs	r3, r0
 8014c98:	617b      	str	r3, [r7, #20]
    if(NULL == p)
 8014c9a:	697b      	ldr	r3, [r7, #20]
 8014c9c:	2b00      	cmp	r3, #0
 8014c9e:	d053      	beq.n	8014d48 <fsm_sdata+0x108>
        return;
    if(p->tot_len != p->len) {
 8014ca0:	697b      	ldr	r3, [r7, #20]
 8014ca2:	891a      	ldrh	r2, [r3, #8]
 8014ca4:	697b      	ldr	r3, [r7, #20]
 8014ca6:	895b      	ldrh	r3, [r3, #10]
 8014ca8:	429a      	cmp	r2, r3
 8014caa:	d004      	beq.n	8014cb6 <fsm_sdata+0x76>
        pbuf_free(p);
 8014cac:	697b      	ldr	r3, [r7, #20]
 8014cae:	0018      	movs	r0, r3
 8014cb0:	f7f4 fcf0 	bl	8009694 <pbuf_free>
        return;
 8014cb4:	e049      	b.n	8014d4a <fsm_sdata+0x10a>
    }

    outp = (u_char*)p->payload;
 8014cb6:	697b      	ldr	r3, [r7, #20]
 8014cb8:	685b      	ldr	r3, [r3, #4]
 8014cba:	613b      	str	r3, [r7, #16]
    if (datalen) /* && data != outp + PPP_HDRLEN + HEADERLEN)  -- was only for fsm_sconfreq() */
 8014cbc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014cbe:	2b00      	cmp	r3, #0
 8014cc0:	d006      	beq.n	8014cd0 <fsm_sdata+0x90>
	MEMCPY(outp + PPP_HDRLEN + HEADERLEN, data, datalen);
 8014cc2:	693b      	ldr	r3, [r7, #16]
 8014cc4:	3308      	adds	r3, #8
 8014cc6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8014cc8:	6879      	ldr	r1, [r7, #4]
 8014cca:	0018      	movs	r0, r3
 8014ccc:	f007 fd92 	bl	801c7f4 <memcpy>
    MAKEHEADER(outp, f->protocol);
 8014cd0:	693b      	ldr	r3, [r7, #16]
 8014cd2:	1c5a      	adds	r2, r3, #1
 8014cd4:	613a      	str	r2, [r7, #16]
 8014cd6:	22ff      	movs	r2, #255	; 0xff
 8014cd8:	701a      	strb	r2, [r3, #0]
 8014cda:	693b      	ldr	r3, [r7, #16]
 8014cdc:	1c5a      	adds	r2, r3, #1
 8014cde:	613a      	str	r2, [r7, #16]
 8014ce0:	2203      	movs	r2, #3
 8014ce2:	701a      	strb	r2, [r3, #0]
 8014ce4:	68fb      	ldr	r3, [r7, #12]
 8014ce6:	89db      	ldrh	r3, [r3, #14]
 8014ce8:	0a1b      	lsrs	r3, r3, #8
 8014cea:	b299      	uxth	r1, r3
 8014cec:	693b      	ldr	r3, [r7, #16]
 8014cee:	1c5a      	adds	r2, r3, #1
 8014cf0:	613a      	str	r2, [r7, #16]
 8014cf2:	b2ca      	uxtb	r2, r1
 8014cf4:	701a      	strb	r2, [r3, #0]
 8014cf6:	68fb      	ldr	r3, [r7, #12]
 8014cf8:	89d9      	ldrh	r1, [r3, #14]
 8014cfa:	693b      	ldr	r3, [r7, #16]
 8014cfc:	1c5a      	adds	r2, r3, #1
 8014cfe:	613a      	str	r2, [r7, #16]
 8014d00:	b2ca      	uxtb	r2, r1
 8014d02:	701a      	strb	r2, [r3, #0]
    PUTCHAR(code, outp);
 8014d04:	693b      	ldr	r3, [r7, #16]
 8014d06:	1c5a      	adds	r2, r3, #1
 8014d08:	613a      	str	r2, [r7, #16]
 8014d0a:	220b      	movs	r2, #11
 8014d0c:	18ba      	adds	r2, r7, r2
 8014d0e:	7812      	ldrb	r2, [r2, #0]
 8014d10:	701a      	strb	r2, [r3, #0]
    PUTCHAR(id, outp);
 8014d12:	693b      	ldr	r3, [r7, #16]
 8014d14:	1c5a      	adds	r2, r3, #1
 8014d16:	613a      	str	r2, [r7, #16]
 8014d18:	220a      	movs	r2, #10
 8014d1a:	18ba      	adds	r2, r7, r2
 8014d1c:	7812      	ldrb	r2, [r2, #0]
 8014d1e:	701a      	strb	r2, [r3, #0]
    PUTSHORT(outlen, outp);
 8014d20:	69bb      	ldr	r3, [r7, #24]
 8014d22:	1219      	asrs	r1, r3, #8
 8014d24:	693b      	ldr	r3, [r7, #16]
 8014d26:	1c5a      	adds	r2, r3, #1
 8014d28:	613a      	str	r2, [r7, #16]
 8014d2a:	b2ca      	uxtb	r2, r1
 8014d2c:	701a      	strb	r2, [r3, #0]
 8014d2e:	693b      	ldr	r3, [r7, #16]
 8014d30:	1c5a      	adds	r2, r3, #1
 8014d32:	613a      	str	r2, [r7, #16]
 8014d34:	69ba      	ldr	r2, [r7, #24]
 8014d36:	b2d2      	uxtb	r2, r2
 8014d38:	701a      	strb	r2, [r3, #0]
    ppp_write(pcb, p);
 8014d3a:	697a      	ldr	r2, [r7, #20]
 8014d3c:	69fb      	ldr	r3, [r7, #28]
 8014d3e:	0011      	movs	r1, r2
 8014d40:	0018      	movs	r0, r3
 8014d42:	f004 ff2b 	bl	8019b9c <ppp_write>
 8014d46:	e000      	b.n	8014d4a <fsm_sdata+0x10a>
        return;
 8014d48:	46c0      	nop			; (mov r8, r8)
}
 8014d4a:	46bd      	mov	sp, r7
 8014d4c:	b008      	add	sp, #32
 8014d4e:	bd80      	pop	{r7, pc}

08014d50 <ipcp_init>:
#endif /* PPP_OPTIONS */

/*
 * ipcp_init - Initialize IPCP.
 */
static void ipcp_init(ppp_pcb *pcb) {
 8014d50:	b580      	push	{r7, lr}
 8014d52:	b086      	sub	sp, #24
 8014d54:	af00      	add	r7, sp, #0
 8014d56:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 8014d58:	687b      	ldr	r3, [r7, #4]
 8014d5a:	4a34      	ldr	r2, [pc, #208]	; (8014e2c <ipcp_init+0xdc>)
 8014d5c:	4694      	mov	ip, r2
 8014d5e:	4463      	add	r3, ip
 8014d60:	617b      	str	r3, [r7, #20]

    ipcp_options *wo = &pcb->ipcp_wantoptions;
 8014d62:	687b      	ldr	r3, [r7, #4]
 8014d64:	4a32      	ldr	r2, [pc, #200]	; (8014e30 <ipcp_init+0xe0>)
 8014d66:	4694      	mov	ip, r2
 8014d68:	4463      	add	r3, ip
 8014d6a:	613b      	str	r3, [r7, #16]
    ipcp_options *ao = &pcb->ipcp_allowoptions;
 8014d6c:	687b      	ldr	r3, [r7, #4]
 8014d6e:	4a31      	ldr	r2, [pc, #196]	; (8014e34 <ipcp_init+0xe4>)
 8014d70:	4694      	mov	ip, r2
 8014d72:	4463      	add	r3, ip
 8014d74:	60fb      	str	r3, [r7, #12]

    f->pcb = pcb;
 8014d76:	697b      	ldr	r3, [r7, #20]
 8014d78:	687a      	ldr	r2, [r7, #4]
 8014d7a:	601a      	str	r2, [r3, #0]
    f->protocol = PPP_IPCP;
 8014d7c:	697b      	ldr	r3, [r7, #20]
 8014d7e:	4a2e      	ldr	r2, [pc, #184]	; (8014e38 <ipcp_init+0xe8>)
 8014d80:	81da      	strh	r2, [r3, #14]
    f->callbacks = &ipcp_callbacks;
 8014d82:	697b      	ldr	r3, [r7, #20]
 8014d84:	4a2d      	ldr	r2, [pc, #180]	; (8014e3c <ipcp_init+0xec>)
 8014d86:	605a      	str	r2, [r3, #4]
    fsm_init(f);
 8014d88:	697b      	ldr	r3, [r7, #20]
 8014d8a:	0018      	movs	r0, r3
 8014d8c:	f7ff f83c 	bl	8013e08 <fsm_init>
     * Some 3G modems use repeated IPCP NAKs as a way of stalling
     * until they can contact a server on the network, so we increase
     * the default number of NAKs we accept before we start treating
     * them as rejects.
     */
    f->maxnakloops = 100;
 8014d90:	697b      	ldr	r3, [r7, #20]
 8014d92:	2264      	movs	r2, #100	; 0x64
 8014d94:	75da      	strb	r2, [r3, #23]
#if 0 /* Not necessary, everything is cleared in ppp_new() */
    memset(wo, 0, sizeof(*wo));
    memset(ao, 0, sizeof(*ao));
#endif /* 0 */

    wo->neg_addr = wo->old_addrs = 1;
 8014d96:	693b      	ldr	r3, [r7, #16]
 8014d98:	781a      	ldrb	r2, [r3, #0]
 8014d9a:	2102      	movs	r1, #2
 8014d9c:	430a      	orrs	r2, r1
 8014d9e:	701a      	strb	r2, [r3, #0]
 8014da0:	693b      	ldr	r3, [r7, #16]
 8014da2:	781b      	ldrb	r3, [r3, #0]
 8014da4:	079b      	lsls	r3, r3, #30
 8014da6:	0fdb      	lsrs	r3, r3, #31
 8014da8:	b2da      	uxtb	r2, r3
 8014daa:	693b      	ldr	r3, [r7, #16]
 8014dac:	2101      	movs	r1, #1
 8014dae:	400a      	ands	r2, r1
 8014db0:	0010      	movs	r0, r2
 8014db2:	781a      	ldrb	r2, [r3, #0]
 8014db4:	2101      	movs	r1, #1
 8014db6:	438a      	bics	r2, r1
 8014db8:	1c11      	adds	r1, r2, #0
 8014dba:	1c02      	adds	r2, r0, #0
 8014dbc:	430a      	orrs	r2, r1
 8014dbe:	701a      	strb	r2, [r3, #0]
#if VJ_SUPPORT
    wo->neg_vj = 1;
 8014dc0:	693b      	ldr	r3, [r7, #16]
 8014dc2:	781a      	ldrb	r2, [r3, #0]
 8014dc4:	2108      	movs	r1, #8
 8014dc6:	430a      	orrs	r2, r1
 8014dc8:	701a      	strb	r2, [r3, #0]
    wo->vj_protocol = IPCP_VJ_COMP;
 8014dca:	693b      	ldr	r3, [r7, #16]
 8014dcc:	222d      	movs	r2, #45	; 0x2d
 8014dce:	829a      	strh	r2, [r3, #20]
    wo->maxslotindex = MAX_STATES - 1; /* really max index */
 8014dd0:	693b      	ldr	r3, [r7, #16]
 8014dd2:	220f      	movs	r2, #15
 8014dd4:	759a      	strb	r2, [r3, #22]
    wo->cflag = 1;
 8014dd6:	693b      	ldr	r3, [r7, #16]
 8014dd8:	781a      	ldrb	r2, [r3, #0]
 8014dda:	2120      	movs	r1, #32
 8014ddc:	430a      	orrs	r2, r1
 8014dde:	701a      	strb	r2, [r3, #0]
#if 0 /* UNUSED */
    /* wanting default route by default */
    wo->default_route = 1;
#endif /* UNUSED */

    ao->neg_addr = ao->old_addrs = 1;
 8014de0:	68fb      	ldr	r3, [r7, #12]
 8014de2:	781a      	ldrb	r2, [r3, #0]
 8014de4:	2102      	movs	r1, #2
 8014de6:	430a      	orrs	r2, r1
 8014de8:	701a      	strb	r2, [r3, #0]
 8014dea:	68fb      	ldr	r3, [r7, #12]
 8014dec:	781b      	ldrb	r3, [r3, #0]
 8014dee:	079b      	lsls	r3, r3, #30
 8014df0:	0fdb      	lsrs	r3, r3, #31
 8014df2:	b2da      	uxtb	r2, r3
 8014df4:	68fb      	ldr	r3, [r7, #12]
 8014df6:	2101      	movs	r1, #1
 8014df8:	400a      	ands	r2, r1
 8014dfa:	0010      	movs	r0, r2
 8014dfc:	781a      	ldrb	r2, [r3, #0]
 8014dfe:	2101      	movs	r1, #1
 8014e00:	438a      	bics	r2, r1
 8014e02:	1c11      	adds	r1, r2, #0
 8014e04:	1c02      	adds	r2, r0, #0
 8014e06:	430a      	orrs	r2, r1
 8014e08:	701a      	strb	r2, [r3, #0]
#if VJ_SUPPORT
    /* max slots and slot-id compression are currently hardwired in */
    /* ppp_if.c to 16 and 1, this needs to be changed (among other */
    /* things) gmc */

    ao->neg_vj = 1;
 8014e0a:	68fb      	ldr	r3, [r7, #12]
 8014e0c:	781a      	ldrb	r2, [r3, #0]
 8014e0e:	2108      	movs	r1, #8
 8014e10:	430a      	orrs	r2, r1
 8014e12:	701a      	strb	r2, [r3, #0]
    ao->maxslotindex = MAX_STATES - 1;
 8014e14:	68fb      	ldr	r3, [r7, #12]
 8014e16:	220f      	movs	r2, #15
 8014e18:	759a      	strb	r2, [r3, #22]
    ao->cflag = 1;
 8014e1a:	68fb      	ldr	r3, [r7, #12]
 8014e1c:	781a      	ldrb	r2, [r3, #0]
 8014e1e:	2120      	movs	r1, #32
 8014e20:	430a      	orrs	r2, r1
 8014e22:	701a      	strb	r2, [r3, #0]
     * and defaultroute options.
     */
    ao->proxy_arp = 1;
    ao->default_route = 1;
#endif /* UNUSED */
}
 8014e24:	46c0      	nop			; (mov r8, r8)
 8014e26:	46bd      	mov	sp, r7
 8014e28:	b006      	add	sp, #24
 8014e2a:	bd80      	pop	{r7, pc}
 8014e2c:	000011e8 	.word	0x000011e8
 8014e30:	00001204 	.word	0x00001204
 8014e34:	00001234 	.word	0x00001234
 8014e38:	ffff8021 	.word	0xffff8021
 8014e3c:	08021b54 	.word	0x08021b54

08014e40 <ipcp_open>:


/*
 * ipcp_open - IPCP is allowed to come up.
 */
static void ipcp_open(ppp_pcb *pcb) {
 8014e40:	b580      	push	{r7, lr}
 8014e42:	b084      	sub	sp, #16
 8014e44:	af00      	add	r7, sp, #0
 8014e46:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 8014e48:	687b      	ldr	r3, [r7, #4]
 8014e4a:	4a09      	ldr	r2, [pc, #36]	; (8014e70 <ipcp_open+0x30>)
 8014e4c:	4694      	mov	ip, r2
 8014e4e:	4463      	add	r3, ip
 8014e50:	60fb      	str	r3, [r7, #12]
    fsm_open(f);
 8014e52:	68fb      	ldr	r3, [r7, #12]
 8014e54:	0018      	movs	r0, r3
 8014e56:	f7ff f865 	bl	8013f24 <fsm_open>
    pcb->ipcp_is_open = 1;
 8014e5a:	687b      	ldr	r3, [r7, #4]
 8014e5c:	2226      	movs	r2, #38	; 0x26
 8014e5e:	5c99      	ldrb	r1, [r3, r2]
 8014e60:	2002      	movs	r0, #2
 8014e62:	4301      	orrs	r1, r0
 8014e64:	5499      	strb	r1, [r3, r2]
}
 8014e66:	46c0      	nop			; (mov r8, r8)
 8014e68:	46bd      	mov	sp, r7
 8014e6a:	b004      	add	sp, #16
 8014e6c:	bd80      	pop	{r7, pc}
 8014e6e:	46c0      	nop			; (mov r8, r8)
 8014e70:	000011e8 	.word	0x000011e8

08014e74 <ipcp_close>:


/*
 * ipcp_close - Take IPCP down.
 */
static void ipcp_close(ppp_pcb *pcb, const char *reason) {
 8014e74:	b580      	push	{r7, lr}
 8014e76:	b084      	sub	sp, #16
 8014e78:	af00      	add	r7, sp, #0
 8014e7a:	6078      	str	r0, [r7, #4]
 8014e7c:	6039      	str	r1, [r7, #0]
    fsm *f = &pcb->ipcp_fsm;
 8014e7e:	687b      	ldr	r3, [r7, #4]
 8014e80:	4a06      	ldr	r2, [pc, #24]	; (8014e9c <ipcp_close+0x28>)
 8014e82:	4694      	mov	ip, r2
 8014e84:	4463      	add	r3, ip
 8014e86:	60fb      	str	r3, [r7, #12]
    fsm_close(f, reason);
 8014e88:	683a      	ldr	r2, [r7, #0]
 8014e8a:	68fb      	ldr	r3, [r7, #12]
 8014e8c:	0011      	movs	r1, r2
 8014e8e:	0018      	movs	r0, r3
 8014e90:	f7ff f90a 	bl	80140a8 <fsm_close>
}
 8014e94:	46c0      	nop			; (mov r8, r8)
 8014e96:	46bd      	mov	sp, r7
 8014e98:	b004      	add	sp, #16
 8014e9a:	bd80      	pop	{r7, pc}
 8014e9c:	000011e8 	.word	0x000011e8

08014ea0 <ipcp_lowerup>:


/*
 * ipcp_lowerup - The lower layer is up.
 */
static void ipcp_lowerup(ppp_pcb *pcb) {
 8014ea0:	b580      	push	{r7, lr}
 8014ea2:	b084      	sub	sp, #16
 8014ea4:	af00      	add	r7, sp, #0
 8014ea6:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 8014ea8:	687b      	ldr	r3, [r7, #4]
 8014eaa:	4a06      	ldr	r2, [pc, #24]	; (8014ec4 <ipcp_lowerup+0x24>)
 8014eac:	4694      	mov	ip, r2
 8014eae:	4463      	add	r3, ip
 8014eb0:	60fb      	str	r3, [r7, #12]
    fsm_lowerup(f);
 8014eb2:	68fb      	ldr	r3, [r7, #12]
 8014eb4:	0018      	movs	r0, r3
 8014eb6:	f7fe ffc2 	bl	8013e3e <fsm_lowerup>
}
 8014eba:	46c0      	nop			; (mov r8, r8)
 8014ebc:	46bd      	mov	sp, r7
 8014ebe:	b004      	add	sp, #16
 8014ec0:	bd80      	pop	{r7, pc}
 8014ec2:	46c0      	nop			; (mov r8, r8)
 8014ec4:	000011e8 	.word	0x000011e8

08014ec8 <ipcp_lowerdown>:


/*
 * ipcp_lowerdown - The lower layer is down.
 */
static void ipcp_lowerdown(ppp_pcb *pcb) {
 8014ec8:	b580      	push	{r7, lr}
 8014eca:	b084      	sub	sp, #16
 8014ecc:	af00      	add	r7, sp, #0
 8014ece:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 8014ed0:	687b      	ldr	r3, [r7, #4]
 8014ed2:	4a06      	ldr	r2, [pc, #24]	; (8014eec <ipcp_lowerdown+0x24>)
 8014ed4:	4694      	mov	ip, r2
 8014ed6:	4463      	add	r3, ip
 8014ed8:	60fb      	str	r3, [r7, #12]
    fsm_lowerdown(f);
 8014eda:	68fb      	ldr	r3, [r7, #12]
 8014edc:	0018      	movs	r0, r3
 8014ede:	f7fe ffd5 	bl	8013e8c <fsm_lowerdown>
}
 8014ee2:	46c0      	nop			; (mov r8, r8)
 8014ee4:	46bd      	mov	sp, r7
 8014ee6:	b004      	add	sp, #16
 8014ee8:	bd80      	pop	{r7, pc}
 8014eea:	46c0      	nop			; (mov r8, r8)
 8014eec:	000011e8 	.word	0x000011e8

08014ef0 <ipcp_input>:


/*
 * ipcp_input - Input IPCP packet.
 */
static void ipcp_input(ppp_pcb *pcb, u_char *p, int len) {
 8014ef0:	b580      	push	{r7, lr}
 8014ef2:	b086      	sub	sp, #24
 8014ef4:	af00      	add	r7, sp, #0
 8014ef6:	60f8      	str	r0, [r7, #12]
 8014ef8:	60b9      	str	r1, [r7, #8]
 8014efa:	607a      	str	r2, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 8014efc:	68fb      	ldr	r3, [r7, #12]
 8014efe:	4a07      	ldr	r2, [pc, #28]	; (8014f1c <ipcp_input+0x2c>)
 8014f00:	4694      	mov	ip, r2
 8014f02:	4463      	add	r3, ip
 8014f04:	617b      	str	r3, [r7, #20]
    fsm_input(f, p, len);
 8014f06:	687a      	ldr	r2, [r7, #4]
 8014f08:	68b9      	ldr	r1, [r7, #8]
 8014f0a:	697b      	ldr	r3, [r7, #20]
 8014f0c:	0018      	movs	r0, r3
 8014f0e:	f7ff f9b5 	bl	801427c <fsm_input>
}
 8014f12:	46c0      	nop			; (mov r8, r8)
 8014f14:	46bd      	mov	sp, r7
 8014f16:	b006      	add	sp, #24
 8014f18:	bd80      	pop	{r7, pc}
 8014f1a:	46c0      	nop			; (mov r8, r8)
 8014f1c:	000011e8 	.word	0x000011e8

08014f20 <ipcp_protrej>:
/*
 * ipcp_protrej - A Protocol-Reject was received for IPCP.
 *
 * Pretend the lower layer went down, so we shut up.
 */
static void ipcp_protrej(ppp_pcb *pcb) {
 8014f20:	b580      	push	{r7, lr}
 8014f22:	b084      	sub	sp, #16
 8014f24:	af00      	add	r7, sp, #0
 8014f26:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->ipcp_fsm;
 8014f28:	687b      	ldr	r3, [r7, #4]
 8014f2a:	4a06      	ldr	r2, [pc, #24]	; (8014f44 <ipcp_protrej+0x24>)
 8014f2c:	4694      	mov	ip, r2
 8014f2e:	4463      	add	r3, ip
 8014f30:	60fb      	str	r3, [r7, #12]
    fsm_lowerdown(f);
 8014f32:	68fb      	ldr	r3, [r7, #12]
 8014f34:	0018      	movs	r0, r3
 8014f36:	f7fe ffa9 	bl	8013e8c <fsm_lowerdown>
}
 8014f3a:	46c0      	nop			; (mov r8, r8)
 8014f3c:	46bd      	mov	sp, r7
 8014f3e:	b004      	add	sp, #16
 8014f40:	bd80      	pop	{r7, pc}
 8014f42:	46c0      	nop			; (mov r8, r8)
 8014f44:	000011e8 	.word	0x000011e8

08014f48 <ipcp_resetci>:

/*
 * ipcp_resetci - Reset our CI.
 * Called by fsm_sconfreq, Send Configure Request.
 */
static void ipcp_resetci(fsm *f) {
 8014f48:	b590      	push	{r4, r7, lr}
 8014f4a:	b087      	sub	sp, #28
 8014f4c:	af00      	add	r7, sp, #0
 8014f4e:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8014f50:	687b      	ldr	r3, [r7, #4]
 8014f52:	681b      	ldr	r3, [r3, #0]
 8014f54:	617b      	str	r3, [r7, #20]
    ipcp_options *wo = &pcb->ipcp_wantoptions;
 8014f56:	697b      	ldr	r3, [r7, #20]
 8014f58:	4a46      	ldr	r2, [pc, #280]	; (8015074 <ipcp_resetci+0x12c>)
 8014f5a:	4694      	mov	ip, r2
 8014f5c:	4463      	add	r3, ip
 8014f5e:	613b      	str	r3, [r7, #16]
    ipcp_options *go = &pcb->ipcp_gotoptions;
 8014f60:	697b      	ldr	r3, [r7, #20]
 8014f62:	4a45      	ldr	r2, [pc, #276]	; (8015078 <ipcp_resetci+0x130>)
 8014f64:	4694      	mov	ip, r2
 8014f66:	4463      	add	r3, ip
 8014f68:	60fb      	str	r3, [r7, #12]
    ipcp_options *ao = &pcb->ipcp_allowoptions;
 8014f6a:	697b      	ldr	r3, [r7, #20]
 8014f6c:	4a43      	ldr	r2, [pc, #268]	; (801507c <ipcp_resetci+0x134>)
 8014f6e:	4694      	mov	ip, r2
 8014f70:	4463      	add	r3, ip
 8014f72:	60bb      	str	r3, [r7, #8]

    wo->req_addr = (wo->neg_addr || wo->old_addrs) &&
 8014f74:	693b      	ldr	r3, [r7, #16]
 8014f76:	781b      	ldrb	r3, [r3, #0]
 8014f78:	2201      	movs	r2, #1
 8014f7a:	4013      	ands	r3, r2
 8014f7c:	b2db      	uxtb	r3, r3
 8014f7e:	2b00      	cmp	r3, #0
 8014f80:	d106      	bne.n	8014f90 <ipcp_resetci+0x48>
 8014f82:	693b      	ldr	r3, [r7, #16]
 8014f84:	781b      	ldrb	r3, [r3, #0]
 8014f86:	2202      	movs	r2, #2
 8014f88:	4013      	ands	r3, r2
 8014f8a:	b2db      	uxtb	r3, r3
 8014f8c:	2b00      	cmp	r3, #0
 8014f8e:	d00f      	beq.n	8014fb0 <ipcp_resetci+0x68>
	(ao->neg_addr || ao->old_addrs);
 8014f90:	68bb      	ldr	r3, [r7, #8]
 8014f92:	781b      	ldrb	r3, [r3, #0]
 8014f94:	2201      	movs	r2, #1
 8014f96:	4013      	ands	r3, r2
 8014f98:	b2db      	uxtb	r3, r3
    wo->req_addr = (wo->neg_addr || wo->old_addrs) &&
 8014f9a:	2b00      	cmp	r3, #0
 8014f9c:	d106      	bne.n	8014fac <ipcp_resetci+0x64>
	(ao->neg_addr || ao->old_addrs);
 8014f9e:	68bb      	ldr	r3, [r7, #8]
 8014fa0:	781b      	ldrb	r3, [r3, #0]
 8014fa2:	2202      	movs	r2, #2
 8014fa4:	4013      	ands	r3, r2
 8014fa6:	b2db      	uxtb	r3, r3
 8014fa8:	2b00      	cmp	r3, #0
 8014faa:	d001      	beq.n	8014fb0 <ipcp_resetci+0x68>
    wo->req_addr = (wo->neg_addr || wo->old_addrs) &&
 8014fac:	2301      	movs	r3, #1
 8014fae:	e000      	b.n	8014fb2 <ipcp_resetci+0x6a>
 8014fb0:	2300      	movs	r3, #0
 8014fb2:	1c1a      	adds	r2, r3, #0
 8014fb4:	2301      	movs	r3, #1
 8014fb6:	4013      	ands	r3, r2
 8014fb8:	b2da      	uxtb	r2, r3
 8014fba:	693b      	ldr	r3, [r7, #16]
 8014fbc:	2101      	movs	r1, #1
 8014fbe:	400a      	ands	r2, r1
 8014fc0:	0090      	lsls	r0, r2, #2
 8014fc2:	781a      	ldrb	r2, [r3, #0]
 8014fc4:	2104      	movs	r1, #4
 8014fc6:	438a      	bics	r2, r1
 8014fc8:	1c11      	adds	r1, r2, #0
 8014fca:	1c02      	adds	r2, r0, #0
 8014fcc:	430a      	orrs	r2, r1
 8014fce:	701a      	strb	r2, [r3, #0]
    if (wo->ouraddr == 0)
 8014fd0:	693b      	ldr	r3, [r7, #16]
 8014fd2:	685b      	ldr	r3, [r3, #4]
 8014fd4:	2b00      	cmp	r3, #0
 8014fd6:	d104      	bne.n	8014fe2 <ipcp_resetci+0x9a>
	wo->accept_local = 1;
 8014fd8:	693b      	ldr	r3, [r7, #16]
 8014fda:	781a      	ldrb	r2, [r3, #0]
 8014fdc:	2140      	movs	r1, #64	; 0x40
 8014fde:	430a      	orrs	r2, r1
 8014fe0:	701a      	strb	r2, [r3, #0]
    if (wo->hisaddr == 0)
 8014fe2:	693b      	ldr	r3, [r7, #16]
 8014fe4:	689b      	ldr	r3, [r3, #8]
 8014fe6:	2b00      	cmp	r3, #0
 8014fe8:	d105      	bne.n	8014ff6 <ipcp_resetci+0xae>
	wo->accept_remote = 1;
 8014fea:	693b      	ldr	r3, [r7, #16]
 8014fec:	781a      	ldrb	r2, [r3, #0]
 8014fee:	2180      	movs	r1, #128	; 0x80
 8014ff0:	4249      	negs	r1, r1
 8014ff2:	430a      	orrs	r2, r1
 8014ff4:	701a      	strb	r2, [r3, #0]
#if LWIP_DNS
    wo->req_dns1 = wo->req_dns2 = pcb->settings.usepeerdns;	/* Request DNS addresses from the peer */
 8014ff6:	697b      	ldr	r3, [r7, #20]
 8014ff8:	781b      	ldrb	r3, [r3, #0]
 8014ffa:	07db      	lsls	r3, r3, #31
 8014ffc:	0fdb      	lsrs	r3, r3, #31
 8014ffe:	b2da      	uxtb	r2, r3
 8015000:	693b      	ldr	r3, [r7, #16]
 8015002:	2101      	movs	r1, #1
 8015004:	400a      	ands	r2, r1
 8015006:	1890      	adds	r0, r2, r2
 8015008:	785a      	ldrb	r2, [r3, #1]
 801500a:	2102      	movs	r1, #2
 801500c:	438a      	bics	r2, r1
 801500e:	1c11      	adds	r1, r2, #0
 8015010:	1c02      	adds	r2, r0, #0
 8015012:	430a      	orrs	r2, r1
 8015014:	705a      	strb	r2, [r3, #1]
 8015016:	693b      	ldr	r3, [r7, #16]
 8015018:	785b      	ldrb	r3, [r3, #1]
 801501a:	079b      	lsls	r3, r3, #30
 801501c:	0fdb      	lsrs	r3, r3, #31
 801501e:	b2da      	uxtb	r2, r3
 8015020:	693b      	ldr	r3, [r7, #16]
 8015022:	2101      	movs	r1, #1
 8015024:	400a      	ands	r2, r1
 8015026:	0010      	movs	r0, r2
 8015028:	785a      	ldrb	r2, [r3, #1]
 801502a:	2101      	movs	r1, #1
 801502c:	438a      	bics	r2, r1
 801502e:	1c11      	adds	r1, r2, #0
 8015030:	1c02      	adds	r2, r0, #0
 8015032:	430a      	orrs	r2, r1
 8015034:	705a      	strb	r2, [r3, #1]
#endif /* LWIP_DNS */
    *go = *wo;
 8015036:	68fb      	ldr	r3, [r7, #12]
 8015038:	693a      	ldr	r2, [r7, #16]
 801503a:	ca13      	ldmia	r2!, {r0, r1, r4}
 801503c:	c313      	stmia	r3!, {r0, r1, r4}
 801503e:	ca13      	ldmia	r2!, {r0, r1, r4}
 8015040:	c313      	stmia	r3!, {r0, r1, r4}
    if (!pcb->ask_for_local)
 8015042:	697b      	ldr	r3, [r7, #20]
 8015044:	2226      	movs	r2, #38	; 0x26
 8015046:	5c9b      	ldrb	r3, [r3, r2]
 8015048:	2201      	movs	r2, #1
 801504a:	4013      	ands	r3, r2
 801504c:	b2db      	uxtb	r3, r3
 801504e:	2b00      	cmp	r3, #0
 8015050:	d102      	bne.n	8015058 <ipcp_resetci+0x110>
	go->ouraddr = 0;
 8015052:	68fb      	ldr	r3, [r7, #12]
 8015054:	2200      	movs	r2, #0
 8015056:	605a      	str	r2, [r3, #4]
	if (wo->hisaddr) {
	    wo->accept_remote = 0;
	}
    }
#endif /* UNUSED */
    BZERO(&pcb->ipcp_hisoptions, sizeof(ipcp_options));
 8015058:	697b      	ldr	r3, [r7, #20]
 801505a:	4a09      	ldr	r2, [pc, #36]	; (8015080 <ipcp_resetci+0x138>)
 801505c:	4694      	mov	ip, r2
 801505e:	4463      	add	r3, ip
 8015060:	2218      	movs	r2, #24
 8015062:	2100      	movs	r1, #0
 8015064:	0018      	movs	r0, r3
 8015066:	f007 fbe1 	bl	801c82c <memset>
}
 801506a:	46c0      	nop			; (mov r8, r8)
 801506c:	46bd      	mov	sp, r7
 801506e:	b007      	add	sp, #28
 8015070:	bd90      	pop	{r4, r7, pc}
 8015072:	46c0      	nop			; (mov r8, r8)
 8015074:	00001204 	.word	0x00001204
 8015078:	0000121c 	.word	0x0000121c
 801507c:	00001234 	.word	0x00001234
 8015080:	0000124c 	.word	0x0000124c

08015084 <ipcp_cilen>:

/*
 * ipcp_cilen - Return length of our CI.
 * Called by fsm_sconfreq, Send Configure Request.
 */
static int ipcp_cilen(fsm *f) {
 8015084:	b580      	push	{r7, lr}
 8015086:	b086      	sub	sp, #24
 8015088:	af00      	add	r7, sp, #0
 801508a:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 801508c:	687b      	ldr	r3, [r7, #4]
 801508e:	681b      	ldr	r3, [r3, #0]
 8015090:	617b      	str	r3, [r7, #20]
    ipcp_options *go = &pcb->ipcp_gotoptions;
 8015092:	697b      	ldr	r3, [r7, #20]
 8015094:	4a54      	ldr	r2, [pc, #336]	; (80151e8 <ipcp_cilen+0x164>)
 8015096:	4694      	mov	ip, r2
 8015098:	4463      	add	r3, ip
 801509a:	613b      	str	r3, [r7, #16]
#if VJ_SUPPORT
    ipcp_options *wo = &pcb->ipcp_wantoptions;
 801509c:	697b      	ldr	r3, [r7, #20]
 801509e:	4a53      	ldr	r2, [pc, #332]	; (80151ec <ipcp_cilen+0x168>)
 80150a0:	4694      	mov	ip, r2
 80150a2:	4463      	add	r3, ip
 80150a4:	60fb      	str	r3, [r7, #12]
#endif /* VJ_SUPPORT */
    ipcp_options *ho = &pcb->ipcp_hisoptions;
 80150a6:	697b      	ldr	r3, [r7, #20]
 80150a8:	4a51      	ldr	r2, [pc, #324]	; (80151f0 <ipcp_cilen+0x16c>)
 80150aa:	4694      	mov	ip, r2
 80150ac:	4463      	add	r3, ip
 80150ae:	60bb      	str	r3, [r7, #8]

    /*
     * First see if we want to change our options to the old
     * forms because we have received old forms from the peer.
     */
    if (go->neg_addr && go->old_addrs && !ho->neg_addr && ho->old_addrs)
 80150b0:	693b      	ldr	r3, [r7, #16]
 80150b2:	781b      	ldrb	r3, [r3, #0]
 80150b4:	2201      	movs	r2, #1
 80150b6:	4013      	ands	r3, r2
 80150b8:	b2db      	uxtb	r3, r3
 80150ba:	2b00      	cmp	r3, #0
 80150bc:	d019      	beq.n	80150f2 <ipcp_cilen+0x6e>
 80150be:	693b      	ldr	r3, [r7, #16]
 80150c0:	781b      	ldrb	r3, [r3, #0]
 80150c2:	2202      	movs	r2, #2
 80150c4:	4013      	ands	r3, r2
 80150c6:	b2db      	uxtb	r3, r3
 80150c8:	2b00      	cmp	r3, #0
 80150ca:	d012      	beq.n	80150f2 <ipcp_cilen+0x6e>
 80150cc:	68bb      	ldr	r3, [r7, #8]
 80150ce:	781b      	ldrb	r3, [r3, #0]
 80150d0:	2201      	movs	r2, #1
 80150d2:	4013      	ands	r3, r2
 80150d4:	b2db      	uxtb	r3, r3
 80150d6:	2b00      	cmp	r3, #0
 80150d8:	d10b      	bne.n	80150f2 <ipcp_cilen+0x6e>
 80150da:	68bb      	ldr	r3, [r7, #8]
 80150dc:	781b      	ldrb	r3, [r3, #0]
 80150de:	2202      	movs	r2, #2
 80150e0:	4013      	ands	r3, r2
 80150e2:	b2db      	uxtb	r3, r3
 80150e4:	2b00      	cmp	r3, #0
 80150e6:	d004      	beq.n	80150f2 <ipcp_cilen+0x6e>
	go->neg_addr = 0;
 80150e8:	693b      	ldr	r3, [r7, #16]
 80150ea:	781a      	ldrb	r2, [r3, #0]
 80150ec:	2101      	movs	r1, #1
 80150ee:	438a      	bics	r2, r1
 80150f0:	701a      	strb	r2, [r3, #0]

#if VJ_SUPPORT
    if (wo->neg_vj && !go->neg_vj && !go->old_vj) {
 80150f2:	68fb      	ldr	r3, [r7, #12]
 80150f4:	781b      	ldrb	r3, [r3, #0]
 80150f6:	2208      	movs	r2, #8
 80150f8:	4013      	ands	r3, r2
 80150fa:	b2db      	uxtb	r3, r3
 80150fc:	2b00      	cmp	r3, #0
 80150fe:	d029      	beq.n	8015154 <ipcp_cilen+0xd0>
 8015100:	693b      	ldr	r3, [r7, #16]
 8015102:	781b      	ldrb	r3, [r3, #0]
 8015104:	2208      	movs	r2, #8
 8015106:	4013      	ands	r3, r2
 8015108:	b2db      	uxtb	r3, r3
 801510a:	2b00      	cmp	r3, #0
 801510c:	d122      	bne.n	8015154 <ipcp_cilen+0xd0>
 801510e:	693b      	ldr	r3, [r7, #16]
 8015110:	781b      	ldrb	r3, [r3, #0]
 8015112:	2210      	movs	r2, #16
 8015114:	4013      	ands	r3, r2
 8015116:	b2db      	uxtb	r3, r3
 8015118:	2b00      	cmp	r3, #0
 801511a:	d11b      	bne.n	8015154 <ipcp_cilen+0xd0>
	/* try an older style of VJ negotiation */
	/* use the old style only if the peer did */
	if (ho->neg_vj && ho->old_vj) {
 801511c:	68bb      	ldr	r3, [r7, #8]
 801511e:	781b      	ldrb	r3, [r3, #0]
 8015120:	2208      	movs	r2, #8
 8015122:	4013      	ands	r3, r2
 8015124:	b2db      	uxtb	r3, r3
 8015126:	2b00      	cmp	r3, #0
 8015128:	d014      	beq.n	8015154 <ipcp_cilen+0xd0>
 801512a:	68bb      	ldr	r3, [r7, #8]
 801512c:	781b      	ldrb	r3, [r3, #0]
 801512e:	2210      	movs	r2, #16
 8015130:	4013      	ands	r3, r2
 8015132:	b2db      	uxtb	r3, r3
 8015134:	2b00      	cmp	r3, #0
 8015136:	d00d      	beq.n	8015154 <ipcp_cilen+0xd0>
	    go->neg_vj = 1;
 8015138:	693b      	ldr	r3, [r7, #16]
 801513a:	781a      	ldrb	r2, [r3, #0]
 801513c:	2108      	movs	r1, #8
 801513e:	430a      	orrs	r2, r1
 8015140:	701a      	strb	r2, [r3, #0]
	    go->old_vj = 1;
 8015142:	693b      	ldr	r3, [r7, #16]
 8015144:	781a      	ldrb	r2, [r3, #0]
 8015146:	2110      	movs	r1, #16
 8015148:	430a      	orrs	r2, r1
 801514a:	701a      	strb	r2, [r3, #0]
	    go->vj_protocol = ho->vj_protocol;
 801514c:	68bb      	ldr	r3, [r7, #8]
 801514e:	8a9a      	ldrh	r2, [r3, #20]
 8015150:	693b      	ldr	r3, [r7, #16]
 8015152:	829a      	strh	r2, [r3, #20]
	}
    }
#endif /* VJ_SUPPORT */

    return (LENCIADDRS(!go->neg_addr && go->old_addrs) +
 8015154:	693b      	ldr	r3, [r7, #16]
 8015156:	781b      	ldrb	r3, [r3, #0]
 8015158:	2201      	movs	r2, #1
 801515a:	4013      	ands	r3, r2
 801515c:	b2db      	uxtb	r3, r3
 801515e:	2b00      	cmp	r3, #0
 8015160:	d108      	bne.n	8015174 <ipcp_cilen+0xf0>
 8015162:	693b      	ldr	r3, [r7, #16]
 8015164:	781b      	ldrb	r3, [r3, #0]
 8015166:	2202      	movs	r2, #2
 8015168:	4013      	ands	r3, r2
 801516a:	b2db      	uxtb	r3, r3
 801516c:	2b00      	cmp	r3, #0
 801516e:	d001      	beq.n	8015174 <ipcp_cilen+0xf0>
 8015170:	220a      	movs	r2, #10
 8015172:	e000      	b.n	8015176 <ipcp_cilen+0xf2>
 8015174:	2200      	movs	r2, #0
#if VJ_SUPPORT
	    LENCIVJ(go->neg_vj, go->old_vj) +
 8015176:	693b      	ldr	r3, [r7, #16]
 8015178:	781b      	ldrb	r3, [r3, #0]
 801517a:	2108      	movs	r1, #8
 801517c:	400b      	ands	r3, r1
 801517e:	b2db      	uxtb	r3, r3
 8015180:	2b00      	cmp	r3, #0
 8015182:	d00a      	beq.n	801519a <ipcp_cilen+0x116>
 8015184:	693b      	ldr	r3, [r7, #16]
 8015186:	781b      	ldrb	r3, [r3, #0]
 8015188:	2110      	movs	r1, #16
 801518a:	400b      	ands	r3, r1
 801518c:	b2db      	uxtb	r3, r3
 801518e:	2b00      	cmp	r3, #0
 8015190:	d001      	beq.n	8015196 <ipcp_cilen+0x112>
 8015192:	2304      	movs	r3, #4
 8015194:	e002      	b.n	801519c <ipcp_cilen+0x118>
 8015196:	2306      	movs	r3, #6
 8015198:	e000      	b.n	801519c <ipcp_cilen+0x118>
 801519a:	2300      	movs	r3, #0
    return (LENCIADDRS(!go->neg_addr && go->old_addrs) +
 801519c:	18d2      	adds	r2, r2, r3
#endif /* VJ_SUPPORT */
	    LENCIADDR(go->neg_addr) +
 801519e:	693b      	ldr	r3, [r7, #16]
 80151a0:	781b      	ldrb	r3, [r3, #0]
 80151a2:	2101      	movs	r1, #1
 80151a4:	400b      	ands	r3, r1
 80151a6:	b2db      	uxtb	r3, r3
 80151a8:	2b00      	cmp	r3, #0
 80151aa:	d001      	beq.n	80151b0 <ipcp_cilen+0x12c>
 80151ac:	2306      	movs	r3, #6
 80151ae:	e000      	b.n	80151b2 <ipcp_cilen+0x12e>
 80151b0:	2300      	movs	r3, #0
	    LENCIVJ(go->neg_vj, go->old_vj) +
 80151b2:	189a      	adds	r2, r3, r2
#if LWIP_DNS
	    LENCIDNS(go->req_dns1) +
 80151b4:	693b      	ldr	r3, [r7, #16]
 80151b6:	785b      	ldrb	r3, [r3, #1]
 80151b8:	2101      	movs	r1, #1
 80151ba:	400b      	ands	r3, r1
 80151bc:	b2db      	uxtb	r3, r3
 80151be:	2b00      	cmp	r3, #0
 80151c0:	d001      	beq.n	80151c6 <ipcp_cilen+0x142>
 80151c2:	2306      	movs	r3, #6
 80151c4:	e000      	b.n	80151c8 <ipcp_cilen+0x144>
 80151c6:	2300      	movs	r3, #0
	    LENCIADDR(go->neg_addr) +
 80151c8:	189a      	adds	r2, r3, r2
	    LENCIDNS(go->req_dns2) +
 80151ca:	693b      	ldr	r3, [r7, #16]
 80151cc:	785b      	ldrb	r3, [r3, #1]
 80151ce:	2102      	movs	r1, #2
 80151d0:	400b      	ands	r3, r1
 80151d2:	b2db      	uxtb	r3, r3
 80151d4:	2b00      	cmp	r3, #0
 80151d6:	d001      	beq.n	80151dc <ipcp_cilen+0x158>
 80151d8:	2306      	movs	r3, #6
 80151da:	e000      	b.n	80151de <ipcp_cilen+0x15a>
 80151dc:	2300      	movs	r3, #0
 80151de:	189b      	adds	r3, r3, r2
#if 0 /* UNUSED - WINS */
	    LENCIWINS(go->winsaddr[0]) +
	    LENCIWINS(go->winsaddr[1]) +
#endif /* UNUSED - WINS */
	    0);
}
 80151e0:	0018      	movs	r0, r3
 80151e2:	46bd      	mov	sp, r7
 80151e4:	b006      	add	sp, #24
 80151e6:	bd80      	pop	{r7, pc}
 80151e8:	0000121c 	.word	0x0000121c
 80151ec:	00001204 	.word	0x00001204
 80151f0:	0000124c 	.word	0x0000124c

080151f4 <ipcp_addci>:

/*
 * ipcp_addci - Add our desired CIs to a packet.
 * Called by fsm_sconfreq, Send Configure Request.
 */
static void ipcp_addci(fsm *f, u_char *ucp, int *lenp) {
 80151f4:	b580      	push	{r7, lr}
 80151f6:	b08c      	sub	sp, #48	; 0x30
 80151f8:	af00      	add	r7, sp, #0
 80151fa:	60f8      	str	r0, [r7, #12]
 80151fc:	60b9      	str	r1, [r7, #8]
 80151fe:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8015200:	68fb      	ldr	r3, [r7, #12]
 8015202:	681b      	ldr	r3, [r3, #0]
 8015204:	62bb      	str	r3, [r7, #40]	; 0x28
    ipcp_options *go = &pcb->ipcp_gotoptions;
 8015206:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015208:	4ac3      	ldr	r2, [pc, #780]	; (8015518 <ipcp_addci+0x324>)
 801520a:	4694      	mov	ip, r2
 801520c:	4463      	add	r3, ip
 801520e:	627b      	str	r3, [r7, #36]	; 0x24
    int len = *lenp;
 8015210:	687b      	ldr	r3, [r7, #4]
 8015212:	681b      	ldr	r3, [r3, #0]
 8015214:	62fb      	str	r3, [r7, #44]	; 0x2c
	} else \
	    addr = 0; \
    }
#endif /* UNUSED - WINS */

    ADDCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs, go->ouraddr,
 8015216:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015218:	781b      	ldrb	r3, [r3, #0]
 801521a:	2201      	movs	r2, #1
 801521c:	4013      	ands	r3, r2
 801521e:	b2db      	uxtb	r3, r3
 8015220:	2b00      	cmp	r3, #0
 8015222:	d160      	bne.n	80152e6 <ipcp_addci+0xf2>
 8015224:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015226:	781b      	ldrb	r3, [r3, #0]
 8015228:	2202      	movs	r2, #2
 801522a:	4013      	ands	r3, r2
 801522c:	b2db      	uxtb	r3, r3
 801522e:	2b00      	cmp	r3, #0
 8015230:	d059      	beq.n	80152e6 <ipcp_addci+0xf2>
 8015232:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015234:	2b09      	cmp	r3, #9
 8015236:	dd51      	ble.n	80152dc <ipcp_addci+0xe8>
 8015238:	68bb      	ldr	r3, [r7, #8]
 801523a:	1c5a      	adds	r2, r3, #1
 801523c:	60ba      	str	r2, [r7, #8]
 801523e:	2201      	movs	r2, #1
 8015240:	701a      	strb	r2, [r3, #0]
 8015242:	68bb      	ldr	r3, [r7, #8]
 8015244:	1c5a      	adds	r2, r3, #1
 8015246:	60ba      	str	r2, [r7, #8]
 8015248:	220a      	movs	r2, #10
 801524a:	701a      	strb	r2, [r3, #0]
 801524c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801524e:	685b      	ldr	r3, [r3, #4]
 8015250:	0018      	movs	r0, r3
 8015252:	f7f1 f985 	bl	8006560 <lwip_htonl>
 8015256:	0003      	movs	r3, r0
 8015258:	623b      	str	r3, [r7, #32]
 801525a:	6a3b      	ldr	r3, [r7, #32]
 801525c:	0e19      	lsrs	r1, r3, #24
 801525e:	68bb      	ldr	r3, [r7, #8]
 8015260:	1c5a      	adds	r2, r3, #1
 8015262:	60ba      	str	r2, [r7, #8]
 8015264:	b2ca      	uxtb	r2, r1
 8015266:	701a      	strb	r2, [r3, #0]
 8015268:	6a3b      	ldr	r3, [r7, #32]
 801526a:	0c19      	lsrs	r1, r3, #16
 801526c:	68bb      	ldr	r3, [r7, #8]
 801526e:	1c5a      	adds	r2, r3, #1
 8015270:	60ba      	str	r2, [r7, #8]
 8015272:	b2ca      	uxtb	r2, r1
 8015274:	701a      	strb	r2, [r3, #0]
 8015276:	6a3b      	ldr	r3, [r7, #32]
 8015278:	0a19      	lsrs	r1, r3, #8
 801527a:	68bb      	ldr	r3, [r7, #8]
 801527c:	1c5a      	adds	r2, r3, #1
 801527e:	60ba      	str	r2, [r7, #8]
 8015280:	b2ca      	uxtb	r2, r1
 8015282:	701a      	strb	r2, [r3, #0]
 8015284:	68bb      	ldr	r3, [r7, #8]
 8015286:	1c5a      	adds	r2, r3, #1
 8015288:	60ba      	str	r2, [r7, #8]
 801528a:	6a3a      	ldr	r2, [r7, #32]
 801528c:	b2d2      	uxtb	r2, r2
 801528e:	701a      	strb	r2, [r3, #0]
 8015290:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015292:	689b      	ldr	r3, [r3, #8]
 8015294:	0018      	movs	r0, r3
 8015296:	f7f1 f963 	bl	8006560 <lwip_htonl>
 801529a:	0003      	movs	r3, r0
 801529c:	623b      	str	r3, [r7, #32]
 801529e:	6a3b      	ldr	r3, [r7, #32]
 80152a0:	0e19      	lsrs	r1, r3, #24
 80152a2:	68bb      	ldr	r3, [r7, #8]
 80152a4:	1c5a      	adds	r2, r3, #1
 80152a6:	60ba      	str	r2, [r7, #8]
 80152a8:	b2ca      	uxtb	r2, r1
 80152aa:	701a      	strb	r2, [r3, #0]
 80152ac:	6a3b      	ldr	r3, [r7, #32]
 80152ae:	0c19      	lsrs	r1, r3, #16
 80152b0:	68bb      	ldr	r3, [r7, #8]
 80152b2:	1c5a      	adds	r2, r3, #1
 80152b4:	60ba      	str	r2, [r7, #8]
 80152b6:	b2ca      	uxtb	r2, r1
 80152b8:	701a      	strb	r2, [r3, #0]
 80152ba:	6a3b      	ldr	r3, [r7, #32]
 80152bc:	0a19      	lsrs	r1, r3, #8
 80152be:	68bb      	ldr	r3, [r7, #8]
 80152c0:	1c5a      	adds	r2, r3, #1
 80152c2:	60ba      	str	r2, [r7, #8]
 80152c4:	b2ca      	uxtb	r2, r1
 80152c6:	701a      	strb	r2, [r3, #0]
 80152c8:	68bb      	ldr	r3, [r7, #8]
 80152ca:	1c5a      	adds	r2, r3, #1
 80152cc:	60ba      	str	r2, [r7, #8]
 80152ce:	6a3a      	ldr	r2, [r7, #32]
 80152d0:	b2d2      	uxtb	r2, r2
 80152d2:	701a      	strb	r2, [r3, #0]
 80152d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80152d6:	3b0a      	subs	r3, #10
 80152d8:	62fb      	str	r3, [r7, #44]	; 0x2c
 80152da:	e004      	b.n	80152e6 <ipcp_addci+0xf2>
 80152dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80152de:	781a      	ldrb	r2, [r3, #0]
 80152e0:	2102      	movs	r1, #2
 80152e2:	438a      	bics	r2, r1
 80152e4:	701a      	strb	r2, [r3, #0]
	       go->hisaddr);

#if VJ_SUPPORT
    ADDCIVJ(CI_COMPRESSTYPE, go->neg_vj, go->vj_protocol, go->old_vj,
 80152e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80152e8:	781b      	ldrb	r3, [r3, #0]
 80152ea:	2208      	movs	r2, #8
 80152ec:	4013      	ands	r3, r2
 80152ee:	b2db      	uxtb	r3, r3
 80152f0:	2b00      	cmp	r3, #0
 80152f2:	d04a      	beq.n	801538a <ipcp_addci+0x196>
 80152f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80152f6:	781b      	ldrb	r3, [r3, #0]
 80152f8:	2210      	movs	r2, #16
 80152fa:	4013      	ands	r3, r2
 80152fc:	b2db      	uxtb	r3, r3
 80152fe:	2b00      	cmp	r3, #0
 8015300:	d001      	beq.n	8015306 <ipcp_addci+0x112>
 8015302:	2304      	movs	r3, #4
 8015304:	e000      	b.n	8015308 <ipcp_addci+0x114>
 8015306:	2306      	movs	r3, #6
 8015308:	61fb      	str	r3, [r7, #28]
 801530a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801530c:	69fb      	ldr	r3, [r7, #28]
 801530e:	429a      	cmp	r2, r3
 8015310:	db36      	blt.n	8015380 <ipcp_addci+0x18c>
 8015312:	68bb      	ldr	r3, [r7, #8]
 8015314:	1c5a      	adds	r2, r3, #1
 8015316:	60ba      	str	r2, [r7, #8]
 8015318:	2202      	movs	r2, #2
 801531a:	701a      	strb	r2, [r3, #0]
 801531c:	68bb      	ldr	r3, [r7, #8]
 801531e:	1c5a      	adds	r2, r3, #1
 8015320:	60ba      	str	r2, [r7, #8]
 8015322:	69fa      	ldr	r2, [r7, #28]
 8015324:	b2d2      	uxtb	r2, r2
 8015326:	701a      	strb	r2, [r3, #0]
 8015328:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801532a:	8a9b      	ldrh	r3, [r3, #20]
 801532c:	0a1b      	lsrs	r3, r3, #8
 801532e:	b299      	uxth	r1, r3
 8015330:	68bb      	ldr	r3, [r7, #8]
 8015332:	1c5a      	adds	r2, r3, #1
 8015334:	60ba      	str	r2, [r7, #8]
 8015336:	b2ca      	uxtb	r2, r1
 8015338:	701a      	strb	r2, [r3, #0]
 801533a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801533c:	8a99      	ldrh	r1, [r3, #20]
 801533e:	68bb      	ldr	r3, [r7, #8]
 8015340:	1c5a      	adds	r2, r3, #1
 8015342:	60ba      	str	r2, [r7, #8]
 8015344:	b2ca      	uxtb	r2, r1
 8015346:	701a      	strb	r2, [r3, #0]
 8015348:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801534a:	781b      	ldrb	r3, [r3, #0]
 801534c:	2210      	movs	r2, #16
 801534e:	4013      	ands	r3, r2
 8015350:	b2db      	uxtb	r3, r3
 8015352:	2b00      	cmp	r3, #0
 8015354:	d10f      	bne.n	8015376 <ipcp_addci+0x182>
 8015356:	68bb      	ldr	r3, [r7, #8]
 8015358:	1c5a      	adds	r2, r3, #1
 801535a:	60ba      	str	r2, [r7, #8]
 801535c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801535e:	7d92      	ldrb	r2, [r2, #22]
 8015360:	701a      	strb	r2, [r3, #0]
 8015362:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015364:	781b      	ldrb	r3, [r3, #0]
 8015366:	069b      	lsls	r3, r3, #26
 8015368:	0fdb      	lsrs	r3, r3, #31
 801536a:	b2d9      	uxtb	r1, r3
 801536c:	68bb      	ldr	r3, [r7, #8]
 801536e:	1c5a      	adds	r2, r3, #1
 8015370:	60ba      	str	r2, [r7, #8]
 8015372:	000a      	movs	r2, r1
 8015374:	701a      	strb	r2, [r3, #0]
 8015376:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8015378:	69fb      	ldr	r3, [r7, #28]
 801537a:	1ad3      	subs	r3, r2, r3
 801537c:	62fb      	str	r3, [r7, #44]	; 0x2c
 801537e:	e004      	b.n	801538a <ipcp_addci+0x196>
 8015380:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015382:	781a      	ldrb	r2, [r3, #0]
 8015384:	2108      	movs	r1, #8
 8015386:	438a      	bics	r2, r1
 8015388:	701a      	strb	r2, [r3, #0]
	    go->maxslotindex, go->cflag);
#endif /* VJ_SUPPORT */

    ADDCIADDR(CI_ADDR, go->neg_addr, go->ouraddr);
 801538a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801538c:	781b      	ldrb	r3, [r3, #0]
 801538e:	2201      	movs	r2, #1
 8015390:	4013      	ands	r3, r2
 8015392:	b2db      	uxtb	r3, r3
 8015394:	2b00      	cmp	r3, #0
 8015396:	d037      	beq.n	8015408 <ipcp_addci+0x214>
 8015398:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801539a:	2b05      	cmp	r3, #5
 801539c:	dd2f      	ble.n	80153fe <ipcp_addci+0x20a>
 801539e:	68bb      	ldr	r3, [r7, #8]
 80153a0:	1c5a      	adds	r2, r3, #1
 80153a2:	60ba      	str	r2, [r7, #8]
 80153a4:	2203      	movs	r2, #3
 80153a6:	701a      	strb	r2, [r3, #0]
 80153a8:	68bb      	ldr	r3, [r7, #8]
 80153aa:	1c5a      	adds	r2, r3, #1
 80153ac:	60ba      	str	r2, [r7, #8]
 80153ae:	2206      	movs	r2, #6
 80153b0:	701a      	strb	r2, [r3, #0]
 80153b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80153b4:	685b      	ldr	r3, [r3, #4]
 80153b6:	0018      	movs	r0, r3
 80153b8:	f7f1 f8d2 	bl	8006560 <lwip_htonl>
 80153bc:	0003      	movs	r3, r0
 80153be:	61bb      	str	r3, [r7, #24]
 80153c0:	69bb      	ldr	r3, [r7, #24]
 80153c2:	0e19      	lsrs	r1, r3, #24
 80153c4:	68bb      	ldr	r3, [r7, #8]
 80153c6:	1c5a      	adds	r2, r3, #1
 80153c8:	60ba      	str	r2, [r7, #8]
 80153ca:	b2ca      	uxtb	r2, r1
 80153cc:	701a      	strb	r2, [r3, #0]
 80153ce:	69bb      	ldr	r3, [r7, #24]
 80153d0:	0c19      	lsrs	r1, r3, #16
 80153d2:	68bb      	ldr	r3, [r7, #8]
 80153d4:	1c5a      	adds	r2, r3, #1
 80153d6:	60ba      	str	r2, [r7, #8]
 80153d8:	b2ca      	uxtb	r2, r1
 80153da:	701a      	strb	r2, [r3, #0]
 80153dc:	69bb      	ldr	r3, [r7, #24]
 80153de:	0a19      	lsrs	r1, r3, #8
 80153e0:	68bb      	ldr	r3, [r7, #8]
 80153e2:	1c5a      	adds	r2, r3, #1
 80153e4:	60ba      	str	r2, [r7, #8]
 80153e6:	b2ca      	uxtb	r2, r1
 80153e8:	701a      	strb	r2, [r3, #0]
 80153ea:	68bb      	ldr	r3, [r7, #8]
 80153ec:	1c5a      	adds	r2, r3, #1
 80153ee:	60ba      	str	r2, [r7, #8]
 80153f0:	69ba      	ldr	r2, [r7, #24]
 80153f2:	b2d2      	uxtb	r2, r2
 80153f4:	701a      	strb	r2, [r3, #0]
 80153f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80153f8:	3b06      	subs	r3, #6
 80153fa:	62fb      	str	r3, [r7, #44]	; 0x2c
 80153fc:	e004      	b.n	8015408 <ipcp_addci+0x214>
 80153fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015400:	781a      	ldrb	r2, [r3, #0]
 8015402:	2101      	movs	r1, #1
 8015404:	438a      	bics	r2, r1
 8015406:	701a      	strb	r2, [r3, #0]

#if LWIP_DNS
    ADDCIDNS(CI_MS_DNS1, go->req_dns1, go->dnsaddr[0]);
 8015408:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801540a:	785b      	ldrb	r3, [r3, #1]
 801540c:	2201      	movs	r2, #1
 801540e:	4013      	ands	r3, r2
 8015410:	b2db      	uxtb	r3, r3
 8015412:	2b00      	cmp	r3, #0
 8015414:	d037      	beq.n	8015486 <ipcp_addci+0x292>
 8015416:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015418:	2b05      	cmp	r3, #5
 801541a:	dd2f      	ble.n	801547c <ipcp_addci+0x288>
 801541c:	68bb      	ldr	r3, [r7, #8]
 801541e:	1c5a      	adds	r2, r3, #1
 8015420:	60ba      	str	r2, [r7, #8]
 8015422:	2281      	movs	r2, #129	; 0x81
 8015424:	701a      	strb	r2, [r3, #0]
 8015426:	68bb      	ldr	r3, [r7, #8]
 8015428:	1c5a      	adds	r2, r3, #1
 801542a:	60ba      	str	r2, [r7, #8]
 801542c:	2206      	movs	r2, #6
 801542e:	701a      	strb	r2, [r3, #0]
 8015430:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015432:	68db      	ldr	r3, [r3, #12]
 8015434:	0018      	movs	r0, r3
 8015436:	f7f1 f893 	bl	8006560 <lwip_htonl>
 801543a:	0003      	movs	r3, r0
 801543c:	617b      	str	r3, [r7, #20]
 801543e:	697b      	ldr	r3, [r7, #20]
 8015440:	0e19      	lsrs	r1, r3, #24
 8015442:	68bb      	ldr	r3, [r7, #8]
 8015444:	1c5a      	adds	r2, r3, #1
 8015446:	60ba      	str	r2, [r7, #8]
 8015448:	b2ca      	uxtb	r2, r1
 801544a:	701a      	strb	r2, [r3, #0]
 801544c:	697b      	ldr	r3, [r7, #20]
 801544e:	0c19      	lsrs	r1, r3, #16
 8015450:	68bb      	ldr	r3, [r7, #8]
 8015452:	1c5a      	adds	r2, r3, #1
 8015454:	60ba      	str	r2, [r7, #8]
 8015456:	b2ca      	uxtb	r2, r1
 8015458:	701a      	strb	r2, [r3, #0]
 801545a:	697b      	ldr	r3, [r7, #20]
 801545c:	0a19      	lsrs	r1, r3, #8
 801545e:	68bb      	ldr	r3, [r7, #8]
 8015460:	1c5a      	adds	r2, r3, #1
 8015462:	60ba      	str	r2, [r7, #8]
 8015464:	b2ca      	uxtb	r2, r1
 8015466:	701a      	strb	r2, [r3, #0]
 8015468:	68bb      	ldr	r3, [r7, #8]
 801546a:	1c5a      	adds	r2, r3, #1
 801546c:	60ba      	str	r2, [r7, #8]
 801546e:	697a      	ldr	r2, [r7, #20]
 8015470:	b2d2      	uxtb	r2, r2
 8015472:	701a      	strb	r2, [r3, #0]
 8015474:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015476:	3b06      	subs	r3, #6
 8015478:	62fb      	str	r3, [r7, #44]	; 0x2c
 801547a:	e004      	b.n	8015486 <ipcp_addci+0x292>
 801547c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801547e:	785a      	ldrb	r2, [r3, #1]
 8015480:	2101      	movs	r1, #1
 8015482:	438a      	bics	r2, r1
 8015484:	705a      	strb	r2, [r3, #1]

    ADDCIDNS(CI_MS_DNS2, go->req_dns2, go->dnsaddr[1]);
 8015486:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015488:	785b      	ldrb	r3, [r3, #1]
 801548a:	2202      	movs	r2, #2
 801548c:	4013      	ands	r3, r2
 801548e:	b2db      	uxtb	r3, r3
 8015490:	2b00      	cmp	r3, #0
 8015492:	d037      	beq.n	8015504 <ipcp_addci+0x310>
 8015494:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015496:	2b05      	cmp	r3, #5
 8015498:	dd2f      	ble.n	80154fa <ipcp_addci+0x306>
 801549a:	68bb      	ldr	r3, [r7, #8]
 801549c:	1c5a      	adds	r2, r3, #1
 801549e:	60ba      	str	r2, [r7, #8]
 80154a0:	2283      	movs	r2, #131	; 0x83
 80154a2:	701a      	strb	r2, [r3, #0]
 80154a4:	68bb      	ldr	r3, [r7, #8]
 80154a6:	1c5a      	adds	r2, r3, #1
 80154a8:	60ba      	str	r2, [r7, #8]
 80154aa:	2206      	movs	r2, #6
 80154ac:	701a      	strb	r2, [r3, #0]
 80154ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80154b0:	691b      	ldr	r3, [r3, #16]
 80154b2:	0018      	movs	r0, r3
 80154b4:	f7f1 f854 	bl	8006560 <lwip_htonl>
 80154b8:	0003      	movs	r3, r0
 80154ba:	613b      	str	r3, [r7, #16]
 80154bc:	693b      	ldr	r3, [r7, #16]
 80154be:	0e19      	lsrs	r1, r3, #24
 80154c0:	68bb      	ldr	r3, [r7, #8]
 80154c2:	1c5a      	adds	r2, r3, #1
 80154c4:	60ba      	str	r2, [r7, #8]
 80154c6:	b2ca      	uxtb	r2, r1
 80154c8:	701a      	strb	r2, [r3, #0]
 80154ca:	693b      	ldr	r3, [r7, #16]
 80154cc:	0c19      	lsrs	r1, r3, #16
 80154ce:	68bb      	ldr	r3, [r7, #8]
 80154d0:	1c5a      	adds	r2, r3, #1
 80154d2:	60ba      	str	r2, [r7, #8]
 80154d4:	b2ca      	uxtb	r2, r1
 80154d6:	701a      	strb	r2, [r3, #0]
 80154d8:	693b      	ldr	r3, [r7, #16]
 80154da:	0a19      	lsrs	r1, r3, #8
 80154dc:	68bb      	ldr	r3, [r7, #8]
 80154de:	1c5a      	adds	r2, r3, #1
 80154e0:	60ba      	str	r2, [r7, #8]
 80154e2:	b2ca      	uxtb	r2, r1
 80154e4:	701a      	strb	r2, [r3, #0]
 80154e6:	68bb      	ldr	r3, [r7, #8]
 80154e8:	1c5a      	adds	r2, r3, #1
 80154ea:	60ba      	str	r2, [r7, #8]
 80154ec:	693a      	ldr	r2, [r7, #16]
 80154ee:	b2d2      	uxtb	r2, r2
 80154f0:	701a      	strb	r2, [r3, #0]
 80154f2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80154f4:	3b06      	subs	r3, #6
 80154f6:	62fb      	str	r3, [r7, #44]	; 0x2c
 80154f8:	e004      	b.n	8015504 <ipcp_addci+0x310>
 80154fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80154fc:	785a      	ldrb	r2, [r3, #1]
 80154fe:	2102      	movs	r1, #2
 8015500:	438a      	bics	r2, r1
 8015502:	705a      	strb	r2, [r3, #1]
    ADDCIWINS(CI_MS_WINS1, go->winsaddr[0]);

    ADDCIWINS(CI_MS_WINS2, go->winsaddr[1]);
#endif /* UNUSED - WINS */
    
    *lenp -= len;
 8015504:	687b      	ldr	r3, [r7, #4]
 8015506:	681a      	ldr	r2, [r3, #0]
 8015508:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801550a:	1ad2      	subs	r2, r2, r3
 801550c:	687b      	ldr	r3, [r7, #4]
 801550e:	601a      	str	r2, [r3, #0]
}
 8015510:	46c0      	nop			; (mov r8, r8)
 8015512:	46bd      	mov	sp, r7
 8015514:	b00c      	add	sp, #48	; 0x30
 8015516:	bd80      	pop	{r7, pc}
 8015518:	0000121c 	.word	0x0000121c

0801551c <ipcp_ackci>:
 *
 * Returns:
 *	0 - Ack was bad.
 *	1 - Ack was good.
 */
static int ipcp_ackci(fsm *f, u_char *p, int len) {
 801551c:	b580      	push	{r7, lr}
 801551e:	b08e      	sub	sp, #56	; 0x38
 8015520:	af00      	add	r7, sp, #0
 8015522:	60f8      	str	r0, [r7, #12]
 8015524:	60b9      	str	r1, [r7, #8]
 8015526:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8015528:	68fb      	ldr	r3, [r7, #12]
 801552a:	681b      	ldr	r3, [r3, #0]
 801552c:	637b      	str	r3, [r7, #52]	; 0x34
    ipcp_options *go = &pcb->ipcp_gotoptions;
 801552e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8015530:	4a51      	ldr	r2, [pc, #324]	; (8015678 <ipcp_ackci+0x15c>)
 8015532:	4694      	mov	ip, r2
 8015534:	4463      	add	r3, ip
 8015536:	633b      	str	r3, [r7, #48]	; 0x30
	if (addr != cilong) \
	    goto bad; \
    }
#endif /* UNUSED - WINS */

    ACKCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs, go->ouraddr,
 8015538:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801553a:	781b      	ldrb	r3, [r3, #0]
 801553c:	2201      	movs	r2, #1
 801553e:	4013      	ands	r3, r2
 8015540:	b2db      	uxtb	r3, r3
 8015542:	2b00      	cmp	r3, #0
 8015544:	d000      	beq.n	8015548 <ipcp_ackci+0x2c>
 8015546:	e086      	b.n	8015656 <ipcp_ackci+0x13a>
 8015548:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801554a:	781b      	ldrb	r3, [r3, #0]
 801554c:	2202      	movs	r2, #2
 801554e:	4013      	ands	r3, r2
 8015550:	b2db      	uxtb	r3, r3
 8015552:	2b00      	cmp	r3, #0
 8015554:	d100      	bne.n	8015558 <ipcp_ackci+0x3c>
 8015556:	e07e      	b.n	8015656 <ipcp_ackci+0x13a>
 8015558:	687b      	ldr	r3, [r7, #4]
 801555a:	3b0a      	subs	r3, #10
 801555c:	607b      	str	r3, [r7, #4]
 801555e:	687b      	ldr	r3, [r7, #4]
 8015560:	2b00      	cmp	r3, #0
 8015562:	da00      	bge.n	8015566 <ipcp_ackci+0x4a>
 8015564:	e1f2      	b.n	801594c <ipcp_ackci+0x430>
 8015566:	68bb      	ldr	r3, [r7, #8]
 8015568:	1c5a      	adds	r2, r3, #1
 801556a:	60ba      	str	r2, [r7, #8]
 801556c:	781a      	ldrb	r2, [r3, #0]
 801556e:	212e      	movs	r1, #46	; 0x2e
 8015570:	187b      	adds	r3, r7, r1
 8015572:	801a      	strh	r2, [r3, #0]
 8015574:	68bb      	ldr	r3, [r7, #8]
 8015576:	1c5a      	adds	r2, r3, #1
 8015578:	60ba      	str	r2, [r7, #8]
 801557a:	781a      	ldrb	r2, [r3, #0]
 801557c:	202c      	movs	r0, #44	; 0x2c
 801557e:	183b      	adds	r3, r7, r0
 8015580:	801a      	strh	r2, [r3, #0]
 8015582:	183b      	adds	r3, r7, r0
 8015584:	881b      	ldrh	r3, [r3, #0]
 8015586:	2b0a      	cmp	r3, #10
 8015588:	d000      	beq.n	801558c <ipcp_ackci+0x70>
 801558a:	e1e1      	b.n	8015950 <ipcp_ackci+0x434>
 801558c:	187b      	adds	r3, r7, r1
 801558e:	881b      	ldrh	r3, [r3, #0]
 8015590:	2b01      	cmp	r3, #1
 8015592:	d000      	beq.n	8015596 <ipcp_ackci+0x7a>
 8015594:	e1dc      	b.n	8015950 <ipcp_ackci+0x434>
 8015596:	68bb      	ldr	r3, [r7, #8]
 8015598:	1c5a      	adds	r2, r3, #1
 801559a:	60ba      	str	r2, [r7, #8]
 801559c:	781b      	ldrb	r3, [r3, #0]
 801559e:	021b      	lsls	r3, r3, #8
 80155a0:	62bb      	str	r3, [r7, #40]	; 0x28
 80155a2:	68bb      	ldr	r3, [r7, #8]
 80155a4:	1c5a      	adds	r2, r3, #1
 80155a6:	60ba      	str	r2, [r7, #8]
 80155a8:	781b      	ldrb	r3, [r3, #0]
 80155aa:	001a      	movs	r2, r3
 80155ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80155ae:	4313      	orrs	r3, r2
 80155b0:	62bb      	str	r3, [r7, #40]	; 0x28
 80155b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80155b4:	021b      	lsls	r3, r3, #8
 80155b6:	62bb      	str	r3, [r7, #40]	; 0x28
 80155b8:	68bb      	ldr	r3, [r7, #8]
 80155ba:	1c5a      	adds	r2, r3, #1
 80155bc:	60ba      	str	r2, [r7, #8]
 80155be:	781b      	ldrb	r3, [r3, #0]
 80155c0:	001a      	movs	r2, r3
 80155c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80155c4:	4313      	orrs	r3, r2
 80155c6:	62bb      	str	r3, [r7, #40]	; 0x28
 80155c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80155ca:	021b      	lsls	r3, r3, #8
 80155cc:	62bb      	str	r3, [r7, #40]	; 0x28
 80155ce:	68bb      	ldr	r3, [r7, #8]
 80155d0:	1c5a      	adds	r2, r3, #1
 80155d2:	60ba      	str	r2, [r7, #8]
 80155d4:	781b      	ldrb	r3, [r3, #0]
 80155d6:	001a      	movs	r2, r3
 80155d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80155da:	4313      	orrs	r3, r2
 80155dc:	62bb      	str	r3, [r7, #40]	; 0x28
 80155de:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80155e0:	0018      	movs	r0, r3
 80155e2:	f7f0 ffbd 	bl	8006560 <lwip_htonl>
 80155e6:	0003      	movs	r3, r0
 80155e8:	627b      	str	r3, [r7, #36]	; 0x24
 80155ea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80155ec:	685b      	ldr	r3, [r3, #4]
 80155ee:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80155f0:	429a      	cmp	r2, r3
 80155f2:	d000      	beq.n	80155f6 <ipcp_ackci+0xda>
 80155f4:	e1ae      	b.n	8015954 <ipcp_ackci+0x438>
 80155f6:	68bb      	ldr	r3, [r7, #8]
 80155f8:	1c5a      	adds	r2, r3, #1
 80155fa:	60ba      	str	r2, [r7, #8]
 80155fc:	781b      	ldrb	r3, [r3, #0]
 80155fe:	021b      	lsls	r3, r3, #8
 8015600:	62bb      	str	r3, [r7, #40]	; 0x28
 8015602:	68bb      	ldr	r3, [r7, #8]
 8015604:	1c5a      	adds	r2, r3, #1
 8015606:	60ba      	str	r2, [r7, #8]
 8015608:	781b      	ldrb	r3, [r3, #0]
 801560a:	001a      	movs	r2, r3
 801560c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801560e:	4313      	orrs	r3, r2
 8015610:	62bb      	str	r3, [r7, #40]	; 0x28
 8015612:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015614:	021b      	lsls	r3, r3, #8
 8015616:	62bb      	str	r3, [r7, #40]	; 0x28
 8015618:	68bb      	ldr	r3, [r7, #8]
 801561a:	1c5a      	adds	r2, r3, #1
 801561c:	60ba      	str	r2, [r7, #8]
 801561e:	781b      	ldrb	r3, [r3, #0]
 8015620:	001a      	movs	r2, r3
 8015622:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015624:	4313      	orrs	r3, r2
 8015626:	62bb      	str	r3, [r7, #40]	; 0x28
 8015628:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801562a:	021b      	lsls	r3, r3, #8
 801562c:	62bb      	str	r3, [r7, #40]	; 0x28
 801562e:	68bb      	ldr	r3, [r7, #8]
 8015630:	1c5a      	adds	r2, r3, #1
 8015632:	60ba      	str	r2, [r7, #8]
 8015634:	781b      	ldrb	r3, [r3, #0]
 8015636:	001a      	movs	r2, r3
 8015638:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801563a:	4313      	orrs	r3, r2
 801563c:	62bb      	str	r3, [r7, #40]	; 0x28
 801563e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015640:	0018      	movs	r0, r3
 8015642:	f7f0 ff8d 	bl	8006560 <lwip_htonl>
 8015646:	0003      	movs	r3, r0
 8015648:	627b      	str	r3, [r7, #36]	; 0x24
 801564a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801564c:	689b      	ldr	r3, [r3, #8]
 801564e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015650:	429a      	cmp	r2, r3
 8015652:	d000      	beq.n	8015656 <ipcp_ackci+0x13a>
 8015654:	e180      	b.n	8015958 <ipcp_ackci+0x43c>
	       go->hisaddr);

#if VJ_SUPPORT
    ACKCIVJ(CI_COMPRESSTYPE, go->neg_vj, go->vj_protocol, go->old_vj,
 8015656:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015658:	781b      	ldrb	r3, [r3, #0]
 801565a:	2208      	movs	r2, #8
 801565c:	4013      	ands	r3, r2
 801565e:	b2db      	uxtb	r3, r3
 8015660:	2b00      	cmp	r3, #0
 8015662:	d100      	bne.n	8015666 <ipcp_ackci+0x14a>
 8015664:	e06e      	b.n	8015744 <ipcp_ackci+0x228>
 8015666:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015668:	781b      	ldrb	r3, [r3, #0]
 801566a:	2210      	movs	r2, #16
 801566c:	4013      	ands	r3, r2
 801566e:	b2db      	uxtb	r3, r3
 8015670:	2b00      	cmp	r3, #0
 8015672:	d003      	beq.n	801567c <ipcp_ackci+0x160>
 8015674:	2304      	movs	r3, #4
 8015676:	e002      	b.n	801567e <ipcp_ackci+0x162>
 8015678:	0000121c 	.word	0x0000121c
 801567c:	2306      	movs	r3, #6
 801567e:	623b      	str	r3, [r7, #32]
 8015680:	687a      	ldr	r2, [r7, #4]
 8015682:	6a3b      	ldr	r3, [r7, #32]
 8015684:	1ad3      	subs	r3, r2, r3
 8015686:	607b      	str	r3, [r7, #4]
 8015688:	687b      	ldr	r3, [r7, #4]
 801568a:	2b00      	cmp	r3, #0
 801568c:	da00      	bge.n	8015690 <ipcp_ackci+0x174>
 801568e:	e165      	b.n	801595c <ipcp_ackci+0x440>
 8015690:	68bb      	ldr	r3, [r7, #8]
 8015692:	1c5a      	adds	r2, r3, #1
 8015694:	60ba      	str	r2, [r7, #8]
 8015696:	781a      	ldrb	r2, [r3, #0]
 8015698:	212e      	movs	r1, #46	; 0x2e
 801569a:	187b      	adds	r3, r7, r1
 801569c:	801a      	strh	r2, [r3, #0]
 801569e:	68bb      	ldr	r3, [r7, #8]
 80156a0:	1c5a      	adds	r2, r3, #1
 80156a2:	60ba      	str	r2, [r7, #8]
 80156a4:	781a      	ldrb	r2, [r3, #0]
 80156a6:	202c      	movs	r0, #44	; 0x2c
 80156a8:	183b      	adds	r3, r7, r0
 80156aa:	801a      	strh	r2, [r3, #0]
 80156ac:	183b      	adds	r3, r7, r0
 80156ae:	881b      	ldrh	r3, [r3, #0]
 80156b0:	6a3a      	ldr	r2, [r7, #32]
 80156b2:	429a      	cmp	r2, r3
 80156b4:	d000      	beq.n	80156b8 <ipcp_ackci+0x19c>
 80156b6:	e153      	b.n	8015960 <ipcp_ackci+0x444>
 80156b8:	187b      	adds	r3, r7, r1
 80156ba:	881b      	ldrh	r3, [r3, #0]
 80156bc:	2b02      	cmp	r3, #2
 80156be:	d000      	beq.n	80156c2 <ipcp_ackci+0x1a6>
 80156c0:	e14e      	b.n	8015960 <ipcp_ackci+0x444>
 80156c2:	68bb      	ldr	r3, [r7, #8]
 80156c4:	1c5a      	adds	r2, r3, #1
 80156c6:	60ba      	str	r2, [r7, #8]
 80156c8:	781b      	ldrb	r3, [r3, #0]
 80156ca:	b29a      	uxth	r2, r3
 80156cc:	201e      	movs	r0, #30
 80156ce:	183b      	adds	r3, r7, r0
 80156d0:	0212      	lsls	r2, r2, #8
 80156d2:	801a      	strh	r2, [r3, #0]
 80156d4:	68bb      	ldr	r3, [r7, #8]
 80156d6:	1c5a      	adds	r2, r3, #1
 80156d8:	60ba      	str	r2, [r7, #8]
 80156da:	781b      	ldrb	r3, [r3, #0]
 80156dc:	b299      	uxth	r1, r3
 80156de:	183b      	adds	r3, r7, r0
 80156e0:	183a      	adds	r2, r7, r0
 80156e2:	8812      	ldrh	r2, [r2, #0]
 80156e4:	430a      	orrs	r2, r1
 80156e6:	801a      	strh	r2, [r3, #0]
 80156e8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80156ea:	8a9b      	ldrh	r3, [r3, #20]
 80156ec:	183a      	adds	r2, r7, r0
 80156ee:	8812      	ldrh	r2, [r2, #0]
 80156f0:	429a      	cmp	r2, r3
 80156f2:	d000      	beq.n	80156f6 <ipcp_ackci+0x1da>
 80156f4:	e136      	b.n	8015964 <ipcp_ackci+0x448>
 80156f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80156f8:	781b      	ldrb	r3, [r3, #0]
 80156fa:	2210      	movs	r2, #16
 80156fc:	4013      	ands	r3, r2
 80156fe:	b2db      	uxtb	r3, r3
 8015700:	2b00      	cmp	r3, #0
 8015702:	d11f      	bne.n	8015744 <ipcp_ackci+0x228>
 8015704:	68bb      	ldr	r3, [r7, #8]
 8015706:	1c5a      	adds	r2, r3, #1
 8015708:	60ba      	str	r2, [r7, #8]
 801570a:	211d      	movs	r1, #29
 801570c:	187a      	adds	r2, r7, r1
 801570e:	781b      	ldrb	r3, [r3, #0]
 8015710:	7013      	strb	r3, [r2, #0]
 8015712:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015714:	7d9b      	ldrb	r3, [r3, #22]
 8015716:	187a      	adds	r2, r7, r1
 8015718:	7812      	ldrb	r2, [r2, #0]
 801571a:	429a      	cmp	r2, r3
 801571c:	d000      	beq.n	8015720 <ipcp_ackci+0x204>
 801571e:	e123      	b.n	8015968 <ipcp_ackci+0x44c>
 8015720:	68bb      	ldr	r3, [r7, #8]
 8015722:	1c5a      	adds	r2, r3, #1
 8015724:	60ba      	str	r2, [r7, #8]
 8015726:	211c      	movs	r1, #28
 8015728:	187a      	adds	r2, r7, r1
 801572a:	781b      	ldrb	r3, [r3, #0]
 801572c:	7013      	strb	r3, [r2, #0]
 801572e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015730:	781b      	ldrb	r3, [r3, #0]
 8015732:	069b      	lsls	r3, r3, #26
 8015734:	0fdb      	lsrs	r3, r3, #31
 8015736:	b2db      	uxtb	r3, r3
 8015738:	001a      	movs	r2, r3
 801573a:	187b      	adds	r3, r7, r1
 801573c:	781b      	ldrb	r3, [r3, #0]
 801573e:	4293      	cmp	r3, r2
 8015740:	d000      	beq.n	8015744 <ipcp_ackci+0x228>
 8015742:	e113      	b.n	801596c <ipcp_ackci+0x450>
	    go->maxslotindex, go->cflag);
#endif /* VJ_SUPPORT */

    ACKCIADDR(CI_ADDR, go->neg_addr, go->ouraddr);
 8015744:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015746:	781b      	ldrb	r3, [r3, #0]
 8015748:	2201      	movs	r2, #1
 801574a:	4013      	ands	r3, r2
 801574c:	b2db      	uxtb	r3, r3
 801574e:	2b00      	cmp	r3, #0
 8015750:	d04e      	beq.n	80157f0 <ipcp_ackci+0x2d4>
 8015752:	687b      	ldr	r3, [r7, #4]
 8015754:	3b06      	subs	r3, #6
 8015756:	607b      	str	r3, [r7, #4]
 8015758:	687b      	ldr	r3, [r7, #4]
 801575a:	2b00      	cmp	r3, #0
 801575c:	da00      	bge.n	8015760 <ipcp_ackci+0x244>
 801575e:	e107      	b.n	8015970 <ipcp_ackci+0x454>
 8015760:	68bb      	ldr	r3, [r7, #8]
 8015762:	1c5a      	adds	r2, r3, #1
 8015764:	60ba      	str	r2, [r7, #8]
 8015766:	781a      	ldrb	r2, [r3, #0]
 8015768:	212e      	movs	r1, #46	; 0x2e
 801576a:	187b      	adds	r3, r7, r1
 801576c:	801a      	strh	r2, [r3, #0]
 801576e:	68bb      	ldr	r3, [r7, #8]
 8015770:	1c5a      	adds	r2, r3, #1
 8015772:	60ba      	str	r2, [r7, #8]
 8015774:	781a      	ldrb	r2, [r3, #0]
 8015776:	202c      	movs	r0, #44	; 0x2c
 8015778:	183b      	adds	r3, r7, r0
 801577a:	801a      	strh	r2, [r3, #0]
 801577c:	183b      	adds	r3, r7, r0
 801577e:	881b      	ldrh	r3, [r3, #0]
 8015780:	2b06      	cmp	r3, #6
 8015782:	d000      	beq.n	8015786 <ipcp_ackci+0x26a>
 8015784:	e0f6      	b.n	8015974 <ipcp_ackci+0x458>
 8015786:	187b      	adds	r3, r7, r1
 8015788:	881b      	ldrh	r3, [r3, #0]
 801578a:	2b03      	cmp	r3, #3
 801578c:	d000      	beq.n	8015790 <ipcp_ackci+0x274>
 801578e:	e0f1      	b.n	8015974 <ipcp_ackci+0x458>
 8015790:	68bb      	ldr	r3, [r7, #8]
 8015792:	1c5a      	adds	r2, r3, #1
 8015794:	60ba      	str	r2, [r7, #8]
 8015796:	781b      	ldrb	r3, [r3, #0]
 8015798:	021b      	lsls	r3, r3, #8
 801579a:	61bb      	str	r3, [r7, #24]
 801579c:	68bb      	ldr	r3, [r7, #8]
 801579e:	1c5a      	adds	r2, r3, #1
 80157a0:	60ba      	str	r2, [r7, #8]
 80157a2:	781b      	ldrb	r3, [r3, #0]
 80157a4:	001a      	movs	r2, r3
 80157a6:	69bb      	ldr	r3, [r7, #24]
 80157a8:	4313      	orrs	r3, r2
 80157aa:	61bb      	str	r3, [r7, #24]
 80157ac:	69bb      	ldr	r3, [r7, #24]
 80157ae:	021b      	lsls	r3, r3, #8
 80157b0:	61bb      	str	r3, [r7, #24]
 80157b2:	68bb      	ldr	r3, [r7, #8]
 80157b4:	1c5a      	adds	r2, r3, #1
 80157b6:	60ba      	str	r2, [r7, #8]
 80157b8:	781b      	ldrb	r3, [r3, #0]
 80157ba:	001a      	movs	r2, r3
 80157bc:	69bb      	ldr	r3, [r7, #24]
 80157be:	4313      	orrs	r3, r2
 80157c0:	61bb      	str	r3, [r7, #24]
 80157c2:	69bb      	ldr	r3, [r7, #24]
 80157c4:	021b      	lsls	r3, r3, #8
 80157c6:	61bb      	str	r3, [r7, #24]
 80157c8:	68bb      	ldr	r3, [r7, #8]
 80157ca:	1c5a      	adds	r2, r3, #1
 80157cc:	60ba      	str	r2, [r7, #8]
 80157ce:	781b      	ldrb	r3, [r3, #0]
 80157d0:	001a      	movs	r2, r3
 80157d2:	69bb      	ldr	r3, [r7, #24]
 80157d4:	4313      	orrs	r3, r2
 80157d6:	61bb      	str	r3, [r7, #24]
 80157d8:	69bb      	ldr	r3, [r7, #24]
 80157da:	0018      	movs	r0, r3
 80157dc:	f7f0 fec0 	bl	8006560 <lwip_htonl>
 80157e0:	0003      	movs	r3, r0
 80157e2:	627b      	str	r3, [r7, #36]	; 0x24
 80157e4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80157e6:	685b      	ldr	r3, [r3, #4]
 80157e8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80157ea:	429a      	cmp	r2, r3
 80157ec:	d000      	beq.n	80157f0 <ipcp_ackci+0x2d4>
 80157ee:	e0c3      	b.n	8015978 <ipcp_ackci+0x45c>

#if LWIP_DNS
    ACKCIDNS(CI_MS_DNS1, go->req_dns1, go->dnsaddr[0]);
 80157f0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80157f2:	785b      	ldrb	r3, [r3, #1]
 80157f4:	2201      	movs	r2, #1
 80157f6:	4013      	ands	r3, r2
 80157f8:	b2db      	uxtb	r3, r3
 80157fa:	2b00      	cmp	r3, #0
 80157fc:	d04e      	beq.n	801589c <ipcp_ackci+0x380>
 80157fe:	687b      	ldr	r3, [r7, #4]
 8015800:	3b06      	subs	r3, #6
 8015802:	607b      	str	r3, [r7, #4]
 8015804:	687b      	ldr	r3, [r7, #4]
 8015806:	2b00      	cmp	r3, #0
 8015808:	da00      	bge.n	801580c <ipcp_ackci+0x2f0>
 801580a:	e0b7      	b.n	801597c <ipcp_ackci+0x460>
 801580c:	68bb      	ldr	r3, [r7, #8]
 801580e:	1c5a      	adds	r2, r3, #1
 8015810:	60ba      	str	r2, [r7, #8]
 8015812:	781a      	ldrb	r2, [r3, #0]
 8015814:	212e      	movs	r1, #46	; 0x2e
 8015816:	187b      	adds	r3, r7, r1
 8015818:	801a      	strh	r2, [r3, #0]
 801581a:	68bb      	ldr	r3, [r7, #8]
 801581c:	1c5a      	adds	r2, r3, #1
 801581e:	60ba      	str	r2, [r7, #8]
 8015820:	781a      	ldrb	r2, [r3, #0]
 8015822:	202c      	movs	r0, #44	; 0x2c
 8015824:	183b      	adds	r3, r7, r0
 8015826:	801a      	strh	r2, [r3, #0]
 8015828:	183b      	adds	r3, r7, r0
 801582a:	881b      	ldrh	r3, [r3, #0]
 801582c:	2b06      	cmp	r3, #6
 801582e:	d000      	beq.n	8015832 <ipcp_ackci+0x316>
 8015830:	e0a6      	b.n	8015980 <ipcp_ackci+0x464>
 8015832:	187b      	adds	r3, r7, r1
 8015834:	881b      	ldrh	r3, [r3, #0]
 8015836:	2b81      	cmp	r3, #129	; 0x81
 8015838:	d000      	beq.n	801583c <ipcp_ackci+0x320>
 801583a:	e0a1      	b.n	8015980 <ipcp_ackci+0x464>
 801583c:	68bb      	ldr	r3, [r7, #8]
 801583e:	1c5a      	adds	r2, r3, #1
 8015840:	60ba      	str	r2, [r7, #8]
 8015842:	781b      	ldrb	r3, [r3, #0]
 8015844:	021b      	lsls	r3, r3, #8
 8015846:	617b      	str	r3, [r7, #20]
 8015848:	68bb      	ldr	r3, [r7, #8]
 801584a:	1c5a      	adds	r2, r3, #1
 801584c:	60ba      	str	r2, [r7, #8]
 801584e:	781b      	ldrb	r3, [r3, #0]
 8015850:	001a      	movs	r2, r3
 8015852:	697b      	ldr	r3, [r7, #20]
 8015854:	4313      	orrs	r3, r2
 8015856:	617b      	str	r3, [r7, #20]
 8015858:	697b      	ldr	r3, [r7, #20]
 801585a:	021b      	lsls	r3, r3, #8
 801585c:	617b      	str	r3, [r7, #20]
 801585e:	68bb      	ldr	r3, [r7, #8]
 8015860:	1c5a      	adds	r2, r3, #1
 8015862:	60ba      	str	r2, [r7, #8]
 8015864:	781b      	ldrb	r3, [r3, #0]
 8015866:	001a      	movs	r2, r3
 8015868:	697b      	ldr	r3, [r7, #20]
 801586a:	4313      	orrs	r3, r2
 801586c:	617b      	str	r3, [r7, #20]
 801586e:	697b      	ldr	r3, [r7, #20]
 8015870:	021b      	lsls	r3, r3, #8
 8015872:	617b      	str	r3, [r7, #20]
 8015874:	68bb      	ldr	r3, [r7, #8]
 8015876:	1c5a      	adds	r2, r3, #1
 8015878:	60ba      	str	r2, [r7, #8]
 801587a:	781b      	ldrb	r3, [r3, #0]
 801587c:	001a      	movs	r2, r3
 801587e:	697b      	ldr	r3, [r7, #20]
 8015880:	4313      	orrs	r3, r2
 8015882:	617b      	str	r3, [r7, #20]
 8015884:	697b      	ldr	r3, [r7, #20]
 8015886:	0018      	movs	r0, r3
 8015888:	f7f0 fe6a 	bl	8006560 <lwip_htonl>
 801588c:	0003      	movs	r3, r0
 801588e:	627b      	str	r3, [r7, #36]	; 0x24
 8015890:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8015892:	68db      	ldr	r3, [r3, #12]
 8015894:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8015896:	429a      	cmp	r2, r3
 8015898:	d000      	beq.n	801589c <ipcp_ackci+0x380>
 801589a:	e073      	b.n	8015984 <ipcp_ackci+0x468>

    ACKCIDNS(CI_MS_DNS2, go->req_dns2, go->dnsaddr[1]);
 801589c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801589e:	785b      	ldrb	r3, [r3, #1]
 80158a0:	2202      	movs	r2, #2
 80158a2:	4013      	ands	r3, r2
 80158a4:	b2db      	uxtb	r3, r3
 80158a6:	2b00      	cmp	r3, #0
 80158a8:	d04b      	beq.n	8015942 <ipcp_ackci+0x426>
 80158aa:	687b      	ldr	r3, [r7, #4]
 80158ac:	3b06      	subs	r3, #6
 80158ae:	607b      	str	r3, [r7, #4]
 80158b0:	687b      	ldr	r3, [r7, #4]
 80158b2:	2b00      	cmp	r3, #0
 80158b4:	da00      	bge.n	80158b8 <ipcp_ackci+0x39c>
 80158b6:	e067      	b.n	8015988 <ipcp_ackci+0x46c>
 80158b8:	68bb      	ldr	r3, [r7, #8]
 80158ba:	1c5a      	adds	r2, r3, #1
 80158bc:	60ba      	str	r2, [r7, #8]
 80158be:	781a      	ldrb	r2, [r3, #0]
 80158c0:	212e      	movs	r1, #46	; 0x2e
 80158c2:	187b      	adds	r3, r7, r1
 80158c4:	801a      	strh	r2, [r3, #0]
 80158c6:	68bb      	ldr	r3, [r7, #8]
 80158c8:	1c5a      	adds	r2, r3, #1
 80158ca:	60ba      	str	r2, [r7, #8]
 80158cc:	781a      	ldrb	r2, [r3, #0]
 80158ce:	202c      	movs	r0, #44	; 0x2c
 80158d0:	183b      	adds	r3, r7, r0
 80158d2:	801a      	strh	r2, [r3, #0]
 80158d4:	183b      	adds	r3, r7, r0
 80158d6:	881b      	ldrh	r3, [r3, #0]
 80158d8:	2b06      	cmp	r3, #6
 80158da:	d157      	bne.n	801598c <ipcp_ackci+0x470>
 80158dc:	187b      	adds	r3, r7, r1
 80158de:	881b      	ldrh	r3, [r3, #0]
 80158e0:	2b83      	cmp	r3, #131	; 0x83
 80158e2:	d153      	bne.n	801598c <ipcp_ackci+0x470>
 80158e4:	68bb      	ldr	r3, [r7, #8]
 80158e6:	1c5a      	adds	r2, r3, #1
 80158e8:	60ba      	str	r2, [r7, #8]
 80158ea:	781b      	ldrb	r3, [r3, #0]
 80158ec:	021b      	lsls	r3, r3, #8
 80158ee:	613b      	str	r3, [r7, #16]
 80158f0:	68bb      	ldr	r3, [r7, #8]
 80158f2:	1c5a      	adds	r2, r3, #1
 80158f4:	60ba      	str	r2, [r7, #8]
 80158f6:	781b      	ldrb	r3, [r3, #0]
 80158f8:	001a      	movs	r2, r3
 80158fa:	693b      	ldr	r3, [r7, #16]
 80158fc:	4313      	orrs	r3, r2
 80158fe:	613b      	str	r3, [r7, #16]
 8015900:	693b      	ldr	r3, [r7, #16]
 8015902:	021b      	lsls	r3, r3, #8
 8015904:	613b      	str	r3, [r7, #16]
 8015906:	68bb      	ldr	r3, [r7, #8]
 8015908:	1c5a      	adds	r2, r3, #1
 801590a:	60ba      	str	r2, [r7, #8]
 801590c:	781b      	ldrb	r3, [r3, #0]
 801590e:	001a      	movs	r2, r3
 8015910:	693b      	ldr	r3, [r7, #16]
 8015912:	4313      	orrs	r3, r2
 8015914:	613b      	str	r3, [r7, #16]
 8015916:	693b      	ldr	r3, [r7, #16]
 8015918:	021b      	lsls	r3, r3, #8
 801591a:	613b      	str	r3, [r7, #16]
 801591c:	68bb      	ldr	r3, [r7, #8]
 801591e:	1c5a      	adds	r2, r3, #1
 8015920:	60ba      	str	r2, [r7, #8]
 8015922:	781b      	ldrb	r3, [r3, #0]
 8015924:	001a      	movs	r2, r3
 8015926:	693b      	ldr	r3, [r7, #16]
 8015928:	4313      	orrs	r3, r2
 801592a:	613b      	str	r3, [r7, #16]
 801592c:	693b      	ldr	r3, [r7, #16]
 801592e:	0018      	movs	r0, r3
 8015930:	f7f0 fe16 	bl	8006560 <lwip_htonl>
 8015934:	0003      	movs	r3, r0
 8015936:	627b      	str	r3, [r7, #36]	; 0x24
 8015938:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801593a:	691b      	ldr	r3, [r3, #16]
 801593c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801593e:	429a      	cmp	r2, r3
 8015940:	d126      	bne.n	8015990 <ipcp_ackci+0x474>
#endif /* UNUSED - WINS */

    /*
     * If there are any remaining CIs, then this packet is bad.
     */
    if (len != 0)
 8015942:	687b      	ldr	r3, [r7, #4]
 8015944:	2b00      	cmp	r3, #0
 8015946:	d125      	bne.n	8015994 <ipcp_ackci+0x478>
	goto bad;
    return (1);
 8015948:	2301      	movs	r3, #1
 801594a:	e025      	b.n	8015998 <ipcp_ackci+0x47c>
    ACKCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs, go->ouraddr,
 801594c:	46c0      	nop			; (mov r8, r8)
 801594e:	e022      	b.n	8015996 <ipcp_ackci+0x47a>
 8015950:	46c0      	nop			; (mov r8, r8)
 8015952:	e020      	b.n	8015996 <ipcp_ackci+0x47a>
 8015954:	46c0      	nop			; (mov r8, r8)
 8015956:	e01e      	b.n	8015996 <ipcp_ackci+0x47a>
 8015958:	46c0      	nop			; (mov r8, r8)
 801595a:	e01c      	b.n	8015996 <ipcp_ackci+0x47a>
    ACKCIVJ(CI_COMPRESSTYPE, go->neg_vj, go->vj_protocol, go->old_vj,
 801595c:	46c0      	nop			; (mov r8, r8)
 801595e:	e01a      	b.n	8015996 <ipcp_ackci+0x47a>
 8015960:	46c0      	nop			; (mov r8, r8)
 8015962:	e018      	b.n	8015996 <ipcp_ackci+0x47a>
 8015964:	46c0      	nop			; (mov r8, r8)
 8015966:	e016      	b.n	8015996 <ipcp_ackci+0x47a>
 8015968:	46c0      	nop			; (mov r8, r8)
 801596a:	e014      	b.n	8015996 <ipcp_ackci+0x47a>
 801596c:	46c0      	nop			; (mov r8, r8)
 801596e:	e012      	b.n	8015996 <ipcp_ackci+0x47a>
    ACKCIADDR(CI_ADDR, go->neg_addr, go->ouraddr);
 8015970:	46c0      	nop			; (mov r8, r8)
 8015972:	e010      	b.n	8015996 <ipcp_ackci+0x47a>
 8015974:	46c0      	nop			; (mov r8, r8)
 8015976:	e00e      	b.n	8015996 <ipcp_ackci+0x47a>
 8015978:	46c0      	nop			; (mov r8, r8)
 801597a:	e00c      	b.n	8015996 <ipcp_ackci+0x47a>
    ACKCIDNS(CI_MS_DNS1, go->req_dns1, go->dnsaddr[0]);
 801597c:	46c0      	nop			; (mov r8, r8)
 801597e:	e00a      	b.n	8015996 <ipcp_ackci+0x47a>
 8015980:	46c0      	nop			; (mov r8, r8)
 8015982:	e008      	b.n	8015996 <ipcp_ackci+0x47a>
 8015984:	46c0      	nop			; (mov r8, r8)
 8015986:	e006      	b.n	8015996 <ipcp_ackci+0x47a>
    ACKCIDNS(CI_MS_DNS2, go->req_dns2, go->dnsaddr[1]);
 8015988:	46c0      	nop			; (mov r8, r8)
 801598a:	e004      	b.n	8015996 <ipcp_ackci+0x47a>
 801598c:	46c0      	nop			; (mov r8, r8)
 801598e:	e002      	b.n	8015996 <ipcp_ackci+0x47a>
 8015990:	46c0      	nop			; (mov r8, r8)
 8015992:	e000      	b.n	8015996 <ipcp_ackci+0x47a>
	goto bad;
 8015994:	46c0      	nop			; (mov r8, r8)

bad:
    IPCPDEBUG(("ipcp_ackci: received bad Ack!"));
    return (0);
 8015996:	2300      	movs	r3, #0
}
 8015998:	0018      	movs	r0, r3
 801599a:	46bd      	mov	sp, r7
 801599c:	b00e      	add	sp, #56	; 0x38
 801599e:	bd80      	pop	{r7, pc}

080159a0 <ipcp_nakci>:
 *
 * Returns:
 *	0 - Nak was bad.
 *	1 - Nak was good.
 */
static int ipcp_nakci(fsm *f, u_char *p, int len, int treat_as_reject) {
 80159a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80159a2:	b09b      	sub	sp, #108	; 0x6c
 80159a4:	af00      	add	r7, sp, #0
 80159a6:	60f8      	str	r0, [r7, #12]
 80159a8:	60b9      	str	r1, [r7, #8]
 80159aa:	607a      	str	r2, [r7, #4]
 80159ac:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 80159ae:	68fb      	ldr	r3, [r7, #12]
 80159b0:	681b      	ldr	r3, [r3, #0]
 80159b2:	667b      	str	r3, [r7, #100]	; 0x64
    ipcp_options *go = &pcb->ipcp_gotoptions;
 80159b4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80159b6:	4ae0      	ldr	r2, [pc, #896]	; (8015d38 <ipcp_nakci+0x398>)
 80159b8:	4694      	mov	ip, r2
 80159ba:	4463      	add	r3, ip
 80159bc:	663b      	str	r3, [r7, #96]	; 0x60
    u32_t cidnsaddr;
#endif /* LWIP_DNS */
    ipcp_options no;		/* options we've seen Naks for */
    ipcp_options try_;		/* options to request next time */

    BZERO(&no, sizeof(no));
 80159be:	2428      	movs	r4, #40	; 0x28
 80159c0:	193b      	adds	r3, r7, r4
 80159c2:	2218      	movs	r2, #24
 80159c4:	2100      	movs	r1, #0
 80159c6:	0018      	movs	r0, r3
 80159c8:	f006 ff30 	bl	801c82c <memset>
    try_ = *go;
 80159cc:	2510      	movs	r5, #16
 80159ce:	197b      	adds	r3, r7, r5
 80159d0:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80159d2:	ca43      	ldmia	r2!, {r0, r1, r6}
 80159d4:	c343      	stmia	r3!, {r0, r1, r6}
 80159d6:	ca43      	ldmia	r2!, {r0, r1, r6}
 80159d8:	c343      	stmia	r3!, {r0, r1, r6}

    /*
     * Accept the peer's idea of {our,his} address, if different
     * from our idea, only if the accept_{local,remote} flag is set.
     */
    NAKCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs,
 80159da:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80159dc:	781b      	ldrb	r3, [r3, #0]
 80159de:	2201      	movs	r2, #1
 80159e0:	4013      	ands	r3, r2
 80159e2:	b2db      	uxtb	r3, r3
 80159e4:	2b00      	cmp	r3, #0
 80159e6:	d000      	beq.n	80159ea <ipcp_nakci+0x4a>
 80159e8:	e0a2      	b.n	8015b30 <ipcp_nakci+0x190>
 80159ea:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80159ec:	781b      	ldrb	r3, [r3, #0]
 80159ee:	2202      	movs	r2, #2
 80159f0:	4013      	ands	r3, r2
 80159f2:	b2db      	uxtb	r3, r3
 80159f4:	2b00      	cmp	r3, #0
 80159f6:	d100      	bne.n	80159fa <ipcp_nakci+0x5a>
 80159f8:	e09a      	b.n	8015b30 <ipcp_nakci+0x190>
 80159fa:	215f      	movs	r1, #95	; 0x5f
 80159fc:	187b      	adds	r3, r7, r1
 80159fe:	68ba      	ldr	r2, [r7, #8]
 8015a00:	7852      	ldrb	r2, [r2, #1]
 8015a02:	701a      	strb	r2, [r3, #0]
 8015a04:	187b      	adds	r3, r7, r1
 8015a06:	781b      	ldrb	r3, [r3, #0]
 8015a08:	2b0a      	cmp	r3, #10
 8015a0a:	d000      	beq.n	8015a0e <ipcp_nakci+0x6e>
 8015a0c:	e090      	b.n	8015b30 <ipcp_nakci+0x190>
 8015a0e:	187b      	adds	r3, r7, r1
 8015a10:	781b      	ldrb	r3, [r3, #0]
 8015a12:	687a      	ldr	r2, [r7, #4]
 8015a14:	429a      	cmp	r2, r3
 8015a16:	da00      	bge.n	8015a1a <ipcp_nakci+0x7a>
 8015a18:	e08a      	b.n	8015b30 <ipcp_nakci+0x190>
 8015a1a:	68bb      	ldr	r3, [r7, #8]
 8015a1c:	781b      	ldrb	r3, [r3, #0]
 8015a1e:	2b01      	cmp	r3, #1
 8015a20:	d000      	beq.n	8015a24 <ipcp_nakci+0x84>
 8015a22:	e085      	b.n	8015b30 <ipcp_nakci+0x190>
 8015a24:	187b      	adds	r3, r7, r1
 8015a26:	781b      	ldrb	r3, [r3, #0]
 8015a28:	687a      	ldr	r2, [r7, #4]
 8015a2a:	1ad3      	subs	r3, r2, r3
 8015a2c:	607b      	str	r3, [r7, #4]
 8015a2e:	68bb      	ldr	r3, [r7, #8]
 8015a30:	3302      	adds	r3, #2
 8015a32:	60bb      	str	r3, [r7, #8]
 8015a34:	68bb      	ldr	r3, [r7, #8]
 8015a36:	1c5a      	adds	r2, r3, #1
 8015a38:	60ba      	str	r2, [r7, #8]
 8015a3a:	781b      	ldrb	r3, [r3, #0]
 8015a3c:	021b      	lsls	r3, r3, #8
 8015a3e:	65bb      	str	r3, [r7, #88]	; 0x58
 8015a40:	68bb      	ldr	r3, [r7, #8]
 8015a42:	1c5a      	adds	r2, r3, #1
 8015a44:	60ba      	str	r2, [r7, #8]
 8015a46:	781b      	ldrb	r3, [r3, #0]
 8015a48:	001a      	movs	r2, r3
 8015a4a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015a4c:	4313      	orrs	r3, r2
 8015a4e:	65bb      	str	r3, [r7, #88]	; 0x58
 8015a50:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015a52:	021b      	lsls	r3, r3, #8
 8015a54:	65bb      	str	r3, [r7, #88]	; 0x58
 8015a56:	68bb      	ldr	r3, [r7, #8]
 8015a58:	1c5a      	adds	r2, r3, #1
 8015a5a:	60ba      	str	r2, [r7, #8]
 8015a5c:	781b      	ldrb	r3, [r3, #0]
 8015a5e:	001a      	movs	r2, r3
 8015a60:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015a62:	4313      	orrs	r3, r2
 8015a64:	65bb      	str	r3, [r7, #88]	; 0x58
 8015a66:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015a68:	021b      	lsls	r3, r3, #8
 8015a6a:	65bb      	str	r3, [r7, #88]	; 0x58
 8015a6c:	68bb      	ldr	r3, [r7, #8]
 8015a6e:	1c5a      	adds	r2, r3, #1
 8015a70:	60ba      	str	r2, [r7, #8]
 8015a72:	781b      	ldrb	r3, [r3, #0]
 8015a74:	001a      	movs	r2, r3
 8015a76:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015a78:	4313      	orrs	r3, r2
 8015a7a:	65bb      	str	r3, [r7, #88]	; 0x58
 8015a7c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015a7e:	0018      	movs	r0, r3
 8015a80:	f7f0 fd6e 	bl	8006560 <lwip_htonl>
 8015a84:	0003      	movs	r3, r0
 8015a86:	657b      	str	r3, [r7, #84]	; 0x54
 8015a88:	68bb      	ldr	r3, [r7, #8]
 8015a8a:	1c5a      	adds	r2, r3, #1
 8015a8c:	60ba      	str	r2, [r7, #8]
 8015a8e:	781b      	ldrb	r3, [r3, #0]
 8015a90:	021b      	lsls	r3, r3, #8
 8015a92:	65bb      	str	r3, [r7, #88]	; 0x58
 8015a94:	68bb      	ldr	r3, [r7, #8]
 8015a96:	1c5a      	adds	r2, r3, #1
 8015a98:	60ba      	str	r2, [r7, #8]
 8015a9a:	781b      	ldrb	r3, [r3, #0]
 8015a9c:	001a      	movs	r2, r3
 8015a9e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015aa0:	4313      	orrs	r3, r2
 8015aa2:	65bb      	str	r3, [r7, #88]	; 0x58
 8015aa4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015aa6:	021b      	lsls	r3, r3, #8
 8015aa8:	65bb      	str	r3, [r7, #88]	; 0x58
 8015aaa:	68bb      	ldr	r3, [r7, #8]
 8015aac:	1c5a      	adds	r2, r3, #1
 8015aae:	60ba      	str	r2, [r7, #8]
 8015ab0:	781b      	ldrb	r3, [r3, #0]
 8015ab2:	001a      	movs	r2, r3
 8015ab4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015ab6:	4313      	orrs	r3, r2
 8015ab8:	65bb      	str	r3, [r7, #88]	; 0x58
 8015aba:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015abc:	021b      	lsls	r3, r3, #8
 8015abe:	65bb      	str	r3, [r7, #88]	; 0x58
 8015ac0:	68bb      	ldr	r3, [r7, #8]
 8015ac2:	1c5a      	adds	r2, r3, #1
 8015ac4:	60ba      	str	r2, [r7, #8]
 8015ac6:	781b      	ldrb	r3, [r3, #0]
 8015ac8:	001a      	movs	r2, r3
 8015aca:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015acc:	4313      	orrs	r3, r2
 8015ace:	65bb      	str	r3, [r7, #88]	; 0x58
 8015ad0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015ad2:	0018      	movs	r0, r3
 8015ad4:	f7f0 fd44 	bl	8006560 <lwip_htonl>
 8015ad8:	0003      	movs	r3, r0
 8015ada:	653b      	str	r3, [r7, #80]	; 0x50
 8015adc:	193b      	adds	r3, r7, r4
 8015ade:	781a      	ldrb	r2, [r3, #0]
 8015ae0:	2102      	movs	r1, #2
 8015ae2:	430a      	orrs	r2, r1
 8015ae4:	701a      	strb	r2, [r3, #0]
 8015ae6:	683b      	ldr	r3, [r7, #0]
 8015ae8:	2b00      	cmp	r3, #0
 8015aea:	d005      	beq.n	8015af8 <ipcp_nakci+0x158>
 8015aec:	197b      	adds	r3, r7, r5
 8015aee:	781a      	ldrb	r2, [r3, #0]
 8015af0:	2102      	movs	r1, #2
 8015af2:	438a      	bics	r2, r1
 8015af4:	701a      	strb	r2, [r3, #0]
 8015af6:	e01b      	b.n	8015b30 <ipcp_nakci+0x190>
 8015af8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8015afa:	781b      	ldrb	r3, [r3, #0]
 8015afc:	2240      	movs	r2, #64	; 0x40
 8015afe:	4013      	ands	r3, r2
 8015b00:	b2db      	uxtb	r3, r3
 8015b02:	2b00      	cmp	r3, #0
 8015b04:	d006      	beq.n	8015b14 <ipcp_nakci+0x174>
 8015b06:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8015b08:	2b00      	cmp	r3, #0
 8015b0a:	d003      	beq.n	8015b14 <ipcp_nakci+0x174>
 8015b0c:	2310      	movs	r3, #16
 8015b0e:	18fb      	adds	r3, r7, r3
 8015b10:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8015b12:	605a      	str	r2, [r3, #4]
 8015b14:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8015b16:	781b      	ldrb	r3, [r3, #0]
 8015b18:	227f      	movs	r2, #127	; 0x7f
 8015b1a:	4393      	bics	r3, r2
 8015b1c:	b2db      	uxtb	r3, r3
 8015b1e:	2b00      	cmp	r3, #0
 8015b20:	d006      	beq.n	8015b30 <ipcp_nakci+0x190>
 8015b22:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8015b24:	2b00      	cmp	r3, #0
 8015b26:	d003      	beq.n	8015b30 <ipcp_nakci+0x190>
 8015b28:	2310      	movs	r3, #16
 8015b2a:	18fb      	adds	r3, r7, r3
 8015b2c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8015b2e:	609a      	str	r2, [r3, #8]
     * Accept the peer's value of maxslotindex provided that it
     * is less than what we asked for.  Turn off slot-ID compression
     * if the peer wants.  Send old-style compress-type option if
     * the peer wants.
     */
    NAKCIVJ(CI_COMPRESSTYPE, neg_vj,
 8015b30:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8015b32:	781b      	ldrb	r3, [r3, #0]
 8015b34:	2208      	movs	r2, #8
 8015b36:	4013      	ands	r3, r2
 8015b38:	b2db      	uxtb	r3, r3
 8015b3a:	2b00      	cmp	r3, #0
 8015b3c:	d100      	bne.n	8015b40 <ipcp_nakci+0x1a0>
 8015b3e:	e09b      	b.n	8015c78 <ipcp_nakci+0x2d8>
 8015b40:	215f      	movs	r1, #95	; 0x5f
 8015b42:	187b      	adds	r3, r7, r1
 8015b44:	68ba      	ldr	r2, [r7, #8]
 8015b46:	7852      	ldrb	r2, [r2, #1]
 8015b48:	701a      	strb	r2, [r3, #0]
 8015b4a:	000a      	movs	r2, r1
 8015b4c:	18bb      	adds	r3, r7, r2
 8015b4e:	781b      	ldrb	r3, [r3, #0]
 8015b50:	2b04      	cmp	r3, #4
 8015b52:	d004      	beq.n	8015b5e <ipcp_nakci+0x1be>
 8015b54:	18bb      	adds	r3, r7, r2
 8015b56:	781b      	ldrb	r3, [r3, #0]
 8015b58:	2b06      	cmp	r3, #6
 8015b5a:	d000      	beq.n	8015b5e <ipcp_nakci+0x1be>
 8015b5c:	e08c      	b.n	8015c78 <ipcp_nakci+0x2d8>
 8015b5e:	215f      	movs	r1, #95	; 0x5f
 8015b60:	187b      	adds	r3, r7, r1
 8015b62:	781b      	ldrb	r3, [r3, #0]
 8015b64:	687a      	ldr	r2, [r7, #4]
 8015b66:	429a      	cmp	r2, r3
 8015b68:	da00      	bge.n	8015b6c <ipcp_nakci+0x1cc>
 8015b6a:	e085      	b.n	8015c78 <ipcp_nakci+0x2d8>
 8015b6c:	68bb      	ldr	r3, [r7, #8]
 8015b6e:	781b      	ldrb	r3, [r3, #0]
 8015b70:	2b02      	cmp	r3, #2
 8015b72:	d000      	beq.n	8015b76 <ipcp_nakci+0x1d6>
 8015b74:	e080      	b.n	8015c78 <ipcp_nakci+0x2d8>
 8015b76:	187b      	adds	r3, r7, r1
 8015b78:	781b      	ldrb	r3, [r3, #0]
 8015b7a:	687a      	ldr	r2, [r7, #4]
 8015b7c:	1ad3      	subs	r3, r2, r3
 8015b7e:	607b      	str	r3, [r7, #4]
 8015b80:	68bb      	ldr	r3, [r7, #8]
 8015b82:	3302      	adds	r3, #2
 8015b84:	60bb      	str	r3, [r7, #8]
 8015b86:	68bb      	ldr	r3, [r7, #8]
 8015b88:	1c5a      	adds	r2, r3, #1
 8015b8a:	60ba      	str	r2, [r7, #8]
 8015b8c:	781b      	ldrb	r3, [r3, #0]
 8015b8e:	b29a      	uxth	r2, r3
 8015b90:	204e      	movs	r0, #78	; 0x4e
 8015b92:	183b      	adds	r3, r7, r0
 8015b94:	0212      	lsls	r2, r2, #8
 8015b96:	801a      	strh	r2, [r3, #0]
 8015b98:	68bb      	ldr	r3, [r7, #8]
 8015b9a:	1c5a      	adds	r2, r3, #1
 8015b9c:	60ba      	str	r2, [r7, #8]
 8015b9e:	781b      	ldrb	r3, [r3, #0]
 8015ba0:	b299      	uxth	r1, r3
 8015ba2:	183b      	adds	r3, r7, r0
 8015ba4:	183a      	adds	r2, r7, r0
 8015ba6:	8812      	ldrh	r2, [r2, #0]
 8015ba8:	430a      	orrs	r2, r1
 8015baa:	801a      	strh	r2, [r3, #0]
 8015bac:	2328      	movs	r3, #40	; 0x28
 8015bae:	18fb      	adds	r3, r7, r3
 8015bb0:	781a      	ldrb	r2, [r3, #0]
 8015bb2:	2108      	movs	r1, #8
 8015bb4:	430a      	orrs	r2, r1
 8015bb6:	701a      	strb	r2, [r3, #0]
 8015bb8:	683b      	ldr	r3, [r7, #0]
 8015bba:	2b00      	cmp	r3, #0
 8015bbc:	d006      	beq.n	8015bcc <ipcp_nakci+0x22c>
 8015bbe:	2310      	movs	r3, #16
 8015bc0:	18fb      	adds	r3, r7, r3
 8015bc2:	781a      	ldrb	r2, [r3, #0]
 8015bc4:	2108      	movs	r1, #8
 8015bc6:	438a      	bics	r2, r1
 8015bc8:	701a      	strb	r2, [r3, #0]
 8015bca:	e055      	b.n	8015c78 <ipcp_nakci+0x2d8>
 8015bcc:	235f      	movs	r3, #95	; 0x5f
 8015bce:	18fb      	adds	r3, r7, r3
 8015bd0:	781b      	ldrb	r3, [r3, #0]
 8015bd2:	2b06      	cmp	r3, #6
 8015bd4:	d135      	bne.n	8015c42 <ipcp_nakci+0x2a2>
 8015bd6:	68bb      	ldr	r3, [r7, #8]
 8015bd8:	1c5a      	adds	r2, r3, #1
 8015bda:	60ba      	str	r2, [r7, #8]
 8015bdc:	204d      	movs	r0, #77	; 0x4d
 8015bde:	183a      	adds	r2, r7, r0
 8015be0:	781b      	ldrb	r3, [r3, #0]
 8015be2:	7013      	strb	r3, [r2, #0]
 8015be4:	68bb      	ldr	r3, [r7, #8]
 8015be6:	1c5a      	adds	r2, r3, #1
 8015be8:	60ba      	str	r2, [r7, #8]
 8015bea:	224c      	movs	r2, #76	; 0x4c
 8015bec:	18ba      	adds	r2, r7, r2
 8015bee:	781b      	ldrb	r3, [r3, #0]
 8015bf0:	7013      	strb	r3, [r2, #0]
 8015bf2:	234e      	movs	r3, #78	; 0x4e
 8015bf4:	18fb      	adds	r3, r7, r3
 8015bf6:	881b      	ldrh	r3, [r3, #0]
 8015bf8:	2b2d      	cmp	r3, #45	; 0x2d
 8015bfa:	d11b      	bne.n	8015c34 <ipcp_nakci+0x294>
 8015bfc:	2410      	movs	r4, #16
 8015bfe:	193b      	adds	r3, r7, r4
 8015c00:	781a      	ldrb	r2, [r3, #0]
 8015c02:	2110      	movs	r1, #16
 8015c04:	438a      	bics	r2, r1
 8015c06:	701a      	strb	r2, [r3, #0]
 8015c08:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8015c0a:	7d9b      	ldrb	r3, [r3, #22]
 8015c0c:	183a      	adds	r2, r7, r0
 8015c0e:	7812      	ldrb	r2, [r2, #0]
 8015c10:	429a      	cmp	r2, r3
 8015c12:	d203      	bcs.n	8015c1c <ipcp_nakci+0x27c>
 8015c14:	193b      	adds	r3, r7, r4
 8015c16:	183a      	adds	r2, r7, r0
 8015c18:	7812      	ldrb	r2, [r2, #0]
 8015c1a:	759a      	strb	r2, [r3, #22]
 8015c1c:	234c      	movs	r3, #76	; 0x4c
 8015c1e:	18fb      	adds	r3, r7, r3
 8015c20:	781b      	ldrb	r3, [r3, #0]
 8015c22:	2b00      	cmp	r3, #0
 8015c24:	d128      	bne.n	8015c78 <ipcp_nakci+0x2d8>
 8015c26:	2310      	movs	r3, #16
 8015c28:	18fb      	adds	r3, r7, r3
 8015c2a:	781a      	ldrb	r2, [r3, #0]
 8015c2c:	2120      	movs	r1, #32
 8015c2e:	438a      	bics	r2, r1
 8015c30:	701a      	strb	r2, [r3, #0]
 8015c32:	e021      	b.n	8015c78 <ipcp_nakci+0x2d8>
 8015c34:	2310      	movs	r3, #16
 8015c36:	18fb      	adds	r3, r7, r3
 8015c38:	781a      	ldrb	r2, [r3, #0]
 8015c3a:	2108      	movs	r1, #8
 8015c3c:	438a      	bics	r2, r1
 8015c3e:	701a      	strb	r2, [r3, #0]
 8015c40:	e01a      	b.n	8015c78 <ipcp_nakci+0x2d8>
 8015c42:	224e      	movs	r2, #78	; 0x4e
 8015c44:	18bb      	adds	r3, r7, r2
 8015c46:	881b      	ldrh	r3, [r3, #0]
 8015c48:	2b2d      	cmp	r3, #45	; 0x2d
 8015c4a:	d003      	beq.n	8015c54 <ipcp_nakci+0x2b4>
 8015c4c:	18bb      	adds	r3, r7, r2
 8015c4e:	881b      	ldrh	r3, [r3, #0]
 8015c50:	2b37      	cmp	r3, #55	; 0x37
 8015c52:	d10b      	bne.n	8015c6c <ipcp_nakci+0x2cc>
 8015c54:	2010      	movs	r0, #16
 8015c56:	183b      	adds	r3, r7, r0
 8015c58:	781a      	ldrb	r2, [r3, #0]
 8015c5a:	2110      	movs	r1, #16
 8015c5c:	430a      	orrs	r2, r1
 8015c5e:	701a      	strb	r2, [r3, #0]
 8015c60:	183b      	adds	r3, r7, r0
 8015c62:	224e      	movs	r2, #78	; 0x4e
 8015c64:	18ba      	adds	r2, r7, r2
 8015c66:	8812      	ldrh	r2, [r2, #0]
 8015c68:	829a      	strh	r2, [r3, #20]
 8015c6a:	e005      	b.n	8015c78 <ipcp_nakci+0x2d8>
 8015c6c:	2310      	movs	r3, #16
 8015c6e:	18fb      	adds	r3, r7, r3
 8015c70:	781a      	ldrb	r2, [r3, #0]
 8015c72:	2108      	movs	r1, #8
 8015c74:	438a      	bics	r2, r1
 8015c76:	701a      	strb	r2, [r3, #0]
		}
	    }
	    );
#endif /* VJ_SUPPORT */

    NAKCIADDR(CI_ADDR, neg_addr,
 8015c78:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8015c7a:	781b      	ldrb	r3, [r3, #0]
 8015c7c:	2201      	movs	r2, #1
 8015c7e:	4013      	ands	r3, r2
 8015c80:	b2db      	uxtb	r3, r3
 8015c82:	2b00      	cmp	r3, #0
 8015c84:	d068      	beq.n	8015d58 <ipcp_nakci+0x3b8>
 8015c86:	215f      	movs	r1, #95	; 0x5f
 8015c88:	187b      	adds	r3, r7, r1
 8015c8a:	68ba      	ldr	r2, [r7, #8]
 8015c8c:	7852      	ldrb	r2, [r2, #1]
 8015c8e:	701a      	strb	r2, [r3, #0]
 8015c90:	187b      	adds	r3, r7, r1
 8015c92:	781b      	ldrb	r3, [r3, #0]
 8015c94:	2b06      	cmp	r3, #6
 8015c96:	d15f      	bne.n	8015d58 <ipcp_nakci+0x3b8>
 8015c98:	187b      	adds	r3, r7, r1
 8015c9a:	781b      	ldrb	r3, [r3, #0]
 8015c9c:	687a      	ldr	r2, [r7, #4]
 8015c9e:	429a      	cmp	r2, r3
 8015ca0:	db5a      	blt.n	8015d58 <ipcp_nakci+0x3b8>
 8015ca2:	68bb      	ldr	r3, [r7, #8]
 8015ca4:	781b      	ldrb	r3, [r3, #0]
 8015ca6:	2b03      	cmp	r3, #3
 8015ca8:	d156      	bne.n	8015d58 <ipcp_nakci+0x3b8>
 8015caa:	187b      	adds	r3, r7, r1
 8015cac:	781b      	ldrb	r3, [r3, #0]
 8015cae:	687a      	ldr	r2, [r7, #4]
 8015cb0:	1ad3      	subs	r3, r2, r3
 8015cb2:	607b      	str	r3, [r7, #4]
 8015cb4:	68bb      	ldr	r3, [r7, #8]
 8015cb6:	3302      	adds	r3, #2
 8015cb8:	60bb      	str	r3, [r7, #8]
 8015cba:	68bb      	ldr	r3, [r7, #8]
 8015cbc:	1c5a      	adds	r2, r3, #1
 8015cbe:	60ba      	str	r2, [r7, #8]
 8015cc0:	781b      	ldrb	r3, [r3, #0]
 8015cc2:	021b      	lsls	r3, r3, #8
 8015cc4:	65bb      	str	r3, [r7, #88]	; 0x58
 8015cc6:	68bb      	ldr	r3, [r7, #8]
 8015cc8:	1c5a      	adds	r2, r3, #1
 8015cca:	60ba      	str	r2, [r7, #8]
 8015ccc:	781b      	ldrb	r3, [r3, #0]
 8015cce:	001a      	movs	r2, r3
 8015cd0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015cd2:	4313      	orrs	r3, r2
 8015cd4:	65bb      	str	r3, [r7, #88]	; 0x58
 8015cd6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015cd8:	021b      	lsls	r3, r3, #8
 8015cda:	65bb      	str	r3, [r7, #88]	; 0x58
 8015cdc:	68bb      	ldr	r3, [r7, #8]
 8015cde:	1c5a      	adds	r2, r3, #1
 8015ce0:	60ba      	str	r2, [r7, #8]
 8015ce2:	781b      	ldrb	r3, [r3, #0]
 8015ce4:	001a      	movs	r2, r3
 8015ce6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015ce8:	4313      	orrs	r3, r2
 8015cea:	65bb      	str	r3, [r7, #88]	; 0x58
 8015cec:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015cee:	021b      	lsls	r3, r3, #8
 8015cf0:	65bb      	str	r3, [r7, #88]	; 0x58
 8015cf2:	68bb      	ldr	r3, [r7, #8]
 8015cf4:	1c5a      	adds	r2, r3, #1
 8015cf6:	60ba      	str	r2, [r7, #8]
 8015cf8:	781b      	ldrb	r3, [r3, #0]
 8015cfa:	001a      	movs	r2, r3
 8015cfc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015cfe:	4313      	orrs	r3, r2
 8015d00:	65bb      	str	r3, [r7, #88]	; 0x58
 8015d02:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015d04:	0018      	movs	r0, r3
 8015d06:	f7f0 fc2b 	bl	8006560 <lwip_htonl>
 8015d0a:	0003      	movs	r3, r0
 8015d0c:	657b      	str	r3, [r7, #84]	; 0x54
 8015d0e:	2328      	movs	r3, #40	; 0x28
 8015d10:	18fb      	adds	r3, r7, r3
 8015d12:	781a      	ldrb	r2, [r3, #0]
 8015d14:	2101      	movs	r1, #1
 8015d16:	430a      	orrs	r2, r1
 8015d18:	701a      	strb	r2, [r3, #0]
 8015d1a:	683b      	ldr	r3, [r7, #0]
 8015d1c:	2b00      	cmp	r3, #0
 8015d1e:	d00d      	beq.n	8015d3c <ipcp_nakci+0x39c>
 8015d20:	2010      	movs	r0, #16
 8015d22:	183b      	adds	r3, r7, r0
 8015d24:	781a      	ldrb	r2, [r3, #0]
 8015d26:	2101      	movs	r1, #1
 8015d28:	438a      	bics	r2, r1
 8015d2a:	701a      	strb	r2, [r3, #0]
 8015d2c:	183b      	adds	r3, r7, r0
 8015d2e:	781a      	ldrb	r2, [r3, #0]
 8015d30:	2102      	movs	r1, #2
 8015d32:	438a      	bics	r2, r1
 8015d34:	701a      	strb	r2, [r3, #0]
 8015d36:	e00f      	b.n	8015d58 <ipcp_nakci+0x3b8>
 8015d38:	0000121c 	.word	0x0000121c
 8015d3c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8015d3e:	781b      	ldrb	r3, [r3, #0]
 8015d40:	2240      	movs	r2, #64	; 0x40
 8015d42:	4013      	ands	r3, r2
 8015d44:	b2db      	uxtb	r3, r3
 8015d46:	2b00      	cmp	r3, #0
 8015d48:	d006      	beq.n	8015d58 <ipcp_nakci+0x3b8>
 8015d4a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8015d4c:	2b00      	cmp	r3, #0
 8015d4e:	d003      	beq.n	8015d58 <ipcp_nakci+0x3b8>
 8015d50:	2310      	movs	r3, #16
 8015d52:	18fb      	adds	r3, r7, r3
 8015d54:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8015d56:	605a      	str	r2, [r3, #4]
		  try_.ouraddr = ciaddr1;
	      }
	      );

#if LWIP_DNS
    NAKCIDNS(CI_MS_DNS1, req_dns1,
 8015d58:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8015d5a:	785b      	ldrb	r3, [r3, #1]
 8015d5c:	2201      	movs	r2, #1
 8015d5e:	4013      	ands	r3, r2
 8015d60:	b2db      	uxtb	r3, r3
 8015d62:	2b00      	cmp	r3, #0
 8015d64:	d057      	beq.n	8015e16 <ipcp_nakci+0x476>
 8015d66:	215f      	movs	r1, #95	; 0x5f
 8015d68:	187b      	adds	r3, r7, r1
 8015d6a:	68ba      	ldr	r2, [r7, #8]
 8015d6c:	7852      	ldrb	r2, [r2, #1]
 8015d6e:	701a      	strb	r2, [r3, #0]
 8015d70:	187b      	adds	r3, r7, r1
 8015d72:	781b      	ldrb	r3, [r3, #0]
 8015d74:	2b06      	cmp	r3, #6
 8015d76:	d14e      	bne.n	8015e16 <ipcp_nakci+0x476>
 8015d78:	187b      	adds	r3, r7, r1
 8015d7a:	781b      	ldrb	r3, [r3, #0]
 8015d7c:	687a      	ldr	r2, [r7, #4]
 8015d7e:	429a      	cmp	r2, r3
 8015d80:	db49      	blt.n	8015e16 <ipcp_nakci+0x476>
 8015d82:	68bb      	ldr	r3, [r7, #8]
 8015d84:	781b      	ldrb	r3, [r3, #0]
 8015d86:	2b81      	cmp	r3, #129	; 0x81
 8015d88:	d145      	bne.n	8015e16 <ipcp_nakci+0x476>
 8015d8a:	187b      	adds	r3, r7, r1
 8015d8c:	781b      	ldrb	r3, [r3, #0]
 8015d8e:	687a      	ldr	r2, [r7, #4]
 8015d90:	1ad3      	subs	r3, r2, r3
 8015d92:	607b      	str	r3, [r7, #4]
 8015d94:	68bb      	ldr	r3, [r7, #8]
 8015d96:	3302      	adds	r3, #2
 8015d98:	60bb      	str	r3, [r7, #8]
 8015d9a:	68bb      	ldr	r3, [r7, #8]
 8015d9c:	1c5a      	adds	r2, r3, #1
 8015d9e:	60ba      	str	r2, [r7, #8]
 8015da0:	781b      	ldrb	r3, [r3, #0]
 8015da2:	021b      	lsls	r3, r3, #8
 8015da4:	65bb      	str	r3, [r7, #88]	; 0x58
 8015da6:	68bb      	ldr	r3, [r7, #8]
 8015da8:	1c5a      	adds	r2, r3, #1
 8015daa:	60ba      	str	r2, [r7, #8]
 8015dac:	781b      	ldrb	r3, [r3, #0]
 8015dae:	001a      	movs	r2, r3
 8015db0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015db2:	4313      	orrs	r3, r2
 8015db4:	65bb      	str	r3, [r7, #88]	; 0x58
 8015db6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015db8:	021b      	lsls	r3, r3, #8
 8015dba:	65bb      	str	r3, [r7, #88]	; 0x58
 8015dbc:	68bb      	ldr	r3, [r7, #8]
 8015dbe:	1c5a      	adds	r2, r3, #1
 8015dc0:	60ba      	str	r2, [r7, #8]
 8015dc2:	781b      	ldrb	r3, [r3, #0]
 8015dc4:	001a      	movs	r2, r3
 8015dc6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015dc8:	4313      	orrs	r3, r2
 8015dca:	65bb      	str	r3, [r7, #88]	; 0x58
 8015dcc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015dce:	021b      	lsls	r3, r3, #8
 8015dd0:	65bb      	str	r3, [r7, #88]	; 0x58
 8015dd2:	68bb      	ldr	r3, [r7, #8]
 8015dd4:	1c5a      	adds	r2, r3, #1
 8015dd6:	60ba      	str	r2, [r7, #8]
 8015dd8:	781b      	ldrb	r3, [r3, #0]
 8015dda:	001a      	movs	r2, r3
 8015ddc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015dde:	4313      	orrs	r3, r2
 8015de0:	65bb      	str	r3, [r7, #88]	; 0x58
 8015de2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015de4:	0018      	movs	r0, r3
 8015de6:	f7f0 fbbb 	bl	8006560 <lwip_htonl>
 8015dea:	0003      	movs	r3, r0
 8015dec:	64bb      	str	r3, [r7, #72]	; 0x48
 8015dee:	2328      	movs	r3, #40	; 0x28
 8015df0:	18fb      	adds	r3, r7, r3
 8015df2:	785a      	ldrb	r2, [r3, #1]
 8015df4:	2101      	movs	r1, #1
 8015df6:	430a      	orrs	r2, r1
 8015df8:	705a      	strb	r2, [r3, #1]
 8015dfa:	683b      	ldr	r3, [r7, #0]
 8015dfc:	2b00      	cmp	r3, #0
 8015dfe:	d006      	beq.n	8015e0e <ipcp_nakci+0x46e>
 8015e00:	2310      	movs	r3, #16
 8015e02:	18fb      	adds	r3, r7, r3
 8015e04:	785a      	ldrb	r2, [r3, #1]
 8015e06:	2101      	movs	r1, #1
 8015e08:	438a      	bics	r2, r1
 8015e0a:	705a      	strb	r2, [r3, #1]
 8015e0c:	e003      	b.n	8015e16 <ipcp_nakci+0x476>
 8015e0e:	2310      	movs	r3, #16
 8015e10:	18fb      	adds	r3, r7, r3
 8015e12:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8015e14:	60da      	str	r2, [r3, #12]
	     } else {
		 try_.dnsaddr[0] = cidnsaddr;
	     }
	     );

    NAKCIDNS(CI_MS_DNS2, req_dns2,
 8015e16:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8015e18:	785b      	ldrb	r3, [r3, #1]
 8015e1a:	2202      	movs	r2, #2
 8015e1c:	4013      	ands	r3, r2
 8015e1e:	b2db      	uxtb	r3, r3
 8015e20:	2b00      	cmp	r3, #0
 8015e22:	d100      	bne.n	8015e26 <ipcp_nakci+0x486>
 8015e24:	e24f      	b.n	80162c6 <ipcp_nakci+0x926>
 8015e26:	215f      	movs	r1, #95	; 0x5f
 8015e28:	187b      	adds	r3, r7, r1
 8015e2a:	68ba      	ldr	r2, [r7, #8]
 8015e2c:	7852      	ldrb	r2, [r2, #1]
 8015e2e:	701a      	strb	r2, [r3, #0]
 8015e30:	187b      	adds	r3, r7, r1
 8015e32:	781b      	ldrb	r3, [r3, #0]
 8015e34:	2b06      	cmp	r3, #6
 8015e36:	d000      	beq.n	8015e3a <ipcp_nakci+0x49a>
 8015e38:	e245      	b.n	80162c6 <ipcp_nakci+0x926>
 8015e3a:	187b      	adds	r3, r7, r1
 8015e3c:	781b      	ldrb	r3, [r3, #0]
 8015e3e:	687a      	ldr	r2, [r7, #4]
 8015e40:	429a      	cmp	r2, r3
 8015e42:	da00      	bge.n	8015e46 <ipcp_nakci+0x4a6>
 8015e44:	e23f      	b.n	80162c6 <ipcp_nakci+0x926>
 8015e46:	68bb      	ldr	r3, [r7, #8]
 8015e48:	781b      	ldrb	r3, [r3, #0]
 8015e4a:	2b83      	cmp	r3, #131	; 0x83
 8015e4c:	d000      	beq.n	8015e50 <ipcp_nakci+0x4b0>
 8015e4e:	e23a      	b.n	80162c6 <ipcp_nakci+0x926>
 8015e50:	187b      	adds	r3, r7, r1
 8015e52:	781b      	ldrb	r3, [r3, #0]
 8015e54:	687a      	ldr	r2, [r7, #4]
 8015e56:	1ad3      	subs	r3, r2, r3
 8015e58:	607b      	str	r3, [r7, #4]
 8015e5a:	68bb      	ldr	r3, [r7, #8]
 8015e5c:	3302      	adds	r3, #2
 8015e5e:	60bb      	str	r3, [r7, #8]
 8015e60:	68bb      	ldr	r3, [r7, #8]
 8015e62:	1c5a      	adds	r2, r3, #1
 8015e64:	60ba      	str	r2, [r7, #8]
 8015e66:	781b      	ldrb	r3, [r3, #0]
 8015e68:	021b      	lsls	r3, r3, #8
 8015e6a:	65bb      	str	r3, [r7, #88]	; 0x58
 8015e6c:	68bb      	ldr	r3, [r7, #8]
 8015e6e:	1c5a      	adds	r2, r3, #1
 8015e70:	60ba      	str	r2, [r7, #8]
 8015e72:	781b      	ldrb	r3, [r3, #0]
 8015e74:	001a      	movs	r2, r3
 8015e76:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015e78:	4313      	orrs	r3, r2
 8015e7a:	65bb      	str	r3, [r7, #88]	; 0x58
 8015e7c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015e7e:	021b      	lsls	r3, r3, #8
 8015e80:	65bb      	str	r3, [r7, #88]	; 0x58
 8015e82:	68bb      	ldr	r3, [r7, #8]
 8015e84:	1c5a      	adds	r2, r3, #1
 8015e86:	60ba      	str	r2, [r7, #8]
 8015e88:	781b      	ldrb	r3, [r3, #0]
 8015e8a:	001a      	movs	r2, r3
 8015e8c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015e8e:	4313      	orrs	r3, r2
 8015e90:	65bb      	str	r3, [r7, #88]	; 0x58
 8015e92:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015e94:	021b      	lsls	r3, r3, #8
 8015e96:	65bb      	str	r3, [r7, #88]	; 0x58
 8015e98:	68bb      	ldr	r3, [r7, #8]
 8015e9a:	1c5a      	adds	r2, r3, #1
 8015e9c:	60ba      	str	r2, [r7, #8]
 8015e9e:	781b      	ldrb	r3, [r3, #0]
 8015ea0:	001a      	movs	r2, r3
 8015ea2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015ea4:	4313      	orrs	r3, r2
 8015ea6:	65bb      	str	r3, [r7, #88]	; 0x58
 8015ea8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015eaa:	0018      	movs	r0, r3
 8015eac:	f7f0 fb58 	bl	8006560 <lwip_htonl>
 8015eb0:	0003      	movs	r3, r0
 8015eb2:	64bb      	str	r3, [r7, #72]	; 0x48
 8015eb4:	2328      	movs	r3, #40	; 0x28
 8015eb6:	18fb      	adds	r3, r7, r3
 8015eb8:	785a      	ldrb	r2, [r3, #1]
 8015eba:	2102      	movs	r1, #2
 8015ebc:	430a      	orrs	r2, r1
 8015ebe:	705a      	strb	r2, [r3, #1]
 8015ec0:	683b      	ldr	r3, [r7, #0]
 8015ec2:	2b00      	cmp	r3, #0
 8015ec4:	d006      	beq.n	8015ed4 <ipcp_nakci+0x534>
 8015ec6:	2310      	movs	r3, #16
 8015ec8:	18fb      	adds	r3, r7, r3
 8015eca:	785a      	ldrb	r2, [r3, #1]
 8015ecc:	2102      	movs	r1, #2
 8015ece:	438a      	bics	r2, r1
 8015ed0:	705a      	strb	r2, [r3, #1]
 8015ed2:	e1f8      	b.n	80162c6 <ipcp_nakci+0x926>
 8015ed4:	2310      	movs	r3, #16
 8015ed6:	18fb      	adds	r3, r7, r3
 8015ed8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8015eda:	611a      	str	r2, [r3, #16]
     * If they want to negotiate about IP addresses, we comply.
     * If they want us to ask for compression, we refuse.
     * If they want us to ask for ms-dns, we do that, since some
     * peers get huffy if we don't.
     */
    while (len >= CILEN_VOID) {
 8015edc:	e1f3      	b.n	80162c6 <ipcp_nakci+0x926>
	GETCHAR(citype, p);
 8015ede:	68bb      	ldr	r3, [r7, #8]
 8015ee0:	1c5a      	adds	r2, r3, #1
 8015ee2:	60ba      	str	r2, [r7, #8]
 8015ee4:	2047      	movs	r0, #71	; 0x47
 8015ee6:	183a      	adds	r2, r7, r0
 8015ee8:	781b      	ldrb	r3, [r3, #0]
 8015eea:	7013      	strb	r3, [r2, #0]
	GETCHAR(cilen, p);
 8015eec:	68bb      	ldr	r3, [r7, #8]
 8015eee:	1c5a      	adds	r2, r3, #1
 8015ef0:	60ba      	str	r2, [r7, #8]
 8015ef2:	215f      	movs	r1, #95	; 0x5f
 8015ef4:	187a      	adds	r2, r7, r1
 8015ef6:	781b      	ldrb	r3, [r3, #0]
 8015ef8:	7013      	strb	r3, [r2, #0]
	if ( cilen < CILEN_VOID || (len -= cilen) < 0 )
 8015efa:	187b      	adds	r3, r7, r1
 8015efc:	781b      	ldrb	r3, [r3, #0]
 8015efe:	2b01      	cmp	r3, #1
 8015f00:	d800      	bhi.n	8015f04 <ipcp_nakci+0x564>
 8015f02:	e1f1      	b.n	80162e8 <ipcp_nakci+0x948>
 8015f04:	187b      	adds	r3, r7, r1
 8015f06:	781b      	ldrb	r3, [r3, #0]
 8015f08:	687a      	ldr	r2, [r7, #4]
 8015f0a:	1ad3      	subs	r3, r2, r3
 8015f0c:	607b      	str	r3, [r7, #4]
 8015f0e:	687b      	ldr	r3, [r7, #4]
 8015f10:	2b00      	cmp	r3, #0
 8015f12:	da00      	bge.n	8015f16 <ipcp_nakci+0x576>
 8015f14:	e1e8      	b.n	80162e8 <ipcp_nakci+0x948>
	    goto bad;
	next = p + cilen - 2;
 8015f16:	187b      	adds	r3, r7, r1
 8015f18:	781b      	ldrb	r3, [r3, #0]
 8015f1a:	3b02      	subs	r3, #2
 8015f1c:	68ba      	ldr	r2, [r7, #8]
 8015f1e:	18d3      	adds	r3, r2, r3
 8015f20:	643b      	str	r3, [r7, #64]	; 0x40

	switch (citype) {
 8015f22:	183b      	adds	r3, r7, r0
 8015f24:	781b      	ldrb	r3, [r3, #0]
 8015f26:	2b83      	cmp	r3, #131	; 0x83
 8015f28:	d100      	bne.n	8015f2c <ipcp_nakci+0x58c>
 8015f2a:	e17e      	b.n	801622a <ipcp_nakci+0x88a>
 8015f2c:	dd00      	ble.n	8015f30 <ipcp_nakci+0x590>
 8015f2e:	e1c7      	b.n	80162c0 <ipcp_nakci+0x920>
 8015f30:	2b81      	cmp	r3, #129	; 0x81
 8015f32:	d100      	bne.n	8015f36 <ipcp_nakci+0x596>
 8015f34:	e12b      	b.n	801618e <ipcp_nakci+0x7ee>
 8015f36:	dd00      	ble.n	8015f3a <ipcp_nakci+0x59a>
 8015f38:	e1c2      	b.n	80162c0 <ipcp_nakci+0x920>
 8015f3a:	2b03      	cmp	r3, #3
 8015f3c:	d100      	bne.n	8015f40 <ipcp_nakci+0x5a0>
 8015f3e:	e0c1      	b.n	80160c4 <ipcp_nakci+0x724>
 8015f40:	dd00      	ble.n	8015f44 <ipcp_nakci+0x5a4>
 8015f42:	e1bd      	b.n	80162c0 <ipcp_nakci+0x920>
 8015f44:	2b01      	cmp	r3, #1
 8015f46:	d023      	beq.n	8015f90 <ipcp_nakci+0x5f0>
 8015f48:	2b02      	cmp	r3, #2
 8015f4a:	d000      	beq.n	8015f4e <ipcp_nakci+0x5ae>
 8015f4c:	e1b8      	b.n	80162c0 <ipcp_nakci+0x920>
#if VJ_SUPPORT
	case CI_COMPRESSTYPE:
	    if (go->neg_vj || no.neg_vj ||
 8015f4e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8015f50:	781b      	ldrb	r3, [r3, #0]
 8015f52:	2208      	movs	r2, #8
 8015f54:	4013      	ands	r3, r2
 8015f56:	b2db      	uxtb	r3, r3
 8015f58:	2b00      	cmp	r3, #0
 8015f5a:	d000      	beq.n	8015f5e <ipcp_nakci+0x5be>
 8015f5c:	e1c6      	b.n	80162ec <ipcp_nakci+0x94c>
 8015f5e:	2328      	movs	r3, #40	; 0x28
 8015f60:	18fb      	adds	r3, r7, r3
 8015f62:	781b      	ldrb	r3, [r3, #0]
 8015f64:	2208      	movs	r2, #8
 8015f66:	4013      	ands	r3, r2
 8015f68:	b2db      	uxtb	r3, r3
 8015f6a:	2b00      	cmp	r3, #0
 8015f6c:	d000      	beq.n	8015f70 <ipcp_nakci+0x5d0>
 8015f6e:	e1bd      	b.n	80162ec <ipcp_nakci+0x94c>
 8015f70:	187b      	adds	r3, r7, r1
 8015f72:	781b      	ldrb	r3, [r3, #0]
 8015f74:	2b06      	cmp	r3, #6
 8015f76:	d004      	beq.n	8015f82 <ipcp_nakci+0x5e2>
		(cilen != CILEN_VJ && cilen != CILEN_COMPRESS))
 8015f78:	187b      	adds	r3, r7, r1
 8015f7a:	781b      	ldrb	r3, [r3, #0]
 8015f7c:	2b04      	cmp	r3, #4
 8015f7e:	d000      	beq.n	8015f82 <ipcp_nakci+0x5e2>
 8015f80:	e1b4      	b.n	80162ec <ipcp_nakci+0x94c>
		goto bad;
	    no.neg_vj = 1;
 8015f82:	2328      	movs	r3, #40	; 0x28
 8015f84:	18fb      	adds	r3, r7, r3
 8015f86:	781a      	ldrb	r2, [r3, #0]
 8015f88:	2108      	movs	r1, #8
 8015f8a:	430a      	orrs	r2, r1
 8015f8c:	701a      	strb	r2, [r3, #0]
	    break;
 8015f8e:	e198      	b.n	80162c2 <ipcp_nakci+0x922>
#endif /* VJ_SUPPORT */
	case CI_ADDRS:
	    if ((!go->neg_addr && go->old_addrs) || no.old_addrs
 8015f90:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8015f92:	781b      	ldrb	r3, [r3, #0]
 8015f94:	2201      	movs	r2, #1
 8015f96:	4013      	ands	r3, r2
 8015f98:	b2db      	uxtb	r3, r3
 8015f9a:	2b00      	cmp	r3, #0
 8015f9c:	d107      	bne.n	8015fae <ipcp_nakci+0x60e>
 8015f9e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8015fa0:	781b      	ldrb	r3, [r3, #0]
 8015fa2:	2202      	movs	r2, #2
 8015fa4:	4013      	ands	r3, r2
 8015fa6:	b2db      	uxtb	r3, r3
 8015fa8:	2b00      	cmp	r3, #0
 8015faa:	d000      	beq.n	8015fae <ipcp_nakci+0x60e>
 8015fac:	e1a0      	b.n	80162f0 <ipcp_nakci+0x950>
 8015fae:	2328      	movs	r3, #40	; 0x28
 8015fb0:	18fb      	adds	r3, r7, r3
 8015fb2:	781b      	ldrb	r3, [r3, #0]
 8015fb4:	2202      	movs	r2, #2
 8015fb6:	4013      	ands	r3, r2
 8015fb8:	b2db      	uxtb	r3, r3
 8015fba:	2b00      	cmp	r3, #0
 8015fbc:	d000      	beq.n	8015fc0 <ipcp_nakci+0x620>
 8015fbe:	e197      	b.n	80162f0 <ipcp_nakci+0x950>
		|| cilen != CILEN_ADDRS)
 8015fc0:	235f      	movs	r3, #95	; 0x5f
 8015fc2:	18fb      	adds	r3, r7, r3
 8015fc4:	781b      	ldrb	r3, [r3, #0]
 8015fc6:	2b0a      	cmp	r3, #10
 8015fc8:	d000      	beq.n	8015fcc <ipcp_nakci+0x62c>
 8015fca:	e191      	b.n	80162f0 <ipcp_nakci+0x950>
		goto bad;
	    try_.neg_addr = 0;
 8015fcc:	2410      	movs	r4, #16
 8015fce:	193b      	adds	r3, r7, r4
 8015fd0:	781a      	ldrb	r2, [r3, #0]
 8015fd2:	2101      	movs	r1, #1
 8015fd4:	438a      	bics	r2, r1
 8015fd6:	701a      	strb	r2, [r3, #0]
	    GETLONG(l, p);
 8015fd8:	68bb      	ldr	r3, [r7, #8]
 8015fda:	1c5a      	adds	r2, r3, #1
 8015fdc:	60ba      	str	r2, [r7, #8]
 8015fde:	781b      	ldrb	r3, [r3, #0]
 8015fe0:	021b      	lsls	r3, r3, #8
 8015fe2:	65bb      	str	r3, [r7, #88]	; 0x58
 8015fe4:	68bb      	ldr	r3, [r7, #8]
 8015fe6:	1c5a      	adds	r2, r3, #1
 8015fe8:	60ba      	str	r2, [r7, #8]
 8015fea:	781b      	ldrb	r3, [r3, #0]
 8015fec:	001a      	movs	r2, r3
 8015fee:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015ff0:	4313      	orrs	r3, r2
 8015ff2:	65bb      	str	r3, [r7, #88]	; 0x58
 8015ff4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015ff6:	021b      	lsls	r3, r3, #8
 8015ff8:	65bb      	str	r3, [r7, #88]	; 0x58
 8015ffa:	68bb      	ldr	r3, [r7, #8]
 8015ffc:	1c5a      	adds	r2, r3, #1
 8015ffe:	60ba      	str	r2, [r7, #8]
 8016000:	781b      	ldrb	r3, [r3, #0]
 8016002:	001a      	movs	r2, r3
 8016004:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016006:	4313      	orrs	r3, r2
 8016008:	65bb      	str	r3, [r7, #88]	; 0x58
 801600a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801600c:	021b      	lsls	r3, r3, #8
 801600e:	65bb      	str	r3, [r7, #88]	; 0x58
 8016010:	68bb      	ldr	r3, [r7, #8]
 8016012:	1c5a      	adds	r2, r3, #1
 8016014:	60ba      	str	r2, [r7, #8]
 8016016:	781b      	ldrb	r3, [r3, #0]
 8016018:	001a      	movs	r2, r3
 801601a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801601c:	4313      	orrs	r3, r2
 801601e:	65bb      	str	r3, [r7, #88]	; 0x58
	    ciaddr1 = lwip_htonl(l);
 8016020:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016022:	0018      	movs	r0, r3
 8016024:	f7f0 fa9c 	bl	8006560 <lwip_htonl>
 8016028:	0003      	movs	r3, r0
 801602a:	657b      	str	r3, [r7, #84]	; 0x54
	    if (ciaddr1 && go->accept_local)
 801602c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801602e:	2b00      	cmp	r3, #0
 8016030:	d009      	beq.n	8016046 <ipcp_nakci+0x6a6>
 8016032:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016034:	781b      	ldrb	r3, [r3, #0]
 8016036:	2240      	movs	r2, #64	; 0x40
 8016038:	4013      	ands	r3, r2
 801603a:	b2db      	uxtb	r3, r3
 801603c:	2b00      	cmp	r3, #0
 801603e:	d002      	beq.n	8016046 <ipcp_nakci+0x6a6>
		try_.ouraddr = ciaddr1;
 8016040:	193b      	adds	r3, r7, r4
 8016042:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8016044:	605a      	str	r2, [r3, #4]
	    GETLONG(l, p);
 8016046:	68bb      	ldr	r3, [r7, #8]
 8016048:	1c5a      	adds	r2, r3, #1
 801604a:	60ba      	str	r2, [r7, #8]
 801604c:	781b      	ldrb	r3, [r3, #0]
 801604e:	021b      	lsls	r3, r3, #8
 8016050:	65bb      	str	r3, [r7, #88]	; 0x58
 8016052:	68bb      	ldr	r3, [r7, #8]
 8016054:	1c5a      	adds	r2, r3, #1
 8016056:	60ba      	str	r2, [r7, #8]
 8016058:	781b      	ldrb	r3, [r3, #0]
 801605a:	001a      	movs	r2, r3
 801605c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801605e:	4313      	orrs	r3, r2
 8016060:	65bb      	str	r3, [r7, #88]	; 0x58
 8016062:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016064:	021b      	lsls	r3, r3, #8
 8016066:	65bb      	str	r3, [r7, #88]	; 0x58
 8016068:	68bb      	ldr	r3, [r7, #8]
 801606a:	1c5a      	adds	r2, r3, #1
 801606c:	60ba      	str	r2, [r7, #8]
 801606e:	781b      	ldrb	r3, [r3, #0]
 8016070:	001a      	movs	r2, r3
 8016072:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016074:	4313      	orrs	r3, r2
 8016076:	65bb      	str	r3, [r7, #88]	; 0x58
 8016078:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801607a:	021b      	lsls	r3, r3, #8
 801607c:	65bb      	str	r3, [r7, #88]	; 0x58
 801607e:	68bb      	ldr	r3, [r7, #8]
 8016080:	1c5a      	adds	r2, r3, #1
 8016082:	60ba      	str	r2, [r7, #8]
 8016084:	781b      	ldrb	r3, [r3, #0]
 8016086:	001a      	movs	r2, r3
 8016088:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801608a:	4313      	orrs	r3, r2
 801608c:	65bb      	str	r3, [r7, #88]	; 0x58
	    ciaddr2 = lwip_htonl(l);
 801608e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016090:	0018      	movs	r0, r3
 8016092:	f7f0 fa65 	bl	8006560 <lwip_htonl>
 8016096:	0003      	movs	r3, r0
 8016098:	653b      	str	r3, [r7, #80]	; 0x50
	    if (ciaddr2 && go->accept_remote)
 801609a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801609c:	2b00      	cmp	r3, #0
 801609e:	d00a      	beq.n	80160b6 <ipcp_nakci+0x716>
 80160a0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80160a2:	781b      	ldrb	r3, [r3, #0]
 80160a4:	227f      	movs	r2, #127	; 0x7f
 80160a6:	4393      	bics	r3, r2
 80160a8:	b2db      	uxtb	r3, r3
 80160aa:	2b00      	cmp	r3, #0
 80160ac:	d003      	beq.n	80160b6 <ipcp_nakci+0x716>
		try_.hisaddr = ciaddr2;
 80160ae:	2310      	movs	r3, #16
 80160b0:	18fb      	adds	r3, r7, r3
 80160b2:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80160b4:	609a      	str	r2, [r3, #8]
	    no.old_addrs = 1;
 80160b6:	2328      	movs	r3, #40	; 0x28
 80160b8:	18fb      	adds	r3, r7, r3
 80160ba:	781a      	ldrb	r2, [r3, #0]
 80160bc:	2102      	movs	r1, #2
 80160be:	430a      	orrs	r2, r1
 80160c0:	701a      	strb	r2, [r3, #0]
	    break;
 80160c2:	e0fe      	b.n	80162c2 <ipcp_nakci+0x922>
	case CI_ADDR:
	    if (go->neg_addr || no.neg_addr || cilen != CILEN_ADDR)
 80160c4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80160c6:	781b      	ldrb	r3, [r3, #0]
 80160c8:	2201      	movs	r2, #1
 80160ca:	4013      	ands	r3, r2
 80160cc:	b2db      	uxtb	r3, r3
 80160ce:	2b00      	cmp	r3, #0
 80160d0:	d000      	beq.n	80160d4 <ipcp_nakci+0x734>
 80160d2:	e10f      	b.n	80162f4 <ipcp_nakci+0x954>
 80160d4:	2328      	movs	r3, #40	; 0x28
 80160d6:	18fb      	adds	r3, r7, r3
 80160d8:	781b      	ldrb	r3, [r3, #0]
 80160da:	2201      	movs	r2, #1
 80160dc:	4013      	ands	r3, r2
 80160de:	b2db      	uxtb	r3, r3
 80160e0:	2b00      	cmp	r3, #0
 80160e2:	d000      	beq.n	80160e6 <ipcp_nakci+0x746>
 80160e4:	e106      	b.n	80162f4 <ipcp_nakci+0x954>
 80160e6:	235f      	movs	r3, #95	; 0x5f
 80160e8:	18fb      	adds	r3, r7, r3
 80160ea:	781b      	ldrb	r3, [r3, #0]
 80160ec:	2b06      	cmp	r3, #6
 80160ee:	d000      	beq.n	80160f2 <ipcp_nakci+0x752>
 80160f0:	e100      	b.n	80162f4 <ipcp_nakci+0x954>
		goto bad;
	    try_.old_addrs = 0;
 80160f2:	2410      	movs	r4, #16
 80160f4:	193b      	adds	r3, r7, r4
 80160f6:	781a      	ldrb	r2, [r3, #0]
 80160f8:	2102      	movs	r1, #2
 80160fa:	438a      	bics	r2, r1
 80160fc:	701a      	strb	r2, [r3, #0]
	    GETLONG(l, p);
 80160fe:	68bb      	ldr	r3, [r7, #8]
 8016100:	1c5a      	adds	r2, r3, #1
 8016102:	60ba      	str	r2, [r7, #8]
 8016104:	781b      	ldrb	r3, [r3, #0]
 8016106:	021b      	lsls	r3, r3, #8
 8016108:	65bb      	str	r3, [r7, #88]	; 0x58
 801610a:	68bb      	ldr	r3, [r7, #8]
 801610c:	1c5a      	adds	r2, r3, #1
 801610e:	60ba      	str	r2, [r7, #8]
 8016110:	781b      	ldrb	r3, [r3, #0]
 8016112:	001a      	movs	r2, r3
 8016114:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016116:	4313      	orrs	r3, r2
 8016118:	65bb      	str	r3, [r7, #88]	; 0x58
 801611a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801611c:	021b      	lsls	r3, r3, #8
 801611e:	65bb      	str	r3, [r7, #88]	; 0x58
 8016120:	68bb      	ldr	r3, [r7, #8]
 8016122:	1c5a      	adds	r2, r3, #1
 8016124:	60ba      	str	r2, [r7, #8]
 8016126:	781b      	ldrb	r3, [r3, #0]
 8016128:	001a      	movs	r2, r3
 801612a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801612c:	4313      	orrs	r3, r2
 801612e:	65bb      	str	r3, [r7, #88]	; 0x58
 8016130:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016132:	021b      	lsls	r3, r3, #8
 8016134:	65bb      	str	r3, [r7, #88]	; 0x58
 8016136:	68bb      	ldr	r3, [r7, #8]
 8016138:	1c5a      	adds	r2, r3, #1
 801613a:	60ba      	str	r2, [r7, #8]
 801613c:	781b      	ldrb	r3, [r3, #0]
 801613e:	001a      	movs	r2, r3
 8016140:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016142:	4313      	orrs	r3, r2
 8016144:	65bb      	str	r3, [r7, #88]	; 0x58
	    ciaddr1 = lwip_htonl(l);
 8016146:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016148:	0018      	movs	r0, r3
 801614a:	f7f0 fa09 	bl	8006560 <lwip_htonl>
 801614e:	0003      	movs	r3, r0
 8016150:	657b      	str	r3, [r7, #84]	; 0x54
	    if (ciaddr1 && go->accept_local)
 8016152:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8016154:	2b00      	cmp	r3, #0
 8016156:	d009      	beq.n	801616c <ipcp_nakci+0x7cc>
 8016158:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801615a:	781b      	ldrb	r3, [r3, #0]
 801615c:	2240      	movs	r2, #64	; 0x40
 801615e:	4013      	ands	r3, r2
 8016160:	b2db      	uxtb	r3, r3
 8016162:	2b00      	cmp	r3, #0
 8016164:	d002      	beq.n	801616c <ipcp_nakci+0x7cc>
		try_.ouraddr = ciaddr1;
 8016166:	193b      	adds	r3, r7, r4
 8016168:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801616a:	605a      	str	r2, [r3, #4]
	    if (try_.ouraddr != 0)
 801616c:	2210      	movs	r2, #16
 801616e:	18bb      	adds	r3, r7, r2
 8016170:	685b      	ldr	r3, [r3, #4]
 8016172:	2b00      	cmp	r3, #0
 8016174:	d004      	beq.n	8016180 <ipcp_nakci+0x7e0>
		try_.neg_addr = 1;
 8016176:	18bb      	adds	r3, r7, r2
 8016178:	781a      	ldrb	r2, [r3, #0]
 801617a:	2101      	movs	r1, #1
 801617c:	430a      	orrs	r2, r1
 801617e:	701a      	strb	r2, [r3, #0]
	    no.neg_addr = 1;
 8016180:	2328      	movs	r3, #40	; 0x28
 8016182:	18fb      	adds	r3, r7, r3
 8016184:	781a      	ldrb	r2, [r3, #0]
 8016186:	2101      	movs	r1, #1
 8016188:	430a      	orrs	r2, r1
 801618a:	701a      	strb	r2, [r3, #0]
	    break;
 801618c:	e099      	b.n	80162c2 <ipcp_nakci+0x922>
#if LWIP_DNS
	case CI_MS_DNS1:
	    if (go->req_dns1 || no.req_dns1 || cilen != CILEN_ADDR)
 801618e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016190:	785b      	ldrb	r3, [r3, #1]
 8016192:	2201      	movs	r2, #1
 8016194:	4013      	ands	r3, r2
 8016196:	b2db      	uxtb	r3, r3
 8016198:	2b00      	cmp	r3, #0
 801619a:	d000      	beq.n	801619e <ipcp_nakci+0x7fe>
 801619c:	e0ac      	b.n	80162f8 <ipcp_nakci+0x958>
 801619e:	2428      	movs	r4, #40	; 0x28
 80161a0:	193b      	adds	r3, r7, r4
 80161a2:	785b      	ldrb	r3, [r3, #1]
 80161a4:	2201      	movs	r2, #1
 80161a6:	4013      	ands	r3, r2
 80161a8:	b2db      	uxtb	r3, r3
 80161aa:	2b00      	cmp	r3, #0
 80161ac:	d000      	beq.n	80161b0 <ipcp_nakci+0x810>
 80161ae:	e0a3      	b.n	80162f8 <ipcp_nakci+0x958>
 80161b0:	235f      	movs	r3, #95	; 0x5f
 80161b2:	18fb      	adds	r3, r7, r3
 80161b4:	781b      	ldrb	r3, [r3, #0]
 80161b6:	2b06      	cmp	r3, #6
 80161b8:	d000      	beq.n	80161bc <ipcp_nakci+0x81c>
 80161ba:	e09d      	b.n	80162f8 <ipcp_nakci+0x958>
		goto bad;
	    GETLONG(l, p);
 80161bc:	68bb      	ldr	r3, [r7, #8]
 80161be:	1c5a      	adds	r2, r3, #1
 80161c0:	60ba      	str	r2, [r7, #8]
 80161c2:	781b      	ldrb	r3, [r3, #0]
 80161c4:	021b      	lsls	r3, r3, #8
 80161c6:	65bb      	str	r3, [r7, #88]	; 0x58
 80161c8:	68bb      	ldr	r3, [r7, #8]
 80161ca:	1c5a      	adds	r2, r3, #1
 80161cc:	60ba      	str	r2, [r7, #8]
 80161ce:	781b      	ldrb	r3, [r3, #0]
 80161d0:	001a      	movs	r2, r3
 80161d2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80161d4:	4313      	orrs	r3, r2
 80161d6:	65bb      	str	r3, [r7, #88]	; 0x58
 80161d8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80161da:	021b      	lsls	r3, r3, #8
 80161dc:	65bb      	str	r3, [r7, #88]	; 0x58
 80161de:	68bb      	ldr	r3, [r7, #8]
 80161e0:	1c5a      	adds	r2, r3, #1
 80161e2:	60ba      	str	r2, [r7, #8]
 80161e4:	781b      	ldrb	r3, [r3, #0]
 80161e6:	001a      	movs	r2, r3
 80161e8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80161ea:	4313      	orrs	r3, r2
 80161ec:	65bb      	str	r3, [r7, #88]	; 0x58
 80161ee:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80161f0:	021b      	lsls	r3, r3, #8
 80161f2:	65bb      	str	r3, [r7, #88]	; 0x58
 80161f4:	68bb      	ldr	r3, [r7, #8]
 80161f6:	1c5a      	adds	r2, r3, #1
 80161f8:	60ba      	str	r2, [r7, #8]
 80161fa:	781b      	ldrb	r3, [r3, #0]
 80161fc:	001a      	movs	r2, r3
 80161fe:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016200:	4313      	orrs	r3, r2
 8016202:	65bb      	str	r3, [r7, #88]	; 0x58
	    try_.dnsaddr[0] = lwip_htonl(l);
 8016204:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016206:	0018      	movs	r0, r3
 8016208:	f7f0 f9aa 	bl	8006560 <lwip_htonl>
 801620c:	0002      	movs	r2, r0
 801620e:	2110      	movs	r1, #16
 8016210:	187b      	adds	r3, r7, r1
 8016212:	60da      	str	r2, [r3, #12]
	    try_.req_dns1 = 1;
 8016214:	187b      	adds	r3, r7, r1
 8016216:	785a      	ldrb	r2, [r3, #1]
 8016218:	2101      	movs	r1, #1
 801621a:	430a      	orrs	r2, r1
 801621c:	705a      	strb	r2, [r3, #1]
	    no.req_dns1 = 1;
 801621e:	193b      	adds	r3, r7, r4
 8016220:	785a      	ldrb	r2, [r3, #1]
 8016222:	2101      	movs	r1, #1
 8016224:	430a      	orrs	r2, r1
 8016226:	705a      	strb	r2, [r3, #1]
	    break;
 8016228:	e04b      	b.n	80162c2 <ipcp_nakci+0x922>
	case CI_MS_DNS2:
	    if (go->req_dns2 || no.req_dns2 || cilen != CILEN_ADDR)
 801622a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801622c:	785b      	ldrb	r3, [r3, #1]
 801622e:	2202      	movs	r2, #2
 8016230:	4013      	ands	r3, r2
 8016232:	b2db      	uxtb	r3, r3
 8016234:	2b00      	cmp	r3, #0
 8016236:	d161      	bne.n	80162fc <ipcp_nakci+0x95c>
 8016238:	2428      	movs	r4, #40	; 0x28
 801623a:	193b      	adds	r3, r7, r4
 801623c:	785b      	ldrb	r3, [r3, #1]
 801623e:	2202      	movs	r2, #2
 8016240:	4013      	ands	r3, r2
 8016242:	b2db      	uxtb	r3, r3
 8016244:	2b00      	cmp	r3, #0
 8016246:	d159      	bne.n	80162fc <ipcp_nakci+0x95c>
 8016248:	235f      	movs	r3, #95	; 0x5f
 801624a:	18fb      	adds	r3, r7, r3
 801624c:	781b      	ldrb	r3, [r3, #0]
 801624e:	2b06      	cmp	r3, #6
 8016250:	d154      	bne.n	80162fc <ipcp_nakci+0x95c>
		goto bad;
	    GETLONG(l, p);
 8016252:	68bb      	ldr	r3, [r7, #8]
 8016254:	1c5a      	adds	r2, r3, #1
 8016256:	60ba      	str	r2, [r7, #8]
 8016258:	781b      	ldrb	r3, [r3, #0]
 801625a:	021b      	lsls	r3, r3, #8
 801625c:	65bb      	str	r3, [r7, #88]	; 0x58
 801625e:	68bb      	ldr	r3, [r7, #8]
 8016260:	1c5a      	adds	r2, r3, #1
 8016262:	60ba      	str	r2, [r7, #8]
 8016264:	781b      	ldrb	r3, [r3, #0]
 8016266:	001a      	movs	r2, r3
 8016268:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801626a:	4313      	orrs	r3, r2
 801626c:	65bb      	str	r3, [r7, #88]	; 0x58
 801626e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016270:	021b      	lsls	r3, r3, #8
 8016272:	65bb      	str	r3, [r7, #88]	; 0x58
 8016274:	68bb      	ldr	r3, [r7, #8]
 8016276:	1c5a      	adds	r2, r3, #1
 8016278:	60ba      	str	r2, [r7, #8]
 801627a:	781b      	ldrb	r3, [r3, #0]
 801627c:	001a      	movs	r2, r3
 801627e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016280:	4313      	orrs	r3, r2
 8016282:	65bb      	str	r3, [r7, #88]	; 0x58
 8016284:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016286:	021b      	lsls	r3, r3, #8
 8016288:	65bb      	str	r3, [r7, #88]	; 0x58
 801628a:	68bb      	ldr	r3, [r7, #8]
 801628c:	1c5a      	adds	r2, r3, #1
 801628e:	60ba      	str	r2, [r7, #8]
 8016290:	781b      	ldrb	r3, [r3, #0]
 8016292:	001a      	movs	r2, r3
 8016294:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8016296:	4313      	orrs	r3, r2
 8016298:	65bb      	str	r3, [r7, #88]	; 0x58
	    try_.dnsaddr[1] = lwip_htonl(l);
 801629a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801629c:	0018      	movs	r0, r3
 801629e:	f7f0 f95f 	bl	8006560 <lwip_htonl>
 80162a2:	0002      	movs	r2, r0
 80162a4:	2110      	movs	r1, #16
 80162a6:	187b      	adds	r3, r7, r1
 80162a8:	611a      	str	r2, [r3, #16]
	    try_.req_dns2 = 1;
 80162aa:	187b      	adds	r3, r7, r1
 80162ac:	785a      	ldrb	r2, [r3, #1]
 80162ae:	2102      	movs	r1, #2
 80162b0:	430a      	orrs	r2, r1
 80162b2:	705a      	strb	r2, [r3, #1]
	    no.req_dns2 = 1;
 80162b4:	193b      	adds	r3, r7, r4
 80162b6:	785a      	ldrb	r2, [r3, #1]
 80162b8:	2102      	movs	r1, #2
 80162ba:	430a      	orrs	r2, r1
 80162bc:	705a      	strb	r2, [r3, #1]
	    break;
 80162be:	e000      	b.n	80162c2 <ipcp_nakci+0x922>
	    if (ciaddr1)
		try_.winsaddr[citype == CI_MS_WINS2] = ciaddr1;
	    break;
#endif /* UNUSED - WINS */
	default:
	    break;
 80162c0:	46c0      	nop			; (mov r8, r8)
	}
	p = next;
 80162c2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80162c4:	60bb      	str	r3, [r7, #8]
    while (len >= CILEN_VOID) {
 80162c6:	687b      	ldr	r3, [r7, #4]
 80162c8:	2b01      	cmp	r3, #1
 80162ca:	dd00      	ble.n	80162ce <ipcp_nakci+0x92e>
 80162cc:	e607      	b.n	8015ede <ipcp_nakci+0x53e>

    /*
     * OK, the Nak is good.  Now we can update state.
     * If there are any remaining options, we ignore them.
     */
    if (f->state != PPP_FSM_OPENED)
 80162ce:	68fb      	ldr	r3, [r7, #12]
 80162d0:	7c1b      	ldrb	r3, [r3, #16]
 80162d2:	2b09      	cmp	r3, #9
 80162d4:	d006      	beq.n	80162e4 <ipcp_nakci+0x944>
	*go = try_;
 80162d6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80162d8:	2210      	movs	r2, #16
 80162da:	18ba      	adds	r2, r7, r2
 80162dc:	ca13      	ldmia	r2!, {r0, r1, r4}
 80162de:	c313      	stmia	r3!, {r0, r1, r4}
 80162e0:	ca13      	ldmia	r2!, {r0, r1, r4}
 80162e2:	c313      	stmia	r3!, {r0, r1, r4}

    return 1;
 80162e4:	2301      	movs	r3, #1
 80162e6:	e00b      	b.n	8016300 <ipcp_nakci+0x960>
	    goto bad;
 80162e8:	46c0      	nop			; (mov r8, r8)
 80162ea:	e008      	b.n	80162fe <ipcp_nakci+0x95e>
		goto bad;
 80162ec:	46c0      	nop			; (mov r8, r8)
 80162ee:	e006      	b.n	80162fe <ipcp_nakci+0x95e>
		goto bad;
 80162f0:	46c0      	nop			; (mov r8, r8)
 80162f2:	e004      	b.n	80162fe <ipcp_nakci+0x95e>
		goto bad;
 80162f4:	46c0      	nop			; (mov r8, r8)
 80162f6:	e002      	b.n	80162fe <ipcp_nakci+0x95e>
		goto bad;
 80162f8:	46c0      	nop			; (mov r8, r8)
 80162fa:	e000      	b.n	80162fe <ipcp_nakci+0x95e>
		goto bad;
 80162fc:	46c0      	nop			; (mov r8, r8)

bad:
    IPCPDEBUG(("ipcp_nakci: received bad Nak!"));
    return 0;
 80162fe:	2300      	movs	r3, #0
}
 8016300:	0018      	movs	r0, r3
 8016302:	46bd      	mov	sp, r7
 8016304:	b01b      	add	sp, #108	; 0x6c
 8016306:	bdf0      	pop	{r4, r5, r6, r7, pc}

08016308 <ipcp_rejci>:

/*
 * ipcp_rejci - Reject some of our CIs.
 * Callback from fsm_rconfnakrej.
 */
static int ipcp_rejci(fsm *f, u_char *p, int len) {
 8016308:	b5b0      	push	{r4, r5, r7, lr}
 801630a:	b094      	sub	sp, #80	; 0x50
 801630c:	af00      	add	r7, sp, #0
 801630e:	60f8      	str	r0, [r7, #12]
 8016310:	60b9      	str	r1, [r7, #8]
 8016312:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8016314:	68fb      	ldr	r3, [r7, #12]
 8016316:	681b      	ldr	r3, [r3, #0]
 8016318:	64fb      	str	r3, [r7, #76]	; 0x4c
    ipcp_options *go = &pcb->ipcp_gotoptions;
 801631a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801631c:	4a57      	ldr	r2, [pc, #348]	; (801647c <ipcp_rejci+0x174>)
 801631e:	4694      	mov	ip, r2
 8016320:	4463      	add	r3, ip
 8016322:	64bb      	str	r3, [r7, #72]	; 0x48
    u_short cishort;
#endif /* VJ_SUPPORT */
    u32_t cilong;
    ipcp_options try_;		/* options to request next time */

    try_ = *go;
 8016324:	2414      	movs	r4, #20
 8016326:	193b      	adds	r3, r7, r4
 8016328:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801632a:	ca23      	ldmia	r2!, {r0, r1, r5}
 801632c:	c323      	stmia	r3!, {r0, r1, r5}
 801632e:	ca23      	ldmia	r2!, {r0, r1, r5}
 8016330:	c323      	stmia	r3!, {r0, r1, r5}
	    goto bad; \
	try_.winsaddr[opt == CI_MS_WINS2] = 0; \
    }
#endif /* UNUSED - WINS */

    REJCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs,
 8016332:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016334:	781b      	ldrb	r3, [r3, #0]
 8016336:	2201      	movs	r2, #1
 8016338:	4013      	ands	r3, r2
 801633a:	b2db      	uxtb	r3, r3
 801633c:	2b00      	cmp	r3, #0
 801633e:	d000      	beq.n	8016342 <ipcp_rejci+0x3a>
 8016340:	e086      	b.n	8016450 <ipcp_rejci+0x148>
 8016342:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016344:	781b      	ldrb	r3, [r3, #0]
 8016346:	2202      	movs	r2, #2
 8016348:	4013      	ands	r3, r2
 801634a:	b2db      	uxtb	r3, r3
 801634c:	2b00      	cmp	r3, #0
 801634e:	d100      	bne.n	8016352 <ipcp_rejci+0x4a>
 8016350:	e07e      	b.n	8016450 <ipcp_rejci+0x148>
 8016352:	2147      	movs	r1, #71	; 0x47
 8016354:	187b      	adds	r3, r7, r1
 8016356:	68ba      	ldr	r2, [r7, #8]
 8016358:	7852      	ldrb	r2, [r2, #1]
 801635a:	701a      	strb	r2, [r3, #0]
 801635c:	187b      	adds	r3, r7, r1
 801635e:	781b      	ldrb	r3, [r3, #0]
 8016360:	2b0a      	cmp	r3, #10
 8016362:	d175      	bne.n	8016450 <ipcp_rejci+0x148>
 8016364:	187b      	adds	r3, r7, r1
 8016366:	781b      	ldrb	r3, [r3, #0]
 8016368:	687a      	ldr	r2, [r7, #4]
 801636a:	429a      	cmp	r2, r3
 801636c:	db70      	blt.n	8016450 <ipcp_rejci+0x148>
 801636e:	68bb      	ldr	r3, [r7, #8]
 8016370:	781b      	ldrb	r3, [r3, #0]
 8016372:	2b01      	cmp	r3, #1
 8016374:	d16c      	bne.n	8016450 <ipcp_rejci+0x148>
 8016376:	187b      	adds	r3, r7, r1
 8016378:	781b      	ldrb	r3, [r3, #0]
 801637a:	687a      	ldr	r2, [r7, #4]
 801637c:	1ad3      	subs	r3, r2, r3
 801637e:	607b      	str	r3, [r7, #4]
 8016380:	68bb      	ldr	r3, [r7, #8]
 8016382:	3302      	adds	r3, #2
 8016384:	60bb      	str	r3, [r7, #8]
 8016386:	68bb      	ldr	r3, [r7, #8]
 8016388:	1c5a      	adds	r2, r3, #1
 801638a:	60ba      	str	r2, [r7, #8]
 801638c:	781b      	ldrb	r3, [r3, #0]
 801638e:	021b      	lsls	r3, r3, #8
 8016390:	643b      	str	r3, [r7, #64]	; 0x40
 8016392:	68bb      	ldr	r3, [r7, #8]
 8016394:	1c5a      	adds	r2, r3, #1
 8016396:	60ba      	str	r2, [r7, #8]
 8016398:	781b      	ldrb	r3, [r3, #0]
 801639a:	001a      	movs	r2, r3
 801639c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801639e:	4313      	orrs	r3, r2
 80163a0:	643b      	str	r3, [r7, #64]	; 0x40
 80163a2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80163a4:	021b      	lsls	r3, r3, #8
 80163a6:	643b      	str	r3, [r7, #64]	; 0x40
 80163a8:	68bb      	ldr	r3, [r7, #8]
 80163aa:	1c5a      	adds	r2, r3, #1
 80163ac:	60ba      	str	r2, [r7, #8]
 80163ae:	781b      	ldrb	r3, [r3, #0]
 80163b0:	001a      	movs	r2, r3
 80163b2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80163b4:	4313      	orrs	r3, r2
 80163b6:	643b      	str	r3, [r7, #64]	; 0x40
 80163b8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80163ba:	021b      	lsls	r3, r3, #8
 80163bc:	643b      	str	r3, [r7, #64]	; 0x40
 80163be:	68bb      	ldr	r3, [r7, #8]
 80163c0:	1c5a      	adds	r2, r3, #1
 80163c2:	60ba      	str	r2, [r7, #8]
 80163c4:	781b      	ldrb	r3, [r3, #0]
 80163c6:	001a      	movs	r2, r3
 80163c8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80163ca:	4313      	orrs	r3, r2
 80163cc:	643b      	str	r3, [r7, #64]	; 0x40
 80163ce:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80163d0:	0018      	movs	r0, r3
 80163d2:	f7f0 f8c5 	bl	8006560 <lwip_htonl>
 80163d6:	0003      	movs	r3, r0
 80163d8:	63fb      	str	r3, [r7, #60]	; 0x3c
 80163da:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80163dc:	685b      	ldr	r3, [r3, #4]
 80163de:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80163e0:	429a      	cmp	r2, r3
 80163e2:	d000      	beq.n	80163e6 <ipcp_rejci+0xde>
 80163e4:	e1bf      	b.n	8016766 <ipcp_rejci+0x45e>
 80163e6:	68bb      	ldr	r3, [r7, #8]
 80163e8:	1c5a      	adds	r2, r3, #1
 80163ea:	60ba      	str	r2, [r7, #8]
 80163ec:	781b      	ldrb	r3, [r3, #0]
 80163ee:	021b      	lsls	r3, r3, #8
 80163f0:	643b      	str	r3, [r7, #64]	; 0x40
 80163f2:	68bb      	ldr	r3, [r7, #8]
 80163f4:	1c5a      	adds	r2, r3, #1
 80163f6:	60ba      	str	r2, [r7, #8]
 80163f8:	781b      	ldrb	r3, [r3, #0]
 80163fa:	001a      	movs	r2, r3
 80163fc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80163fe:	4313      	orrs	r3, r2
 8016400:	643b      	str	r3, [r7, #64]	; 0x40
 8016402:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016404:	021b      	lsls	r3, r3, #8
 8016406:	643b      	str	r3, [r7, #64]	; 0x40
 8016408:	68bb      	ldr	r3, [r7, #8]
 801640a:	1c5a      	adds	r2, r3, #1
 801640c:	60ba      	str	r2, [r7, #8]
 801640e:	781b      	ldrb	r3, [r3, #0]
 8016410:	001a      	movs	r2, r3
 8016412:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016414:	4313      	orrs	r3, r2
 8016416:	643b      	str	r3, [r7, #64]	; 0x40
 8016418:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801641a:	021b      	lsls	r3, r3, #8
 801641c:	643b      	str	r3, [r7, #64]	; 0x40
 801641e:	68bb      	ldr	r3, [r7, #8]
 8016420:	1c5a      	adds	r2, r3, #1
 8016422:	60ba      	str	r2, [r7, #8]
 8016424:	781b      	ldrb	r3, [r3, #0]
 8016426:	001a      	movs	r2, r3
 8016428:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801642a:	4313      	orrs	r3, r2
 801642c:	643b      	str	r3, [r7, #64]	; 0x40
 801642e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016430:	0018      	movs	r0, r3
 8016432:	f7f0 f895 	bl	8006560 <lwip_htonl>
 8016436:	0003      	movs	r3, r0
 8016438:	63fb      	str	r3, [r7, #60]	; 0x3c
 801643a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801643c:	689b      	ldr	r3, [r3, #8]
 801643e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016440:	429a      	cmp	r2, r3
 8016442:	d000      	beq.n	8016446 <ipcp_rejci+0x13e>
 8016444:	e191      	b.n	801676a <ipcp_rejci+0x462>
 8016446:	193b      	adds	r3, r7, r4
 8016448:	781a      	ldrb	r2, [r3, #0]
 801644a:	2102      	movs	r1, #2
 801644c:	438a      	bics	r2, r1
 801644e:	701a      	strb	r2, [r3, #0]
	       go->ouraddr, go->hisaddr);

#if VJ_SUPPORT
    REJCIVJ(CI_COMPRESSTYPE, neg_vj, go->vj_protocol, go->old_vj,
 8016450:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016452:	781b      	ldrb	r3, [r3, #0]
 8016454:	2208      	movs	r2, #8
 8016456:	4013      	ands	r3, r2
 8016458:	b2db      	uxtb	r3, r3
 801645a:	2b00      	cmp	r3, #0
 801645c:	d100      	bne.n	8016460 <ipcp_rejci+0x158>
 801645e:	e06e      	b.n	801653e <ipcp_rejci+0x236>
 8016460:	68bb      	ldr	r3, [r7, #8]
 8016462:	3301      	adds	r3, #1
 8016464:	781b      	ldrb	r3, [r3, #0]
 8016466:	0019      	movs	r1, r3
 8016468:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801646a:	781b      	ldrb	r3, [r3, #0]
 801646c:	2210      	movs	r2, #16
 801646e:	4013      	ands	r3, r2
 8016470:	b2db      	uxtb	r3, r3
 8016472:	2b00      	cmp	r3, #0
 8016474:	d004      	beq.n	8016480 <ipcp_rejci+0x178>
 8016476:	2304      	movs	r3, #4
 8016478:	e003      	b.n	8016482 <ipcp_rejci+0x17a>
 801647a:	46c0      	nop			; (mov r8, r8)
 801647c:	0000121c 	.word	0x0000121c
 8016480:	2306      	movs	r3, #6
 8016482:	428b      	cmp	r3, r1
 8016484:	d15b      	bne.n	801653e <ipcp_rejci+0x236>
 8016486:	68bb      	ldr	r3, [r7, #8]
 8016488:	3301      	adds	r3, #1
 801648a:	781b      	ldrb	r3, [r3, #0]
 801648c:	001a      	movs	r2, r3
 801648e:	687b      	ldr	r3, [r7, #4]
 8016490:	4293      	cmp	r3, r2
 8016492:	db54      	blt.n	801653e <ipcp_rejci+0x236>
 8016494:	68bb      	ldr	r3, [r7, #8]
 8016496:	781b      	ldrb	r3, [r3, #0]
 8016498:	2b02      	cmp	r3, #2
 801649a:	d150      	bne.n	801653e <ipcp_rejci+0x236>
 801649c:	68bb      	ldr	r3, [r7, #8]
 801649e:	3301      	adds	r3, #1
 80164a0:	781b      	ldrb	r3, [r3, #0]
 80164a2:	001a      	movs	r2, r3
 80164a4:	687b      	ldr	r3, [r7, #4]
 80164a6:	1a9b      	subs	r3, r3, r2
 80164a8:	607b      	str	r3, [r7, #4]
 80164aa:	68bb      	ldr	r3, [r7, #8]
 80164ac:	3302      	adds	r3, #2
 80164ae:	60bb      	str	r3, [r7, #8]
 80164b0:	68bb      	ldr	r3, [r7, #8]
 80164b2:	1c5a      	adds	r2, r3, #1
 80164b4:	60ba      	str	r2, [r7, #8]
 80164b6:	781b      	ldrb	r3, [r3, #0]
 80164b8:	b29a      	uxth	r2, r3
 80164ba:	203a      	movs	r0, #58	; 0x3a
 80164bc:	183b      	adds	r3, r7, r0
 80164be:	0212      	lsls	r2, r2, #8
 80164c0:	801a      	strh	r2, [r3, #0]
 80164c2:	68bb      	ldr	r3, [r7, #8]
 80164c4:	1c5a      	adds	r2, r3, #1
 80164c6:	60ba      	str	r2, [r7, #8]
 80164c8:	781b      	ldrb	r3, [r3, #0]
 80164ca:	b299      	uxth	r1, r3
 80164cc:	183b      	adds	r3, r7, r0
 80164ce:	183a      	adds	r2, r7, r0
 80164d0:	8812      	ldrh	r2, [r2, #0]
 80164d2:	430a      	orrs	r2, r1
 80164d4:	801a      	strh	r2, [r3, #0]
 80164d6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80164d8:	8a9b      	ldrh	r3, [r3, #20]
 80164da:	183a      	adds	r2, r7, r0
 80164dc:	8812      	ldrh	r2, [r2, #0]
 80164de:	429a      	cmp	r2, r3
 80164e0:	d000      	beq.n	80164e4 <ipcp_rejci+0x1dc>
 80164e2:	e144      	b.n	801676e <ipcp_rejci+0x466>
 80164e4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80164e6:	781b      	ldrb	r3, [r3, #0]
 80164e8:	2210      	movs	r2, #16
 80164ea:	4013      	ands	r3, r2
 80164ec:	b2db      	uxtb	r3, r3
 80164ee:	2b00      	cmp	r3, #0
 80164f0:	d11f      	bne.n	8016532 <ipcp_rejci+0x22a>
 80164f2:	68bb      	ldr	r3, [r7, #8]
 80164f4:	1c5a      	adds	r2, r3, #1
 80164f6:	60ba      	str	r2, [r7, #8]
 80164f8:	2139      	movs	r1, #57	; 0x39
 80164fa:	187a      	adds	r2, r7, r1
 80164fc:	781b      	ldrb	r3, [r3, #0]
 80164fe:	7013      	strb	r3, [r2, #0]
 8016500:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016502:	7d9b      	ldrb	r3, [r3, #22]
 8016504:	187a      	adds	r2, r7, r1
 8016506:	7812      	ldrb	r2, [r2, #0]
 8016508:	429a      	cmp	r2, r3
 801650a:	d000      	beq.n	801650e <ipcp_rejci+0x206>
 801650c:	e131      	b.n	8016772 <ipcp_rejci+0x46a>
 801650e:	68bb      	ldr	r3, [r7, #8]
 8016510:	1c5a      	adds	r2, r3, #1
 8016512:	60ba      	str	r2, [r7, #8]
 8016514:	2138      	movs	r1, #56	; 0x38
 8016516:	187a      	adds	r2, r7, r1
 8016518:	781b      	ldrb	r3, [r3, #0]
 801651a:	7013      	strb	r3, [r2, #0]
 801651c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801651e:	781b      	ldrb	r3, [r3, #0]
 8016520:	069b      	lsls	r3, r3, #26
 8016522:	0fdb      	lsrs	r3, r3, #31
 8016524:	b2db      	uxtb	r3, r3
 8016526:	001a      	movs	r2, r3
 8016528:	187b      	adds	r3, r7, r1
 801652a:	781b      	ldrb	r3, [r3, #0]
 801652c:	4293      	cmp	r3, r2
 801652e:	d000      	beq.n	8016532 <ipcp_rejci+0x22a>
 8016530:	e121      	b.n	8016776 <ipcp_rejci+0x46e>
 8016532:	2314      	movs	r3, #20
 8016534:	18fb      	adds	r3, r7, r3
 8016536:	781a      	ldrb	r2, [r3, #0]
 8016538:	2108      	movs	r1, #8
 801653a:	438a      	bics	r2, r1
 801653c:	701a      	strb	r2, [r3, #0]
	    go->maxslotindex, go->cflag);
#endif /* VJ_SUPPORT */

    REJCIADDR(CI_ADDR, neg_addr, go->ouraddr);
 801653e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016540:	781b      	ldrb	r3, [r3, #0]
 8016542:	2201      	movs	r2, #1
 8016544:	4013      	ands	r3, r2
 8016546:	b2db      	uxtb	r3, r3
 8016548:	2b00      	cmp	r3, #0
 801654a:	d04f      	beq.n	80165ec <ipcp_rejci+0x2e4>
 801654c:	2147      	movs	r1, #71	; 0x47
 801654e:	187b      	adds	r3, r7, r1
 8016550:	68ba      	ldr	r2, [r7, #8]
 8016552:	7852      	ldrb	r2, [r2, #1]
 8016554:	701a      	strb	r2, [r3, #0]
 8016556:	187b      	adds	r3, r7, r1
 8016558:	781b      	ldrb	r3, [r3, #0]
 801655a:	2b06      	cmp	r3, #6
 801655c:	d146      	bne.n	80165ec <ipcp_rejci+0x2e4>
 801655e:	187b      	adds	r3, r7, r1
 8016560:	781b      	ldrb	r3, [r3, #0]
 8016562:	687a      	ldr	r2, [r7, #4]
 8016564:	429a      	cmp	r2, r3
 8016566:	db41      	blt.n	80165ec <ipcp_rejci+0x2e4>
 8016568:	68bb      	ldr	r3, [r7, #8]
 801656a:	781b      	ldrb	r3, [r3, #0]
 801656c:	2b03      	cmp	r3, #3
 801656e:	d13d      	bne.n	80165ec <ipcp_rejci+0x2e4>
 8016570:	187b      	adds	r3, r7, r1
 8016572:	781b      	ldrb	r3, [r3, #0]
 8016574:	687a      	ldr	r2, [r7, #4]
 8016576:	1ad3      	subs	r3, r2, r3
 8016578:	607b      	str	r3, [r7, #4]
 801657a:	68bb      	ldr	r3, [r7, #8]
 801657c:	3302      	adds	r3, #2
 801657e:	60bb      	str	r3, [r7, #8]
 8016580:	68bb      	ldr	r3, [r7, #8]
 8016582:	1c5a      	adds	r2, r3, #1
 8016584:	60ba      	str	r2, [r7, #8]
 8016586:	781b      	ldrb	r3, [r3, #0]
 8016588:	021b      	lsls	r3, r3, #8
 801658a:	637b      	str	r3, [r7, #52]	; 0x34
 801658c:	68bb      	ldr	r3, [r7, #8]
 801658e:	1c5a      	adds	r2, r3, #1
 8016590:	60ba      	str	r2, [r7, #8]
 8016592:	781b      	ldrb	r3, [r3, #0]
 8016594:	001a      	movs	r2, r3
 8016596:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016598:	4313      	orrs	r3, r2
 801659a:	637b      	str	r3, [r7, #52]	; 0x34
 801659c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801659e:	021b      	lsls	r3, r3, #8
 80165a0:	637b      	str	r3, [r7, #52]	; 0x34
 80165a2:	68bb      	ldr	r3, [r7, #8]
 80165a4:	1c5a      	adds	r2, r3, #1
 80165a6:	60ba      	str	r2, [r7, #8]
 80165a8:	781b      	ldrb	r3, [r3, #0]
 80165aa:	001a      	movs	r2, r3
 80165ac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80165ae:	4313      	orrs	r3, r2
 80165b0:	637b      	str	r3, [r7, #52]	; 0x34
 80165b2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80165b4:	021b      	lsls	r3, r3, #8
 80165b6:	637b      	str	r3, [r7, #52]	; 0x34
 80165b8:	68bb      	ldr	r3, [r7, #8]
 80165ba:	1c5a      	adds	r2, r3, #1
 80165bc:	60ba      	str	r2, [r7, #8]
 80165be:	781b      	ldrb	r3, [r3, #0]
 80165c0:	001a      	movs	r2, r3
 80165c2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80165c4:	4313      	orrs	r3, r2
 80165c6:	637b      	str	r3, [r7, #52]	; 0x34
 80165c8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80165ca:	0018      	movs	r0, r3
 80165cc:	f7ef ffc8 	bl	8006560 <lwip_htonl>
 80165d0:	0003      	movs	r3, r0
 80165d2:	63fb      	str	r3, [r7, #60]	; 0x3c
 80165d4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80165d6:	685b      	ldr	r3, [r3, #4]
 80165d8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80165da:	429a      	cmp	r2, r3
 80165dc:	d000      	beq.n	80165e0 <ipcp_rejci+0x2d8>
 80165de:	e0cc      	b.n	801677a <ipcp_rejci+0x472>
 80165e0:	2314      	movs	r3, #20
 80165e2:	18fb      	adds	r3, r7, r3
 80165e4:	781a      	ldrb	r2, [r3, #0]
 80165e6:	2101      	movs	r1, #1
 80165e8:	438a      	bics	r2, r1
 80165ea:	701a      	strb	r2, [r3, #0]

#if LWIP_DNS
    REJCIDNS(CI_MS_DNS1, req_dns1, go->dnsaddr[0]);
 80165ec:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80165ee:	785b      	ldrb	r3, [r3, #1]
 80165f0:	2201      	movs	r2, #1
 80165f2:	4013      	ands	r3, r2
 80165f4:	b2db      	uxtb	r3, r3
 80165f6:	2b00      	cmp	r3, #0
 80165f8:	d04f      	beq.n	801669a <ipcp_rejci+0x392>
 80165fa:	2147      	movs	r1, #71	; 0x47
 80165fc:	187b      	adds	r3, r7, r1
 80165fe:	68ba      	ldr	r2, [r7, #8]
 8016600:	7852      	ldrb	r2, [r2, #1]
 8016602:	701a      	strb	r2, [r3, #0]
 8016604:	187b      	adds	r3, r7, r1
 8016606:	781b      	ldrb	r3, [r3, #0]
 8016608:	2b06      	cmp	r3, #6
 801660a:	d146      	bne.n	801669a <ipcp_rejci+0x392>
 801660c:	187b      	adds	r3, r7, r1
 801660e:	781b      	ldrb	r3, [r3, #0]
 8016610:	687a      	ldr	r2, [r7, #4]
 8016612:	429a      	cmp	r2, r3
 8016614:	db41      	blt.n	801669a <ipcp_rejci+0x392>
 8016616:	68bb      	ldr	r3, [r7, #8]
 8016618:	781b      	ldrb	r3, [r3, #0]
 801661a:	2b81      	cmp	r3, #129	; 0x81
 801661c:	d13d      	bne.n	801669a <ipcp_rejci+0x392>
 801661e:	187b      	adds	r3, r7, r1
 8016620:	781b      	ldrb	r3, [r3, #0]
 8016622:	687a      	ldr	r2, [r7, #4]
 8016624:	1ad3      	subs	r3, r2, r3
 8016626:	607b      	str	r3, [r7, #4]
 8016628:	68bb      	ldr	r3, [r7, #8]
 801662a:	3302      	adds	r3, #2
 801662c:	60bb      	str	r3, [r7, #8]
 801662e:	68bb      	ldr	r3, [r7, #8]
 8016630:	1c5a      	adds	r2, r3, #1
 8016632:	60ba      	str	r2, [r7, #8]
 8016634:	781b      	ldrb	r3, [r3, #0]
 8016636:	021b      	lsls	r3, r3, #8
 8016638:	633b      	str	r3, [r7, #48]	; 0x30
 801663a:	68bb      	ldr	r3, [r7, #8]
 801663c:	1c5a      	adds	r2, r3, #1
 801663e:	60ba      	str	r2, [r7, #8]
 8016640:	781b      	ldrb	r3, [r3, #0]
 8016642:	001a      	movs	r2, r3
 8016644:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016646:	4313      	orrs	r3, r2
 8016648:	633b      	str	r3, [r7, #48]	; 0x30
 801664a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801664c:	021b      	lsls	r3, r3, #8
 801664e:	633b      	str	r3, [r7, #48]	; 0x30
 8016650:	68bb      	ldr	r3, [r7, #8]
 8016652:	1c5a      	adds	r2, r3, #1
 8016654:	60ba      	str	r2, [r7, #8]
 8016656:	781b      	ldrb	r3, [r3, #0]
 8016658:	001a      	movs	r2, r3
 801665a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801665c:	4313      	orrs	r3, r2
 801665e:	633b      	str	r3, [r7, #48]	; 0x30
 8016660:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016662:	021b      	lsls	r3, r3, #8
 8016664:	633b      	str	r3, [r7, #48]	; 0x30
 8016666:	68bb      	ldr	r3, [r7, #8]
 8016668:	1c5a      	adds	r2, r3, #1
 801666a:	60ba      	str	r2, [r7, #8]
 801666c:	781b      	ldrb	r3, [r3, #0]
 801666e:	001a      	movs	r2, r3
 8016670:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016672:	4313      	orrs	r3, r2
 8016674:	633b      	str	r3, [r7, #48]	; 0x30
 8016676:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016678:	0018      	movs	r0, r3
 801667a:	f7ef ff71 	bl	8006560 <lwip_htonl>
 801667e:	0003      	movs	r3, r0
 8016680:	63fb      	str	r3, [r7, #60]	; 0x3c
 8016682:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016684:	68db      	ldr	r3, [r3, #12]
 8016686:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016688:	429a      	cmp	r2, r3
 801668a:	d000      	beq.n	801668e <ipcp_rejci+0x386>
 801668c:	e077      	b.n	801677e <ipcp_rejci+0x476>
 801668e:	2314      	movs	r3, #20
 8016690:	18fb      	adds	r3, r7, r3
 8016692:	785a      	ldrb	r2, [r3, #1]
 8016694:	2101      	movs	r1, #1
 8016696:	438a      	bics	r2, r1
 8016698:	705a      	strb	r2, [r3, #1]

    REJCIDNS(CI_MS_DNS2, req_dns2, go->dnsaddr[1]);
 801669a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801669c:	785b      	ldrb	r3, [r3, #1]
 801669e:	2202      	movs	r2, #2
 80166a0:	4013      	ands	r3, r2
 80166a2:	b2db      	uxtb	r3, r3
 80166a4:	2b00      	cmp	r3, #0
 80166a6:	d04e      	beq.n	8016746 <ipcp_rejci+0x43e>
 80166a8:	2147      	movs	r1, #71	; 0x47
 80166aa:	187b      	adds	r3, r7, r1
 80166ac:	68ba      	ldr	r2, [r7, #8]
 80166ae:	7852      	ldrb	r2, [r2, #1]
 80166b0:	701a      	strb	r2, [r3, #0]
 80166b2:	187b      	adds	r3, r7, r1
 80166b4:	781b      	ldrb	r3, [r3, #0]
 80166b6:	2b06      	cmp	r3, #6
 80166b8:	d145      	bne.n	8016746 <ipcp_rejci+0x43e>
 80166ba:	187b      	adds	r3, r7, r1
 80166bc:	781b      	ldrb	r3, [r3, #0]
 80166be:	687a      	ldr	r2, [r7, #4]
 80166c0:	429a      	cmp	r2, r3
 80166c2:	db40      	blt.n	8016746 <ipcp_rejci+0x43e>
 80166c4:	68bb      	ldr	r3, [r7, #8]
 80166c6:	781b      	ldrb	r3, [r3, #0]
 80166c8:	2b83      	cmp	r3, #131	; 0x83
 80166ca:	d13c      	bne.n	8016746 <ipcp_rejci+0x43e>
 80166cc:	187b      	adds	r3, r7, r1
 80166ce:	781b      	ldrb	r3, [r3, #0]
 80166d0:	687a      	ldr	r2, [r7, #4]
 80166d2:	1ad3      	subs	r3, r2, r3
 80166d4:	607b      	str	r3, [r7, #4]
 80166d6:	68bb      	ldr	r3, [r7, #8]
 80166d8:	3302      	adds	r3, #2
 80166da:	60bb      	str	r3, [r7, #8]
 80166dc:	68bb      	ldr	r3, [r7, #8]
 80166de:	1c5a      	adds	r2, r3, #1
 80166e0:	60ba      	str	r2, [r7, #8]
 80166e2:	781b      	ldrb	r3, [r3, #0]
 80166e4:	021b      	lsls	r3, r3, #8
 80166e6:	62fb      	str	r3, [r7, #44]	; 0x2c
 80166e8:	68bb      	ldr	r3, [r7, #8]
 80166ea:	1c5a      	adds	r2, r3, #1
 80166ec:	60ba      	str	r2, [r7, #8]
 80166ee:	781b      	ldrb	r3, [r3, #0]
 80166f0:	001a      	movs	r2, r3
 80166f2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80166f4:	4313      	orrs	r3, r2
 80166f6:	62fb      	str	r3, [r7, #44]	; 0x2c
 80166f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80166fa:	021b      	lsls	r3, r3, #8
 80166fc:	62fb      	str	r3, [r7, #44]	; 0x2c
 80166fe:	68bb      	ldr	r3, [r7, #8]
 8016700:	1c5a      	adds	r2, r3, #1
 8016702:	60ba      	str	r2, [r7, #8]
 8016704:	781b      	ldrb	r3, [r3, #0]
 8016706:	001a      	movs	r2, r3
 8016708:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801670a:	4313      	orrs	r3, r2
 801670c:	62fb      	str	r3, [r7, #44]	; 0x2c
 801670e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016710:	021b      	lsls	r3, r3, #8
 8016712:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016714:	68bb      	ldr	r3, [r7, #8]
 8016716:	1c5a      	adds	r2, r3, #1
 8016718:	60ba      	str	r2, [r7, #8]
 801671a:	781b      	ldrb	r3, [r3, #0]
 801671c:	001a      	movs	r2, r3
 801671e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016720:	4313      	orrs	r3, r2
 8016722:	62fb      	str	r3, [r7, #44]	; 0x2c
 8016724:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016726:	0018      	movs	r0, r3
 8016728:	f7ef ff1a 	bl	8006560 <lwip_htonl>
 801672c:	0003      	movs	r3, r0
 801672e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8016730:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016732:	691b      	ldr	r3, [r3, #16]
 8016734:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016736:	429a      	cmp	r2, r3
 8016738:	d123      	bne.n	8016782 <ipcp_rejci+0x47a>
 801673a:	2314      	movs	r3, #20
 801673c:	18fb      	adds	r3, r7, r3
 801673e:	785a      	ldrb	r2, [r3, #1]
 8016740:	2102      	movs	r1, #2
 8016742:	438a      	bics	r2, r1
 8016744:	705a      	strb	r2, [r3, #1]
#endif /* UNUSED - WINS */

    /*
     * If there are any remaining CIs, then this packet is bad.
     */
    if (len != 0)
 8016746:	687b      	ldr	r3, [r7, #4]
 8016748:	2b00      	cmp	r3, #0
 801674a:	d11c      	bne.n	8016786 <ipcp_rejci+0x47e>
	goto bad;
    /*
     * Now we can update state.
     */
    if (f->state != PPP_FSM_OPENED)
 801674c:	68fb      	ldr	r3, [r7, #12]
 801674e:	7c1b      	ldrb	r3, [r3, #16]
 8016750:	2b09      	cmp	r3, #9
 8016752:	d006      	beq.n	8016762 <ipcp_rejci+0x45a>
	*go = try_;
 8016754:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016756:	2214      	movs	r2, #20
 8016758:	18ba      	adds	r2, r7, r2
 801675a:	ca13      	ldmia	r2!, {r0, r1, r4}
 801675c:	c313      	stmia	r3!, {r0, r1, r4}
 801675e:	ca13      	ldmia	r2!, {r0, r1, r4}
 8016760:	c313      	stmia	r3!, {r0, r1, r4}
    return 1;
 8016762:	2301      	movs	r3, #1
 8016764:	e011      	b.n	801678a <ipcp_rejci+0x482>
    REJCIADDRS(CI_ADDRS, !go->neg_addr && go->old_addrs,
 8016766:	46c0      	nop			; (mov r8, r8)
 8016768:	e00e      	b.n	8016788 <ipcp_rejci+0x480>
 801676a:	46c0      	nop			; (mov r8, r8)
 801676c:	e00c      	b.n	8016788 <ipcp_rejci+0x480>
    REJCIVJ(CI_COMPRESSTYPE, neg_vj, go->vj_protocol, go->old_vj,
 801676e:	46c0      	nop			; (mov r8, r8)
 8016770:	e00a      	b.n	8016788 <ipcp_rejci+0x480>
 8016772:	46c0      	nop			; (mov r8, r8)
 8016774:	e008      	b.n	8016788 <ipcp_rejci+0x480>
 8016776:	46c0      	nop			; (mov r8, r8)
 8016778:	e006      	b.n	8016788 <ipcp_rejci+0x480>
    REJCIADDR(CI_ADDR, neg_addr, go->ouraddr);
 801677a:	46c0      	nop			; (mov r8, r8)
 801677c:	e004      	b.n	8016788 <ipcp_rejci+0x480>
    REJCIDNS(CI_MS_DNS1, req_dns1, go->dnsaddr[0]);
 801677e:	46c0      	nop			; (mov r8, r8)
 8016780:	e002      	b.n	8016788 <ipcp_rejci+0x480>
    REJCIDNS(CI_MS_DNS2, req_dns2, go->dnsaddr[1]);
 8016782:	46c0      	nop			; (mov r8, r8)
 8016784:	e000      	b.n	8016788 <ipcp_rejci+0x480>
	goto bad;
 8016786:	46c0      	nop			; (mov r8, r8)

bad:
    IPCPDEBUG(("ipcp_rejci: received bad Reject!"));
    return 0;
 8016788:	2300      	movs	r3, #0
}
 801678a:	0018      	movs	r0, r3
 801678c:	46bd      	mov	sp, r7
 801678e:	b014      	add	sp, #80	; 0x50
 8016790:	bdb0      	pop	{r4, r5, r7, pc}
 8016792:	46c0      	nop			; (mov r8, r8)

08016794 <ipcp_reqci>:
 * CONFNAK; returns CONFREJ if it can't return CONFACK.
 *
 * inp = Requested CIs
 * len = Length of requested CIs
 */
static int ipcp_reqci(fsm *f, u_char *inp, int *len, int reject_if_disagree) {
 8016794:	b580      	push	{r7, lr}
 8016796:	b096      	sub	sp, #88	; 0x58
 8016798:	af00      	add	r7, sp, #0
 801679a:	60f8      	str	r0, [r7, #12]
 801679c:	60b9      	str	r1, [r7, #8]
 801679e:	607a      	str	r2, [r7, #4]
 80167a0:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 80167a2:	68fb      	ldr	r3, [r7, #12]
 80167a4:	681b      	ldr	r3, [r3, #0]
 80167a6:	63bb      	str	r3, [r7, #56]	; 0x38
    ipcp_options *wo = &pcb->ipcp_wantoptions;
 80167a8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80167aa:	4abe      	ldr	r2, [pc, #760]	; (8016aa4 <ipcp_reqci+0x310>)
 80167ac:	4694      	mov	ip, r2
 80167ae:	4463      	add	r3, ip
 80167b0:	637b      	str	r3, [r7, #52]	; 0x34
    ipcp_options *ho = &pcb->ipcp_hisoptions;
 80167b2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80167b4:	4abc      	ldr	r2, [pc, #752]	; (8016aa8 <ipcp_reqci+0x314>)
 80167b6:	4694      	mov	ip, r2
 80167b8:	4463      	add	r3, ip
 80167ba:	633b      	str	r3, [r7, #48]	; 0x30
    ipcp_options *ao = &pcb->ipcp_allowoptions;
 80167bc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80167be:	4abb      	ldr	r2, [pc, #748]	; (8016aac <ipcp_reqci+0x318>)
 80167c0:	4694      	mov	ip, r2
 80167c2:	4463      	add	r3, ip
 80167c4:	62fb      	str	r3, [r7, #44]	; 0x2c
    u_short cilen, citype;	/* Parsed len, type */
#if VJ_SUPPORT
    u_short cishort;		/* Parsed short value */
#endif /* VJ_SUPPORT */
    u32_t tl, ciaddr1, ciaddr2;/* Parsed address values */
    int rc = CONFACK;		/* Final packet return code */
 80167c6:	2302      	movs	r3, #2
 80167c8:	64fb      	str	r3, [r7, #76]	; 0x4c
    int orc;			/* Individual option return code */
    u_char *p;			/* Pointer to next char to parse */
    u_char *ucp = inp;		/* Pointer to current output char */
 80167ca:	68bb      	ldr	r3, [r7, #8]
 80167cc:	643b      	str	r3, [r7, #64]	; 0x40
    int l = *len;		/* Length left */
 80167ce:	687b      	ldr	r3, [r7, #4]
 80167d0:	681b      	ldr	r3, [r3, #0]
 80167d2:	63fb      	str	r3, [r7, #60]	; 0x3c
#endif /* LWIP_DNS */

    /*
     * Reset all his options.
     */
    BZERO(ho, sizeof(*ho));
 80167d4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80167d6:	2218      	movs	r2, #24
 80167d8:	2100      	movs	r1, #0
 80167da:	0018      	movs	r0, r3
 80167dc:	f006 f826 	bl	801c82c <memset>
    
    /*
     * Process all his options.
     */
    next = inp;
 80167e0:	68bb      	ldr	r3, [r7, #8]
 80167e2:	657b      	str	r3, [r7, #84]	; 0x54
    while (l) {
 80167e4:	e33d      	b.n	8016e62 <ipcp_reqci+0x6ce>
	orc = CONFACK;			/* Assume success */
 80167e6:	2302      	movs	r3, #2
 80167e8:	64bb      	str	r3, [r7, #72]	; 0x48
	cip = p = next;			/* Remember begining of CI */
 80167ea:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80167ec:	647b      	str	r3, [r7, #68]	; 0x44
 80167ee:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80167f0:	627b      	str	r3, [r7, #36]	; 0x24
	if (l < 2 ||			/* Not enough data for CI header or */
 80167f2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80167f4:	2b01      	cmp	r3, #1
 80167f6:	dd0b      	ble.n	8016810 <ipcp_reqci+0x7c>
	    p[1] < 2 ||			/*  CI length too small or */
 80167f8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80167fa:	3301      	adds	r3, #1
 80167fc:	781b      	ldrb	r3, [r3, #0]
	if (l < 2 ||			/* Not enough data for CI header or */
 80167fe:	2b01      	cmp	r3, #1
 8016800:	d906      	bls.n	8016810 <ipcp_reqci+0x7c>
	    p[1] > l) {			/*  CI length too big? */
 8016802:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016804:	3301      	adds	r3, #1
 8016806:	781b      	ldrb	r3, [r3, #0]
 8016808:	001a      	movs	r2, r3
	    p[1] < 2 ||			/*  CI length too small or */
 801680a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801680c:	4293      	cmp	r3, r2
 801680e:	da08      	bge.n	8016822 <ipcp_reqci+0x8e>
	    IPCPDEBUG(("ipcp_reqci: bad CI length!"));
	    orc = CONFREJ;		/* Reject bad CI */
 8016810:	2304      	movs	r3, #4
 8016812:	64bb      	str	r3, [r7, #72]	; 0x48
	    cilen = l;			/* Reject till end of packet */
 8016814:	2352      	movs	r3, #82	; 0x52
 8016816:	18fb      	adds	r3, r7, r3
 8016818:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801681a:	801a      	strh	r2, [r3, #0]
	    l = 0;			/* Don't loop again */
 801681c:	2300      	movs	r3, #0
 801681e:	63fb      	str	r3, [r7, #60]	; 0x3c
	    goto endswitch;
 8016820:	e2e8      	b.n	8016df4 <ipcp_reqci+0x660>
	}
	GETCHAR(citype, p);		/* Parse CI type */
 8016822:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016824:	1c5a      	adds	r2, r3, #1
 8016826:	647a      	str	r2, [r7, #68]	; 0x44
 8016828:	781a      	ldrb	r2, [r3, #0]
 801682a:	2022      	movs	r0, #34	; 0x22
 801682c:	183b      	adds	r3, r7, r0
 801682e:	801a      	strh	r2, [r3, #0]
	GETCHAR(cilen, p);		/* Parse CI length */
 8016830:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016832:	1c5a      	adds	r2, r3, #1
 8016834:	647a      	str	r2, [r7, #68]	; 0x44
 8016836:	781a      	ldrb	r2, [r3, #0]
 8016838:	2152      	movs	r1, #82	; 0x52
 801683a:	187b      	adds	r3, r7, r1
 801683c:	801a      	strh	r2, [r3, #0]
	l -= cilen;			/* Adjust remaining length */
 801683e:	187b      	adds	r3, r7, r1
 8016840:	881b      	ldrh	r3, [r3, #0]
 8016842:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016844:	1ad3      	subs	r3, r2, r3
 8016846:	63fb      	str	r3, [r7, #60]	; 0x3c
	next += cilen;			/* Step to next CI */
 8016848:	187b      	adds	r3, r7, r1
 801684a:	881b      	ldrh	r3, [r3, #0]
 801684c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801684e:	18d3      	adds	r3, r2, r3
 8016850:	657b      	str	r3, [r7, #84]	; 0x54

	switch (citype) {		/* Check CI type */
 8016852:	183b      	adds	r3, r7, r0
 8016854:	881b      	ldrh	r3, [r3, #0]
 8016856:	2b83      	cmp	r3, #131	; 0x83
 8016858:	d100      	bne.n	801685c <ipcp_reqci+0xc8>
 801685a:	e1a5      	b.n	8016ba8 <ipcp_reqci+0x414>
 801685c:	dd00      	ble.n	8016860 <ipcp_reqci+0xcc>
 801685e:	e2c5      	b.n	8016dec <ipcp_reqci+0x658>
 8016860:	2b81      	cmp	r3, #129	; 0x81
 8016862:	d100      	bne.n	8016866 <ipcp_reqci+0xd2>
 8016864:	e1a0      	b.n	8016ba8 <ipcp_reqci+0x414>
 8016866:	dd00      	ble.n	801686a <ipcp_reqci+0xd6>
 8016868:	e2c0      	b.n	8016dec <ipcp_reqci+0x658>
 801686a:	2b03      	cmp	r3, #3
 801686c:	d100      	bne.n	8016870 <ipcp_reqci+0xdc>
 801686e:	e103      	b.n	8016a78 <ipcp_reqci+0x2e4>
 8016870:	dd00      	ble.n	8016874 <ipcp_reqci+0xe0>
 8016872:	e2bb      	b.n	8016dec <ipcp_reqci+0x658>
 8016874:	2b01      	cmp	r3, #1
 8016876:	d003      	beq.n	8016880 <ipcp_reqci+0xec>
 8016878:	2b02      	cmp	r3, #2
 801687a:	d100      	bne.n	801687e <ipcp_reqci+0xea>
 801687c:	e20d      	b.n	8016c9a <ipcp_reqci+0x506>
 801687e:	e2b5      	b.n	8016dec <ipcp_reqci+0x658>
	case CI_ADDRS:
	    if (!ao->old_addrs || ho->neg_addr ||
 8016880:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016882:	781b      	ldrb	r3, [r3, #0]
 8016884:	2202      	movs	r2, #2
 8016886:	4013      	ands	r3, r2
 8016888:	b2db      	uxtb	r3, r3
 801688a:	2b00      	cmp	r3, #0
 801688c:	d00b      	beq.n	80168a6 <ipcp_reqci+0x112>
 801688e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016890:	781b      	ldrb	r3, [r3, #0]
 8016892:	2201      	movs	r2, #1
 8016894:	4013      	ands	r3, r2
 8016896:	b2db      	uxtb	r3, r3
 8016898:	2b00      	cmp	r3, #0
 801689a:	d104      	bne.n	80168a6 <ipcp_reqci+0x112>
 801689c:	2352      	movs	r3, #82	; 0x52
 801689e:	18fb      	adds	r3, r7, r3
 80168a0:	881b      	ldrh	r3, [r3, #0]
 80168a2:	2b0a      	cmp	r3, #10
 80168a4:	d002      	beq.n	80168ac <ipcp_reqci+0x118>
		cilen != CILEN_ADDRS) {	/* Check CI length */
		orc = CONFREJ;		/* Reject CI */
 80168a6:	2304      	movs	r3, #4
 80168a8:	64bb      	str	r3, [r7, #72]	; 0x48
		break;
 80168aa:	e2a3      	b.n	8016df4 <ipcp_reqci+0x660>
	     * If he has no address, or if we both have his address but
	     * disagree about it, then NAK it with our idea.
	     * In particular, if we don't know his address, but he does,
	     * then accept it.
	     */
	    GETLONG(tl, p);		/* Parse source address (his) */
 80168ac:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80168ae:	1c5a      	adds	r2, r3, #1
 80168b0:	647a      	str	r2, [r7, #68]	; 0x44
 80168b2:	781b      	ldrb	r3, [r3, #0]
 80168b4:	021b      	lsls	r3, r3, #8
 80168b6:	62bb      	str	r3, [r7, #40]	; 0x28
 80168b8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80168ba:	1c5a      	adds	r2, r3, #1
 80168bc:	647a      	str	r2, [r7, #68]	; 0x44
 80168be:	781b      	ldrb	r3, [r3, #0]
 80168c0:	001a      	movs	r2, r3
 80168c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80168c4:	4313      	orrs	r3, r2
 80168c6:	62bb      	str	r3, [r7, #40]	; 0x28
 80168c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80168ca:	021b      	lsls	r3, r3, #8
 80168cc:	62bb      	str	r3, [r7, #40]	; 0x28
 80168ce:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80168d0:	1c5a      	adds	r2, r3, #1
 80168d2:	647a      	str	r2, [r7, #68]	; 0x44
 80168d4:	781b      	ldrb	r3, [r3, #0]
 80168d6:	001a      	movs	r2, r3
 80168d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80168da:	4313      	orrs	r3, r2
 80168dc:	62bb      	str	r3, [r7, #40]	; 0x28
 80168de:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80168e0:	021b      	lsls	r3, r3, #8
 80168e2:	62bb      	str	r3, [r7, #40]	; 0x28
 80168e4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80168e6:	1c5a      	adds	r2, r3, #1
 80168e8:	647a      	str	r2, [r7, #68]	; 0x44
 80168ea:	781b      	ldrb	r3, [r3, #0]
 80168ec:	001a      	movs	r2, r3
 80168ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80168f0:	4313      	orrs	r3, r2
 80168f2:	62bb      	str	r3, [r7, #40]	; 0x28
	    ciaddr1 = lwip_htonl(tl);
 80168f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80168f6:	0018      	movs	r0, r3
 80168f8:	f7ef fe32 	bl	8006560 <lwip_htonl>
 80168fc:	0003      	movs	r3, r0
 80168fe:	61bb      	str	r3, [r7, #24]
	    if (ciaddr1 != wo->hisaddr
 8016900:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016902:	689b      	ldr	r3, [r3, #8]
 8016904:	69ba      	ldr	r2, [r7, #24]
 8016906:	429a      	cmp	r2, r3
 8016908:	d034      	beq.n	8016974 <ipcp_reqci+0x1e0>
		&& (ciaddr1 == 0 || !wo->accept_remote)) {
 801690a:	69bb      	ldr	r3, [r7, #24]
 801690c:	2b00      	cmp	r3, #0
 801690e:	d006      	beq.n	801691e <ipcp_reqci+0x18a>
 8016910:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016912:	781b      	ldrb	r3, [r3, #0]
 8016914:	227f      	movs	r2, #127	; 0x7f
 8016916:	4393      	bics	r3, r2
 8016918:	b2db      	uxtb	r3, r3
 801691a:	2b00      	cmp	r3, #0
 801691c:	d12a      	bne.n	8016974 <ipcp_reqci+0x1e0>
		orc = CONFNAK;
 801691e:	2303      	movs	r3, #3
 8016920:	64bb      	str	r3, [r7, #72]	; 0x48
		if (!reject_if_disagree) {
 8016922:	683b      	ldr	r3, [r7, #0]
 8016924:	2b00      	cmp	r3, #0
 8016926:	d134      	bne.n	8016992 <ipcp_reqci+0x1fe>
		    DECPTR(sizeof(u32_t), p);
 8016928:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801692a:	3b04      	subs	r3, #4
 801692c:	647b      	str	r3, [r7, #68]	; 0x44
		    tl = lwip_ntohl(wo->hisaddr);
 801692e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016930:	689b      	ldr	r3, [r3, #8]
 8016932:	0018      	movs	r0, r3
 8016934:	f7ef fe14 	bl	8006560 <lwip_htonl>
 8016938:	0003      	movs	r3, r0
 801693a:	62bb      	str	r3, [r7, #40]	; 0x28
		    PUTLONG(tl, p);
 801693c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801693e:	0e19      	lsrs	r1, r3, #24
 8016940:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016942:	1c5a      	adds	r2, r3, #1
 8016944:	647a      	str	r2, [r7, #68]	; 0x44
 8016946:	b2ca      	uxtb	r2, r1
 8016948:	701a      	strb	r2, [r3, #0]
 801694a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801694c:	0c19      	lsrs	r1, r3, #16
 801694e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016950:	1c5a      	adds	r2, r3, #1
 8016952:	647a      	str	r2, [r7, #68]	; 0x44
 8016954:	b2ca      	uxtb	r2, r1
 8016956:	701a      	strb	r2, [r3, #0]
 8016958:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801695a:	0a19      	lsrs	r1, r3, #8
 801695c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801695e:	1c5a      	adds	r2, r3, #1
 8016960:	647a      	str	r2, [r7, #68]	; 0x44
 8016962:	b2ca      	uxtb	r2, r1
 8016964:	701a      	strb	r2, [r3, #0]
 8016966:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016968:	1c5a      	adds	r2, r3, #1
 801696a:	647a      	str	r2, [r7, #68]	; 0x44
 801696c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801696e:	b2d2      	uxtb	r2, r2
 8016970:	701a      	strb	r2, [r3, #0]
		if (!reject_if_disagree) {
 8016972:	e00e      	b.n	8016992 <ipcp_reqci+0x1fe>
		}
	    } else if (ciaddr1 == 0 && wo->hisaddr == 0) {
 8016974:	69bb      	ldr	r3, [r7, #24]
 8016976:	2b00      	cmp	r3, #0
 8016978:	d10b      	bne.n	8016992 <ipcp_reqci+0x1fe>
 801697a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801697c:	689b      	ldr	r3, [r3, #8]
 801697e:	2b00      	cmp	r3, #0
 8016980:	d107      	bne.n	8016992 <ipcp_reqci+0x1fe>
		/*
		 * If neither we nor he knows his address, reject the option.
		 */
		orc = CONFREJ;
 8016982:	2304      	movs	r3, #4
 8016984:	64bb      	str	r3, [r7, #72]	; 0x48
		wo->req_addr = 0;	/* don't NAK with 0.0.0.0 later */
 8016986:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016988:	781a      	ldrb	r2, [r3, #0]
 801698a:	2104      	movs	r1, #4
 801698c:	438a      	bics	r2, r1
 801698e:	701a      	strb	r2, [r3, #0]
		break;
 8016990:	e230      	b.n	8016df4 <ipcp_reqci+0x660>

	    /*
	     * If he doesn't know our address, or if we both have our address
	     * but disagree about it, then NAK it with our idea.
	     */
	    GETLONG(tl, p);		/* Parse desination address (ours) */
 8016992:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016994:	1c5a      	adds	r2, r3, #1
 8016996:	647a      	str	r2, [r7, #68]	; 0x44
 8016998:	781b      	ldrb	r3, [r3, #0]
 801699a:	021b      	lsls	r3, r3, #8
 801699c:	62bb      	str	r3, [r7, #40]	; 0x28
 801699e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80169a0:	1c5a      	adds	r2, r3, #1
 80169a2:	647a      	str	r2, [r7, #68]	; 0x44
 80169a4:	781b      	ldrb	r3, [r3, #0]
 80169a6:	001a      	movs	r2, r3
 80169a8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80169aa:	4313      	orrs	r3, r2
 80169ac:	62bb      	str	r3, [r7, #40]	; 0x28
 80169ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80169b0:	021b      	lsls	r3, r3, #8
 80169b2:	62bb      	str	r3, [r7, #40]	; 0x28
 80169b4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80169b6:	1c5a      	adds	r2, r3, #1
 80169b8:	647a      	str	r2, [r7, #68]	; 0x44
 80169ba:	781b      	ldrb	r3, [r3, #0]
 80169bc:	001a      	movs	r2, r3
 80169be:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80169c0:	4313      	orrs	r3, r2
 80169c2:	62bb      	str	r3, [r7, #40]	; 0x28
 80169c4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80169c6:	021b      	lsls	r3, r3, #8
 80169c8:	62bb      	str	r3, [r7, #40]	; 0x28
 80169ca:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80169cc:	1c5a      	adds	r2, r3, #1
 80169ce:	647a      	str	r2, [r7, #68]	; 0x44
 80169d0:	781b      	ldrb	r3, [r3, #0]
 80169d2:	001a      	movs	r2, r3
 80169d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80169d6:	4313      	orrs	r3, r2
 80169d8:	62bb      	str	r3, [r7, #40]	; 0x28
	    ciaddr2 = lwip_htonl(tl);
 80169da:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80169dc:	0018      	movs	r0, r3
 80169de:	f7ef fdbf 	bl	8006560 <lwip_htonl>
 80169e2:	0003      	movs	r3, r0
 80169e4:	613b      	str	r3, [r7, #16]
	    if (ciaddr2 != wo->ouraddr) {
 80169e6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80169e8:	685b      	ldr	r3, [r3, #4]
 80169ea:	693a      	ldr	r2, [r7, #16]
 80169ec:	429a      	cmp	r2, r3
 80169ee:	d037      	beq.n	8016a60 <ipcp_reqci+0x2cc>
		if (ciaddr2 == 0 || !wo->accept_local) {
 80169f0:	693b      	ldr	r3, [r7, #16]
 80169f2:	2b00      	cmp	r3, #0
 80169f4:	d006      	beq.n	8016a04 <ipcp_reqci+0x270>
 80169f6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80169f8:	781b      	ldrb	r3, [r3, #0]
 80169fa:	2240      	movs	r2, #64	; 0x40
 80169fc:	4013      	ands	r3, r2
 80169fe:	b2db      	uxtb	r3, r3
 8016a00:	2b00      	cmp	r3, #0
 8016a02:	d12a      	bne.n	8016a5a <ipcp_reqci+0x2c6>
		    orc = CONFNAK;
 8016a04:	2303      	movs	r3, #3
 8016a06:	64bb      	str	r3, [r7, #72]	; 0x48
		    if (!reject_if_disagree) {
 8016a08:	683b      	ldr	r3, [r7, #0]
 8016a0a:	2b00      	cmp	r3, #0
 8016a0c:	d128      	bne.n	8016a60 <ipcp_reqci+0x2cc>
			DECPTR(sizeof(u32_t), p);
 8016a0e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016a10:	3b04      	subs	r3, #4
 8016a12:	647b      	str	r3, [r7, #68]	; 0x44
			tl = lwip_ntohl(wo->ouraddr);
 8016a14:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016a16:	685b      	ldr	r3, [r3, #4]
 8016a18:	0018      	movs	r0, r3
 8016a1a:	f7ef fda1 	bl	8006560 <lwip_htonl>
 8016a1e:	0003      	movs	r3, r0
 8016a20:	62bb      	str	r3, [r7, #40]	; 0x28
			PUTLONG(tl, p);
 8016a22:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016a24:	0e19      	lsrs	r1, r3, #24
 8016a26:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016a28:	1c5a      	adds	r2, r3, #1
 8016a2a:	647a      	str	r2, [r7, #68]	; 0x44
 8016a2c:	b2ca      	uxtb	r2, r1
 8016a2e:	701a      	strb	r2, [r3, #0]
 8016a30:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016a32:	0c19      	lsrs	r1, r3, #16
 8016a34:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016a36:	1c5a      	adds	r2, r3, #1
 8016a38:	647a      	str	r2, [r7, #68]	; 0x44
 8016a3a:	b2ca      	uxtb	r2, r1
 8016a3c:	701a      	strb	r2, [r3, #0]
 8016a3e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016a40:	0a19      	lsrs	r1, r3, #8
 8016a42:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016a44:	1c5a      	adds	r2, r3, #1
 8016a46:	647a      	str	r2, [r7, #68]	; 0x44
 8016a48:	b2ca      	uxtb	r2, r1
 8016a4a:	701a      	strb	r2, [r3, #0]
 8016a4c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016a4e:	1c5a      	adds	r2, r3, #1
 8016a50:	647a      	str	r2, [r7, #68]	; 0x44
 8016a52:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016a54:	b2d2      	uxtb	r2, r2
 8016a56:	701a      	strb	r2, [r3, #0]
		    if (!reject_if_disagree) {
 8016a58:	e002      	b.n	8016a60 <ipcp_reqci+0x2cc>
		    }
		} else {
		    wo->ouraddr = ciaddr2;	/* accept peer's idea */
 8016a5a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016a5c:	693a      	ldr	r2, [r7, #16]
 8016a5e:	605a      	str	r2, [r3, #4]
		}
	    }

	    ho->old_addrs = 1;
 8016a60:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016a62:	781a      	ldrb	r2, [r3, #0]
 8016a64:	2102      	movs	r1, #2
 8016a66:	430a      	orrs	r2, r1
 8016a68:	701a      	strb	r2, [r3, #0]
	    ho->hisaddr = ciaddr1;
 8016a6a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016a6c:	69ba      	ldr	r2, [r7, #24]
 8016a6e:	609a      	str	r2, [r3, #8]
	    ho->ouraddr = ciaddr2;
 8016a70:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016a72:	693a      	ldr	r2, [r7, #16]
 8016a74:	605a      	str	r2, [r3, #4]
	    break;
 8016a76:	e1bd      	b.n	8016df4 <ipcp_reqci+0x660>

	case CI_ADDR:
	    if (!ao->neg_addr || ho->old_addrs ||
 8016a78:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016a7a:	781b      	ldrb	r3, [r3, #0]
 8016a7c:	2201      	movs	r2, #1
 8016a7e:	4013      	ands	r3, r2
 8016a80:	b2db      	uxtb	r3, r3
 8016a82:	2b00      	cmp	r3, #0
 8016a84:	d00b      	beq.n	8016a9e <ipcp_reqci+0x30a>
 8016a86:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016a88:	781b      	ldrb	r3, [r3, #0]
 8016a8a:	2202      	movs	r2, #2
 8016a8c:	4013      	ands	r3, r2
 8016a8e:	b2db      	uxtb	r3, r3
 8016a90:	2b00      	cmp	r3, #0
 8016a92:	d104      	bne.n	8016a9e <ipcp_reqci+0x30a>
 8016a94:	2352      	movs	r3, #82	; 0x52
 8016a96:	18fb      	adds	r3, r7, r3
 8016a98:	881b      	ldrh	r3, [r3, #0]
 8016a9a:	2b06      	cmp	r3, #6
 8016a9c:	d008      	beq.n	8016ab0 <ipcp_reqci+0x31c>
		cilen != CILEN_ADDR) {	/* Check CI length */
		orc = CONFREJ;		/* Reject CI */
 8016a9e:	2304      	movs	r3, #4
 8016aa0:	64bb      	str	r3, [r7, #72]	; 0x48
		break;
 8016aa2:	e1a7      	b.n	8016df4 <ipcp_reqci+0x660>
 8016aa4:	00001204 	.word	0x00001204
 8016aa8:	0000124c 	.word	0x0000124c
 8016aac:	00001234 	.word	0x00001234
	     * If he has no address, or if we both have his address but
	     * disagree about it, then NAK it with our idea.
	     * In particular, if we don't know his address, but he does,
	     * then accept it.
	     */
	    GETLONG(tl, p);	/* Parse source address (his) */
 8016ab0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016ab2:	1c5a      	adds	r2, r3, #1
 8016ab4:	647a      	str	r2, [r7, #68]	; 0x44
 8016ab6:	781b      	ldrb	r3, [r3, #0]
 8016ab8:	021b      	lsls	r3, r3, #8
 8016aba:	62bb      	str	r3, [r7, #40]	; 0x28
 8016abc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016abe:	1c5a      	adds	r2, r3, #1
 8016ac0:	647a      	str	r2, [r7, #68]	; 0x44
 8016ac2:	781b      	ldrb	r3, [r3, #0]
 8016ac4:	001a      	movs	r2, r3
 8016ac6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016ac8:	4313      	orrs	r3, r2
 8016aca:	62bb      	str	r3, [r7, #40]	; 0x28
 8016acc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016ace:	021b      	lsls	r3, r3, #8
 8016ad0:	62bb      	str	r3, [r7, #40]	; 0x28
 8016ad2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016ad4:	1c5a      	adds	r2, r3, #1
 8016ad6:	647a      	str	r2, [r7, #68]	; 0x44
 8016ad8:	781b      	ldrb	r3, [r3, #0]
 8016ada:	001a      	movs	r2, r3
 8016adc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016ade:	4313      	orrs	r3, r2
 8016ae0:	62bb      	str	r3, [r7, #40]	; 0x28
 8016ae2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016ae4:	021b      	lsls	r3, r3, #8
 8016ae6:	62bb      	str	r3, [r7, #40]	; 0x28
 8016ae8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016aea:	1c5a      	adds	r2, r3, #1
 8016aec:	647a      	str	r2, [r7, #68]	; 0x44
 8016aee:	781b      	ldrb	r3, [r3, #0]
 8016af0:	001a      	movs	r2, r3
 8016af2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016af4:	4313      	orrs	r3, r2
 8016af6:	62bb      	str	r3, [r7, #40]	; 0x28
	    ciaddr1 = lwip_htonl(tl);
 8016af8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016afa:	0018      	movs	r0, r3
 8016afc:	f7ef fd30 	bl	8006560 <lwip_htonl>
 8016b00:	0003      	movs	r3, r0
 8016b02:	61bb      	str	r3, [r7, #24]
	    if (ciaddr1 != wo->hisaddr
 8016b04:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016b06:	689b      	ldr	r3, [r3, #8]
 8016b08:	69ba      	ldr	r2, [r7, #24]
 8016b0a:	429a      	cmp	r2, r3
 8016b0c:	d034      	beq.n	8016b78 <ipcp_reqci+0x3e4>
		&& (ciaddr1 == 0 || !wo->accept_remote)) {
 8016b0e:	69bb      	ldr	r3, [r7, #24]
 8016b10:	2b00      	cmp	r3, #0
 8016b12:	d006      	beq.n	8016b22 <ipcp_reqci+0x38e>
 8016b14:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016b16:	781b      	ldrb	r3, [r3, #0]
 8016b18:	227f      	movs	r2, #127	; 0x7f
 8016b1a:	4393      	bics	r3, r2
 8016b1c:	b2db      	uxtb	r3, r3
 8016b1e:	2b00      	cmp	r3, #0
 8016b20:	d12a      	bne.n	8016b78 <ipcp_reqci+0x3e4>
		orc = CONFNAK;
 8016b22:	2303      	movs	r3, #3
 8016b24:	64bb      	str	r3, [r7, #72]	; 0x48
		if (!reject_if_disagree) {
 8016b26:	683b      	ldr	r3, [r7, #0]
 8016b28:	2b00      	cmp	r3, #0
 8016b2a:	d134      	bne.n	8016b96 <ipcp_reqci+0x402>
		    DECPTR(sizeof(u32_t), p);
 8016b2c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016b2e:	3b04      	subs	r3, #4
 8016b30:	647b      	str	r3, [r7, #68]	; 0x44
		    tl = lwip_ntohl(wo->hisaddr);
 8016b32:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016b34:	689b      	ldr	r3, [r3, #8]
 8016b36:	0018      	movs	r0, r3
 8016b38:	f7ef fd12 	bl	8006560 <lwip_htonl>
 8016b3c:	0003      	movs	r3, r0
 8016b3e:	62bb      	str	r3, [r7, #40]	; 0x28
		    PUTLONG(tl, p);
 8016b40:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016b42:	0e19      	lsrs	r1, r3, #24
 8016b44:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016b46:	1c5a      	adds	r2, r3, #1
 8016b48:	647a      	str	r2, [r7, #68]	; 0x44
 8016b4a:	b2ca      	uxtb	r2, r1
 8016b4c:	701a      	strb	r2, [r3, #0]
 8016b4e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016b50:	0c19      	lsrs	r1, r3, #16
 8016b52:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016b54:	1c5a      	adds	r2, r3, #1
 8016b56:	647a      	str	r2, [r7, #68]	; 0x44
 8016b58:	b2ca      	uxtb	r2, r1
 8016b5a:	701a      	strb	r2, [r3, #0]
 8016b5c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016b5e:	0a19      	lsrs	r1, r3, #8
 8016b60:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016b62:	1c5a      	adds	r2, r3, #1
 8016b64:	647a      	str	r2, [r7, #68]	; 0x44
 8016b66:	b2ca      	uxtb	r2, r1
 8016b68:	701a      	strb	r2, [r3, #0]
 8016b6a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016b6c:	1c5a      	adds	r2, r3, #1
 8016b6e:	647a      	str	r2, [r7, #68]	; 0x44
 8016b70:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016b72:	b2d2      	uxtb	r2, r2
 8016b74:	701a      	strb	r2, [r3, #0]
		if (!reject_if_disagree) {
 8016b76:	e00e      	b.n	8016b96 <ipcp_reqci+0x402>
		}
	    } else if (ciaddr1 == 0 && wo->hisaddr == 0) {
 8016b78:	69bb      	ldr	r3, [r7, #24]
 8016b7a:	2b00      	cmp	r3, #0
 8016b7c:	d10b      	bne.n	8016b96 <ipcp_reqci+0x402>
 8016b7e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016b80:	689b      	ldr	r3, [r3, #8]
 8016b82:	2b00      	cmp	r3, #0
 8016b84:	d107      	bne.n	8016b96 <ipcp_reqci+0x402>
		/*
		 * Don't ACK an address of 0.0.0.0 - reject it instead.
		 */
		orc = CONFREJ;
 8016b86:	2304      	movs	r3, #4
 8016b88:	64bb      	str	r3, [r7, #72]	; 0x48
		wo->req_addr = 0;	/* don't NAK with 0.0.0.0 later */
 8016b8a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016b8c:	781a      	ldrb	r2, [r3, #0]
 8016b8e:	2104      	movs	r1, #4
 8016b90:	438a      	bics	r2, r1
 8016b92:	701a      	strb	r2, [r3, #0]
		break;
 8016b94:	e12e      	b.n	8016df4 <ipcp_reqci+0x660>
	    }
	
	    ho->neg_addr = 1;
 8016b96:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016b98:	781a      	ldrb	r2, [r3, #0]
 8016b9a:	2101      	movs	r1, #1
 8016b9c:	430a      	orrs	r2, r1
 8016b9e:	701a      	strb	r2, [r3, #0]
	    ho->hisaddr = ciaddr1;
 8016ba0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016ba2:	69ba      	ldr	r2, [r7, #24]
 8016ba4:	609a      	str	r2, [r3, #8]
	    break;
 8016ba6:	e125      	b.n	8016df4 <ipcp_reqci+0x660>

#if LWIP_DNS
	case CI_MS_DNS1:
	case CI_MS_DNS2:
	    /* Microsoft primary or secondary DNS request */
	    d = citype == CI_MS_DNS2;
 8016ba8:	2322      	movs	r3, #34	; 0x22
 8016baa:	18fb      	adds	r3, r7, r3
 8016bac:	881b      	ldrh	r3, [r3, #0]
 8016bae:	3b83      	subs	r3, #131	; 0x83
 8016bb0:	425a      	negs	r2, r3
 8016bb2:	4153      	adcs	r3, r2
 8016bb4:	b2db      	uxtb	r3, r3
 8016bb6:	61fb      	str	r3, [r7, #28]

	    /* If we do not have a DNS address then we cannot send it */
	    if (ao->dnsaddr[d] == 0 ||
 8016bb8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016bba:	69fb      	ldr	r3, [r7, #28]
 8016bbc:	3302      	adds	r3, #2
 8016bbe:	009b      	lsls	r3, r3, #2
 8016bc0:	18d3      	adds	r3, r2, r3
 8016bc2:	3304      	adds	r3, #4
 8016bc4:	681b      	ldr	r3, [r3, #0]
 8016bc6:	2b00      	cmp	r3, #0
 8016bc8:	d004      	beq.n	8016bd4 <ipcp_reqci+0x440>
 8016bca:	2352      	movs	r3, #82	; 0x52
 8016bcc:	18fb      	adds	r3, r7, r3
 8016bce:	881b      	ldrh	r3, [r3, #0]
 8016bd0:	2b06      	cmp	r3, #6
 8016bd2:	d002      	beq.n	8016bda <ipcp_reqci+0x446>
		cilen != CILEN_ADDR) {	/* Check CI length */
		orc = CONFREJ;		/* Reject CI */
 8016bd4:	2304      	movs	r3, #4
 8016bd6:	64bb      	str	r3, [r7, #72]	; 0x48
		break;
 8016bd8:	e10c      	b.n	8016df4 <ipcp_reqci+0x660>
	    }
	    GETLONG(tl, p);
 8016bda:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016bdc:	1c5a      	adds	r2, r3, #1
 8016bde:	647a      	str	r2, [r7, #68]	; 0x44
 8016be0:	781b      	ldrb	r3, [r3, #0]
 8016be2:	021b      	lsls	r3, r3, #8
 8016be4:	62bb      	str	r3, [r7, #40]	; 0x28
 8016be6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016be8:	1c5a      	adds	r2, r3, #1
 8016bea:	647a      	str	r2, [r7, #68]	; 0x44
 8016bec:	781b      	ldrb	r3, [r3, #0]
 8016bee:	001a      	movs	r2, r3
 8016bf0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016bf2:	4313      	orrs	r3, r2
 8016bf4:	62bb      	str	r3, [r7, #40]	; 0x28
 8016bf6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016bf8:	021b      	lsls	r3, r3, #8
 8016bfa:	62bb      	str	r3, [r7, #40]	; 0x28
 8016bfc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016bfe:	1c5a      	adds	r2, r3, #1
 8016c00:	647a      	str	r2, [r7, #68]	; 0x44
 8016c02:	781b      	ldrb	r3, [r3, #0]
 8016c04:	001a      	movs	r2, r3
 8016c06:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016c08:	4313      	orrs	r3, r2
 8016c0a:	62bb      	str	r3, [r7, #40]	; 0x28
 8016c0c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016c0e:	021b      	lsls	r3, r3, #8
 8016c10:	62bb      	str	r3, [r7, #40]	; 0x28
 8016c12:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016c14:	1c5a      	adds	r2, r3, #1
 8016c16:	647a      	str	r2, [r7, #68]	; 0x44
 8016c18:	781b      	ldrb	r3, [r3, #0]
 8016c1a:	001a      	movs	r2, r3
 8016c1c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016c1e:	4313      	orrs	r3, r2
 8016c20:	62bb      	str	r3, [r7, #40]	; 0x28
	    if (lwip_htonl(tl) != ao->dnsaddr[d]) {
 8016c22:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016c24:	0018      	movs	r0, r3
 8016c26:	f7ef fc9b 	bl	8006560 <lwip_htonl>
 8016c2a:	0001      	movs	r1, r0
 8016c2c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016c2e:	69fb      	ldr	r3, [r7, #28]
 8016c30:	3302      	adds	r3, #2
 8016c32:	009b      	lsls	r3, r3, #2
 8016c34:	18d3      	adds	r3, r2, r3
 8016c36:	3304      	adds	r3, #4
 8016c38:	681b      	ldr	r3, [r3, #0]
 8016c3a:	4299      	cmp	r1, r3
 8016c3c:	d100      	bne.n	8016c40 <ipcp_reqci+0x4ac>
 8016c3e:	e0d8      	b.n	8016df2 <ipcp_reqci+0x65e>
                DECPTR(sizeof(u32_t), p);
 8016c40:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016c42:	3b04      	subs	r3, #4
 8016c44:	647b      	str	r3, [r7, #68]	; 0x44
		tl = lwip_ntohl(ao->dnsaddr[d]);
 8016c46:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016c48:	69fb      	ldr	r3, [r7, #28]
 8016c4a:	3302      	adds	r3, #2
 8016c4c:	009b      	lsls	r3, r3, #2
 8016c4e:	18d3      	adds	r3, r2, r3
 8016c50:	3304      	adds	r3, #4
 8016c52:	681b      	ldr	r3, [r3, #0]
 8016c54:	0018      	movs	r0, r3
 8016c56:	f7ef fc83 	bl	8006560 <lwip_htonl>
 8016c5a:	0003      	movs	r3, r0
 8016c5c:	62bb      	str	r3, [r7, #40]	; 0x28
		PUTLONG(tl, p);
 8016c5e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016c60:	0e19      	lsrs	r1, r3, #24
 8016c62:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016c64:	1c5a      	adds	r2, r3, #1
 8016c66:	647a      	str	r2, [r7, #68]	; 0x44
 8016c68:	b2ca      	uxtb	r2, r1
 8016c6a:	701a      	strb	r2, [r3, #0]
 8016c6c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016c6e:	0c19      	lsrs	r1, r3, #16
 8016c70:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016c72:	1c5a      	adds	r2, r3, #1
 8016c74:	647a      	str	r2, [r7, #68]	; 0x44
 8016c76:	b2ca      	uxtb	r2, r1
 8016c78:	701a      	strb	r2, [r3, #0]
 8016c7a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016c7c:	0a19      	lsrs	r1, r3, #8
 8016c7e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016c80:	1c5a      	adds	r2, r3, #1
 8016c82:	647a      	str	r2, [r7, #68]	; 0x44
 8016c84:	b2ca      	uxtb	r2, r1
 8016c86:	701a      	strb	r2, [r3, #0]
 8016c88:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016c8a:	1c5a      	adds	r2, r3, #1
 8016c8c:	647a      	str	r2, [r7, #68]	; 0x44
 8016c8e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016c90:	b2d2      	uxtb	r2, r2
 8016c92:	701a      	strb	r2, [r3, #0]
		orc = CONFNAK;
 8016c94:	2303      	movs	r3, #3
 8016c96:	64bb      	str	r3, [r7, #72]	; 0x48
            }
            break;
 8016c98:	e0ab      	b.n	8016df2 <ipcp_reqci+0x65e>
            break;
#endif /* UNUSED - WINS */

#if VJ_SUPPORT
	case CI_COMPRESSTYPE:
	    if (!ao->neg_vj ||
 8016c9a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016c9c:	781b      	ldrb	r3, [r3, #0]
 8016c9e:	2208      	movs	r2, #8
 8016ca0:	4013      	ands	r3, r2
 8016ca2:	b2db      	uxtb	r3, r3
 8016ca4:	2b00      	cmp	r3, #0
 8016ca6:	d008      	beq.n	8016cba <ipcp_reqci+0x526>
 8016ca8:	2252      	movs	r2, #82	; 0x52
 8016caa:	18bb      	adds	r3, r7, r2
 8016cac:	881b      	ldrh	r3, [r3, #0]
 8016cae:	2b06      	cmp	r3, #6
 8016cb0:	d006      	beq.n	8016cc0 <ipcp_reqci+0x52c>
		(cilen != CILEN_VJ && cilen != CILEN_COMPRESS)) {
 8016cb2:	18bb      	adds	r3, r7, r2
 8016cb4:	881b      	ldrh	r3, [r3, #0]
 8016cb6:	2b04      	cmp	r3, #4
 8016cb8:	d002      	beq.n	8016cc0 <ipcp_reqci+0x52c>
		orc = CONFREJ;
 8016cba:	2304      	movs	r3, #4
 8016cbc:	64bb      	str	r3, [r7, #72]	; 0x48
		break;
 8016cbe:	e099      	b.n	8016df4 <ipcp_reqci+0x660>
	    }
	    GETSHORT(cishort, p);
 8016cc0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016cc2:	1c5a      	adds	r2, r3, #1
 8016cc4:	647a      	str	r2, [r7, #68]	; 0x44
 8016cc6:	781b      	ldrb	r3, [r3, #0]
 8016cc8:	b29a      	uxth	r2, r3
 8016cca:	2016      	movs	r0, #22
 8016ccc:	183b      	adds	r3, r7, r0
 8016cce:	0212      	lsls	r2, r2, #8
 8016cd0:	801a      	strh	r2, [r3, #0]
 8016cd2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016cd4:	1c5a      	adds	r2, r3, #1
 8016cd6:	647a      	str	r2, [r7, #68]	; 0x44
 8016cd8:	781b      	ldrb	r3, [r3, #0]
 8016cda:	b299      	uxth	r1, r3
 8016cdc:	183b      	adds	r3, r7, r0
 8016cde:	183a      	adds	r2, r7, r0
 8016ce0:	8812      	ldrh	r2, [r2, #0]
 8016ce2:	430a      	orrs	r2, r1
 8016ce4:	801a      	strh	r2, [r3, #0]

	    if (!(cishort == IPCP_VJ_COMP ||
 8016ce6:	183b      	adds	r3, r7, r0
 8016ce8:	881b      	ldrh	r3, [r3, #0]
 8016cea:	2b2d      	cmp	r3, #45	; 0x2d
 8016cec:	d00b      	beq.n	8016d06 <ipcp_reqci+0x572>
 8016cee:	183b      	adds	r3, r7, r0
 8016cf0:	881b      	ldrh	r3, [r3, #0]
 8016cf2:	2b37      	cmp	r3, #55	; 0x37
 8016cf4:	d104      	bne.n	8016d00 <ipcp_reqci+0x56c>
		  (cishort == IPCP_VJ_COMP_OLD && cilen == CILEN_COMPRESS))) {
 8016cf6:	2352      	movs	r3, #82	; 0x52
 8016cf8:	18fb      	adds	r3, r7, r3
 8016cfa:	881b      	ldrh	r3, [r3, #0]
 8016cfc:	2b04      	cmp	r3, #4
 8016cfe:	d002      	beq.n	8016d06 <ipcp_reqci+0x572>
		orc = CONFREJ;
 8016d00:	2304      	movs	r3, #4
 8016d02:	64bb      	str	r3, [r7, #72]	; 0x48
		break;
 8016d04:	e076      	b.n	8016df4 <ipcp_reqci+0x660>
	    }

	    ho->neg_vj = 1;
 8016d06:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016d08:	781a      	ldrb	r2, [r3, #0]
 8016d0a:	2108      	movs	r1, #8
 8016d0c:	430a      	orrs	r2, r1
 8016d0e:	701a      	strb	r2, [r3, #0]
	    ho->vj_protocol = cishort;
 8016d10:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016d12:	2216      	movs	r2, #22
 8016d14:	18ba      	adds	r2, r7, r2
 8016d16:	8812      	ldrh	r2, [r2, #0]
 8016d18:	829a      	strh	r2, [r3, #20]
	    if (cilen == CILEN_VJ) {
 8016d1a:	2352      	movs	r3, #82	; 0x52
 8016d1c:	18fb      	adds	r3, r7, r3
 8016d1e:	881b      	ldrh	r3, [r3, #0]
 8016d20:	2b06      	cmp	r3, #6
 8016d22:	d155      	bne.n	8016dd0 <ipcp_reqci+0x63c>
		GETCHAR(maxslotindex, p);
 8016d24:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016d26:	1c5a      	adds	r2, r3, #1
 8016d28:	647a      	str	r2, [r7, #68]	; 0x44
 8016d2a:	2115      	movs	r1, #21
 8016d2c:	187a      	adds	r2, r7, r1
 8016d2e:	781b      	ldrb	r3, [r3, #0]
 8016d30:	7013      	strb	r3, [r2, #0]
		if (maxslotindex > ao->maxslotindex) { 
 8016d32:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016d34:	7d9b      	ldrb	r3, [r3, #22]
 8016d36:	187a      	adds	r2, r7, r1
 8016d38:	7812      	ldrb	r2, [r2, #0]
 8016d3a:	429a      	cmp	r2, r3
 8016d3c:	d90d      	bls.n	8016d5a <ipcp_reqci+0x5c6>
		    orc = CONFNAK;
 8016d3e:	2303      	movs	r3, #3
 8016d40:	64bb      	str	r3, [r7, #72]	; 0x48
		    if (!reject_if_disagree){
 8016d42:	683b      	ldr	r3, [r7, #0]
 8016d44:	2b00      	cmp	r3, #0
 8016d46:	d108      	bne.n	8016d5a <ipcp_reqci+0x5c6>
			DECPTR(1, p);
 8016d48:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016d4a:	3b01      	subs	r3, #1
 8016d4c:	647b      	str	r3, [r7, #68]	; 0x44
			PUTCHAR(ao->maxslotindex, p);
 8016d4e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016d50:	1c5a      	adds	r2, r3, #1
 8016d52:	647a      	str	r2, [r7, #68]	; 0x44
 8016d54:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016d56:	7d92      	ldrb	r2, [r2, #22]
 8016d58:	701a      	strb	r2, [r3, #0]
		    }
		}
		GETCHAR(cflag, p);
 8016d5a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016d5c:	1c5a      	adds	r2, r3, #1
 8016d5e:	647a      	str	r2, [r7, #68]	; 0x44
 8016d60:	2114      	movs	r1, #20
 8016d62:	187a      	adds	r2, r7, r1
 8016d64:	781b      	ldrb	r3, [r3, #0]
 8016d66:	7013      	strb	r3, [r2, #0]
		if (cflag && !ao->cflag) {
 8016d68:	187b      	adds	r3, r7, r1
 8016d6a:	781b      	ldrb	r3, [r3, #0]
 8016d6c:	2b00      	cmp	r3, #0
 8016d6e:	d018      	beq.n	8016da2 <ipcp_reqci+0x60e>
 8016d70:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016d72:	781b      	ldrb	r3, [r3, #0]
 8016d74:	2220      	movs	r2, #32
 8016d76:	4013      	ands	r3, r2
 8016d78:	b2db      	uxtb	r3, r3
 8016d7a:	2b00      	cmp	r3, #0
 8016d7c:	d111      	bne.n	8016da2 <ipcp_reqci+0x60e>
		    orc = CONFNAK;
 8016d7e:	2303      	movs	r3, #3
 8016d80:	64bb      	str	r3, [r7, #72]	; 0x48
		    if (!reject_if_disagree){
 8016d82:	683b      	ldr	r3, [r7, #0]
 8016d84:	2b00      	cmp	r3, #0
 8016d86:	d10c      	bne.n	8016da2 <ipcp_reqci+0x60e>
			DECPTR(1, p);
 8016d88:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016d8a:	3b01      	subs	r3, #1
 8016d8c:	647b      	str	r3, [r7, #68]	; 0x44
			PUTCHAR(wo->cflag, p);
 8016d8e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016d90:	781b      	ldrb	r3, [r3, #0]
 8016d92:	069b      	lsls	r3, r3, #26
 8016d94:	0fdb      	lsrs	r3, r3, #31
 8016d96:	b2d9      	uxtb	r1, r3
 8016d98:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8016d9a:	1c5a      	adds	r2, r3, #1
 8016d9c:	647a      	str	r2, [r7, #68]	; 0x44
 8016d9e:	000a      	movs	r2, r1
 8016da0:	701a      	strb	r2, [r3, #0]
		    }
		}
		ho->maxslotindex = maxslotindex;
 8016da2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016da4:	2215      	movs	r2, #21
 8016da6:	18ba      	adds	r2, r7, r2
 8016da8:	7812      	ldrb	r2, [r2, #0]
 8016daa:	759a      	strb	r2, [r3, #22]
		ho->cflag = cflag;
 8016dac:	2314      	movs	r3, #20
 8016dae:	18fb      	adds	r3, r7, r3
 8016db0:	781b      	ldrb	r3, [r3, #0]
 8016db2:	2201      	movs	r2, #1
 8016db4:	4013      	ands	r3, r2
 8016db6:	b2da      	uxtb	r2, r3
 8016db8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016dba:	2101      	movs	r1, #1
 8016dbc:	400a      	ands	r2, r1
 8016dbe:	0150      	lsls	r0, r2, #5
 8016dc0:	781a      	ldrb	r2, [r3, #0]
 8016dc2:	2120      	movs	r1, #32
 8016dc4:	438a      	bics	r2, r1
 8016dc6:	1c11      	adds	r1, r2, #0
 8016dc8:	1c02      	adds	r2, r0, #0
 8016dca:	430a      	orrs	r2, r1
 8016dcc:	701a      	strb	r2, [r3, #0]
	    } else {
		ho->old_vj = 1;
		ho->maxslotindex = MAX_STATES - 1;
		ho->cflag = 1;
	    }
	    break;
 8016dce:	e011      	b.n	8016df4 <ipcp_reqci+0x660>
		ho->old_vj = 1;
 8016dd0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016dd2:	781a      	ldrb	r2, [r3, #0]
 8016dd4:	2110      	movs	r1, #16
 8016dd6:	430a      	orrs	r2, r1
 8016dd8:	701a      	strb	r2, [r3, #0]
		ho->maxslotindex = MAX_STATES - 1;
 8016dda:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016ddc:	220f      	movs	r2, #15
 8016dde:	759a      	strb	r2, [r3, #22]
		ho->cflag = 1;
 8016de0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016de2:	781a      	ldrb	r2, [r3, #0]
 8016de4:	2120      	movs	r1, #32
 8016de6:	430a      	orrs	r2, r1
 8016de8:	701a      	strb	r2, [r3, #0]
	    break;
 8016dea:	e003      	b.n	8016df4 <ipcp_reqci+0x660>
#endif /* VJ_SUPPORT */

	default:
	    orc = CONFREJ;
 8016dec:	2304      	movs	r3, #4
 8016dee:	64bb      	str	r3, [r7, #72]	; 0x48
	    break;
 8016df0:	e000      	b.n	8016df4 <ipcp_reqci+0x660>
            break;
 8016df2:	46c0      	nop			; (mov r8, r8)
	}
endswitch:
	if (orc == CONFACK &&		/* Good CI */
 8016df4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016df6:	2b02      	cmp	r3, #2
 8016df8:	d103      	bne.n	8016e02 <ipcp_reqci+0x66e>
 8016dfa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016dfc:	2b02      	cmp	r3, #2
 8016dfe:	d000      	beq.n	8016e02 <ipcp_reqci+0x66e>
	    rc != CONFACK)		/*  but prior CI wasnt? */
	    continue;			/* Don't send this one */
 8016e00:	e02f      	b.n	8016e62 <ipcp_reqci+0x6ce>

	if (orc == CONFNAK) {		/* Nak this CI? */
 8016e02:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016e04:	2b03      	cmp	r3, #3
 8016e06:	d110      	bne.n	8016e2a <ipcp_reqci+0x696>
	    if (reject_if_disagree)	/* Getting fed up with sending NAKs? */
 8016e08:	683b      	ldr	r3, [r7, #0]
 8016e0a:	2b00      	cmp	r3, #0
 8016e0c:	d002      	beq.n	8016e14 <ipcp_reqci+0x680>
		orc = CONFREJ;		/* Get tough if so */
 8016e0e:	2304      	movs	r3, #4
 8016e10:	64bb      	str	r3, [r7, #72]	; 0x48
 8016e12:	e00a      	b.n	8016e2a <ipcp_reqci+0x696>
	    else {
		if (rc == CONFREJ)	/* Rejecting prior CI? */
 8016e14:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016e16:	2b04      	cmp	r3, #4
 8016e18:	d100      	bne.n	8016e1c <ipcp_reqci+0x688>
		    continue;		/* Don't send this one */
 8016e1a:	e022      	b.n	8016e62 <ipcp_reqci+0x6ce>
		if (rc == CONFACK) {	/* Ack'd all prior CIs? */
 8016e1c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016e1e:	2b02      	cmp	r3, #2
 8016e20:	d103      	bne.n	8016e2a <ipcp_reqci+0x696>
		    rc = CONFNAK;	/* Not anymore... */
 8016e22:	2303      	movs	r3, #3
 8016e24:	64fb      	str	r3, [r7, #76]	; 0x4c
		    ucp = inp;		/* Backup */
 8016e26:	68bb      	ldr	r3, [r7, #8]
 8016e28:	643b      	str	r3, [r7, #64]	; 0x40
		}
	    }
	}

	if (orc == CONFREJ &&		/* Reject this CI */
 8016e2a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016e2c:	2b04      	cmp	r3, #4
 8016e2e:	d106      	bne.n	8016e3e <ipcp_reqci+0x6aa>
 8016e30:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016e32:	2b04      	cmp	r3, #4
 8016e34:	d003      	beq.n	8016e3e <ipcp_reqci+0x6aa>
	    rc != CONFREJ) {		/*  but no prior ones? */
	    rc = CONFREJ;
 8016e36:	2304      	movs	r3, #4
 8016e38:	64fb      	str	r3, [r7, #76]	; 0x4c
	    ucp = inp;			/* Backup */
 8016e3a:	68bb      	ldr	r3, [r7, #8]
 8016e3c:	643b      	str	r3, [r7, #64]	; 0x40
	}

	/* Need to move CI? */
	if (ucp != cip)
 8016e3e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8016e40:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016e42:	429a      	cmp	r2, r3
 8016e44:	d007      	beq.n	8016e56 <ipcp_reqci+0x6c2>
	    MEMCPY(ucp, cip, cilen);	/* Move it */
 8016e46:	2352      	movs	r3, #82	; 0x52
 8016e48:	18fb      	adds	r3, r7, r3
 8016e4a:	881a      	ldrh	r2, [r3, #0]
 8016e4c:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8016e4e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016e50:	0018      	movs	r0, r3
 8016e52:	f005 fccf 	bl	801c7f4 <memcpy>

	/* Update output pointer */
	INCPTR(cilen, ucp);
 8016e56:	2352      	movs	r3, #82	; 0x52
 8016e58:	18fb      	adds	r3, r7, r3
 8016e5a:	881b      	ldrh	r3, [r3, #0]
 8016e5c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8016e5e:	18d3      	adds	r3, r2, r3
 8016e60:	643b      	str	r3, [r7, #64]	; 0x40
    while (l) {
 8016e62:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016e64:	2b00      	cmp	r3, #0
 8016e66:	d000      	beq.n	8016e6a <ipcp_reqci+0x6d6>
 8016e68:	e4bd      	b.n	80167e6 <ipcp_reqci+0x52>
     * their address, and they didn't send their address, then we
     * send a NAK with a CI_ADDR option appended.  We assume the
     * input buffer is long enough that we can append the extra
     * option safely.
     */
    if (rc != CONFREJ && !ho->neg_addr && !ho->old_addrs &&
 8016e6a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016e6c:	2b04      	cmp	r3, #4
 8016e6e:	d056      	beq.n	8016f1e <ipcp_reqci+0x78a>
 8016e70:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016e72:	781b      	ldrb	r3, [r3, #0]
 8016e74:	2201      	movs	r2, #1
 8016e76:	4013      	ands	r3, r2
 8016e78:	b2db      	uxtb	r3, r3
 8016e7a:	2b00      	cmp	r3, #0
 8016e7c:	d14f      	bne.n	8016f1e <ipcp_reqci+0x78a>
 8016e7e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016e80:	781b      	ldrb	r3, [r3, #0]
 8016e82:	2202      	movs	r2, #2
 8016e84:	4013      	ands	r3, r2
 8016e86:	b2db      	uxtb	r3, r3
 8016e88:	2b00      	cmp	r3, #0
 8016e8a:	d148      	bne.n	8016f1e <ipcp_reqci+0x78a>
 8016e8c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016e8e:	781b      	ldrb	r3, [r3, #0]
 8016e90:	2204      	movs	r2, #4
 8016e92:	4013      	ands	r3, r2
 8016e94:	b2db      	uxtb	r3, r3
 8016e96:	2b00      	cmp	r3, #0
 8016e98:	d041      	beq.n	8016f1e <ipcp_reqci+0x78a>
	wo->req_addr && !reject_if_disagree && !pcb->settings.noremoteip) {
 8016e9a:	683b      	ldr	r3, [r7, #0]
 8016e9c:	2b00      	cmp	r3, #0
 8016e9e:	d13e      	bne.n	8016f1e <ipcp_reqci+0x78a>
 8016ea0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016ea2:	781b      	ldrb	r3, [r3, #0]
 8016ea4:	2204      	movs	r2, #4
 8016ea6:	4013      	ands	r3, r2
 8016ea8:	b2db      	uxtb	r3, r3
 8016eaa:	2b00      	cmp	r3, #0
 8016eac:	d137      	bne.n	8016f1e <ipcp_reqci+0x78a>
	if (rc == CONFACK) {
 8016eae:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8016eb0:	2b02      	cmp	r3, #2
 8016eb2:	d108      	bne.n	8016ec6 <ipcp_reqci+0x732>
	    rc = CONFNAK;
 8016eb4:	2303      	movs	r3, #3
 8016eb6:	64fb      	str	r3, [r7, #76]	; 0x4c
	    ucp = inp;			/* reset pointer */
 8016eb8:	68bb      	ldr	r3, [r7, #8]
 8016eba:	643b      	str	r3, [r7, #64]	; 0x40
	    wo->req_addr = 0;		/* don't ask again */
 8016ebc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016ebe:	781a      	ldrb	r2, [r3, #0]
 8016ec0:	2104      	movs	r1, #4
 8016ec2:	438a      	bics	r2, r1
 8016ec4:	701a      	strb	r2, [r3, #0]
	}
	PUTCHAR(CI_ADDR, ucp);
 8016ec6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016ec8:	1c5a      	adds	r2, r3, #1
 8016eca:	643a      	str	r2, [r7, #64]	; 0x40
 8016ecc:	2203      	movs	r2, #3
 8016ece:	701a      	strb	r2, [r3, #0]
	PUTCHAR(CILEN_ADDR, ucp);
 8016ed0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016ed2:	1c5a      	adds	r2, r3, #1
 8016ed4:	643a      	str	r2, [r7, #64]	; 0x40
 8016ed6:	2206      	movs	r2, #6
 8016ed8:	701a      	strb	r2, [r3, #0]
	tl = lwip_ntohl(wo->hisaddr);
 8016eda:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016edc:	689b      	ldr	r3, [r3, #8]
 8016ede:	0018      	movs	r0, r3
 8016ee0:	f7ef fb3e 	bl	8006560 <lwip_htonl>
 8016ee4:	0003      	movs	r3, r0
 8016ee6:	62bb      	str	r3, [r7, #40]	; 0x28
	PUTLONG(tl, ucp);
 8016ee8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016eea:	0e19      	lsrs	r1, r3, #24
 8016eec:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016eee:	1c5a      	adds	r2, r3, #1
 8016ef0:	643a      	str	r2, [r7, #64]	; 0x40
 8016ef2:	b2ca      	uxtb	r2, r1
 8016ef4:	701a      	strb	r2, [r3, #0]
 8016ef6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016ef8:	0c19      	lsrs	r1, r3, #16
 8016efa:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016efc:	1c5a      	adds	r2, r3, #1
 8016efe:	643a      	str	r2, [r7, #64]	; 0x40
 8016f00:	b2ca      	uxtb	r2, r1
 8016f02:	701a      	strb	r2, [r3, #0]
 8016f04:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016f06:	0a19      	lsrs	r1, r3, #8
 8016f08:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016f0a:	1c5a      	adds	r2, r3, #1
 8016f0c:	643a      	str	r2, [r7, #64]	; 0x40
 8016f0e:	b2ca      	uxtb	r2, r1
 8016f10:	701a      	strb	r2, [r3, #0]
 8016f12:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016f14:	1c5a      	adds	r2, r3, #1
 8016f16:	643a      	str	r2, [r7, #64]	; 0x40
 8016f18:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016f1a:	b2d2      	uxtb	r2, r2
 8016f1c:	701a      	strb	r2, [r3, #0]
    }

    *len = ucp - inp;			/* Compute output length */
 8016f1e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8016f20:	68bb      	ldr	r3, [r7, #8]
 8016f22:	1ad2      	subs	r2, r2, r3
 8016f24:	687b      	ldr	r3, [r7, #4]
 8016f26:	601a      	str	r2, [r3, #0]
    IPCPDEBUG(("ipcp: returning Configure-%s", CODENAME(rc)));
    return (rc);			/* Return final code */
 8016f28:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
}
 8016f2a:	0018      	movs	r0, r3
 8016f2c:	46bd      	mov	sp, r7
 8016f2e:	b016      	add	sp, #88	; 0x58
 8016f30:	bd80      	pop	{r7, pc}
 8016f32:	46c0      	nop			; (mov r8, r8)

08016f34 <ipcp_up>:
/*
 * ipcp_up - IPCP has come UP.
 *
 * Configure the IP network interface appropriately and bring it up.
 */
static void ipcp_up(fsm *f) {
 8016f34:	b580      	push	{r7, lr}
 8016f36:	b088      	sub	sp, #32
 8016f38:	af00      	add	r7, sp, #0
 8016f3a:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8016f3c:	687b      	ldr	r3, [r7, #4]
 8016f3e:	681b      	ldr	r3, [r3, #0]
 8016f40:	61fb      	str	r3, [r7, #28]
    u32_t mask;
    ipcp_options *ho = &pcb->ipcp_hisoptions;
 8016f42:	69fb      	ldr	r3, [r7, #28]
 8016f44:	4a9e      	ldr	r2, [pc, #632]	; (80171c0 <ipcp_up+0x28c>)
 8016f46:	4694      	mov	ip, r2
 8016f48:	4463      	add	r3, ip
 8016f4a:	61bb      	str	r3, [r7, #24]
    ipcp_options *go = &pcb->ipcp_gotoptions;
 8016f4c:	69fb      	ldr	r3, [r7, #28]
 8016f4e:	4a9d      	ldr	r2, [pc, #628]	; (80171c4 <ipcp_up+0x290>)
 8016f50:	4694      	mov	ip, r2
 8016f52:	4463      	add	r3, ip
 8016f54:	617b      	str	r3, [r7, #20]
    ipcp_options *wo = &pcb->ipcp_wantoptions;
 8016f56:	69fb      	ldr	r3, [r7, #28]
 8016f58:	4a9b      	ldr	r2, [pc, #620]	; (80171c8 <ipcp_up+0x294>)
 8016f5a:	4694      	mov	ip, r2
 8016f5c:	4463      	add	r3, ip
 8016f5e:	613b      	str	r3, [r7, #16]
    IPCPDEBUG(("ipcp: up"));

    /*
     * We must have a non-zero IP address for both ends of the link.
     */
    if (!ho->neg_addr && !ho->old_addrs)
 8016f60:	69bb      	ldr	r3, [r7, #24]
 8016f62:	781b      	ldrb	r3, [r3, #0]
 8016f64:	2201      	movs	r2, #1
 8016f66:	4013      	ands	r3, r2
 8016f68:	b2db      	uxtb	r3, r3
 8016f6a:	2b00      	cmp	r3, #0
 8016f6c:	d10a      	bne.n	8016f84 <ipcp_up+0x50>
 8016f6e:	69bb      	ldr	r3, [r7, #24]
 8016f70:	781b      	ldrb	r3, [r3, #0]
 8016f72:	2202      	movs	r2, #2
 8016f74:	4013      	ands	r3, r2
 8016f76:	b2db      	uxtb	r3, r3
 8016f78:	2b00      	cmp	r3, #0
 8016f7a:	d103      	bne.n	8016f84 <ipcp_up+0x50>
	ho->hisaddr = wo->hisaddr;
 8016f7c:	693b      	ldr	r3, [r7, #16]
 8016f7e:	689a      	ldr	r2, [r3, #8]
 8016f80:	69bb      	ldr	r3, [r7, #24]
 8016f82:	609a      	str	r2, [r3, #8]

    if (!(go->neg_addr || go->old_addrs) && (wo->neg_addr || wo->old_addrs)
 8016f84:	697b      	ldr	r3, [r7, #20]
 8016f86:	781b      	ldrb	r3, [r3, #0]
 8016f88:	2201      	movs	r2, #1
 8016f8a:	4013      	ands	r3, r2
 8016f8c:	b2db      	uxtb	r3, r3
 8016f8e:	2b00      	cmp	r3, #0
 8016f90:	d124      	bne.n	8016fdc <ipcp_up+0xa8>
 8016f92:	697b      	ldr	r3, [r7, #20]
 8016f94:	781b      	ldrb	r3, [r3, #0]
 8016f96:	2202      	movs	r2, #2
 8016f98:	4013      	ands	r3, r2
 8016f9a:	b2db      	uxtb	r3, r3
 8016f9c:	2b00      	cmp	r3, #0
 8016f9e:	d11d      	bne.n	8016fdc <ipcp_up+0xa8>
 8016fa0:	693b      	ldr	r3, [r7, #16]
 8016fa2:	781b      	ldrb	r3, [r3, #0]
 8016fa4:	2201      	movs	r2, #1
 8016fa6:	4013      	ands	r3, r2
 8016fa8:	b2db      	uxtb	r3, r3
 8016faa:	2b00      	cmp	r3, #0
 8016fac:	d106      	bne.n	8016fbc <ipcp_up+0x88>
 8016fae:	693b      	ldr	r3, [r7, #16]
 8016fb0:	781b      	ldrb	r3, [r3, #0]
 8016fb2:	2202      	movs	r2, #2
 8016fb4:	4013      	ands	r3, r2
 8016fb6:	b2db      	uxtb	r3, r3
 8016fb8:	2b00      	cmp	r3, #0
 8016fba:	d00f      	beq.n	8016fdc <ipcp_up+0xa8>
	&& wo->ouraddr != 0) {
 8016fbc:	693b      	ldr	r3, [r7, #16]
 8016fbe:	685b      	ldr	r3, [r3, #4]
 8016fc0:	2b00      	cmp	r3, #0
 8016fc2:	d00b      	beq.n	8016fdc <ipcp_up+0xa8>
	ppp_error("Peer refused to agree to our IP address");
 8016fc4:	4b81      	ldr	r3, [pc, #516]	; (80171cc <ipcp_up+0x298>)
 8016fc6:	0018      	movs	r0, r3
 8016fc8:	f004 f8b5 	bl	801b136 <ppp_error>
	ipcp_close(f->pcb, "Refused our IP address");
 8016fcc:	687b      	ldr	r3, [r7, #4]
 8016fce:	681b      	ldr	r3, [r3, #0]
 8016fd0:	4a7f      	ldr	r2, [pc, #508]	; (80171d0 <ipcp_up+0x29c>)
 8016fd2:	0011      	movs	r1, r2
 8016fd4:	0018      	movs	r0, r3
 8016fd6:	f7fd ff4d 	bl	8014e74 <ipcp_close>
	return;
 8016fda:	e0ed      	b.n	80171b8 <ipcp_up+0x284>
    }
    if (go->ouraddr == 0) {
 8016fdc:	697b      	ldr	r3, [r7, #20]
 8016fde:	685b      	ldr	r3, [r3, #4]
 8016fe0:	2b00      	cmp	r3, #0
 8016fe2:	d10b      	bne.n	8016ffc <ipcp_up+0xc8>
	ppp_error("Could not determine local IP address");
 8016fe4:	4b7b      	ldr	r3, [pc, #492]	; (80171d4 <ipcp_up+0x2a0>)
 8016fe6:	0018      	movs	r0, r3
 8016fe8:	f004 f8a5 	bl	801b136 <ppp_error>
	ipcp_close(f->pcb, "Could not determine local IP address");
 8016fec:	687b      	ldr	r3, [r7, #4]
 8016fee:	681b      	ldr	r3, [r3, #0]
 8016ff0:	4a78      	ldr	r2, [pc, #480]	; (80171d4 <ipcp_up+0x2a0>)
 8016ff2:	0011      	movs	r1, r2
 8016ff4:	0018      	movs	r0, r3
 8016ff6:	f7fd ff3d 	bl	8014e74 <ipcp_close>
	return;
 8016ffa:	e0dd      	b.n	80171b8 <ipcp_up+0x284>
    }
    if (ho->hisaddr == 0 && !pcb->settings.noremoteip) {
 8016ffc:	69bb      	ldr	r3, [r7, #24]
 8016ffe:	689b      	ldr	r3, [r3, #8]
 8017000:	2b00      	cmp	r3, #0
 8017002:	d114      	bne.n	801702e <ipcp_up+0xfa>
 8017004:	69fb      	ldr	r3, [r7, #28]
 8017006:	781b      	ldrb	r3, [r3, #0]
 8017008:	2204      	movs	r2, #4
 801700a:	4013      	ands	r3, r2
 801700c:	b2db      	uxtb	r3, r3
 801700e:	2b00      	cmp	r3, #0
 8017010:	d10d      	bne.n	801702e <ipcp_up+0xfa>
	ho->hisaddr = lwip_htonl(0x0a404040);
 8017012:	4b71      	ldr	r3, [pc, #452]	; (80171d8 <ipcp_up+0x2a4>)
 8017014:	0018      	movs	r0, r3
 8017016:	f7ef faa3 	bl	8006560 <lwip_htonl>
 801701a:	0002      	movs	r2, r0
 801701c:	69bb      	ldr	r3, [r7, #24]
 801701e:	609a      	str	r2, [r3, #8]
	ppp_warn("Could not determine remote IP address: defaulting to %I",
 8017020:	69bb      	ldr	r3, [r7, #24]
 8017022:	689a      	ldr	r2, [r3, #8]
 8017024:	4b6d      	ldr	r3, [pc, #436]	; (80171dc <ipcp_up+0x2a8>)
 8017026:	0011      	movs	r1, r2
 8017028:	0018      	movs	r0, r3
 801702a:	f004 f898 	bl	801b15e <ppp_warn>
    if (ho->hisaddr != 0)
	script_setenv("IPREMOTE", ip_ntoa(ho->hisaddr), 1);
#endif /* UNUSED */

#if LWIP_DNS
    if (!go->req_dns1)
 801702e:	697b      	ldr	r3, [r7, #20]
 8017030:	785b      	ldrb	r3, [r3, #1]
 8017032:	2201      	movs	r2, #1
 8017034:	4013      	ands	r3, r2
 8017036:	b2db      	uxtb	r3, r3
 8017038:	2b00      	cmp	r3, #0
 801703a:	d102      	bne.n	8017042 <ipcp_up+0x10e>
	    go->dnsaddr[0] = 0;
 801703c:	697b      	ldr	r3, [r7, #20]
 801703e:	2200      	movs	r2, #0
 8017040:	60da      	str	r2, [r3, #12]
    if (!go->req_dns2)
 8017042:	697b      	ldr	r3, [r7, #20]
 8017044:	785b      	ldrb	r3, [r3, #1]
 8017046:	2202      	movs	r2, #2
 8017048:	4013      	ands	r3, r2
 801704a:	b2db      	uxtb	r3, r3
 801704c:	2b00      	cmp	r3, #0
 801704e:	d102      	bne.n	8017056 <ipcp_up+0x122>
	    go->dnsaddr[1] = 0;
 8017050:	697b      	ldr	r3, [r7, #20]
 8017052:	2200      	movs	r2, #0
 8017054:	611a      	str	r2, [r3, #16]
    if (go->dnsaddr[0])
	script_setenv("DNS1", ip_ntoa(go->dnsaddr[0]), 0);
    if (go->dnsaddr[1])
	script_setenv("DNS2", ip_ntoa(go->dnsaddr[1]), 0);
#endif /* UNUSED */
    if (pcb->settings.usepeerdns && (go->dnsaddr[0] || go->dnsaddr[1])) {
 8017056:	69fb      	ldr	r3, [r7, #28]
 8017058:	781b      	ldrb	r3, [r3, #0]
 801705a:	2201      	movs	r2, #1
 801705c:	4013      	ands	r3, r2
 801705e:	b2db      	uxtb	r3, r3
 8017060:	2b00      	cmp	r3, #0
 8017062:	d00f      	beq.n	8017084 <ipcp_up+0x150>
 8017064:	697b      	ldr	r3, [r7, #20]
 8017066:	68db      	ldr	r3, [r3, #12]
 8017068:	2b00      	cmp	r3, #0
 801706a:	d103      	bne.n	8017074 <ipcp_up+0x140>
 801706c:	697b      	ldr	r3, [r7, #20]
 801706e:	691b      	ldr	r3, [r3, #16]
 8017070:	2b00      	cmp	r3, #0
 8017072:	d007      	beq.n	8017084 <ipcp_up+0x150>
	sdns(pcb, go->dnsaddr[0], go->dnsaddr[1]);
 8017074:	697b      	ldr	r3, [r7, #20]
 8017076:	68d9      	ldr	r1, [r3, #12]
 8017078:	697b      	ldr	r3, [r7, #20]
 801707a:	691a      	ldr	r2, [r3, #16]
 801707c:	69fb      	ldr	r3, [r7, #28]
 801707e:	0018      	movs	r0, r3
 8017080:	f002 fe36 	bl	8019cf0 <sdns>
#endif /* LWIP_DNS */

    /*
     * Check that the peer is allowed to use the IP address it wants.
     */
    if (ho->hisaddr != 0) {
 8017084:	69bb      	ldr	r3, [r7, #24]
 8017086:	689b      	ldr	r3, [r3, #8]
 8017088:	2b00      	cmp	r3, #0
 801708a:	d026      	beq.n	80170da <ipcp_up+0x1a6>
	u32_t addr = lwip_ntohl(ho->hisaddr);
 801708c:	69bb      	ldr	r3, [r7, #24]
 801708e:	689b      	ldr	r3, [r3, #8]
 8017090:	0018      	movs	r0, r3
 8017092:	f7ef fa65 	bl	8006560 <lwip_htonl>
 8017096:	0003      	movs	r3, r0
 8017098:	60fb      	str	r3, [r7, #12]
	if ((addr >> IP_CLASSA_NSHIFT) == IP_LOOPBACKNET
 801709a:	68fb      	ldr	r3, [r7, #12]
 801709c:	0e1b      	lsrs	r3, r3, #24
 801709e:	2b7f      	cmp	r3, #127	; 0x7f
 80170a0:	d00d      	beq.n	80170be <ipcp_up+0x18a>
	    || IP_MULTICAST(addr) || IP_BADCLASS(addr)
 80170a2:	68fb      	ldr	r3, [r7, #12]
 80170a4:	0f1b      	lsrs	r3, r3, #28
 80170a6:	071a      	lsls	r2, r3, #28
 80170a8:	23e0      	movs	r3, #224	; 0xe0
 80170aa:	061b      	lsls	r3, r3, #24
 80170ac:	429a      	cmp	r2, r3
 80170ae:	d006      	beq.n	80170be <ipcp_up+0x18a>
 80170b0:	68fb      	ldr	r3, [r7, #12]
 80170b2:	0f1b      	lsrs	r3, r3, #28
 80170b4:	071a      	lsls	r2, r3, #28
 80170b6:	23f0      	movs	r3, #240	; 0xf0
 80170b8:	061b      	lsls	r3, r3, #24
 80170ba:	429a      	cmp	r2, r3
 80170bc:	d10d      	bne.n	80170da <ipcp_up+0x1a6>
	     */
#if PPP_SERVER && PPP_AUTH_SUPPORT
	    || (pcb->settings.auth_required && wo->hisaddr != ho->hisaddr)
#endif /* PPP_SERVER && PPP_AUTH_SUPPORT */
	    ) {
		ppp_error("Peer is not authorized to use remote address %I", ho->hisaddr);
 80170be:	69bb      	ldr	r3, [r7, #24]
 80170c0:	689a      	ldr	r2, [r3, #8]
 80170c2:	4b47      	ldr	r3, [pc, #284]	; (80171e0 <ipcp_up+0x2ac>)
 80170c4:	0011      	movs	r1, r2
 80170c6:	0018      	movs	r0, r3
 80170c8:	f004 f835 	bl	801b136 <ppp_error>
		ipcp_close(pcb, "Unauthorized remote IP address");
 80170cc:	4a45      	ldr	r2, [pc, #276]	; (80171e4 <ipcp_up+0x2b0>)
 80170ce:	69fb      	ldr	r3, [r7, #28]
 80170d0:	0011      	movs	r1, r2
 80170d2:	0018      	movs	r0, r3
 80170d4:	f7fd fece 	bl	8014e74 <ipcp_close>
		return;
 80170d8:	e06e      	b.n	80171b8 <ipcp_up+0x284>
    }
#endif /* Unused */

#if VJ_SUPPORT
    /* set tcp compression */
    sifvjcomp(pcb, ho->neg_vj, ho->cflag, ho->maxslotindex);
 80170da:	69bb      	ldr	r3, [r7, #24]
 80170dc:	781b      	ldrb	r3, [r3, #0]
 80170de:	071b      	lsls	r3, r3, #28
 80170e0:	0fdb      	lsrs	r3, r3, #31
 80170e2:	b2db      	uxtb	r3, r3
 80170e4:	0019      	movs	r1, r3
 80170e6:	69bb      	ldr	r3, [r7, #24]
 80170e8:	781b      	ldrb	r3, [r3, #0]
 80170ea:	069b      	lsls	r3, r3, #26
 80170ec:	0fdb      	lsrs	r3, r3, #31
 80170ee:	b2db      	uxtb	r3, r3
 80170f0:	001a      	movs	r2, r3
 80170f2:	69bb      	ldr	r3, [r7, #24]
 80170f4:	7d9b      	ldrb	r3, [r3, #22]
 80170f6:	69f8      	ldr	r0, [r7, #28]
 80170f8:	f002 fe44 	bl	8019d84 <sifvjcomp>
#endif /* DEMAND_SUPPORT */
    {
	/*
	 * Set IP addresses and (if specified) netmask.
	 */
	mask = get_mask(go->ouraddr);
 80170fc:	697b      	ldr	r3, [r7, #20]
 80170fe:	685b      	ldr	r3, [r3, #4]
 8017100:	0018      	movs	r0, r3
 8017102:	f002 fe9d 	bl	8019e40 <get_mask>
 8017106:	0003      	movs	r3, r0
 8017108:	60bb      	str	r3, [r7, #8]

#if !(defined(SVR4) && (defined(SNI) || defined(__USLC__)))
	if (!sifaddr(pcb, go->ouraddr, ho->hisaddr, mask)) {
 801710a:	697b      	ldr	r3, [r7, #20]
 801710c:	6859      	ldr	r1, [r3, #4]
 801710e:	69bb      	ldr	r3, [r7, #24]
 8017110:	689a      	ldr	r2, [r3, #8]
 8017112:	68bb      	ldr	r3, [r7, #8]
 8017114:	69f8      	ldr	r0, [r7, #28]
 8017116:	f002 fdb9 	bl	8019c8c <sifaddr>
 801711a:	1e03      	subs	r3, r0, #0
 801711c:	d107      	bne.n	801712e <ipcp_up+0x1fa>
#if PPP_DEBUG
	    ppp_warn("Interface configuration failed");
#endif /* PPP_DEBUG */
	    ipcp_close(f->pcb, "Interface configuration failed");
 801711e:	687b      	ldr	r3, [r7, #4]
 8017120:	681b      	ldr	r3, [r3, #0]
 8017122:	4a31      	ldr	r2, [pc, #196]	; (80171e8 <ipcp_up+0x2b4>)
 8017124:	0011      	movs	r1, r2
 8017126:	0018      	movs	r0, r3
 8017128:	f7fd fea4 	bl	8014e74 <ipcp_close>
	    return;
 801712c:	e044      	b.n	80171b8 <ipcp_up+0x284>
	}
#endif

	/* bring the interface up for IP */
	if (!sifup(pcb)) {
 801712e:	69fb      	ldr	r3, [r7, #28]
 8017130:	0018      	movs	r0, r3
 8017132:	f002 fe4e 	bl	8019dd2 <sifup>
 8017136:	1e03      	subs	r3, r0, #0
 8017138:	d107      	bne.n	801714a <ipcp_up+0x216>
#if PPP_DEBUG
	    ppp_warn("Interface failed to come up");
#endif /* PPP_DEBUG */
	    ipcp_close(f->pcb, "Interface configuration failed");
 801713a:	687b      	ldr	r3, [r7, #4]
 801713c:	681b      	ldr	r3, [r3, #0]
 801713e:	4a2a      	ldr	r2, [pc, #168]	; (80171e8 <ipcp_up+0x2b4>)
 8017140:	0011      	movs	r1, r2
 8017142:	0018      	movs	r0, r3
 8017144:	f7fd fe96 	bl	8014e74 <ipcp_close>
	    return;
 8017148:	e036      	b.n	80171b8 <ipcp_up+0x284>
	if (ho->hisaddr != 0 && wo->proxy_arp)
	    if (sifproxyarp(pcb, ho->hisaddr))
		pcb->proxy_arp_set = 1;
#endif /* UNUSED - PROXY ARP */

	wo->ouraddr = go->ouraddr;
 801714a:	697b      	ldr	r3, [r7, #20]
 801714c:	685a      	ldr	r2, [r3, #4]
 801714e:	693b      	ldr	r3, [r7, #16]
 8017150:	605a      	str	r2, [r3, #4]

	ppp_notice("local  IP address %I", go->ouraddr);
 8017152:	697b      	ldr	r3, [r7, #20]
 8017154:	685a      	ldr	r2, [r3, #4]
 8017156:	4b25      	ldr	r3, [pc, #148]	; (80171ec <ipcp_up+0x2b8>)
 8017158:	0011      	movs	r1, r2
 801715a:	0018      	movs	r0, r3
 801715c:	f004 f813 	bl	801b186 <ppp_notice>
	if (ho->hisaddr != 0)
 8017160:	69bb      	ldr	r3, [r7, #24]
 8017162:	689b      	ldr	r3, [r3, #8]
 8017164:	2b00      	cmp	r3, #0
 8017166:	d006      	beq.n	8017176 <ipcp_up+0x242>
	    ppp_notice("remote IP address %I", ho->hisaddr);
 8017168:	69bb      	ldr	r3, [r7, #24]
 801716a:	689a      	ldr	r2, [r3, #8]
 801716c:	4b20      	ldr	r3, [pc, #128]	; (80171f0 <ipcp_up+0x2bc>)
 801716e:	0011      	movs	r1, r2
 8017170:	0018      	movs	r0, r3
 8017172:	f004 f808 	bl	801b186 <ppp_notice>
#if LWIP_DNS
	if (go->dnsaddr[0])
 8017176:	697b      	ldr	r3, [r7, #20]
 8017178:	68db      	ldr	r3, [r3, #12]
 801717a:	2b00      	cmp	r3, #0
 801717c:	d006      	beq.n	801718c <ipcp_up+0x258>
	    ppp_notice("primary   DNS address %I", go->dnsaddr[0]);
 801717e:	697b      	ldr	r3, [r7, #20]
 8017180:	68da      	ldr	r2, [r3, #12]
 8017182:	4b1c      	ldr	r3, [pc, #112]	; (80171f4 <ipcp_up+0x2c0>)
 8017184:	0011      	movs	r1, r2
 8017186:	0018      	movs	r0, r3
 8017188:	f003 fffd 	bl	801b186 <ppp_notice>
	if (go->dnsaddr[1])
 801718c:	697b      	ldr	r3, [r7, #20]
 801718e:	691b      	ldr	r3, [r3, #16]
 8017190:	2b00      	cmp	r3, #0
 8017192:	d006      	beq.n	80171a2 <ipcp_up+0x26e>
	    ppp_notice("secondary DNS address %I", go->dnsaddr[1]);
 8017194:	697b      	ldr	r3, [r7, #20]
 8017196:	691a      	ldr	r2, [r3, #16]
 8017198:	4b17      	ldr	r3, [pc, #92]	; (80171f8 <ipcp_up+0x2c4>)
 801719a:	0011      	movs	r1, r2
 801719c:	0018      	movs	r0, r3
 801719e:	f003 fff2 	bl	801b186 <ppp_notice>

#if PPP_STATS_SUPPORT
    reset_link_stats(f->unit);
#endif /* PPP_STATS_SUPPORT */

    np_up(pcb, PPP_IP);
 80171a2:	69fb      	ldr	r3, [r7, #28]
 80171a4:	2121      	movs	r1, #33	; 0x21
 80171a6:	0018      	movs	r0, r3
 80171a8:	f7fc fdda 	bl	8013d60 <np_up>
    pcb->ipcp_is_up = 1;
 80171ac:	69fb      	ldr	r3, [r7, #28]
 80171ae:	2226      	movs	r2, #38	; 0x26
 80171b0:	5c99      	ldrb	r1, [r3, r2]
 80171b2:	2004      	movs	r0, #4
 80171b4:	4301      	orrs	r1, r0
 80171b6:	5499      	strb	r1, [r3, r2]
#endif /* PPP_NOTIFY */
#if 0 /* UNUSED */
    if (ip_up_hook)
	ip_up_hook();
#endif /* UNUSED */
}
 80171b8:	46bd      	mov	sp, r7
 80171ba:	b008      	add	sp, #32
 80171bc:	bd80      	pop	{r7, pc}
 80171be:	46c0      	nop			; (mov r8, r8)
 80171c0:	0000124c 	.word	0x0000124c
 80171c4:	0000121c 	.word	0x0000121c
 80171c8:	00001204 	.word	0x00001204
 80171cc:	08020f54 	.word	0x08020f54
 80171d0:	08020f7c 	.word	0x08020f7c
 80171d4:	08020f94 	.word	0x08020f94
 80171d8:	0a404040 	.word	0x0a404040
 80171dc:	08020fbc 	.word	0x08020fbc
 80171e0:	08020ff4 	.word	0x08020ff4
 80171e4:	08021024 	.word	0x08021024
 80171e8:	08021044 	.word	0x08021044
 80171ec:	08021064 	.word	0x08021064
 80171f0:	0802107c 	.word	0x0802107c
 80171f4:	08021094 	.word	0x08021094
 80171f8:	080210b0 	.word	0x080210b0

080171fc <ipcp_down>:
 * ipcp_down - IPCP has gone DOWN.
 *
 * Take the IP network interface down, clear its addresses
 * and delete routes through it.
 */
static void ipcp_down(fsm *f) {
 80171fc:	b580      	push	{r7, lr}
 80171fe:	b086      	sub	sp, #24
 8017200:	af00      	add	r7, sp, #0
 8017202:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8017204:	687b      	ldr	r3, [r7, #4]
 8017206:	681b      	ldr	r3, [r3, #0]
 8017208:	617b      	str	r3, [r7, #20]
    ipcp_options *ho = &pcb->ipcp_hisoptions;
 801720a:	697b      	ldr	r3, [r7, #20]
 801720c:	4a1c      	ldr	r2, [pc, #112]	; (8017280 <ipcp_down+0x84>)
 801720e:	4694      	mov	ip, r2
 8017210:	4463      	add	r3, ip
 8017212:	613b      	str	r3, [r7, #16]
    ipcp_options *go = &pcb->ipcp_gotoptions;
 8017214:	697b      	ldr	r3, [r7, #20]
 8017216:	4a1b      	ldr	r2, [pc, #108]	; (8017284 <ipcp_down+0x88>)
 8017218:	4694      	mov	ip, r2
 801721a:	4463      	add	r3, ip
 801721c:	60fb      	str	r3, [r7, #12]
#endif /* PPP_NOTIFY */
#if 0 /* UNUSED */
    if (ip_down_hook)
	ip_down_hook();
#endif /* UNUSED */
    if (pcb->ipcp_is_up) {
 801721e:	697b      	ldr	r3, [r7, #20]
 8017220:	2226      	movs	r2, #38	; 0x26
 8017222:	5c9b      	ldrb	r3, [r3, r2]
 8017224:	2204      	movs	r2, #4
 8017226:	4013      	ands	r3, r2
 8017228:	b2db      	uxtb	r3, r3
 801722a:	2b00      	cmp	r3, #0
 801722c:	d00a      	beq.n	8017244 <ipcp_down+0x48>
	pcb->ipcp_is_up = 0;
 801722e:	697b      	ldr	r3, [r7, #20]
 8017230:	2226      	movs	r2, #38	; 0x26
 8017232:	5c99      	ldrb	r1, [r3, r2]
 8017234:	2004      	movs	r0, #4
 8017236:	4381      	bics	r1, r0
 8017238:	5499      	strb	r1, [r3, r2]
	np_down(pcb, PPP_IP);
 801723a:	697b      	ldr	r3, [r7, #20]
 801723c:	2121      	movs	r1, #33	; 0x21
 801723e:	0018      	movs	r0, r3
 8017240:	f7fc fda9 	bl	8013d96 <np_down>
    }
#if VJ_SUPPORT
    sifvjcomp(pcb, 0, 0, 0);
 8017244:	6978      	ldr	r0, [r7, #20]
 8017246:	2300      	movs	r3, #0
 8017248:	2200      	movs	r2, #0
 801724a:	2100      	movs	r1, #0
 801724c:	f002 fd9a 	bl	8019d84 <sifvjcomp>
#endif /* DEMAND_SUPPORT */
    {
#if DEMAND_SUPPORT
	sifnpmode(pcb, PPP_IP, NPMODE_DROP);
#endif /* DEMAND_SUPPORT */
	sifdown(pcb);
 8017250:	697b      	ldr	r3, [r7, #20]
 8017252:	0018      	movs	r0, r3
 8017254:	f002 fde0 	bl	8019e18 <sifdown>
	ipcp_clear_addrs(pcb, go->ouraddr,
 8017258:	68fb      	ldr	r3, [r7, #12]
 801725a:	6859      	ldr	r1, [r3, #4]
 801725c:	693b      	ldr	r3, [r7, #16]
 801725e:	689a      	ldr	r2, [r3, #8]
 8017260:	6978      	ldr	r0, [r7, #20]
 8017262:	2300      	movs	r3, #0
 8017264:	f000 f810 	bl	8017288 <ipcp_clear_addrs>
			 ho->hisaddr, 0);
#if LWIP_DNS
	cdns(pcb, go->dnsaddr[0], go->dnsaddr[1]);
 8017268:	68fb      	ldr	r3, [r7, #12]
 801726a:	68d9      	ldr	r1, [r3, #12]
 801726c:	68fb      	ldr	r3, [r7, #12]
 801726e:	691a      	ldr	r2, [r3, #16]
 8017270:	697b      	ldr	r3, [r7, #20]
 8017272:	0018      	movs	r0, r3
 8017274:	f002 fd56 	bl	8019d24 <cdns>
#endif /* LWIP_DNS */
    }
}
 8017278:	46c0      	nop			; (mov r8, r8)
 801727a:	46bd      	mov	sp, r7
 801727c:	b006      	add	sp, #24
 801727e:	bd80      	pop	{r7, pc}
 8017280:	0000124c 	.word	0x0000124c
 8017284:	0000121c 	.word	0x0000121c

08017288 <ipcp_clear_addrs>:

/*
 * ipcp_clear_addrs() - clear the interface addresses, routes,
 * proxy arp entries, etc.
 */
static void ipcp_clear_addrs(ppp_pcb *pcb, u32_t ouraddr, u32_t hisaddr, u8_t replacedefaultroute) {
 8017288:	b580      	push	{r7, lr}
 801728a:	b084      	sub	sp, #16
 801728c:	af00      	add	r7, sp, #0
 801728e:	60f8      	str	r0, [r7, #12]
 8017290:	60b9      	str	r1, [r7, #8]
 8017292:	607a      	str	r2, [r7, #4]
 8017294:	001a      	movs	r2, r3
 8017296:	1cfb      	adds	r3, r7, #3
 8017298:	701a      	strb	r2, [r3, #0]
    if (!replacedefaultroute && pcb->default_route_set) {
	cifdefaultroute(pcb, ouraddr, hisaddr);
	pcb->default_route_set = 0;
    }
#endif /* UNUSED */
    cifaddr(pcb, ouraddr, hisaddr);
 801729a:	687a      	ldr	r2, [r7, #4]
 801729c:	68b9      	ldr	r1, [r7, #8]
 801729e:	68fb      	ldr	r3, [r7, #12]
 80172a0:	0018      	movs	r0, r3
 80172a2:	f002 fd0f 	bl	8019cc4 <cifaddr>
}
 80172a6:	46c0      	nop			; (mov r8, r8)
 80172a8:	46bd      	mov	sp, r7
 80172aa:	b004      	add	sp, #16
 80172ac:	bd80      	pop	{r7, pc}

080172ae <ipcp_finished>:


/*
 * ipcp_finished - possibly shut down the lower layers.
 */
static void ipcp_finished(fsm *f) {
 80172ae:	b580      	push	{r7, lr}
 80172b0:	b084      	sub	sp, #16
 80172b2:	af00      	add	r7, sp, #0
 80172b4:	6078      	str	r0, [r7, #4]
	ppp_pcb *pcb = f->pcb;
 80172b6:	687b      	ldr	r3, [r7, #4]
 80172b8:	681b      	ldr	r3, [r3, #0]
 80172ba:	60fb      	str	r3, [r7, #12]
	if (pcb->ipcp_is_open) {
 80172bc:	68fb      	ldr	r3, [r7, #12]
 80172be:	2226      	movs	r2, #38	; 0x26
 80172c0:	5c9b      	ldrb	r3, [r3, r2]
 80172c2:	2202      	movs	r2, #2
 80172c4:	4013      	ands	r3, r2
 80172c6:	b2db      	uxtb	r3, r3
 80172c8:	2b00      	cmp	r3, #0
 80172ca:	d00a      	beq.n	80172e2 <ipcp_finished+0x34>
		pcb->ipcp_is_open = 0;
 80172cc:	68fb      	ldr	r3, [r7, #12]
 80172ce:	2226      	movs	r2, #38	; 0x26
 80172d0:	5c99      	ldrb	r1, [r3, r2]
 80172d2:	2002      	movs	r0, #2
 80172d4:	4381      	bics	r1, r0
 80172d6:	5499      	strb	r1, [r3, r2]
		np_finished(pcb, PPP_IP);
 80172d8:	68fb      	ldr	r3, [r7, #12]
 80172da:	2121      	movs	r1, #33	; 0x21
 80172dc:	0018      	movs	r0, r3
 80172de:	f7fc fd75 	bl	8013dcc <np_finished>
	}
}
 80172e2:	46c0      	nop			; (mov r8, r8)
 80172e4:	46bd      	mov	sp, r7
 80172e6:	b004      	add	sp, #16
 80172e8:	bd80      	pop	{r7, pc}
	...

080172ec <lcp_init>:
#endif /* HAVE_MULTILINK */

/*
 * lcp_init - Initialize LCP.
 */
static void lcp_init(ppp_pcb *pcb) {
 80172ec:	b580      	push	{r7, lr}
 80172ee:	b086      	sub	sp, #24
 80172f0:	af00      	add	r7, sp, #0
 80172f2:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 80172f4:	687b      	ldr	r3, [r7, #4]
 80172f6:	3328      	adds	r3, #40	; 0x28
 80172f8:	617b      	str	r3, [r7, #20]
    lcp_options *wo = &pcb->lcp_wantoptions;
 80172fa:	687b      	ldr	r3, [r7, #4]
 80172fc:	3344      	adds	r3, #68	; 0x44
 80172fe:	613b      	str	r3, [r7, #16]
    lcp_options *ao = &pcb->lcp_allowoptions;
 8017300:	687b      	ldr	r3, [r7, #4]
 8017302:	338c      	adds	r3, #140	; 0x8c
 8017304:	60fb      	str	r3, [r7, #12]

    f->pcb = pcb;
 8017306:	697b      	ldr	r3, [r7, #20]
 8017308:	687a      	ldr	r2, [r7, #4]
 801730a:	601a      	str	r2, [r3, #0]
    f->protocol = PPP_LCP;
 801730c:	697b      	ldr	r3, [r7, #20]
 801730e:	4a2b      	ldr	r2, [pc, #172]	; (80173bc <lcp_init+0xd0>)
 8017310:	81da      	strh	r2, [r3, #14]
    f->callbacks = &lcp_callbacks;
 8017312:	697b      	ldr	r3, [r7, #20]
 8017314:	4a2a      	ldr	r2, [pc, #168]	; (80173c0 <lcp_init+0xd4>)
 8017316:	605a      	str	r2, [r3, #4]

    fsm_init(f);
 8017318:	697b      	ldr	r3, [r7, #20]
 801731a:	0018      	movs	r0, r3
 801731c:	f7fc fd74 	bl	8013e08 <fsm_init>

    BZERO(wo, sizeof(*wo));
 8017320:	693b      	ldr	r3, [r7, #16]
 8017322:	2224      	movs	r2, #36	; 0x24
 8017324:	2100      	movs	r1, #0
 8017326:	0018      	movs	r0, r3
 8017328:	f005 fa80 	bl	801c82c <memset>
    wo->neg_mru = 1;
 801732c:	693b      	ldr	r3, [r7, #16]
 801732e:	781a      	ldrb	r2, [r3, #0]
 8017330:	2104      	movs	r1, #4
 8017332:	430a      	orrs	r2, r1
 8017334:	701a      	strb	r2, [r3, #0]
    wo->mru = PPP_DEFMRU;
 8017336:	693b      	ldr	r3, [r7, #16]
 8017338:	4a22      	ldr	r2, [pc, #136]	; (80173c4 <lcp_init+0xd8>)
 801733a:	805a      	strh	r2, [r3, #2]
    wo->neg_asyncmap = 1;
 801733c:	693b      	ldr	r3, [r7, #16]
 801733e:	781a      	ldrb	r2, [r3, #0]
 8017340:	2108      	movs	r1, #8
 8017342:	430a      	orrs	r2, r1
 8017344:	701a      	strb	r2, [r3, #0]
    wo->neg_magicnumber = 1;
 8017346:	693b      	ldr	r3, [r7, #16]
 8017348:	781a      	ldrb	r2, [r3, #0]
 801734a:	2110      	movs	r1, #16
 801734c:	430a      	orrs	r2, r1
 801734e:	701a      	strb	r2, [r3, #0]
    wo->neg_pcompression = 1;
 8017350:	693b      	ldr	r3, [r7, #16]
 8017352:	781a      	ldrb	r2, [r3, #0]
 8017354:	2120      	movs	r1, #32
 8017356:	430a      	orrs	r2, r1
 8017358:	701a      	strb	r2, [r3, #0]
    wo->neg_accompression = 1;
 801735a:	693b      	ldr	r3, [r7, #16]
 801735c:	781a      	ldrb	r2, [r3, #0]
 801735e:	2140      	movs	r1, #64	; 0x40
 8017360:	430a      	orrs	r2, r1
 8017362:	701a      	strb	r2, [r3, #0]

    BZERO(ao, sizeof(*ao));
 8017364:	68fb      	ldr	r3, [r7, #12]
 8017366:	2224      	movs	r2, #36	; 0x24
 8017368:	2100      	movs	r1, #0
 801736a:	0018      	movs	r0, r3
 801736c:	f005 fa5e 	bl	801c82c <memset>
    ao->neg_mru = 1;
 8017370:	68fb      	ldr	r3, [r7, #12]
 8017372:	781a      	ldrb	r2, [r3, #0]
 8017374:	2104      	movs	r1, #4
 8017376:	430a      	orrs	r2, r1
 8017378:	701a      	strb	r2, [r3, #0]
    ao->mru = PPP_MAXMRU;
 801737a:	68fb      	ldr	r3, [r7, #12]
 801737c:	4a11      	ldr	r2, [pc, #68]	; (80173c4 <lcp_init+0xd8>)
 801737e:	805a      	strh	r2, [r3, #2]
    ao->neg_asyncmap = 1;
 8017380:	68fb      	ldr	r3, [r7, #12]
 8017382:	781a      	ldrb	r2, [r3, #0]
 8017384:	2108      	movs	r1, #8
 8017386:	430a      	orrs	r2, r1
 8017388:	701a      	strb	r2, [r3, #0]
    ao->neg_upap = 1;
#endif /* PAP_SUPPORT */
#if EAP_SUPPORT
    ao->neg_eap = 1;
#endif /* EAP_SUPPORT */
    ao->neg_magicnumber = 1;
 801738a:	68fb      	ldr	r3, [r7, #12]
 801738c:	781a      	ldrb	r2, [r3, #0]
 801738e:	2110      	movs	r1, #16
 8017390:	430a      	orrs	r2, r1
 8017392:	701a      	strb	r2, [r3, #0]
    ao->neg_pcompression = 1;
 8017394:	68fb      	ldr	r3, [r7, #12]
 8017396:	781a      	ldrb	r2, [r3, #0]
 8017398:	2120      	movs	r1, #32
 801739a:	430a      	orrs	r2, r1
 801739c:	701a      	strb	r2, [r3, #0]
    ao->neg_accompression = 1;
 801739e:	68fb      	ldr	r3, [r7, #12]
 80173a0:	781a      	ldrb	r2, [r3, #0]
 80173a2:	2140      	movs	r1, #64	; 0x40
 80173a4:	430a      	orrs	r2, r1
 80173a6:	701a      	strb	r2, [r3, #0]
    ao->neg_endpoint = 1;
 80173a8:	68fb      	ldr	r3, [r7, #12]
 80173aa:	785a      	ldrb	r2, [r3, #1]
 80173ac:	2102      	movs	r1, #2
 80173ae:	430a      	orrs	r2, r1
 80173b0:	705a      	strb	r2, [r3, #1]
}
 80173b2:	46c0      	nop			; (mov r8, r8)
 80173b4:	46bd      	mov	sp, r7
 80173b6:	b006      	add	sp, #24
 80173b8:	bd80      	pop	{r7, pc}
 80173ba:	46c0      	nop			; (mov r8, r8)
 80173bc:	ffffc021 	.word	0xffffc021
 80173c0:	08021bb0 	.word	0x08021bb0
 80173c4:	000005dc 	.word	0x000005dc

080173c8 <lcp_open>:


/*
 * lcp_open - LCP is allowed to come up.
 */
void lcp_open(ppp_pcb *pcb) {
 80173c8:	b580      	push	{r7, lr}
 80173ca:	b084      	sub	sp, #16
 80173cc:	af00      	add	r7, sp, #0
 80173ce:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 80173d0:	687b      	ldr	r3, [r7, #4]
 80173d2:	3328      	adds	r3, #40	; 0x28
 80173d4:	60fb      	str	r3, [r7, #12]
    lcp_options *wo = &pcb->lcp_wantoptions;
 80173d6:	687b      	ldr	r3, [r7, #4]
 80173d8:	3344      	adds	r3, #68	; 0x44
 80173da:	60bb      	str	r3, [r7, #8]

    f->flags &= ~(OPT_PASSIVE | OPT_SILENT);
 80173dc:	68fb      	ldr	r3, [r7, #12]
 80173de:	7c5b      	ldrb	r3, [r3, #17]
 80173e0:	2205      	movs	r2, #5
 80173e2:	4393      	bics	r3, r2
 80173e4:	b2da      	uxtb	r2, r3
 80173e6:	68fb      	ldr	r3, [r7, #12]
 80173e8:	745a      	strb	r2, [r3, #17]
    if (wo->passive)
 80173ea:	68bb      	ldr	r3, [r7, #8]
 80173ec:	781b      	ldrb	r3, [r3, #0]
 80173ee:	2201      	movs	r2, #1
 80173f0:	4013      	ands	r3, r2
 80173f2:	b2db      	uxtb	r3, r3
 80173f4:	2b00      	cmp	r3, #0
 80173f6:	d006      	beq.n	8017406 <lcp_open+0x3e>
	f->flags |= OPT_PASSIVE;
 80173f8:	68fb      	ldr	r3, [r7, #12]
 80173fa:	7c5b      	ldrb	r3, [r3, #17]
 80173fc:	2201      	movs	r2, #1
 80173fe:	4313      	orrs	r3, r2
 8017400:	b2da      	uxtb	r2, r3
 8017402:	68fb      	ldr	r3, [r7, #12]
 8017404:	745a      	strb	r2, [r3, #17]
    if (wo->silent)
 8017406:	68bb      	ldr	r3, [r7, #8]
 8017408:	781b      	ldrb	r3, [r3, #0]
 801740a:	2202      	movs	r2, #2
 801740c:	4013      	ands	r3, r2
 801740e:	b2db      	uxtb	r3, r3
 8017410:	2b00      	cmp	r3, #0
 8017412:	d006      	beq.n	8017422 <lcp_open+0x5a>
	f->flags |= OPT_SILENT;
 8017414:	68fb      	ldr	r3, [r7, #12]
 8017416:	7c5b      	ldrb	r3, [r3, #17]
 8017418:	2204      	movs	r2, #4
 801741a:	4313      	orrs	r3, r2
 801741c:	b2da      	uxtb	r2, r3
 801741e:	68fb      	ldr	r3, [r7, #12]
 8017420:	745a      	strb	r2, [r3, #17]
    fsm_open(f);
 8017422:	68fb      	ldr	r3, [r7, #12]
 8017424:	0018      	movs	r0, r3
 8017426:	f7fc fd7d 	bl	8013f24 <fsm_open>
}
 801742a:	46c0      	nop			; (mov r8, r8)
 801742c:	46bd      	mov	sp, r7
 801742e:	b004      	add	sp, #16
 8017430:	bd80      	pop	{r7, pc}
	...

08017434 <lcp_close>:


/*
 * lcp_close - Take LCP down.
 */
void lcp_close(ppp_pcb *pcb, const char *reason) {
 8017434:	b580      	push	{r7, lr}
 8017436:	b084      	sub	sp, #16
 8017438:	af00      	add	r7, sp, #0
 801743a:	6078      	str	r0, [r7, #4]
 801743c:	6039      	str	r1, [r7, #0]
    fsm *f = &pcb->lcp_fsm;
 801743e:	687b      	ldr	r3, [r7, #4]
 8017440:	3328      	adds	r3, #40	; 0x28
 8017442:	60fb      	str	r3, [r7, #12]
    int oldstate;

    if (pcb->phase != PPP_PHASE_DEAD
 8017444:	687b      	ldr	r3, [r7, #4]
 8017446:	2224      	movs	r2, #36	; 0x24
 8017448:	5c9b      	ldrb	r3, [r3, r2]
 801744a:	2b00      	cmp	r3, #0
 801744c:	d004      	beq.n	8017458 <lcp_close+0x24>
#ifdef HAVE_MULTILINK
    && pcb->phase != PPP_PHASE_MASTER
#endif /* HAVE_MULTILINK */
    )
	new_phase(pcb, PPP_PHASE_TERMINATE);
 801744e:	687b      	ldr	r3, [r7, #4]
 8017450:	210b      	movs	r1, #11
 8017452:	0018      	movs	r0, r3
 8017454:	f002 fbc5 	bl	8019be2 <new_phase>

    if (f->flags & DELAYED_UP) {
 8017458:	68fb      	ldr	r3, [r7, #12]
 801745a:	7c5b      	ldrb	r3, [r3, #17]
 801745c:	b25b      	sxtb	r3, r3
 801745e:	2b00      	cmp	r3, #0
 8017460:	da08      	bge.n	8017474 <lcp_close+0x40>
	UNTIMEOUT(lcp_delayed_up, f);
 8017462:	68fa      	ldr	r2, [r7, #12]
 8017464:	4b14      	ldr	r3, [pc, #80]	; (80174b8 <lcp_close+0x84>)
 8017466:	0011      	movs	r1, r2
 8017468:	0018      	movs	r0, r3
 801746a:	f7fa fc1d 	bl	8011ca8 <sys_untimeout>
	f->state = PPP_FSM_STOPPED;
 801746e:	68fb      	ldr	r3, [r7, #12]
 8017470:	2203      	movs	r2, #3
 8017472:	741a      	strb	r2, [r3, #16]
    }
    oldstate = f->state;
 8017474:	68fb      	ldr	r3, [r7, #12]
 8017476:	7c1b      	ldrb	r3, [r3, #16]
 8017478:	60bb      	str	r3, [r7, #8]

    fsm_close(f, reason);
 801747a:	683a      	ldr	r2, [r7, #0]
 801747c:	68fb      	ldr	r3, [r7, #12]
 801747e:	0011      	movs	r1, r2
 8017480:	0018      	movs	r0, r3
 8017482:	f7fc fe11 	bl	80140a8 <fsm_close>
    if (oldstate == PPP_FSM_STOPPED && (f->flags & (OPT_PASSIVE|OPT_SILENT|DELAYED_UP))) {
 8017486:	68bb      	ldr	r3, [r7, #8]
 8017488:	2b03      	cmp	r3, #3
 801748a:	d110      	bne.n	80174ae <lcp_close+0x7a>
 801748c:	68fb      	ldr	r3, [r7, #12]
 801748e:	7c5b      	ldrb	r3, [r3, #17]
 8017490:	001a      	movs	r2, r3
 8017492:	2385      	movs	r3, #133	; 0x85
 8017494:	4013      	ands	r3, r2
 8017496:	d00a      	beq.n	80174ae <lcp_close+0x7a>
	 * but it does mean that the program terminates if you do a
	 * lcp_close() when a connection hasn't been established
	 * because we are in passive/silent mode or because we have
	 * delayed the fsm_lowerup() call and it hasn't happened yet.
	 */
	f->flags &= ~DELAYED_UP;
 8017498:	68fb      	ldr	r3, [r7, #12]
 801749a:	7c5b      	ldrb	r3, [r3, #17]
 801749c:	227f      	movs	r2, #127	; 0x7f
 801749e:	4013      	ands	r3, r2
 80174a0:	b2da      	uxtb	r2, r3
 80174a2:	68fb      	ldr	r3, [r7, #12]
 80174a4:	745a      	strb	r2, [r3, #17]
	lcp_finished(f);
 80174a6:	68fb      	ldr	r3, [r7, #12]
 80174a8:	0018      	movs	r0, r3
 80174aa:	f001 fe64 	bl	8019176 <lcp_finished>
    }
}
 80174ae:	46c0      	nop			; (mov r8, r8)
 80174b0:	46bd      	mov	sp, r7
 80174b2:	b004      	add	sp, #16
 80174b4:	bd80      	pop	{r7, pc}
 80174b6:	46c0      	nop			; (mov r8, r8)
 80174b8:	080175c5 	.word	0x080175c5

080174bc <lcp_lowerup>:


/*
 * lcp_lowerup - The lower layer is up.
 */
void lcp_lowerup(ppp_pcb *pcb) {
 80174bc:	b590      	push	{r4, r7, lr}
 80174be:	b087      	sub	sp, #28
 80174c0:	af02      	add	r7, sp, #8
 80174c2:	6078      	str	r0, [r7, #4]
    lcp_options *wo = &pcb->lcp_wantoptions;
 80174c4:	687b      	ldr	r3, [r7, #4]
 80174c6:	3344      	adds	r3, #68	; 0x44
 80174c8:	60fb      	str	r3, [r7, #12]
    fsm *f = &pcb->lcp_fsm;
 80174ca:	687b      	ldr	r3, [r7, #4]
 80174cc:	3328      	adds	r3, #40	; 0x28
 80174ce:	60bb      	str	r3, [r7, #8]
    /*
     * Don't use A/C or protocol compression on transmission,
     * but accept A/C and protocol compressed packets
     * if we are going to ask for A/C and protocol compression.
     */
    if (ppp_send_config(pcb, PPP_MRU, 0xffffffff, 0, 0) < 0
 80174d0:	2301      	movs	r3, #1
 80174d2:	425a      	negs	r2, r3
 80174d4:	4927      	ldr	r1, [pc, #156]	; (8017574 <lcp_lowerup+0xb8>)
 80174d6:	6878      	ldr	r0, [r7, #4]
 80174d8:	2300      	movs	r3, #0
 80174da:	9300      	str	r3, [sp, #0]
 80174dc:	2300      	movs	r3, #0
 80174de:	f002 fb9b 	bl	8019c18 <ppp_send_config>
 80174e2:	1e03      	subs	r3, r0, #0
 80174e4:	db41      	blt.n	801756a <lcp_lowerup+0xae>
	|| ppp_recv_config(pcb, PPP_MRU, (pcb->settings.lax_recv? 0: 0xffffffff),
 80174e6:	687b      	ldr	r3, [r7, #4]
 80174e8:	781b      	ldrb	r3, [r3, #0]
 80174ea:	2208      	movs	r2, #8
 80174ec:	4013      	ands	r3, r2
 80174ee:	b2db      	uxtb	r3, r3
 80174f0:	2b00      	cmp	r3, #0
 80174f2:	d001      	beq.n	80174f8 <lcp_lowerup+0x3c>
 80174f4:	2200      	movs	r2, #0
 80174f6:	e001      	b.n	80174fc <lcp_lowerup+0x40>
 80174f8:	2301      	movs	r3, #1
 80174fa:	425a      	negs	r2, r3
			   wo->neg_pcompression, wo->neg_accompression) < 0)
 80174fc:	68fb      	ldr	r3, [r7, #12]
 80174fe:	781b      	ldrb	r3, [r3, #0]
 8017500:	069b      	lsls	r3, r3, #26
 8017502:	0fdb      	lsrs	r3, r3, #31
 8017504:	b2db      	uxtb	r3, r3
	|| ppp_recv_config(pcb, PPP_MRU, (pcb->settings.lax_recv? 0: 0xffffffff),
 8017506:	001c      	movs	r4, r3
			   wo->neg_pcompression, wo->neg_accompression) < 0)
 8017508:	68fb      	ldr	r3, [r7, #12]
 801750a:	781b      	ldrb	r3, [r3, #0]
 801750c:	065b      	lsls	r3, r3, #25
 801750e:	0fdb      	lsrs	r3, r3, #31
 8017510:	b2db      	uxtb	r3, r3
	|| ppp_recv_config(pcb, PPP_MRU, (pcb->settings.lax_recv? 0: 0xffffffff),
 8017512:	4918      	ldr	r1, [pc, #96]	; (8017574 <lcp_lowerup+0xb8>)
 8017514:	6878      	ldr	r0, [r7, #4]
 8017516:	9300      	str	r3, [sp, #0]
 8017518:	0023      	movs	r3, r4
 801751a:	f002 fb9a 	bl	8019c52 <ppp_recv_config>
 801751e:	1e03      	subs	r3, r0, #0
 8017520:	db23      	blt.n	801756a <lcp_lowerup+0xae>
	    return;
    pcb->peer_mru = PPP_MRU;
 8017522:	687b      	ldr	r3, [r7, #4]
 8017524:	22d4      	movs	r2, #212	; 0xd4
 8017526:	4913      	ldr	r1, [pc, #76]	; (8017574 <lcp_lowerup+0xb8>)
 8017528:	5299      	strh	r1, [r3, r2]

    if (pcb->settings.listen_time != 0) {
 801752a:	687b      	ldr	r3, [r7, #4]
 801752c:	885b      	ldrh	r3, [r3, #2]
 801752e:	2b00      	cmp	r3, #0
 8017530:	d016      	beq.n	8017560 <lcp_lowerup+0xa4>
	f->flags |= DELAYED_UP;
 8017532:	68bb      	ldr	r3, [r7, #8]
 8017534:	7c5b      	ldrb	r3, [r3, #17]
 8017536:	2280      	movs	r2, #128	; 0x80
 8017538:	4252      	negs	r2, r2
 801753a:	4313      	orrs	r3, r2
 801753c:	b2da      	uxtb	r2, r3
 801753e:	68bb      	ldr	r3, [r7, #8]
 8017540:	745a      	strb	r2, [r3, #17]
	TIMEOUTMS(lcp_delayed_up, f, pcb->settings.listen_time);
 8017542:	68ba      	ldr	r2, [r7, #8]
 8017544:	4b0c      	ldr	r3, [pc, #48]	; (8017578 <lcp_lowerup+0xbc>)
 8017546:	0011      	movs	r1, r2
 8017548:	0018      	movs	r0, r3
 801754a:	f7fa fbad 	bl	8011ca8 <sys_untimeout>
 801754e:	687b      	ldr	r3, [r7, #4]
 8017550:	885b      	ldrh	r3, [r3, #2]
 8017552:	0018      	movs	r0, r3
 8017554:	68ba      	ldr	r2, [r7, #8]
 8017556:	4b08      	ldr	r3, [pc, #32]	; (8017578 <lcp_lowerup+0xbc>)
 8017558:	0019      	movs	r1, r3
 801755a:	f7fa fb7d 	bl	8011c58 <sys_timeout>
 801755e:	e005      	b.n	801756c <lcp_lowerup+0xb0>
    } else
	fsm_lowerup(f);
 8017560:	68bb      	ldr	r3, [r7, #8]
 8017562:	0018      	movs	r0, r3
 8017564:	f7fc fc6b 	bl	8013e3e <fsm_lowerup>
 8017568:	e000      	b.n	801756c <lcp_lowerup+0xb0>
	    return;
 801756a:	46c0      	nop			; (mov r8, r8)
}
 801756c:	46bd      	mov	sp, r7
 801756e:	b005      	add	sp, #20
 8017570:	bd90      	pop	{r4, r7, pc}
 8017572:	46c0      	nop			; (mov r8, r8)
 8017574:	000005dc 	.word	0x000005dc
 8017578:	080175c5 	.word	0x080175c5

0801757c <lcp_lowerdown>:


/*
 * lcp_lowerdown - The lower layer is down.
 */
void lcp_lowerdown(ppp_pcb *pcb) {
 801757c:	b580      	push	{r7, lr}
 801757e:	b084      	sub	sp, #16
 8017580:	af00      	add	r7, sp, #0
 8017582:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 8017584:	687b      	ldr	r3, [r7, #4]
 8017586:	3328      	adds	r3, #40	; 0x28
 8017588:	60fb      	str	r3, [r7, #12]

    if (f->flags & DELAYED_UP) {
 801758a:	68fb      	ldr	r3, [r7, #12]
 801758c:	7c5b      	ldrb	r3, [r3, #17]
 801758e:	b25b      	sxtb	r3, r3
 8017590:	2b00      	cmp	r3, #0
 8017592:	da0d      	bge.n	80175b0 <lcp_lowerdown+0x34>
	f->flags &= ~DELAYED_UP;
 8017594:	68fb      	ldr	r3, [r7, #12]
 8017596:	7c5b      	ldrb	r3, [r3, #17]
 8017598:	227f      	movs	r2, #127	; 0x7f
 801759a:	4013      	ands	r3, r2
 801759c:	b2da      	uxtb	r2, r3
 801759e:	68fb      	ldr	r3, [r7, #12]
 80175a0:	745a      	strb	r2, [r3, #17]
	UNTIMEOUT(lcp_delayed_up, f);
 80175a2:	68fa      	ldr	r2, [r7, #12]
 80175a4:	4b06      	ldr	r3, [pc, #24]	; (80175c0 <lcp_lowerdown+0x44>)
 80175a6:	0011      	movs	r1, r2
 80175a8:	0018      	movs	r0, r3
 80175aa:	f7fa fb7d 	bl	8011ca8 <sys_untimeout>
    } else
	fsm_lowerdown(f);
}
 80175ae:	e003      	b.n	80175b8 <lcp_lowerdown+0x3c>
	fsm_lowerdown(f);
 80175b0:	68fb      	ldr	r3, [r7, #12]
 80175b2:	0018      	movs	r0, r3
 80175b4:	f7fc fc6a 	bl	8013e8c <fsm_lowerdown>
}
 80175b8:	46c0      	nop			; (mov r8, r8)
 80175ba:	46bd      	mov	sp, r7
 80175bc:	b004      	add	sp, #16
 80175be:	bd80      	pop	{r7, pc}
 80175c0:	080175c5 	.word	0x080175c5

080175c4 <lcp_delayed_up>:


/*
 * lcp_delayed_up - Bring the lower layer up now.
 */
static void lcp_delayed_up(void *arg) {
 80175c4:	b580      	push	{r7, lr}
 80175c6:	b084      	sub	sp, #16
 80175c8:	af00      	add	r7, sp, #0
 80175ca:	6078      	str	r0, [r7, #4]
    fsm *f = (fsm*)arg;
 80175cc:	687b      	ldr	r3, [r7, #4]
 80175ce:	60fb      	str	r3, [r7, #12]

    if (f->flags & DELAYED_UP) {
 80175d0:	68fb      	ldr	r3, [r7, #12]
 80175d2:	7c5b      	ldrb	r3, [r3, #17]
 80175d4:	b25b      	sxtb	r3, r3
 80175d6:	2b00      	cmp	r3, #0
 80175d8:	da0a      	bge.n	80175f0 <lcp_delayed_up+0x2c>
	f->flags &= ~DELAYED_UP;
 80175da:	68fb      	ldr	r3, [r7, #12]
 80175dc:	7c5b      	ldrb	r3, [r3, #17]
 80175de:	227f      	movs	r2, #127	; 0x7f
 80175e0:	4013      	ands	r3, r2
 80175e2:	b2da      	uxtb	r2, r3
 80175e4:	68fb      	ldr	r3, [r7, #12]
 80175e6:	745a      	strb	r2, [r3, #17]
	fsm_lowerup(f);
 80175e8:	68fb      	ldr	r3, [r7, #12]
 80175ea:	0018      	movs	r0, r3
 80175ec:	f7fc fc27 	bl	8013e3e <fsm_lowerup>
    }
}
 80175f0:	46c0      	nop			; (mov r8, r8)
 80175f2:	46bd      	mov	sp, r7
 80175f4:	b004      	add	sp, #16
 80175f6:	bd80      	pop	{r7, pc}

080175f8 <lcp_input>:


/*
 * lcp_input - Input LCP packet.
 */
static void lcp_input(ppp_pcb *pcb, u_char *p, int len) {
 80175f8:	b580      	push	{r7, lr}
 80175fa:	b086      	sub	sp, #24
 80175fc:	af00      	add	r7, sp, #0
 80175fe:	60f8      	str	r0, [r7, #12]
 8017600:	60b9      	str	r1, [r7, #8]
 8017602:	607a      	str	r2, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 8017604:	68fb      	ldr	r3, [r7, #12]
 8017606:	3328      	adds	r3, #40	; 0x28
 8017608:	617b      	str	r3, [r7, #20]

    if (f->flags & DELAYED_UP) {
 801760a:	697b      	ldr	r3, [r7, #20]
 801760c:	7c5b      	ldrb	r3, [r3, #17]
 801760e:	b25b      	sxtb	r3, r3
 8017610:	2b00      	cmp	r3, #0
 8017612:	da10      	bge.n	8017636 <lcp_input+0x3e>
	f->flags &= ~DELAYED_UP;
 8017614:	697b      	ldr	r3, [r7, #20]
 8017616:	7c5b      	ldrb	r3, [r3, #17]
 8017618:	227f      	movs	r2, #127	; 0x7f
 801761a:	4013      	ands	r3, r2
 801761c:	b2da      	uxtb	r2, r3
 801761e:	697b      	ldr	r3, [r7, #20]
 8017620:	745a      	strb	r2, [r3, #17]
	UNTIMEOUT(lcp_delayed_up, f);
 8017622:	697a      	ldr	r2, [r7, #20]
 8017624:	4b09      	ldr	r3, [pc, #36]	; (801764c <lcp_input+0x54>)
 8017626:	0011      	movs	r1, r2
 8017628:	0018      	movs	r0, r3
 801762a:	f7fa fb3d 	bl	8011ca8 <sys_untimeout>
	fsm_lowerup(f);
 801762e:	697b      	ldr	r3, [r7, #20]
 8017630:	0018      	movs	r0, r3
 8017632:	f7fc fc04 	bl	8013e3e <fsm_lowerup>
    }
    fsm_input(f, p, len);
 8017636:	687a      	ldr	r2, [r7, #4]
 8017638:	68b9      	ldr	r1, [r7, #8]
 801763a:	697b      	ldr	r3, [r7, #20]
 801763c:	0018      	movs	r0, r3
 801763e:	f7fc fe1d 	bl	801427c <fsm_input>
}
 8017642:	46c0      	nop			; (mov r8, r8)
 8017644:	46bd      	mov	sp, r7
 8017646:	b006      	add	sp, #24
 8017648:	bd80      	pop	{r7, pc}
 801764a:	46c0      	nop			; (mov r8, r8)
 801764c:	080175c5 	.word	0x080175c5

08017650 <lcp_extcode>:

/*
 * lcp_extcode - Handle a LCP-specific code.
 */
static int lcp_extcode(fsm *f, int code, int id, u_char *inp, int len) {
 8017650:	b580      	push	{r7, lr}
 8017652:	b08a      	sub	sp, #40	; 0x28
 8017654:	af02      	add	r7, sp, #8
 8017656:	60f8      	str	r0, [r7, #12]
 8017658:	60b9      	str	r1, [r7, #8]
 801765a:	607a      	str	r2, [r7, #4]
 801765c:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 801765e:	68fb      	ldr	r3, [r7, #12]
 8017660:	681b      	ldr	r3, [r3, #0]
 8017662:	61fb      	str	r3, [r7, #28]
    lcp_options *go = &pcb->lcp_gotoptions;
 8017664:	69fb      	ldr	r3, [r7, #28]
 8017666:	3368      	adds	r3, #104	; 0x68
 8017668:	61bb      	str	r3, [r7, #24]
    u_char *magp;

    switch( code ){
 801766a:	68bb      	ldr	r3, [r7, #8]
 801766c:	2b0d      	cmp	r3, #13
 801766e:	dc4d      	bgt.n	801770c <lcp_extcode+0xbc>
 8017670:	68bb      	ldr	r3, [r7, #8]
 8017672:	2b0b      	cmp	r3, #11
 8017674:	da4c      	bge.n	8017710 <lcp_extcode+0xc0>
 8017676:	68bb      	ldr	r3, [r7, #8]
 8017678:	2b0a      	cmp	r3, #10
 801767a:	d040      	beq.n	80176fe <lcp_extcode+0xae>
 801767c:	68bb      	ldr	r3, [r7, #8]
 801767e:	2b0a      	cmp	r3, #10
 8017680:	dc44      	bgt.n	801770c <lcp_extcode+0xbc>
 8017682:	68bb      	ldr	r3, [r7, #8]
 8017684:	2b08      	cmp	r3, #8
 8017686:	d003      	beq.n	8017690 <lcp_extcode+0x40>
 8017688:	68bb      	ldr	r3, [r7, #8]
 801768a:	2b09      	cmp	r3, #9
 801768c:	d007      	beq.n	801769e <lcp_extcode+0x4e>
 801768e:	e03d      	b.n	801770c <lcp_extcode+0xbc>
    case PROTREJ:
	lcp_rprotrej(f, inp, len);
 8017690:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8017692:	6839      	ldr	r1, [r7, #0]
 8017694:	68fb      	ldr	r3, [r7, #12]
 8017696:	0018      	movs	r0, r3
 8017698:	f000 f842 	bl	8017720 <lcp_rprotrej>
	break;
 801769c:	e03b      	b.n	8017716 <lcp_extcode+0xc6>
    
    case ECHOREQ:
	if (f->state != PPP_FSM_OPENED)
 801769e:	68fb      	ldr	r3, [r7, #12]
 80176a0:	7c1b      	ldrb	r3, [r3, #16]
 80176a2:	2b09      	cmp	r3, #9
 80176a4:	d136      	bne.n	8017714 <lcp_extcode+0xc4>
	    break;
	magp = inp;
 80176a6:	683b      	ldr	r3, [r7, #0]
 80176a8:	617b      	str	r3, [r7, #20]
	PUTLONG(go->magicnumber, magp);
 80176aa:	69bb      	ldr	r3, [r7, #24]
 80176ac:	689b      	ldr	r3, [r3, #8]
 80176ae:	0e19      	lsrs	r1, r3, #24
 80176b0:	697b      	ldr	r3, [r7, #20]
 80176b2:	1c5a      	adds	r2, r3, #1
 80176b4:	617a      	str	r2, [r7, #20]
 80176b6:	b2ca      	uxtb	r2, r1
 80176b8:	701a      	strb	r2, [r3, #0]
 80176ba:	69bb      	ldr	r3, [r7, #24]
 80176bc:	689b      	ldr	r3, [r3, #8]
 80176be:	0c19      	lsrs	r1, r3, #16
 80176c0:	697b      	ldr	r3, [r7, #20]
 80176c2:	1c5a      	adds	r2, r3, #1
 80176c4:	617a      	str	r2, [r7, #20]
 80176c6:	b2ca      	uxtb	r2, r1
 80176c8:	701a      	strb	r2, [r3, #0]
 80176ca:	69bb      	ldr	r3, [r7, #24]
 80176cc:	689b      	ldr	r3, [r3, #8]
 80176ce:	0a19      	lsrs	r1, r3, #8
 80176d0:	697b      	ldr	r3, [r7, #20]
 80176d2:	1c5a      	adds	r2, r3, #1
 80176d4:	617a      	str	r2, [r7, #20]
 80176d6:	b2ca      	uxtb	r2, r1
 80176d8:	701a      	strb	r2, [r3, #0]
 80176da:	69bb      	ldr	r3, [r7, #24]
 80176dc:	6899      	ldr	r1, [r3, #8]
 80176de:	697b      	ldr	r3, [r7, #20]
 80176e0:	1c5a      	adds	r2, r3, #1
 80176e2:	617a      	str	r2, [r7, #20]
 80176e4:	b2ca      	uxtb	r2, r1
 80176e6:	701a      	strb	r2, [r3, #0]
	fsm_sdata(f, ECHOREP, id, inp, len);
 80176e8:	687b      	ldr	r3, [r7, #4]
 80176ea:	b2da      	uxtb	r2, r3
 80176ec:	6839      	ldr	r1, [r7, #0]
 80176ee:	68f8      	ldr	r0, [r7, #12]
 80176f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80176f2:	9300      	str	r3, [sp, #0]
 80176f4:	000b      	movs	r3, r1
 80176f6:	210a      	movs	r1, #10
 80176f8:	f7fd faa2 	bl	8014c40 <fsm_sdata>
	break;
 80176fc:	e00b      	b.n	8017716 <lcp_extcode+0xc6>
    
    case ECHOREP:
	lcp_received_echo_reply(f, id, inp, len);
 80176fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8017700:	683a      	ldr	r2, [r7, #0]
 8017702:	6879      	ldr	r1, [r7, #4]
 8017704:	68f8      	ldr	r0, [r7, #12]
 8017706:	f001 fdd1 	bl	80192ac <lcp_received_echo_reply>
	break;
 801770a:	e004      	b.n	8017716 <lcp_extcode+0xc6>
    case IDENTIF:
    case TIMEREM:
	break;

    default:
	return 0;
 801770c:	2300      	movs	r3, #0
 801770e:	e003      	b.n	8017718 <lcp_extcode+0xc8>
	break;
 8017710:	46c0      	nop			; (mov r8, r8)
 8017712:	e000      	b.n	8017716 <lcp_extcode+0xc6>
	    break;
 8017714:	46c0      	nop			; (mov r8, r8)
    }
    return 1;
 8017716:	2301      	movs	r3, #1
}
 8017718:	0018      	movs	r0, r3
 801771a:	46bd      	mov	sp, r7
 801771c:	b008      	add	sp, #32
 801771e:	bd80      	pop	{r7, pc}

08017720 <lcp_rprotrej>:
/*
 * lcp_rprotrej - Receive an Protocol-Reject.
 *
 * Figure out which protocol is rejected and inform it.
 */
static void lcp_rprotrej(fsm *f, u_char *inp, int len) {
 8017720:	b580      	push	{r7, lr}
 8017722:	b088      	sub	sp, #32
 8017724:	af00      	add	r7, sp, #0
 8017726:	60f8      	str	r0, [r7, #12]
 8017728:	60b9      	str	r1, [r7, #8]
 801772a:	607a      	str	r2, [r7, #4]
    u_short prot;
#if PPP_PROTOCOLNAME
    const char *pname;
#endif /* PPP_PROTOCOLNAME */

    if (len < 2) {
 801772c:	687b      	ldr	r3, [r7, #4]
 801772e:	2b01      	cmp	r3, #1
 8017730:	dd42      	ble.n	80177b8 <lcp_rprotrej+0x98>
	LCPDEBUG(("lcp_rprotrej: Rcvd short Protocol-Reject packet!"));
	return;
    }

    GETSHORT(prot, inp);
 8017732:	68bb      	ldr	r3, [r7, #8]
 8017734:	1c5a      	adds	r2, r3, #1
 8017736:	60ba      	str	r2, [r7, #8]
 8017738:	781b      	ldrb	r3, [r3, #0]
 801773a:	b29a      	uxth	r2, r3
 801773c:	201a      	movs	r0, #26
 801773e:	183b      	adds	r3, r7, r0
 8017740:	0212      	lsls	r2, r2, #8
 8017742:	801a      	strh	r2, [r3, #0]
 8017744:	68bb      	ldr	r3, [r7, #8]
 8017746:	1c5a      	adds	r2, r3, #1
 8017748:	60ba      	str	r2, [r7, #8]
 801774a:	781b      	ldrb	r3, [r3, #0]
 801774c:	b299      	uxth	r1, r3
 801774e:	183b      	adds	r3, r7, r0
 8017750:	183a      	adds	r2, r7, r0
 8017752:	8812      	ldrh	r2, [r2, #0]
 8017754:	430a      	orrs	r2, r1
 8017756:	801a      	strh	r2, [r3, #0]

    /*
     * Protocol-Reject packets received in any state other than the LCP
     * OPENED state SHOULD be silently discarded.
     */
    if( f->state != PPP_FSM_OPENED ){
 8017758:	68fb      	ldr	r3, [r7, #12]
 801775a:	7c1b      	ldrb	r3, [r3, #16]
 801775c:	2b09      	cmp	r3, #9
 801775e:	d12d      	bne.n	80177bc <lcp_rprotrej+0x9c>
#endif /* PPP_PROTOCOLNAME */

    /*
     * Upcall the proper Protocol-Reject routine.
     */
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
 8017760:	2300      	movs	r3, #0
 8017762:	61fb      	str	r3, [r7, #28]
 8017764:	e017      	b.n	8017796 <lcp_rprotrej+0x76>
	if (protp->protocol == prot) {
 8017766:	697b      	ldr	r3, [r7, #20]
 8017768:	881b      	ldrh	r3, [r3, #0]
 801776a:	211a      	movs	r1, #26
 801776c:	187a      	adds	r2, r7, r1
 801776e:	8812      	ldrh	r2, [r2, #0]
 8017770:	429a      	cmp	r2, r3
 8017772:	d10d      	bne.n	8017790 <lcp_rprotrej+0x70>
	    if (pname != NULL)
		ppp_dbglog("Protocol-Reject for '%s' (0x%x) received", pname,
		       prot);
	    else
#endif /* PPP_PROTOCOLNAME */
		ppp_dbglog("Protocol-Reject for 0x%x received", prot);
 8017774:	187b      	adds	r3, r7, r1
 8017776:	881a      	ldrh	r2, [r3, #0]
 8017778:	4b12      	ldr	r3, [pc, #72]	; (80177c4 <lcp_rprotrej+0xa4>)
 801777a:	0011      	movs	r1, r2
 801777c:	0018      	movs	r0, r3
 801777e:	f003 fd2a 	bl	801b1d6 <ppp_dbglog>
	    (*protp->protrej)(f->pcb);
 8017782:	697b      	ldr	r3, [r7, #20]
 8017784:	68da      	ldr	r2, [r3, #12]
 8017786:	68fb      	ldr	r3, [r7, #12]
 8017788:	681b      	ldr	r3, [r3, #0]
 801778a:	0018      	movs	r0, r3
 801778c:	4790      	blx	r2
	    return;
 801778e:	e016      	b.n	80177be <lcp_rprotrej+0x9e>
    for (i = 0; (protp = protocols[i]) != NULL; ++i)
 8017790:	69fb      	ldr	r3, [r7, #28]
 8017792:	3301      	adds	r3, #1
 8017794:	61fb      	str	r3, [r7, #28]
 8017796:	4b0c      	ldr	r3, [pc, #48]	; (80177c8 <lcp_rprotrej+0xa8>)
 8017798:	69fa      	ldr	r2, [r7, #28]
 801779a:	0092      	lsls	r2, r2, #2
 801779c:	58d3      	ldr	r3, [r2, r3]
 801779e:	617b      	str	r3, [r7, #20]
 80177a0:	697b      	ldr	r3, [r7, #20]
 80177a2:	2b00      	cmp	r3, #0
 80177a4:	d1df      	bne.n	8017766 <lcp_rprotrej+0x46>
    if (pname != NULL)
	ppp_warn("Protocol-Reject for unsupported protocol '%s' (0x%x)", pname,
	     prot);
    else
#endif /* #if PPP_PROTOCOLNAME */
	ppp_warn("Protocol-Reject for unsupported protocol 0x%x", prot);
 80177a6:	231a      	movs	r3, #26
 80177a8:	18fb      	adds	r3, r7, r3
 80177aa:	881a      	ldrh	r2, [r3, #0]
 80177ac:	4b07      	ldr	r3, [pc, #28]	; (80177cc <lcp_rprotrej+0xac>)
 80177ae:	0011      	movs	r1, r2
 80177b0:	0018      	movs	r0, r3
 80177b2:	f003 fcd4 	bl	801b15e <ppp_warn>
 80177b6:	e002      	b.n	80177be <lcp_rprotrej+0x9e>
	return;
 80177b8:	46c0      	nop			; (mov r8, r8)
 80177ba:	e000      	b.n	80177be <lcp_rprotrej+0x9e>
	return;
 80177bc:	46c0      	nop			; (mov r8, r8)
}
 80177be:	46bd      	mov	sp, r7
 80177c0:	b008      	add	sp, #32
 80177c2:	bd80      	pop	{r7, pc}
 80177c4:	080210d0 	.word	0x080210d0
 80177c8:	08021cbc 	.word	0x08021cbc
 80177cc:	080210f4 	.word	0x080210f4

080177d0 <lcp_protrej>:

/*
 * lcp_protrej - A Protocol-Reject was received.
 */
/*ARGSUSED*/
static void lcp_protrej(ppp_pcb *pcb) {
 80177d0:	b580      	push	{r7, lr}
 80177d2:	b082      	sub	sp, #8
 80177d4:	af00      	add	r7, sp, #0
 80177d6:	6078      	str	r0, [r7, #4]
    /*
     * Can't reject LCP!
     */
    ppp_error("Received Protocol-Reject for LCP!");
 80177d8:	4b06      	ldr	r3, [pc, #24]	; (80177f4 <lcp_protrej+0x24>)
 80177da:	0018      	movs	r0, r3
 80177dc:	f003 fcab 	bl	801b136 <ppp_error>
    fsm_protreject(&pcb->lcp_fsm);
 80177e0:	687b      	ldr	r3, [r7, #4]
 80177e2:	3328      	adds	r3, #40	; 0x28
 80177e4:	0018      	movs	r0, r3
 80177e6:	f7fd f8ed 	bl	80149c4 <fsm_protreject>
}
 80177ea:	46c0      	nop			; (mov r8, r8)
 80177ec:	46bd      	mov	sp, r7
 80177ee:	b002      	add	sp, #8
 80177f0:	bd80      	pop	{r7, pc}
 80177f2:	46c0      	nop			; (mov r8, r8)
 80177f4:	08021124 	.word	0x08021124

080177f8 <lcp_sprotrej>:


/*
 * lcp_sprotrej - Send a Protocol-Reject for some protocol.
 */
void lcp_sprotrej(ppp_pcb *pcb, u_char *p, int len) {
 80177f8:	b580      	push	{r7, lr}
 80177fa:	b088      	sub	sp, #32
 80177fc:	af02      	add	r7, sp, #8
 80177fe:	60f8      	str	r0, [r7, #12]
 8017800:	60b9      	str	r1, [r7, #8]
 8017802:	607a      	str	r2, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 8017804:	68fb      	ldr	r3, [r7, #12]
 8017806:	3328      	adds	r3, #40	; 0x28
 8017808:	617b      	str	r3, [r7, #20]
#if 0
    p += 2;
    len -= 2;
#endif

    fsm_sdata(f, PROTREJ, ++f->id,
 801780a:	697b      	ldr	r3, [r7, #20]
 801780c:	7c9b      	ldrb	r3, [r3, #18]
 801780e:	3301      	adds	r3, #1
 8017810:	b2da      	uxtb	r2, r3
 8017812:	697b      	ldr	r3, [r7, #20]
 8017814:	749a      	strb	r2, [r3, #18]
 8017816:	697b      	ldr	r3, [r7, #20]
 8017818:	7c9a      	ldrb	r2, [r3, #18]
 801781a:	68b9      	ldr	r1, [r7, #8]
 801781c:	6978      	ldr	r0, [r7, #20]
 801781e:	687b      	ldr	r3, [r7, #4]
 8017820:	9300      	str	r3, [sp, #0]
 8017822:	000b      	movs	r3, r1
 8017824:	2108      	movs	r1, #8
 8017826:	f7fd fa0b 	bl	8014c40 <fsm_sdata>
	      p, len);
}
 801782a:	46c0      	nop			; (mov r8, r8)
 801782c:	46bd      	mov	sp, r7
 801782e:	b006      	add	sp, #24
 8017830:	bd80      	pop	{r7, pc}
	...

08017834 <lcp_resetci>:


/*
 * lcp_resetci - Reset our CI.
 */
static void lcp_resetci(fsm *f) {
 8017834:	b590      	push	{r4, r7, lr}
 8017836:	b087      	sub	sp, #28
 8017838:	af00      	add	r7, sp, #0
 801783a:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 801783c:	687b      	ldr	r3, [r7, #4]
 801783e:	681b      	ldr	r3, [r3, #0]
 8017840:	617b      	str	r3, [r7, #20]
    lcp_options *wo = &pcb->lcp_wantoptions;
 8017842:	697b      	ldr	r3, [r7, #20]
 8017844:	3344      	adds	r3, #68	; 0x44
 8017846:	613b      	str	r3, [r7, #16]
    lcp_options *go = &pcb->lcp_gotoptions;
 8017848:	697b      	ldr	r3, [r7, #20]
 801784a:	3368      	adds	r3, #104	; 0x68
 801784c:	60fb      	str	r3, [r7, #12]
    lcp_options *ao = &pcb->lcp_allowoptions;
 801784e:	697b      	ldr	r3, [r7, #20]
 8017850:	338c      	adds	r3, #140	; 0x8c
 8017852:	60bb      	str	r3, [r7, #8]
#endif /* EAP_SUPPORT */
    PPPDEBUG(LOG_DEBUG, ("\n"));

#endif /* PPP_AUTH_SUPPORT */

    wo->magicnumber = magic();
 8017854:	f001 fe46 	bl	80194e4 <magic>
 8017858:	0002      	movs	r2, r0
 801785a:	693b      	ldr	r3, [r7, #16]
 801785c:	609a      	str	r2, [r3, #8]
    wo->numloops = 0;
 801785e:	693b      	ldr	r3, [r7, #16]
 8017860:	2200      	movs	r2, #0
 8017862:	731a      	strb	r2, [r3, #12]
    *go = *wo;
 8017864:	68fb      	ldr	r3, [r7, #12]
 8017866:	693a      	ldr	r2, [r7, #16]
 8017868:	ca13      	ldmia	r2!, {r0, r1, r4}
 801786a:	c313      	stmia	r3!, {r0, r1, r4}
 801786c:	ca13      	ldmia	r2!, {r0, r1, r4}
 801786e:	c313      	stmia	r3!, {r0, r1, r4}
 8017870:	ca13      	ldmia	r2!, {r0, r1, r4}
 8017872:	c313      	stmia	r3!, {r0, r1, r4}
#ifdef HAVE_MULTILINK
    if (!multilink) {
	go->neg_mrru = 0;
#endif /* HAVE_MULTILINK */
	go->neg_ssnhf = 0;
 8017874:	68fb      	ldr	r3, [r7, #12]
 8017876:	785a      	ldrb	r2, [r3, #1]
 8017878:	2101      	movs	r1, #1
 801787a:	438a      	bics	r2, r1
 801787c:	705a      	strb	r2, [r3, #1]
	go->neg_endpoint = 0;
 801787e:	68fb      	ldr	r3, [r7, #12]
 8017880:	785a      	ldrb	r2, [r3, #1]
 8017882:	2102      	movs	r1, #2
 8017884:	438a      	bics	r2, r1
 8017886:	705a      	strb	r2, [r3, #1]
#ifdef HAVE_MULTILINK
    }
#endif /* HAVE_MULTILINK */
    if (pcb->settings.noendpoint)
 8017888:	697b      	ldr	r3, [r7, #20]
 801788a:	781b      	ldrb	r3, [r3, #0]
 801788c:	2210      	movs	r2, #16
 801788e:	4013      	ands	r3, r2
 8017890:	b2db      	uxtb	r3, r3
 8017892:	2b00      	cmp	r3, #0
 8017894:	d004      	beq.n	80178a0 <lcp_resetci+0x6c>
	ao->neg_endpoint = 0;
 8017896:	68bb      	ldr	r3, [r7, #8]
 8017898:	785a      	ldrb	r2, [r3, #1]
 801789a:	2102      	movs	r1, #2
 801789c:	438a      	bics	r2, r1
 801789e:	705a      	strb	r2, [r3, #1]
    pcb->peer_mru = PPP_MRU;
 80178a0:	697b      	ldr	r3, [r7, #20]
 80178a2:	22d4      	movs	r2, #212	; 0xd4
 80178a4:	4902      	ldr	r1, [pc, #8]	; (80178b0 <lcp_resetci+0x7c>)
 80178a6:	5299      	strh	r1, [r3, r2]
#if 0 /* UNUSED */
    auth_reset(pcb);
#endif /* UNUSED */
}
 80178a8:	46c0      	nop			; (mov r8, r8)
 80178aa:	46bd      	mov	sp, r7
 80178ac:	b007      	add	sp, #28
 80178ae:	bd90      	pop	{r4, r7, pc}
 80178b0:	000005dc 	.word	0x000005dc

080178b4 <lcp_cilen>:


/*
 * lcp_cilen - Return length of our CI.
 */
static int lcp_cilen(fsm *f) {
 80178b4:	b580      	push	{r7, lr}
 80178b6:	b084      	sub	sp, #16
 80178b8:	af00      	add	r7, sp, #0
 80178ba:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 80178bc:	687b      	ldr	r3, [r7, #4]
 80178be:	681b      	ldr	r3, [r3, #0]
 80178c0:	60fb      	str	r3, [r7, #12]
    lcp_options *go = &pcb->lcp_gotoptions;
 80178c2:	68fb      	ldr	r3, [r7, #12]
 80178c4:	3368      	adds	r3, #104	; 0x68
 80178c6:	60bb      	str	r3, [r7, #8]
    /*
     * NB: we only ask for one of CHAP, UPAP, or EAP, even if we will
     * accept more than one.  We prefer EAP first, then CHAP, then
     * PAP.
     */
    return (LENCISHORT(go->neg_mru && go->mru != PPP_DEFMRU) +
 80178c8:	68bb      	ldr	r3, [r7, #8]
 80178ca:	781b      	ldrb	r3, [r3, #0]
 80178cc:	2204      	movs	r2, #4
 80178ce:	4013      	ands	r3, r2
 80178d0:	b2db      	uxtb	r3, r3
 80178d2:	2b00      	cmp	r3, #0
 80178d4:	d006      	beq.n	80178e4 <lcp_cilen+0x30>
 80178d6:	68bb      	ldr	r3, [r7, #8]
 80178d8:	885b      	ldrh	r3, [r3, #2]
 80178da:	4a29      	ldr	r2, [pc, #164]	; (8017980 <lcp_cilen+0xcc>)
 80178dc:	4293      	cmp	r3, r2
 80178de:	d001      	beq.n	80178e4 <lcp_cilen+0x30>
 80178e0:	2204      	movs	r2, #4
 80178e2:	e000      	b.n	80178e6 <lcp_cilen+0x32>
 80178e4:	2200      	movs	r2, #0
	    LENCILONG(go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF) +
 80178e6:	68bb      	ldr	r3, [r7, #8]
 80178e8:	781b      	ldrb	r3, [r3, #0]
 80178ea:	2108      	movs	r1, #8
 80178ec:	400b      	ands	r3, r1
 80178ee:	b2db      	uxtb	r3, r3
 80178f0:	2b00      	cmp	r3, #0
 80178f2:	d005      	beq.n	8017900 <lcp_cilen+0x4c>
 80178f4:	68bb      	ldr	r3, [r7, #8]
 80178f6:	685b      	ldr	r3, [r3, #4]
 80178f8:	3301      	adds	r3, #1
 80178fa:	d001      	beq.n	8017900 <lcp_cilen+0x4c>
 80178fc:	2306      	movs	r3, #6
 80178fe:	e000      	b.n	8017902 <lcp_cilen+0x4e>
 8017900:	2300      	movs	r3, #0
    return (LENCISHORT(go->neg_mru && go->mru != PPP_DEFMRU) +
 8017902:	18d2      	adds	r2, r2, r3
#endif /* !EAP_SUPPORT && !CHAP_SUPPORT */
#endif /* PAP_SUPPORT */
#if LQR_SUPPORT
	    LENCILQR(go->neg_lqr) +
#endif /* LQR_SUPPORT */
	    LENCICBCP(go->neg_cbcp) +
 8017904:	68bb      	ldr	r3, [r7, #8]
 8017906:	781b      	ldrb	r3, [r3, #0]
 8017908:	217f      	movs	r1, #127	; 0x7f
 801790a:	438b      	bics	r3, r1
 801790c:	b2db      	uxtb	r3, r3
 801790e:	2b00      	cmp	r3, #0
 8017910:	d001      	beq.n	8017916 <lcp_cilen+0x62>
 8017912:	2303      	movs	r3, #3
 8017914:	e000      	b.n	8017918 <lcp_cilen+0x64>
 8017916:	2300      	movs	r3, #0
	    LENCILONG(go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF) +
 8017918:	189a      	adds	r2, r3, r2
	    LENCILONG(go->neg_magicnumber) +
 801791a:	68bb      	ldr	r3, [r7, #8]
 801791c:	781b      	ldrb	r3, [r3, #0]
 801791e:	2110      	movs	r1, #16
 8017920:	400b      	ands	r3, r1
 8017922:	b2db      	uxtb	r3, r3
 8017924:	2b00      	cmp	r3, #0
 8017926:	d001      	beq.n	801792c <lcp_cilen+0x78>
 8017928:	2306      	movs	r3, #6
 801792a:	e000      	b.n	801792e <lcp_cilen+0x7a>
 801792c:	2300      	movs	r3, #0
	    LENCICBCP(go->neg_cbcp) +
 801792e:	189a      	adds	r2, r3, r2
	    LENCIVOID(go->neg_pcompression) +
 8017930:	68bb      	ldr	r3, [r7, #8]
 8017932:	781b      	ldrb	r3, [r3, #0]
 8017934:	091b      	lsrs	r3, r3, #4
 8017936:	b2db      	uxtb	r3, r3
 8017938:	0019      	movs	r1, r3
 801793a:	2302      	movs	r3, #2
 801793c:	400b      	ands	r3, r1
	    LENCILONG(go->neg_magicnumber) +
 801793e:	18d2      	adds	r2, r2, r3
	    LENCIVOID(go->neg_accompression) +
 8017940:	68bb      	ldr	r3, [r7, #8]
 8017942:	781b      	ldrb	r3, [r3, #0]
 8017944:	095b      	lsrs	r3, r3, #5
 8017946:	b2db      	uxtb	r3, r3
 8017948:	0019      	movs	r1, r3
 801794a:	2302      	movs	r3, #2
 801794c:	400b      	ands	r3, r1
	    LENCIVOID(go->neg_pcompression) +
 801794e:	18d2      	adds	r2, r2, r3
#ifdef HAVE_MULTILINK
	    LENCISHORT(go->neg_mrru) +
#endif /* HAVE_MULTILINK */
	    LENCIVOID(go->neg_ssnhf) +
 8017950:	68bb      	ldr	r3, [r7, #8]
 8017952:	785b      	ldrb	r3, [r3, #1]
 8017954:	005b      	lsls	r3, r3, #1
 8017956:	2102      	movs	r1, #2
 8017958:	400b      	ands	r3, r1
	    LENCIVOID(go->neg_accompression) +
 801795a:	18d2      	adds	r2, r2, r3
	    (go->neg_endpoint? CILEN_CHAR + go->endpoint.length: 0));
 801795c:	68bb      	ldr	r3, [r7, #8]
 801795e:	785b      	ldrb	r3, [r3, #1]
 8017960:	2102      	movs	r1, #2
 8017962:	400b      	ands	r3, r1
 8017964:	b2db      	uxtb	r3, r3
 8017966:	2b00      	cmp	r3, #0
 8017968:	d003      	beq.n	8017972 <lcp_cilen+0xbe>
 801796a:	68bb      	ldr	r3, [r7, #8]
 801796c:	7b9b      	ldrb	r3, [r3, #14]
 801796e:	3303      	adds	r3, #3
 8017970:	e000      	b.n	8017974 <lcp_cilen+0xc0>
 8017972:	2300      	movs	r3, #0
	    LENCIVOID(go->neg_ssnhf) +
 8017974:	189b      	adds	r3, r3, r2
}
 8017976:	0018      	movs	r0, r3
 8017978:	46bd      	mov	sp, r7
 801797a:	b004      	add	sp, #16
 801797c:	bd80      	pop	{r7, pc}
 801797e:	46c0      	nop			; (mov r8, r8)
 8017980:	000005dc 	.word	0x000005dc

08017984 <lcp_addci>:


/*
 * lcp_addci - Add our desired CIs to a packet.
 */
static void lcp_addci(fsm *f, u_char *ucp, int *lenp) {
 8017984:	b580      	push	{r7, lr}
 8017986:	b088      	sub	sp, #32
 8017988:	af00      	add	r7, sp, #0
 801798a:	60f8      	str	r0, [r7, #12]
 801798c:	60b9      	str	r1, [r7, #8]
 801798e:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8017990:	68fb      	ldr	r3, [r7, #12]
 8017992:	681b      	ldr	r3, [r3, #0]
 8017994:	61bb      	str	r3, [r7, #24]
    lcp_options *go = &pcb->lcp_gotoptions;
 8017996:	69bb      	ldr	r3, [r7, #24]
 8017998:	3368      	adds	r3, #104	; 0x68
 801799a:	617b      	str	r3, [r7, #20]
    u_char *start_ucp = ucp;
 801799c:	68bb      	ldr	r3, [r7, #8]
 801799e:	613b      	str	r3, [r7, #16]
	PUTCHAR(class, ucp); \
	for (i = 0; i < len; ++i) \
	    PUTCHAR(val[i], ucp); \
    }

    ADDCISHORT(CI_MRU, go->neg_mru && go->mru != PPP_DEFMRU, go->mru);
 80179a0:	697b      	ldr	r3, [r7, #20]
 80179a2:	781b      	ldrb	r3, [r3, #0]
 80179a4:	2204      	movs	r2, #4
 80179a6:	4013      	ands	r3, r2
 80179a8:	b2db      	uxtb	r3, r3
 80179aa:	2b00      	cmp	r3, #0
 80179ac:	d01e      	beq.n	80179ec <lcp_addci+0x68>
 80179ae:	697b      	ldr	r3, [r7, #20]
 80179b0:	885b      	ldrh	r3, [r3, #2]
 80179b2:	4a84      	ldr	r2, [pc, #528]	; (8017bc4 <lcp_addci+0x240>)
 80179b4:	4293      	cmp	r3, r2
 80179b6:	d019      	beq.n	80179ec <lcp_addci+0x68>
 80179b8:	68bb      	ldr	r3, [r7, #8]
 80179ba:	1c5a      	adds	r2, r3, #1
 80179bc:	60ba      	str	r2, [r7, #8]
 80179be:	2201      	movs	r2, #1
 80179c0:	701a      	strb	r2, [r3, #0]
 80179c2:	68bb      	ldr	r3, [r7, #8]
 80179c4:	1c5a      	adds	r2, r3, #1
 80179c6:	60ba      	str	r2, [r7, #8]
 80179c8:	2204      	movs	r2, #4
 80179ca:	701a      	strb	r2, [r3, #0]
 80179cc:	697b      	ldr	r3, [r7, #20]
 80179ce:	885b      	ldrh	r3, [r3, #2]
 80179d0:	0a1b      	lsrs	r3, r3, #8
 80179d2:	b299      	uxth	r1, r3
 80179d4:	68bb      	ldr	r3, [r7, #8]
 80179d6:	1c5a      	adds	r2, r3, #1
 80179d8:	60ba      	str	r2, [r7, #8]
 80179da:	b2ca      	uxtb	r2, r1
 80179dc:	701a      	strb	r2, [r3, #0]
 80179de:	697b      	ldr	r3, [r7, #20]
 80179e0:	8859      	ldrh	r1, [r3, #2]
 80179e2:	68bb      	ldr	r3, [r7, #8]
 80179e4:	1c5a      	adds	r2, r3, #1
 80179e6:	60ba      	str	r2, [r7, #8]
 80179e8:	b2ca      	uxtb	r2, r1
 80179ea:	701a      	strb	r2, [r3, #0]
    ADDCILONG(CI_ASYNCMAP, go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF,
 80179ec:	697b      	ldr	r3, [r7, #20]
 80179ee:	781b      	ldrb	r3, [r3, #0]
 80179f0:	2208      	movs	r2, #8
 80179f2:	4013      	ands	r3, r2
 80179f4:	b2db      	uxtb	r3, r3
 80179f6:	2b00      	cmp	r3, #0
 80179f8:	d02c      	beq.n	8017a54 <lcp_addci+0xd0>
 80179fa:	697b      	ldr	r3, [r7, #20]
 80179fc:	685b      	ldr	r3, [r3, #4]
 80179fe:	3301      	adds	r3, #1
 8017a00:	d028      	beq.n	8017a54 <lcp_addci+0xd0>
 8017a02:	68bb      	ldr	r3, [r7, #8]
 8017a04:	1c5a      	adds	r2, r3, #1
 8017a06:	60ba      	str	r2, [r7, #8]
 8017a08:	2202      	movs	r2, #2
 8017a0a:	701a      	strb	r2, [r3, #0]
 8017a0c:	68bb      	ldr	r3, [r7, #8]
 8017a0e:	1c5a      	adds	r2, r3, #1
 8017a10:	60ba      	str	r2, [r7, #8]
 8017a12:	2206      	movs	r2, #6
 8017a14:	701a      	strb	r2, [r3, #0]
 8017a16:	697b      	ldr	r3, [r7, #20]
 8017a18:	685b      	ldr	r3, [r3, #4]
 8017a1a:	0e19      	lsrs	r1, r3, #24
 8017a1c:	68bb      	ldr	r3, [r7, #8]
 8017a1e:	1c5a      	adds	r2, r3, #1
 8017a20:	60ba      	str	r2, [r7, #8]
 8017a22:	b2ca      	uxtb	r2, r1
 8017a24:	701a      	strb	r2, [r3, #0]
 8017a26:	697b      	ldr	r3, [r7, #20]
 8017a28:	685b      	ldr	r3, [r3, #4]
 8017a2a:	0c19      	lsrs	r1, r3, #16
 8017a2c:	68bb      	ldr	r3, [r7, #8]
 8017a2e:	1c5a      	adds	r2, r3, #1
 8017a30:	60ba      	str	r2, [r7, #8]
 8017a32:	b2ca      	uxtb	r2, r1
 8017a34:	701a      	strb	r2, [r3, #0]
 8017a36:	697b      	ldr	r3, [r7, #20]
 8017a38:	685b      	ldr	r3, [r3, #4]
 8017a3a:	0a19      	lsrs	r1, r3, #8
 8017a3c:	68bb      	ldr	r3, [r7, #8]
 8017a3e:	1c5a      	adds	r2, r3, #1
 8017a40:	60ba      	str	r2, [r7, #8]
 8017a42:	b2ca      	uxtb	r2, r1
 8017a44:	701a      	strb	r2, [r3, #0]
 8017a46:	697b      	ldr	r3, [r7, #20]
 8017a48:	6859      	ldr	r1, [r3, #4]
 8017a4a:	68bb      	ldr	r3, [r7, #8]
 8017a4c:	1c5a      	adds	r2, r3, #1
 8017a4e:	60ba      	str	r2, [r7, #8]
 8017a50:	b2ca      	uxtb	r2, r1
 8017a52:	701a      	strb	r2, [r3, #0]
#endif /* !EAP_SUPPORT && !CHAP_SUPPORT */
#endif /* PAP_SUPPORT */
#if LQR_SUPPORT
    ADDCILQR(CI_QUALITY, go->neg_lqr, go->lqr_period);
#endif /* LQR_SUPPORT */
    ADDCICHAR(CI_CALLBACK, go->neg_cbcp, CBCP_OPT);
 8017a54:	697b      	ldr	r3, [r7, #20]
 8017a56:	781b      	ldrb	r3, [r3, #0]
 8017a58:	227f      	movs	r2, #127	; 0x7f
 8017a5a:	4393      	bics	r3, r2
 8017a5c:	b2db      	uxtb	r3, r3
 8017a5e:	2b00      	cmp	r3, #0
 8017a60:	d00e      	beq.n	8017a80 <lcp_addci+0xfc>
 8017a62:	68bb      	ldr	r3, [r7, #8]
 8017a64:	1c5a      	adds	r2, r3, #1
 8017a66:	60ba      	str	r2, [r7, #8]
 8017a68:	220d      	movs	r2, #13
 8017a6a:	701a      	strb	r2, [r3, #0]
 8017a6c:	68bb      	ldr	r3, [r7, #8]
 8017a6e:	1c5a      	adds	r2, r3, #1
 8017a70:	60ba      	str	r2, [r7, #8]
 8017a72:	2203      	movs	r2, #3
 8017a74:	701a      	strb	r2, [r3, #0]
 8017a76:	68bb      	ldr	r3, [r7, #8]
 8017a78:	1c5a      	adds	r2, r3, #1
 8017a7a:	60ba      	str	r2, [r7, #8]
 8017a7c:	2206      	movs	r2, #6
 8017a7e:	701a      	strb	r2, [r3, #0]
    ADDCILONG(CI_MAGICNUMBER, go->neg_magicnumber, go->magicnumber);
 8017a80:	697b      	ldr	r3, [r7, #20]
 8017a82:	781b      	ldrb	r3, [r3, #0]
 8017a84:	2210      	movs	r2, #16
 8017a86:	4013      	ands	r3, r2
 8017a88:	b2db      	uxtb	r3, r3
 8017a8a:	2b00      	cmp	r3, #0
 8017a8c:	d028      	beq.n	8017ae0 <lcp_addci+0x15c>
 8017a8e:	68bb      	ldr	r3, [r7, #8]
 8017a90:	1c5a      	adds	r2, r3, #1
 8017a92:	60ba      	str	r2, [r7, #8]
 8017a94:	2205      	movs	r2, #5
 8017a96:	701a      	strb	r2, [r3, #0]
 8017a98:	68bb      	ldr	r3, [r7, #8]
 8017a9a:	1c5a      	adds	r2, r3, #1
 8017a9c:	60ba      	str	r2, [r7, #8]
 8017a9e:	2206      	movs	r2, #6
 8017aa0:	701a      	strb	r2, [r3, #0]
 8017aa2:	697b      	ldr	r3, [r7, #20]
 8017aa4:	689b      	ldr	r3, [r3, #8]
 8017aa6:	0e19      	lsrs	r1, r3, #24
 8017aa8:	68bb      	ldr	r3, [r7, #8]
 8017aaa:	1c5a      	adds	r2, r3, #1
 8017aac:	60ba      	str	r2, [r7, #8]
 8017aae:	b2ca      	uxtb	r2, r1
 8017ab0:	701a      	strb	r2, [r3, #0]
 8017ab2:	697b      	ldr	r3, [r7, #20]
 8017ab4:	689b      	ldr	r3, [r3, #8]
 8017ab6:	0c19      	lsrs	r1, r3, #16
 8017ab8:	68bb      	ldr	r3, [r7, #8]
 8017aba:	1c5a      	adds	r2, r3, #1
 8017abc:	60ba      	str	r2, [r7, #8]
 8017abe:	b2ca      	uxtb	r2, r1
 8017ac0:	701a      	strb	r2, [r3, #0]
 8017ac2:	697b      	ldr	r3, [r7, #20]
 8017ac4:	689b      	ldr	r3, [r3, #8]
 8017ac6:	0a19      	lsrs	r1, r3, #8
 8017ac8:	68bb      	ldr	r3, [r7, #8]
 8017aca:	1c5a      	adds	r2, r3, #1
 8017acc:	60ba      	str	r2, [r7, #8]
 8017ace:	b2ca      	uxtb	r2, r1
 8017ad0:	701a      	strb	r2, [r3, #0]
 8017ad2:	697b      	ldr	r3, [r7, #20]
 8017ad4:	6899      	ldr	r1, [r3, #8]
 8017ad6:	68bb      	ldr	r3, [r7, #8]
 8017ad8:	1c5a      	adds	r2, r3, #1
 8017ada:	60ba      	str	r2, [r7, #8]
 8017adc:	b2ca      	uxtb	r2, r1
 8017ade:	701a      	strb	r2, [r3, #0]
    ADDCIVOID(CI_PCOMPRESSION, go->neg_pcompression);
 8017ae0:	697b      	ldr	r3, [r7, #20]
 8017ae2:	781b      	ldrb	r3, [r3, #0]
 8017ae4:	2220      	movs	r2, #32
 8017ae6:	4013      	ands	r3, r2
 8017ae8:	b2db      	uxtb	r3, r3
 8017aea:	2b00      	cmp	r3, #0
 8017aec:	d009      	beq.n	8017b02 <lcp_addci+0x17e>
 8017aee:	68bb      	ldr	r3, [r7, #8]
 8017af0:	1c5a      	adds	r2, r3, #1
 8017af2:	60ba      	str	r2, [r7, #8]
 8017af4:	2207      	movs	r2, #7
 8017af6:	701a      	strb	r2, [r3, #0]
 8017af8:	68bb      	ldr	r3, [r7, #8]
 8017afa:	1c5a      	adds	r2, r3, #1
 8017afc:	60ba      	str	r2, [r7, #8]
 8017afe:	2202      	movs	r2, #2
 8017b00:	701a      	strb	r2, [r3, #0]
    ADDCIVOID(CI_ACCOMPRESSION, go->neg_accompression);
 8017b02:	697b      	ldr	r3, [r7, #20]
 8017b04:	781b      	ldrb	r3, [r3, #0]
 8017b06:	2240      	movs	r2, #64	; 0x40
 8017b08:	4013      	ands	r3, r2
 8017b0a:	b2db      	uxtb	r3, r3
 8017b0c:	2b00      	cmp	r3, #0
 8017b0e:	d009      	beq.n	8017b24 <lcp_addci+0x1a0>
 8017b10:	68bb      	ldr	r3, [r7, #8]
 8017b12:	1c5a      	adds	r2, r3, #1
 8017b14:	60ba      	str	r2, [r7, #8]
 8017b16:	2208      	movs	r2, #8
 8017b18:	701a      	strb	r2, [r3, #0]
 8017b1a:	68bb      	ldr	r3, [r7, #8]
 8017b1c:	1c5a      	adds	r2, r3, #1
 8017b1e:	60ba      	str	r2, [r7, #8]
 8017b20:	2202      	movs	r2, #2
 8017b22:	701a      	strb	r2, [r3, #0]
#ifdef HAVE_MULTILINK
    ADDCISHORT(CI_MRRU, go->neg_mrru, go->mrru);
#endif
    ADDCIVOID(CI_SSNHF, go->neg_ssnhf);
 8017b24:	697b      	ldr	r3, [r7, #20]
 8017b26:	785b      	ldrb	r3, [r3, #1]
 8017b28:	2201      	movs	r2, #1
 8017b2a:	4013      	ands	r3, r2
 8017b2c:	b2db      	uxtb	r3, r3
 8017b2e:	2b00      	cmp	r3, #0
 8017b30:	d009      	beq.n	8017b46 <lcp_addci+0x1c2>
 8017b32:	68bb      	ldr	r3, [r7, #8]
 8017b34:	1c5a      	adds	r2, r3, #1
 8017b36:	60ba      	str	r2, [r7, #8]
 8017b38:	2212      	movs	r2, #18
 8017b3a:	701a      	strb	r2, [r3, #0]
 8017b3c:	68bb      	ldr	r3, [r7, #8]
 8017b3e:	1c5a      	adds	r2, r3, #1
 8017b40:	60ba      	str	r2, [r7, #8]
 8017b42:	2202      	movs	r2, #2
 8017b44:	701a      	strb	r2, [r3, #0]
    ADDCIENDP(CI_EPDISC, go->neg_endpoint, go->endpoint.class_,
 8017b46:	697b      	ldr	r3, [r7, #20]
 8017b48:	785b      	ldrb	r3, [r3, #1]
 8017b4a:	2202      	movs	r2, #2
 8017b4c:	4013      	ands	r3, r2
 8017b4e:	b2db      	uxtb	r3, r3
 8017b50:	2b00      	cmp	r3, #0
 8017b52:	d027      	beq.n	8017ba4 <lcp_addci+0x220>
 8017b54:	68bb      	ldr	r3, [r7, #8]
 8017b56:	1c5a      	adds	r2, r3, #1
 8017b58:	60ba      	str	r2, [r7, #8]
 8017b5a:	2213      	movs	r2, #19
 8017b5c:	701a      	strb	r2, [r3, #0]
 8017b5e:	697b      	ldr	r3, [r7, #20]
 8017b60:	7b9a      	ldrb	r2, [r3, #14]
 8017b62:	68bb      	ldr	r3, [r7, #8]
 8017b64:	1c59      	adds	r1, r3, #1
 8017b66:	60b9      	str	r1, [r7, #8]
 8017b68:	3203      	adds	r2, #3
 8017b6a:	b2d2      	uxtb	r2, r2
 8017b6c:	701a      	strb	r2, [r3, #0]
 8017b6e:	68bb      	ldr	r3, [r7, #8]
 8017b70:	1c5a      	adds	r2, r3, #1
 8017b72:	60ba      	str	r2, [r7, #8]
 8017b74:	697a      	ldr	r2, [r7, #20]
 8017b76:	7b52      	ldrb	r2, [r2, #13]
 8017b78:	701a      	strb	r2, [r3, #0]
 8017b7a:	2300      	movs	r3, #0
 8017b7c:	61fb      	str	r3, [r7, #28]
 8017b7e:	e00b      	b.n	8017b98 <lcp_addci+0x214>
 8017b80:	68bb      	ldr	r3, [r7, #8]
 8017b82:	1c5a      	adds	r2, r3, #1
 8017b84:	60ba      	str	r2, [r7, #8]
 8017b86:	6979      	ldr	r1, [r7, #20]
 8017b88:	69fa      	ldr	r2, [r7, #28]
 8017b8a:	188a      	adds	r2, r1, r2
 8017b8c:	320f      	adds	r2, #15
 8017b8e:	7812      	ldrb	r2, [r2, #0]
 8017b90:	701a      	strb	r2, [r3, #0]
 8017b92:	69fb      	ldr	r3, [r7, #28]
 8017b94:	3301      	adds	r3, #1
 8017b96:	61fb      	str	r3, [r7, #28]
 8017b98:	697b      	ldr	r3, [r7, #20]
 8017b9a:	7b9b      	ldrb	r3, [r3, #14]
 8017b9c:	001a      	movs	r2, r3
 8017b9e:	69fb      	ldr	r3, [r7, #28]
 8017ba0:	4293      	cmp	r3, r2
 8017ba2:	dbed      	blt.n	8017b80 <lcp_addci+0x1fc>
	      go->endpoint.value, go->endpoint.length);

    if (ucp - start_ucp != *lenp) {
 8017ba4:	68ba      	ldr	r2, [r7, #8]
 8017ba6:	693b      	ldr	r3, [r7, #16]
 8017ba8:	1ad2      	subs	r2, r2, r3
 8017baa:	687b      	ldr	r3, [r7, #4]
 8017bac:	681b      	ldr	r3, [r3, #0]
 8017bae:	429a      	cmp	r2, r3
 8017bb0:	d003      	beq.n	8017bba <lcp_addci+0x236>
	/* this should never happen, because peer_mtu should be 1500 */
	ppp_error("Bug in lcp_addci: wrong length");
 8017bb2:	4b05      	ldr	r3, [pc, #20]	; (8017bc8 <lcp_addci+0x244>)
 8017bb4:	0018      	movs	r0, r3
 8017bb6:	f003 fabe 	bl	801b136 <ppp_error>
    }
}
 8017bba:	46c0      	nop			; (mov r8, r8)
 8017bbc:	46bd      	mov	sp, r7
 8017bbe:	b008      	add	sp, #32
 8017bc0:	bd80      	pop	{r7, pc}
 8017bc2:	46c0      	nop			; (mov r8, r8)
 8017bc4:	000005dc 	.word	0x000005dc
 8017bc8:	08021148 	.word	0x08021148

08017bcc <lcp_ackci>:
 *
 * Returns:
 *	0 - Ack was bad.
 *	1 - Ack was good.
 */
static int lcp_ackci(fsm *f, u_char *p, int len) {
 8017bcc:	b580      	push	{r7, lr}
 8017bce:	b08a      	sub	sp, #40	; 0x28
 8017bd0:	af00      	add	r7, sp, #0
 8017bd2:	60f8      	str	r0, [r7, #12]
 8017bd4:	60b9      	str	r1, [r7, #8]
 8017bd6:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8017bd8:	68fb      	ldr	r3, [r7, #12]
 8017bda:	681b      	ldr	r3, [r3, #0]
 8017bdc:	623b      	str	r3, [r7, #32]
    lcp_options *go = &pcb->lcp_gotoptions;
 8017bde:	6a3b      	ldr	r3, [r7, #32]
 8017be0:	3368      	adds	r3, #104	; 0x68
 8017be2:	61fb      	str	r3, [r7, #28]
	    if (cichar != val[i]) \
		goto bad; \
	} \
    }

    ACKCISHORT(CI_MRU, go->neg_mru && go->mru != PPP_DEFMRU, go->mru);
 8017be4:	69fb      	ldr	r3, [r7, #28]
 8017be6:	781b      	ldrb	r3, [r3, #0]
 8017be8:	2204      	movs	r2, #4
 8017bea:	4013      	ands	r3, r2
 8017bec:	b2db      	uxtb	r3, r3
 8017bee:	2b00      	cmp	r3, #0
 8017bf0:	d03d      	beq.n	8017c6e <lcp_ackci+0xa2>
 8017bf2:	69fb      	ldr	r3, [r7, #28]
 8017bf4:	885b      	ldrh	r3, [r3, #2]
 8017bf6:	4adf      	ldr	r2, [pc, #892]	; (8017f74 <lcp_ackci+0x3a8>)
 8017bf8:	4293      	cmp	r3, r2
 8017bfa:	d038      	beq.n	8017c6e <lcp_ackci+0xa2>
 8017bfc:	687b      	ldr	r3, [r7, #4]
 8017bfe:	3b04      	subs	r3, #4
 8017c00:	607b      	str	r3, [r7, #4]
 8017c02:	687b      	ldr	r3, [r7, #4]
 8017c04:	2b00      	cmp	r3, #0
 8017c06:	da00      	bge.n	8017c0a <lcp_ackci+0x3e>
 8017c08:	e1d4      	b.n	8017fb4 <lcp_ackci+0x3e8>
 8017c0a:	68bb      	ldr	r3, [r7, #8]
 8017c0c:	1c5a      	adds	r2, r3, #1
 8017c0e:	60ba      	str	r2, [r7, #8]
 8017c10:	211b      	movs	r1, #27
 8017c12:	187a      	adds	r2, r7, r1
 8017c14:	781b      	ldrb	r3, [r3, #0]
 8017c16:	7013      	strb	r3, [r2, #0]
 8017c18:	68bb      	ldr	r3, [r7, #8]
 8017c1a:	1c5a      	adds	r2, r3, #1
 8017c1c:	60ba      	str	r2, [r7, #8]
 8017c1e:	201a      	movs	r0, #26
 8017c20:	183a      	adds	r2, r7, r0
 8017c22:	781b      	ldrb	r3, [r3, #0]
 8017c24:	7013      	strb	r3, [r2, #0]
 8017c26:	183b      	adds	r3, r7, r0
 8017c28:	781b      	ldrb	r3, [r3, #0]
 8017c2a:	2b04      	cmp	r3, #4
 8017c2c:	d000      	beq.n	8017c30 <lcp_ackci+0x64>
 8017c2e:	e1c3      	b.n	8017fb8 <lcp_ackci+0x3ec>
 8017c30:	187b      	adds	r3, r7, r1
 8017c32:	781b      	ldrb	r3, [r3, #0]
 8017c34:	2b01      	cmp	r3, #1
 8017c36:	d000      	beq.n	8017c3a <lcp_ackci+0x6e>
 8017c38:	e1be      	b.n	8017fb8 <lcp_ackci+0x3ec>
 8017c3a:	68bb      	ldr	r3, [r7, #8]
 8017c3c:	1c5a      	adds	r2, r3, #1
 8017c3e:	60ba      	str	r2, [r7, #8]
 8017c40:	781b      	ldrb	r3, [r3, #0]
 8017c42:	b29a      	uxth	r2, r3
 8017c44:	2018      	movs	r0, #24
 8017c46:	183b      	adds	r3, r7, r0
 8017c48:	0212      	lsls	r2, r2, #8
 8017c4a:	801a      	strh	r2, [r3, #0]
 8017c4c:	68bb      	ldr	r3, [r7, #8]
 8017c4e:	1c5a      	adds	r2, r3, #1
 8017c50:	60ba      	str	r2, [r7, #8]
 8017c52:	781b      	ldrb	r3, [r3, #0]
 8017c54:	b299      	uxth	r1, r3
 8017c56:	183b      	adds	r3, r7, r0
 8017c58:	183a      	adds	r2, r7, r0
 8017c5a:	8812      	ldrh	r2, [r2, #0]
 8017c5c:	430a      	orrs	r2, r1
 8017c5e:	801a      	strh	r2, [r3, #0]
 8017c60:	69fb      	ldr	r3, [r7, #28]
 8017c62:	885b      	ldrh	r3, [r3, #2]
 8017c64:	183a      	adds	r2, r7, r0
 8017c66:	8812      	ldrh	r2, [r2, #0]
 8017c68:	429a      	cmp	r2, r3
 8017c6a:	d000      	beq.n	8017c6e <lcp_ackci+0xa2>
 8017c6c:	e1a6      	b.n	8017fbc <lcp_ackci+0x3f0>
    ACKCILONG(CI_ASYNCMAP, go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF,
 8017c6e:	69fb      	ldr	r3, [r7, #28]
 8017c70:	781b      	ldrb	r3, [r3, #0]
 8017c72:	2208      	movs	r2, #8
 8017c74:	4013      	ands	r3, r2
 8017c76:	b2db      	uxtb	r3, r3
 8017c78:	2b00      	cmp	r3, #0
 8017c7a:	d04c      	beq.n	8017d16 <lcp_ackci+0x14a>
 8017c7c:	69fb      	ldr	r3, [r7, #28]
 8017c7e:	685b      	ldr	r3, [r3, #4]
 8017c80:	3301      	adds	r3, #1
 8017c82:	d048      	beq.n	8017d16 <lcp_ackci+0x14a>
 8017c84:	687b      	ldr	r3, [r7, #4]
 8017c86:	3b06      	subs	r3, #6
 8017c88:	607b      	str	r3, [r7, #4]
 8017c8a:	687b      	ldr	r3, [r7, #4]
 8017c8c:	2b00      	cmp	r3, #0
 8017c8e:	da00      	bge.n	8017c92 <lcp_ackci+0xc6>
 8017c90:	e196      	b.n	8017fc0 <lcp_ackci+0x3f4>
 8017c92:	68bb      	ldr	r3, [r7, #8]
 8017c94:	1c5a      	adds	r2, r3, #1
 8017c96:	60ba      	str	r2, [r7, #8]
 8017c98:	211b      	movs	r1, #27
 8017c9a:	187a      	adds	r2, r7, r1
 8017c9c:	781b      	ldrb	r3, [r3, #0]
 8017c9e:	7013      	strb	r3, [r2, #0]
 8017ca0:	68bb      	ldr	r3, [r7, #8]
 8017ca2:	1c5a      	adds	r2, r3, #1
 8017ca4:	60ba      	str	r2, [r7, #8]
 8017ca6:	201a      	movs	r0, #26
 8017ca8:	183a      	adds	r2, r7, r0
 8017caa:	781b      	ldrb	r3, [r3, #0]
 8017cac:	7013      	strb	r3, [r2, #0]
 8017cae:	183b      	adds	r3, r7, r0
 8017cb0:	781b      	ldrb	r3, [r3, #0]
 8017cb2:	2b06      	cmp	r3, #6
 8017cb4:	d000      	beq.n	8017cb8 <lcp_ackci+0xec>
 8017cb6:	e185      	b.n	8017fc4 <lcp_ackci+0x3f8>
 8017cb8:	187b      	adds	r3, r7, r1
 8017cba:	781b      	ldrb	r3, [r3, #0]
 8017cbc:	2b02      	cmp	r3, #2
 8017cbe:	d000      	beq.n	8017cc2 <lcp_ackci+0xf6>
 8017cc0:	e180      	b.n	8017fc4 <lcp_ackci+0x3f8>
 8017cc2:	68bb      	ldr	r3, [r7, #8]
 8017cc4:	1c5a      	adds	r2, r3, #1
 8017cc6:	60ba      	str	r2, [r7, #8]
 8017cc8:	781b      	ldrb	r3, [r3, #0]
 8017cca:	021b      	lsls	r3, r3, #8
 8017ccc:	617b      	str	r3, [r7, #20]
 8017cce:	68bb      	ldr	r3, [r7, #8]
 8017cd0:	1c5a      	adds	r2, r3, #1
 8017cd2:	60ba      	str	r2, [r7, #8]
 8017cd4:	781b      	ldrb	r3, [r3, #0]
 8017cd6:	001a      	movs	r2, r3
 8017cd8:	697b      	ldr	r3, [r7, #20]
 8017cda:	4313      	orrs	r3, r2
 8017cdc:	617b      	str	r3, [r7, #20]
 8017cde:	697b      	ldr	r3, [r7, #20]
 8017ce0:	021b      	lsls	r3, r3, #8
 8017ce2:	617b      	str	r3, [r7, #20]
 8017ce4:	68bb      	ldr	r3, [r7, #8]
 8017ce6:	1c5a      	adds	r2, r3, #1
 8017ce8:	60ba      	str	r2, [r7, #8]
 8017cea:	781b      	ldrb	r3, [r3, #0]
 8017cec:	001a      	movs	r2, r3
 8017cee:	697b      	ldr	r3, [r7, #20]
 8017cf0:	4313      	orrs	r3, r2
 8017cf2:	617b      	str	r3, [r7, #20]
 8017cf4:	697b      	ldr	r3, [r7, #20]
 8017cf6:	021b      	lsls	r3, r3, #8
 8017cf8:	617b      	str	r3, [r7, #20]
 8017cfa:	68bb      	ldr	r3, [r7, #8]
 8017cfc:	1c5a      	adds	r2, r3, #1
 8017cfe:	60ba      	str	r2, [r7, #8]
 8017d00:	781b      	ldrb	r3, [r3, #0]
 8017d02:	001a      	movs	r2, r3
 8017d04:	697b      	ldr	r3, [r7, #20]
 8017d06:	4313      	orrs	r3, r2
 8017d08:	617b      	str	r3, [r7, #20]
 8017d0a:	69fb      	ldr	r3, [r7, #28]
 8017d0c:	685b      	ldr	r3, [r3, #4]
 8017d0e:	697a      	ldr	r2, [r7, #20]
 8017d10:	429a      	cmp	r2, r3
 8017d12:	d000      	beq.n	8017d16 <lcp_ackci+0x14a>
 8017d14:	e158      	b.n	8017fc8 <lcp_ackci+0x3fc>
#endif /* !EAP_SUPPORT && !CHAP_SUPPORT */
#endif /* PAP_SUPPORT */
#if LQR_SUPPORT
    ACKCILQR(CI_QUALITY, go->neg_lqr, go->lqr_period);
#endif /* LQR_SUPPORT */
    ACKCICHAR(CI_CALLBACK, go->neg_cbcp, CBCP_OPT);
 8017d16:	69fb      	ldr	r3, [r7, #28]
 8017d18:	781b      	ldrb	r3, [r3, #0]
 8017d1a:	227f      	movs	r2, #127	; 0x7f
 8017d1c:	4393      	bics	r3, r2
 8017d1e:	b2db      	uxtb	r3, r3
 8017d20:	2b00      	cmp	r3, #0
 8017d22:	d02a      	beq.n	8017d7a <lcp_ackci+0x1ae>
 8017d24:	687b      	ldr	r3, [r7, #4]
 8017d26:	3b03      	subs	r3, #3
 8017d28:	607b      	str	r3, [r7, #4]
 8017d2a:	687b      	ldr	r3, [r7, #4]
 8017d2c:	2b00      	cmp	r3, #0
 8017d2e:	da00      	bge.n	8017d32 <lcp_ackci+0x166>
 8017d30:	e14c      	b.n	8017fcc <lcp_ackci+0x400>
 8017d32:	68bb      	ldr	r3, [r7, #8]
 8017d34:	1c5a      	adds	r2, r3, #1
 8017d36:	60ba      	str	r2, [r7, #8]
 8017d38:	211b      	movs	r1, #27
 8017d3a:	187a      	adds	r2, r7, r1
 8017d3c:	781b      	ldrb	r3, [r3, #0]
 8017d3e:	7013      	strb	r3, [r2, #0]
 8017d40:	68bb      	ldr	r3, [r7, #8]
 8017d42:	1c5a      	adds	r2, r3, #1
 8017d44:	60ba      	str	r2, [r7, #8]
 8017d46:	201a      	movs	r0, #26
 8017d48:	183a      	adds	r2, r7, r0
 8017d4a:	781b      	ldrb	r3, [r3, #0]
 8017d4c:	7013      	strb	r3, [r2, #0]
 8017d4e:	183b      	adds	r3, r7, r0
 8017d50:	781b      	ldrb	r3, [r3, #0]
 8017d52:	2b03      	cmp	r3, #3
 8017d54:	d000      	beq.n	8017d58 <lcp_ackci+0x18c>
 8017d56:	e13b      	b.n	8017fd0 <lcp_ackci+0x404>
 8017d58:	187b      	adds	r3, r7, r1
 8017d5a:	781b      	ldrb	r3, [r3, #0]
 8017d5c:	2b0d      	cmp	r3, #13
 8017d5e:	d000      	beq.n	8017d62 <lcp_ackci+0x196>
 8017d60:	e136      	b.n	8017fd0 <lcp_ackci+0x404>
 8017d62:	68bb      	ldr	r3, [r7, #8]
 8017d64:	1c5a      	adds	r2, r3, #1
 8017d66:	60ba      	str	r2, [r7, #8]
 8017d68:	2113      	movs	r1, #19
 8017d6a:	187a      	adds	r2, r7, r1
 8017d6c:	781b      	ldrb	r3, [r3, #0]
 8017d6e:	7013      	strb	r3, [r2, #0]
 8017d70:	187b      	adds	r3, r7, r1
 8017d72:	781b      	ldrb	r3, [r3, #0]
 8017d74:	2b06      	cmp	r3, #6
 8017d76:	d000      	beq.n	8017d7a <lcp_ackci+0x1ae>
 8017d78:	e12c      	b.n	8017fd4 <lcp_ackci+0x408>
    ACKCILONG(CI_MAGICNUMBER, go->neg_magicnumber, go->magicnumber);
 8017d7a:	69fb      	ldr	r3, [r7, #28]
 8017d7c:	781b      	ldrb	r3, [r3, #0]
 8017d7e:	2210      	movs	r2, #16
 8017d80:	4013      	ands	r3, r2
 8017d82:	b2db      	uxtb	r3, r3
 8017d84:	2b00      	cmp	r3, #0
 8017d86:	d048      	beq.n	8017e1a <lcp_ackci+0x24e>
 8017d88:	687b      	ldr	r3, [r7, #4]
 8017d8a:	3b06      	subs	r3, #6
 8017d8c:	607b      	str	r3, [r7, #4]
 8017d8e:	687b      	ldr	r3, [r7, #4]
 8017d90:	2b00      	cmp	r3, #0
 8017d92:	da00      	bge.n	8017d96 <lcp_ackci+0x1ca>
 8017d94:	e120      	b.n	8017fd8 <lcp_ackci+0x40c>
 8017d96:	68bb      	ldr	r3, [r7, #8]
 8017d98:	1c5a      	adds	r2, r3, #1
 8017d9a:	60ba      	str	r2, [r7, #8]
 8017d9c:	211b      	movs	r1, #27
 8017d9e:	187a      	adds	r2, r7, r1
 8017da0:	781b      	ldrb	r3, [r3, #0]
 8017da2:	7013      	strb	r3, [r2, #0]
 8017da4:	68bb      	ldr	r3, [r7, #8]
 8017da6:	1c5a      	adds	r2, r3, #1
 8017da8:	60ba      	str	r2, [r7, #8]
 8017daa:	201a      	movs	r0, #26
 8017dac:	183a      	adds	r2, r7, r0
 8017dae:	781b      	ldrb	r3, [r3, #0]
 8017db0:	7013      	strb	r3, [r2, #0]
 8017db2:	183b      	adds	r3, r7, r0
 8017db4:	781b      	ldrb	r3, [r3, #0]
 8017db6:	2b06      	cmp	r3, #6
 8017db8:	d000      	beq.n	8017dbc <lcp_ackci+0x1f0>
 8017dba:	e10f      	b.n	8017fdc <lcp_ackci+0x410>
 8017dbc:	187b      	adds	r3, r7, r1
 8017dbe:	781b      	ldrb	r3, [r3, #0]
 8017dc0:	2b05      	cmp	r3, #5
 8017dc2:	d000      	beq.n	8017dc6 <lcp_ackci+0x1fa>
 8017dc4:	e10a      	b.n	8017fdc <lcp_ackci+0x410>
 8017dc6:	68bb      	ldr	r3, [r7, #8]
 8017dc8:	1c5a      	adds	r2, r3, #1
 8017dca:	60ba      	str	r2, [r7, #8]
 8017dcc:	781b      	ldrb	r3, [r3, #0]
 8017dce:	021b      	lsls	r3, r3, #8
 8017dd0:	617b      	str	r3, [r7, #20]
 8017dd2:	68bb      	ldr	r3, [r7, #8]
 8017dd4:	1c5a      	adds	r2, r3, #1
 8017dd6:	60ba      	str	r2, [r7, #8]
 8017dd8:	781b      	ldrb	r3, [r3, #0]
 8017dda:	001a      	movs	r2, r3
 8017ddc:	697b      	ldr	r3, [r7, #20]
 8017dde:	4313      	orrs	r3, r2
 8017de0:	617b      	str	r3, [r7, #20]
 8017de2:	697b      	ldr	r3, [r7, #20]
 8017de4:	021b      	lsls	r3, r3, #8
 8017de6:	617b      	str	r3, [r7, #20]
 8017de8:	68bb      	ldr	r3, [r7, #8]
 8017dea:	1c5a      	adds	r2, r3, #1
 8017dec:	60ba      	str	r2, [r7, #8]
 8017dee:	781b      	ldrb	r3, [r3, #0]
 8017df0:	001a      	movs	r2, r3
 8017df2:	697b      	ldr	r3, [r7, #20]
 8017df4:	4313      	orrs	r3, r2
 8017df6:	617b      	str	r3, [r7, #20]
 8017df8:	697b      	ldr	r3, [r7, #20]
 8017dfa:	021b      	lsls	r3, r3, #8
 8017dfc:	617b      	str	r3, [r7, #20]
 8017dfe:	68bb      	ldr	r3, [r7, #8]
 8017e00:	1c5a      	adds	r2, r3, #1
 8017e02:	60ba      	str	r2, [r7, #8]
 8017e04:	781b      	ldrb	r3, [r3, #0]
 8017e06:	001a      	movs	r2, r3
 8017e08:	697b      	ldr	r3, [r7, #20]
 8017e0a:	4313      	orrs	r3, r2
 8017e0c:	617b      	str	r3, [r7, #20]
 8017e0e:	69fb      	ldr	r3, [r7, #28]
 8017e10:	689b      	ldr	r3, [r3, #8]
 8017e12:	697a      	ldr	r2, [r7, #20]
 8017e14:	429a      	cmp	r2, r3
 8017e16:	d000      	beq.n	8017e1a <lcp_ackci+0x24e>
 8017e18:	e0e2      	b.n	8017fe0 <lcp_ackci+0x414>
    ACKCIVOID(CI_PCOMPRESSION, go->neg_pcompression);
 8017e1a:	69fb      	ldr	r3, [r7, #28]
 8017e1c:	781b      	ldrb	r3, [r3, #0]
 8017e1e:	2220      	movs	r2, #32
 8017e20:	4013      	ands	r3, r2
 8017e22:	b2db      	uxtb	r3, r3
 8017e24:	2b00      	cmp	r3, #0
 8017e26:	d01e      	beq.n	8017e66 <lcp_ackci+0x29a>
 8017e28:	687b      	ldr	r3, [r7, #4]
 8017e2a:	3b02      	subs	r3, #2
 8017e2c:	607b      	str	r3, [r7, #4]
 8017e2e:	687b      	ldr	r3, [r7, #4]
 8017e30:	2b00      	cmp	r3, #0
 8017e32:	da00      	bge.n	8017e36 <lcp_ackci+0x26a>
 8017e34:	e0d6      	b.n	8017fe4 <lcp_ackci+0x418>
 8017e36:	68bb      	ldr	r3, [r7, #8]
 8017e38:	1c5a      	adds	r2, r3, #1
 8017e3a:	60ba      	str	r2, [r7, #8]
 8017e3c:	211b      	movs	r1, #27
 8017e3e:	187a      	adds	r2, r7, r1
 8017e40:	781b      	ldrb	r3, [r3, #0]
 8017e42:	7013      	strb	r3, [r2, #0]
 8017e44:	68bb      	ldr	r3, [r7, #8]
 8017e46:	1c5a      	adds	r2, r3, #1
 8017e48:	60ba      	str	r2, [r7, #8]
 8017e4a:	201a      	movs	r0, #26
 8017e4c:	183a      	adds	r2, r7, r0
 8017e4e:	781b      	ldrb	r3, [r3, #0]
 8017e50:	7013      	strb	r3, [r2, #0]
 8017e52:	183b      	adds	r3, r7, r0
 8017e54:	781b      	ldrb	r3, [r3, #0]
 8017e56:	2b02      	cmp	r3, #2
 8017e58:	d000      	beq.n	8017e5c <lcp_ackci+0x290>
 8017e5a:	e0c5      	b.n	8017fe8 <lcp_ackci+0x41c>
 8017e5c:	187b      	adds	r3, r7, r1
 8017e5e:	781b      	ldrb	r3, [r3, #0]
 8017e60:	2b07      	cmp	r3, #7
 8017e62:	d000      	beq.n	8017e66 <lcp_ackci+0x29a>
 8017e64:	e0c0      	b.n	8017fe8 <lcp_ackci+0x41c>
    ACKCIVOID(CI_ACCOMPRESSION, go->neg_accompression);
 8017e66:	69fb      	ldr	r3, [r7, #28]
 8017e68:	781b      	ldrb	r3, [r3, #0]
 8017e6a:	2240      	movs	r2, #64	; 0x40
 8017e6c:	4013      	ands	r3, r2
 8017e6e:	b2db      	uxtb	r3, r3
 8017e70:	2b00      	cmp	r3, #0
 8017e72:	d01e      	beq.n	8017eb2 <lcp_ackci+0x2e6>
 8017e74:	687b      	ldr	r3, [r7, #4]
 8017e76:	3b02      	subs	r3, #2
 8017e78:	607b      	str	r3, [r7, #4]
 8017e7a:	687b      	ldr	r3, [r7, #4]
 8017e7c:	2b00      	cmp	r3, #0
 8017e7e:	da00      	bge.n	8017e82 <lcp_ackci+0x2b6>
 8017e80:	e0b4      	b.n	8017fec <lcp_ackci+0x420>
 8017e82:	68bb      	ldr	r3, [r7, #8]
 8017e84:	1c5a      	adds	r2, r3, #1
 8017e86:	60ba      	str	r2, [r7, #8]
 8017e88:	211b      	movs	r1, #27
 8017e8a:	187a      	adds	r2, r7, r1
 8017e8c:	781b      	ldrb	r3, [r3, #0]
 8017e8e:	7013      	strb	r3, [r2, #0]
 8017e90:	68bb      	ldr	r3, [r7, #8]
 8017e92:	1c5a      	adds	r2, r3, #1
 8017e94:	60ba      	str	r2, [r7, #8]
 8017e96:	201a      	movs	r0, #26
 8017e98:	183a      	adds	r2, r7, r0
 8017e9a:	781b      	ldrb	r3, [r3, #0]
 8017e9c:	7013      	strb	r3, [r2, #0]
 8017e9e:	183b      	adds	r3, r7, r0
 8017ea0:	781b      	ldrb	r3, [r3, #0]
 8017ea2:	2b02      	cmp	r3, #2
 8017ea4:	d000      	beq.n	8017ea8 <lcp_ackci+0x2dc>
 8017ea6:	e0a3      	b.n	8017ff0 <lcp_ackci+0x424>
 8017ea8:	187b      	adds	r3, r7, r1
 8017eaa:	781b      	ldrb	r3, [r3, #0]
 8017eac:	2b08      	cmp	r3, #8
 8017eae:	d000      	beq.n	8017eb2 <lcp_ackci+0x2e6>
 8017eb0:	e09e      	b.n	8017ff0 <lcp_ackci+0x424>
#ifdef HAVE_MULTILINK
    ACKCISHORT(CI_MRRU, go->neg_mrru, go->mrru);
#endif /* HAVE_MULTILINK */
    ACKCIVOID(CI_SSNHF, go->neg_ssnhf);
 8017eb2:	69fb      	ldr	r3, [r7, #28]
 8017eb4:	785b      	ldrb	r3, [r3, #1]
 8017eb6:	2201      	movs	r2, #1
 8017eb8:	4013      	ands	r3, r2
 8017eba:	b2db      	uxtb	r3, r3
 8017ebc:	2b00      	cmp	r3, #0
 8017ebe:	d01e      	beq.n	8017efe <lcp_ackci+0x332>
 8017ec0:	687b      	ldr	r3, [r7, #4]
 8017ec2:	3b02      	subs	r3, #2
 8017ec4:	607b      	str	r3, [r7, #4]
 8017ec6:	687b      	ldr	r3, [r7, #4]
 8017ec8:	2b00      	cmp	r3, #0
 8017eca:	da00      	bge.n	8017ece <lcp_ackci+0x302>
 8017ecc:	e092      	b.n	8017ff4 <lcp_ackci+0x428>
 8017ece:	68bb      	ldr	r3, [r7, #8]
 8017ed0:	1c5a      	adds	r2, r3, #1
 8017ed2:	60ba      	str	r2, [r7, #8]
 8017ed4:	211b      	movs	r1, #27
 8017ed6:	187a      	adds	r2, r7, r1
 8017ed8:	781b      	ldrb	r3, [r3, #0]
 8017eda:	7013      	strb	r3, [r2, #0]
 8017edc:	68bb      	ldr	r3, [r7, #8]
 8017ede:	1c5a      	adds	r2, r3, #1
 8017ee0:	60ba      	str	r2, [r7, #8]
 8017ee2:	201a      	movs	r0, #26
 8017ee4:	183a      	adds	r2, r7, r0
 8017ee6:	781b      	ldrb	r3, [r3, #0]
 8017ee8:	7013      	strb	r3, [r2, #0]
 8017eea:	183b      	adds	r3, r7, r0
 8017eec:	781b      	ldrb	r3, [r3, #0]
 8017eee:	2b02      	cmp	r3, #2
 8017ef0:	d000      	beq.n	8017ef4 <lcp_ackci+0x328>
 8017ef2:	e081      	b.n	8017ff8 <lcp_ackci+0x42c>
 8017ef4:	187b      	adds	r3, r7, r1
 8017ef6:	781b      	ldrb	r3, [r3, #0]
 8017ef8:	2b12      	cmp	r3, #18
 8017efa:	d000      	beq.n	8017efe <lcp_ackci+0x332>
 8017efc:	e07c      	b.n	8017ff8 <lcp_ackci+0x42c>
    ACKCIENDP(CI_EPDISC, go->neg_endpoint, go->endpoint.class_,
 8017efe:	69fb      	ldr	r3, [r7, #28]
 8017f00:	785b      	ldrb	r3, [r3, #1]
 8017f02:	2202      	movs	r2, #2
 8017f04:	4013      	ands	r3, r2
 8017f06:	b2db      	uxtb	r3, r3
 8017f08:	2b00      	cmp	r3, #0
 8017f0a:	d04e      	beq.n	8017faa <lcp_ackci+0x3de>
 8017f0c:	69fb      	ldr	r3, [r7, #28]
 8017f0e:	7b9b      	ldrb	r3, [r3, #14]
 8017f10:	3303      	adds	r3, #3
 8017f12:	687a      	ldr	r2, [r7, #4]
 8017f14:	1ad3      	subs	r3, r2, r3
 8017f16:	607b      	str	r3, [r7, #4]
 8017f18:	687b      	ldr	r3, [r7, #4]
 8017f1a:	2b00      	cmp	r3, #0
 8017f1c:	da00      	bge.n	8017f20 <lcp_ackci+0x354>
 8017f1e:	e06d      	b.n	8017ffc <lcp_ackci+0x430>
 8017f20:	68bb      	ldr	r3, [r7, #8]
 8017f22:	1c5a      	adds	r2, r3, #1
 8017f24:	60ba      	str	r2, [r7, #8]
 8017f26:	211b      	movs	r1, #27
 8017f28:	187a      	adds	r2, r7, r1
 8017f2a:	781b      	ldrb	r3, [r3, #0]
 8017f2c:	7013      	strb	r3, [r2, #0]
 8017f2e:	68bb      	ldr	r3, [r7, #8]
 8017f30:	1c5a      	adds	r2, r3, #1
 8017f32:	60ba      	str	r2, [r7, #8]
 8017f34:	201a      	movs	r0, #26
 8017f36:	183a      	adds	r2, r7, r0
 8017f38:	781b      	ldrb	r3, [r3, #0]
 8017f3a:	7013      	strb	r3, [r2, #0]
 8017f3c:	183b      	adds	r3, r7, r0
 8017f3e:	781a      	ldrb	r2, [r3, #0]
 8017f40:	69fb      	ldr	r3, [r7, #28]
 8017f42:	7b9b      	ldrb	r3, [r3, #14]
 8017f44:	3303      	adds	r3, #3
 8017f46:	429a      	cmp	r2, r3
 8017f48:	d15a      	bne.n	8018000 <lcp_ackci+0x434>
 8017f4a:	187b      	adds	r3, r7, r1
 8017f4c:	781b      	ldrb	r3, [r3, #0]
 8017f4e:	2b13      	cmp	r3, #19
 8017f50:	d156      	bne.n	8018000 <lcp_ackci+0x434>
 8017f52:	68bb      	ldr	r3, [r7, #8]
 8017f54:	1c5a      	adds	r2, r3, #1
 8017f56:	60ba      	str	r2, [r7, #8]
 8017f58:	2113      	movs	r1, #19
 8017f5a:	187a      	adds	r2, r7, r1
 8017f5c:	781b      	ldrb	r3, [r3, #0]
 8017f5e:	7013      	strb	r3, [r2, #0]
 8017f60:	69fb      	ldr	r3, [r7, #28]
 8017f62:	7b5b      	ldrb	r3, [r3, #13]
 8017f64:	187a      	adds	r2, r7, r1
 8017f66:	7812      	ldrb	r2, [r2, #0]
 8017f68:	429a      	cmp	r2, r3
 8017f6a:	d14b      	bne.n	8018004 <lcp_ackci+0x438>
 8017f6c:	2300      	movs	r3, #0
 8017f6e:	627b      	str	r3, [r7, #36]	; 0x24
 8017f70:	e015      	b.n	8017f9e <lcp_ackci+0x3d2>
 8017f72:	46c0      	nop			; (mov r8, r8)
 8017f74:	000005dc 	.word	0x000005dc
 8017f78:	68bb      	ldr	r3, [r7, #8]
 8017f7a:	1c5a      	adds	r2, r3, #1
 8017f7c:	60ba      	str	r2, [r7, #8]
 8017f7e:	2113      	movs	r1, #19
 8017f80:	187a      	adds	r2, r7, r1
 8017f82:	781b      	ldrb	r3, [r3, #0]
 8017f84:	7013      	strb	r3, [r2, #0]
 8017f86:	69fa      	ldr	r2, [r7, #28]
 8017f88:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017f8a:	18d3      	adds	r3, r2, r3
 8017f8c:	330f      	adds	r3, #15
 8017f8e:	781b      	ldrb	r3, [r3, #0]
 8017f90:	187a      	adds	r2, r7, r1
 8017f92:	7812      	ldrb	r2, [r2, #0]
 8017f94:	429a      	cmp	r2, r3
 8017f96:	d137      	bne.n	8018008 <lcp_ackci+0x43c>
 8017f98:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017f9a:	3301      	adds	r3, #1
 8017f9c:	627b      	str	r3, [r7, #36]	; 0x24
 8017f9e:	69fb      	ldr	r3, [r7, #28]
 8017fa0:	7b9b      	ldrb	r3, [r3, #14]
 8017fa2:	001a      	movs	r2, r3
 8017fa4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017fa6:	4293      	cmp	r3, r2
 8017fa8:	dbe6      	blt.n	8017f78 <lcp_ackci+0x3ac>
	      go->endpoint.value, go->endpoint.length);

    /*
     * If there are any remaining CIs, then this packet is bad.
     */
    if (len != 0)
 8017faa:	687b      	ldr	r3, [r7, #4]
 8017fac:	2b00      	cmp	r3, #0
 8017fae:	d12d      	bne.n	801800c <lcp_ackci+0x440>
	goto bad;
    return (1);
 8017fb0:	2301      	movs	r3, #1
 8017fb2:	e02d      	b.n	8018010 <lcp_ackci+0x444>
    ACKCISHORT(CI_MRU, go->neg_mru && go->mru != PPP_DEFMRU, go->mru);
 8017fb4:	46c0      	nop			; (mov r8, r8)
 8017fb6:	e02a      	b.n	801800e <lcp_ackci+0x442>
 8017fb8:	46c0      	nop			; (mov r8, r8)
 8017fba:	e028      	b.n	801800e <lcp_ackci+0x442>
 8017fbc:	46c0      	nop			; (mov r8, r8)
 8017fbe:	e026      	b.n	801800e <lcp_ackci+0x442>
    ACKCILONG(CI_ASYNCMAP, go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF,
 8017fc0:	46c0      	nop			; (mov r8, r8)
 8017fc2:	e024      	b.n	801800e <lcp_ackci+0x442>
 8017fc4:	46c0      	nop			; (mov r8, r8)
 8017fc6:	e022      	b.n	801800e <lcp_ackci+0x442>
 8017fc8:	46c0      	nop			; (mov r8, r8)
 8017fca:	e020      	b.n	801800e <lcp_ackci+0x442>
    ACKCICHAR(CI_CALLBACK, go->neg_cbcp, CBCP_OPT);
 8017fcc:	46c0      	nop			; (mov r8, r8)
 8017fce:	e01e      	b.n	801800e <lcp_ackci+0x442>
 8017fd0:	46c0      	nop			; (mov r8, r8)
 8017fd2:	e01c      	b.n	801800e <lcp_ackci+0x442>
 8017fd4:	46c0      	nop			; (mov r8, r8)
 8017fd6:	e01a      	b.n	801800e <lcp_ackci+0x442>
    ACKCILONG(CI_MAGICNUMBER, go->neg_magicnumber, go->magicnumber);
 8017fd8:	46c0      	nop			; (mov r8, r8)
 8017fda:	e018      	b.n	801800e <lcp_ackci+0x442>
 8017fdc:	46c0      	nop			; (mov r8, r8)
 8017fde:	e016      	b.n	801800e <lcp_ackci+0x442>
 8017fe0:	46c0      	nop			; (mov r8, r8)
 8017fe2:	e014      	b.n	801800e <lcp_ackci+0x442>
    ACKCIVOID(CI_PCOMPRESSION, go->neg_pcompression);
 8017fe4:	46c0      	nop			; (mov r8, r8)
 8017fe6:	e012      	b.n	801800e <lcp_ackci+0x442>
 8017fe8:	46c0      	nop			; (mov r8, r8)
 8017fea:	e010      	b.n	801800e <lcp_ackci+0x442>
    ACKCIVOID(CI_ACCOMPRESSION, go->neg_accompression);
 8017fec:	46c0      	nop			; (mov r8, r8)
 8017fee:	e00e      	b.n	801800e <lcp_ackci+0x442>
 8017ff0:	46c0      	nop			; (mov r8, r8)
 8017ff2:	e00c      	b.n	801800e <lcp_ackci+0x442>
    ACKCIVOID(CI_SSNHF, go->neg_ssnhf);
 8017ff4:	46c0      	nop			; (mov r8, r8)
 8017ff6:	e00a      	b.n	801800e <lcp_ackci+0x442>
 8017ff8:	46c0      	nop			; (mov r8, r8)
 8017ffa:	e008      	b.n	801800e <lcp_ackci+0x442>
    ACKCIENDP(CI_EPDISC, go->neg_endpoint, go->endpoint.class_,
 8017ffc:	46c0      	nop			; (mov r8, r8)
 8017ffe:	e006      	b.n	801800e <lcp_ackci+0x442>
 8018000:	46c0      	nop			; (mov r8, r8)
 8018002:	e004      	b.n	801800e <lcp_ackci+0x442>
 8018004:	46c0      	nop			; (mov r8, r8)
 8018006:	e002      	b.n	801800e <lcp_ackci+0x442>
 8018008:	46c0      	nop			; (mov r8, r8)
 801800a:	e000      	b.n	801800e <lcp_ackci+0x442>
	goto bad;
 801800c:	46c0      	nop			; (mov r8, r8)
bad:
    LCPDEBUG(("lcp_acki: received bad Ack!"));
    return (0);
 801800e:	2300      	movs	r3, #0
}
 8018010:	0018      	movs	r0, r3
 8018012:	46bd      	mov	sp, r7
 8018014:	b00a      	add	sp, #40	; 0x28
 8018016:	bd80      	pop	{r7, pc}

08018018 <lcp_nakci>:
 *
 * Returns:
 *	0 - Nak was bad.
 *	1 - Nak was good.
 */
static int lcp_nakci(fsm *f, u_char *p, int len, int treat_as_reject) {
 8018018:	b5b0      	push	{r4, r5, r7, lr}
 801801a:	b0a0      	sub	sp, #128	; 0x80
 801801c:	af00      	add	r7, sp, #0
 801801e:	60f8      	str	r0, [r7, #12]
 8018020:	60b9      	str	r1, [r7, #8]
 8018022:	607a      	str	r2, [r7, #4]
 8018024:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 8018026:	68fb      	ldr	r3, [r7, #12]
 8018028:	681b      	ldr	r3, [r3, #0]
 801802a:	67bb      	str	r3, [r7, #120]	; 0x78
    lcp_options *go = &pcb->lcp_gotoptions;
 801802c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 801802e:	3368      	adds	r3, #104	; 0x68
 8018030:	677b      	str	r3, [r7, #116]	; 0x74
    lcp_options *wo = &pcb->lcp_wantoptions;
 8018032:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8018034:	3344      	adds	r3, #68	; 0x44
 8018036:	673b      	str	r3, [r7, #112]	; 0x70
    u_char citype, cichar, *next;
    u_short cishort;
    u32_t cilong;
    lcp_options no;		/* options we've seen Naks for */
    lcp_options try_;		/* options to request next time */
    int looped_back = 0;
 8018038:	2300      	movs	r3, #0
 801803a:	67fb      	str	r3, [r7, #124]	; 0x7c
    int cilen;

    BZERO(&no, sizeof(no));
 801803c:	2438      	movs	r4, #56	; 0x38
 801803e:	193b      	adds	r3, r7, r4
 8018040:	2224      	movs	r2, #36	; 0x24
 8018042:	2100      	movs	r1, #0
 8018044:	0018      	movs	r0, r3
 8018046:	f004 fbf1 	bl	801c82c <memset>
    try_ = *go;
 801804a:	2314      	movs	r3, #20
 801804c:	18fb      	adds	r3, r7, r3
 801804e:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8018050:	ca23      	ldmia	r2!, {r0, r1, r5}
 8018052:	c323      	stmia	r3!, {r0, r1, r5}
 8018054:	ca23      	ldmia	r2!, {r0, r1, r5}
 8018056:	c323      	stmia	r3!, {r0, r1, r5}
 8018058:	ca23      	ldmia	r2!, {r0, r1, r5}
 801805a:	c323      	stmia	r3!, {r0, r1, r5}
     * we want.  Therefore, accept any MRU less than what we asked for,
     * but then ignore the new value when setting the MRU in the kernel.
     * If they send us a bigger MRU than what we asked, accept it, up to
     * the limit of the default MRU we'd get if we didn't negotiate.
     */
    if (go->neg_mru && go->mru != PPP_DEFMRU) {
 801805c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801805e:	781b      	ldrb	r3, [r3, #0]
 8018060:	2204      	movs	r2, #4
 8018062:	4013      	ands	r3, r2
 8018064:	b2db      	uxtb	r3, r3
 8018066:	2b00      	cmp	r3, #0
 8018068:	d04a      	beq.n	8018100 <lcp_nakci+0xe8>
 801806a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801806c:	885b      	ldrh	r3, [r3, #2]
 801806e:	4a20      	ldr	r2, [pc, #128]	; (80180f0 <lcp_nakci+0xd8>)
 8018070:	4293      	cmp	r3, r2
 8018072:	d045      	beq.n	8018100 <lcp_nakci+0xe8>
	NAKCISHORT(CI_MRU, neg_mru,
 8018074:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018076:	781b      	ldrb	r3, [r3, #0]
 8018078:	2204      	movs	r2, #4
 801807a:	4013      	ands	r3, r2
 801807c:	b2db      	uxtb	r3, r3
 801807e:	2b00      	cmp	r3, #0
 8018080:	d03e      	beq.n	8018100 <lcp_nakci+0xe8>
 8018082:	687b      	ldr	r3, [r7, #4]
 8018084:	2b03      	cmp	r3, #3
 8018086:	dd3b      	ble.n	8018100 <lcp_nakci+0xe8>
 8018088:	68bb      	ldr	r3, [r7, #8]
 801808a:	3301      	adds	r3, #1
 801808c:	781b      	ldrb	r3, [r3, #0]
 801808e:	2b04      	cmp	r3, #4
 8018090:	d136      	bne.n	8018100 <lcp_nakci+0xe8>
 8018092:	68bb      	ldr	r3, [r7, #8]
 8018094:	781b      	ldrb	r3, [r3, #0]
 8018096:	2b01      	cmp	r3, #1
 8018098:	d132      	bne.n	8018100 <lcp_nakci+0xe8>
 801809a:	687b      	ldr	r3, [r7, #4]
 801809c:	3b04      	subs	r3, #4
 801809e:	607b      	str	r3, [r7, #4]
 80180a0:	68bb      	ldr	r3, [r7, #8]
 80180a2:	3302      	adds	r3, #2
 80180a4:	60bb      	str	r3, [r7, #8]
 80180a6:	68bb      	ldr	r3, [r7, #8]
 80180a8:	1c5a      	adds	r2, r3, #1
 80180aa:	60ba      	str	r2, [r7, #8]
 80180ac:	781b      	ldrb	r3, [r3, #0]
 80180ae:	b29a      	uxth	r2, r3
 80180b0:	206e      	movs	r0, #110	; 0x6e
 80180b2:	183b      	adds	r3, r7, r0
 80180b4:	0212      	lsls	r2, r2, #8
 80180b6:	801a      	strh	r2, [r3, #0]
 80180b8:	68bb      	ldr	r3, [r7, #8]
 80180ba:	1c5a      	adds	r2, r3, #1
 80180bc:	60ba      	str	r2, [r7, #8]
 80180be:	781b      	ldrb	r3, [r3, #0]
 80180c0:	b299      	uxth	r1, r3
 80180c2:	183b      	adds	r3, r7, r0
 80180c4:	183a      	adds	r2, r7, r0
 80180c6:	8812      	ldrh	r2, [r2, #0]
 80180c8:	430a      	orrs	r2, r1
 80180ca:	801a      	strh	r2, [r3, #0]
 80180cc:	193b      	adds	r3, r7, r4
 80180ce:	781a      	ldrb	r2, [r3, #0]
 80180d0:	2104      	movs	r1, #4
 80180d2:	430a      	orrs	r2, r1
 80180d4:	701a      	strb	r2, [r3, #0]
 80180d6:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80180d8:	885b      	ldrh	r3, [r3, #2]
 80180da:	183a      	adds	r2, r7, r0
 80180dc:	8812      	ldrh	r2, [r2, #0]
 80180de:	429a      	cmp	r2, r3
 80180e0:	d908      	bls.n	80180f4 <lcp_nakci+0xdc>
 80180e2:	183b      	adds	r3, r7, r0
 80180e4:	881b      	ldrh	r3, [r3, #0]
 80180e6:	4a02      	ldr	r2, [pc, #8]	; (80180f0 <lcp_nakci+0xd8>)
 80180e8:	4293      	cmp	r3, r2
 80180ea:	d809      	bhi.n	8018100 <lcp_nakci+0xe8>
 80180ec:	e002      	b.n	80180f4 <lcp_nakci+0xdc>
 80180ee:	46c0      	nop			; (mov r8, r8)
 80180f0:	000005dc 	.word	0x000005dc
 80180f4:	2314      	movs	r3, #20
 80180f6:	18fb      	adds	r3, r7, r3
 80180f8:	226e      	movs	r2, #110	; 0x6e
 80180fa:	18ba      	adds	r2, r7, r2
 80180fc:	8812      	ldrh	r2, [r2, #0]
 80180fe:	805a      	strh	r2, [r3, #2]
    }

    /*
     * Add any characters they want to our (receive-side) asyncmap.
     */
    if (go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF) {
 8018100:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018102:	781b      	ldrb	r3, [r3, #0]
 8018104:	2208      	movs	r2, #8
 8018106:	4013      	ands	r3, r2
 8018108:	b2db      	uxtb	r3, r3
 801810a:	2b00      	cmp	r3, #0
 801810c:	d04d      	beq.n	80181aa <lcp_nakci+0x192>
 801810e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018110:	685b      	ldr	r3, [r3, #4]
 8018112:	3301      	adds	r3, #1
 8018114:	d049      	beq.n	80181aa <lcp_nakci+0x192>
	NAKCILONG(CI_ASYNCMAP, neg_asyncmap,
 8018116:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018118:	781b      	ldrb	r3, [r3, #0]
 801811a:	2208      	movs	r2, #8
 801811c:	4013      	ands	r3, r2
 801811e:	b2db      	uxtb	r3, r3
 8018120:	2b00      	cmp	r3, #0
 8018122:	d042      	beq.n	80181aa <lcp_nakci+0x192>
 8018124:	687b      	ldr	r3, [r7, #4]
 8018126:	2b05      	cmp	r3, #5
 8018128:	dd3f      	ble.n	80181aa <lcp_nakci+0x192>
 801812a:	68bb      	ldr	r3, [r7, #8]
 801812c:	3301      	adds	r3, #1
 801812e:	781b      	ldrb	r3, [r3, #0]
 8018130:	2b06      	cmp	r3, #6
 8018132:	d13a      	bne.n	80181aa <lcp_nakci+0x192>
 8018134:	68bb      	ldr	r3, [r7, #8]
 8018136:	781b      	ldrb	r3, [r3, #0]
 8018138:	2b02      	cmp	r3, #2
 801813a:	d136      	bne.n	80181aa <lcp_nakci+0x192>
 801813c:	687b      	ldr	r3, [r7, #4]
 801813e:	3b06      	subs	r3, #6
 8018140:	607b      	str	r3, [r7, #4]
 8018142:	68bb      	ldr	r3, [r7, #8]
 8018144:	3302      	adds	r3, #2
 8018146:	60bb      	str	r3, [r7, #8]
 8018148:	68bb      	ldr	r3, [r7, #8]
 801814a:	1c5a      	adds	r2, r3, #1
 801814c:	60ba      	str	r2, [r7, #8]
 801814e:	781b      	ldrb	r3, [r3, #0]
 8018150:	021b      	lsls	r3, r3, #8
 8018152:	66bb      	str	r3, [r7, #104]	; 0x68
 8018154:	68bb      	ldr	r3, [r7, #8]
 8018156:	1c5a      	adds	r2, r3, #1
 8018158:	60ba      	str	r2, [r7, #8]
 801815a:	781b      	ldrb	r3, [r3, #0]
 801815c:	001a      	movs	r2, r3
 801815e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018160:	4313      	orrs	r3, r2
 8018162:	66bb      	str	r3, [r7, #104]	; 0x68
 8018164:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018166:	021b      	lsls	r3, r3, #8
 8018168:	66bb      	str	r3, [r7, #104]	; 0x68
 801816a:	68bb      	ldr	r3, [r7, #8]
 801816c:	1c5a      	adds	r2, r3, #1
 801816e:	60ba      	str	r2, [r7, #8]
 8018170:	781b      	ldrb	r3, [r3, #0]
 8018172:	001a      	movs	r2, r3
 8018174:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018176:	4313      	orrs	r3, r2
 8018178:	66bb      	str	r3, [r7, #104]	; 0x68
 801817a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801817c:	021b      	lsls	r3, r3, #8
 801817e:	66bb      	str	r3, [r7, #104]	; 0x68
 8018180:	68bb      	ldr	r3, [r7, #8]
 8018182:	1c5a      	adds	r2, r3, #1
 8018184:	60ba      	str	r2, [r7, #8]
 8018186:	781b      	ldrb	r3, [r3, #0]
 8018188:	001a      	movs	r2, r3
 801818a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801818c:	4313      	orrs	r3, r2
 801818e:	66bb      	str	r3, [r7, #104]	; 0x68
 8018190:	2338      	movs	r3, #56	; 0x38
 8018192:	18fb      	adds	r3, r7, r3
 8018194:	781a      	ldrb	r2, [r3, #0]
 8018196:	2108      	movs	r1, #8
 8018198:	430a      	orrs	r2, r1
 801819a:	701a      	strb	r2, [r3, #0]
 801819c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801819e:	685a      	ldr	r2, [r3, #4]
 80181a0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80181a2:	431a      	orrs	r2, r3
 80181a4:	2314      	movs	r3, #20
 80181a6:	18fb      	adds	r3, r7, r3
 80181a8:	605a      	str	r2, [r3, #4]
#endif /* LQR_SUPPORT */

    /*
     * Only implementing CBCP...not the rest of the callback options
     */
    NAKCICHAR(CI_CALLBACK, neg_cbcp,
 80181aa:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80181ac:	781b      	ldrb	r3, [r3, #0]
 80181ae:	227f      	movs	r2, #127	; 0x7f
 80181b0:	4393      	bics	r3, r2
 80181b2:	b2db      	uxtb	r3, r3
 80181b4:	2b00      	cmp	r3, #0
 80181b6:	d025      	beq.n	8018204 <lcp_nakci+0x1ec>
 80181b8:	687b      	ldr	r3, [r7, #4]
 80181ba:	2b02      	cmp	r3, #2
 80181bc:	dd22      	ble.n	8018204 <lcp_nakci+0x1ec>
 80181be:	68bb      	ldr	r3, [r7, #8]
 80181c0:	3301      	adds	r3, #1
 80181c2:	781b      	ldrb	r3, [r3, #0]
 80181c4:	2b03      	cmp	r3, #3
 80181c6:	d11d      	bne.n	8018204 <lcp_nakci+0x1ec>
 80181c8:	68bb      	ldr	r3, [r7, #8]
 80181ca:	781b      	ldrb	r3, [r3, #0]
 80181cc:	2b0d      	cmp	r3, #13
 80181ce:	d119      	bne.n	8018204 <lcp_nakci+0x1ec>
 80181d0:	687b      	ldr	r3, [r7, #4]
 80181d2:	3b03      	subs	r3, #3
 80181d4:	607b      	str	r3, [r7, #4]
 80181d6:	68bb      	ldr	r3, [r7, #8]
 80181d8:	3302      	adds	r3, #2
 80181da:	60bb      	str	r3, [r7, #8]
 80181dc:	68bb      	ldr	r3, [r7, #8]
 80181de:	1c5a      	adds	r2, r3, #1
 80181e0:	60ba      	str	r2, [r7, #8]
 80181e2:	2267      	movs	r2, #103	; 0x67
 80181e4:	18ba      	adds	r2, r7, r2
 80181e6:	781b      	ldrb	r3, [r3, #0]
 80181e8:	7013      	strb	r3, [r2, #0]
 80181ea:	2338      	movs	r3, #56	; 0x38
 80181ec:	18fb      	adds	r3, r7, r3
 80181ee:	781a      	ldrb	r2, [r3, #0]
 80181f0:	2180      	movs	r1, #128	; 0x80
 80181f2:	4249      	negs	r1, r1
 80181f4:	430a      	orrs	r2, r1
 80181f6:	701a      	strb	r2, [r3, #0]
 80181f8:	2314      	movs	r3, #20
 80181fa:	18fb      	adds	r3, r7, r3
 80181fc:	781a      	ldrb	r2, [r3, #0]
 80181fe:	217f      	movs	r1, #127	; 0x7f
 8018200:	400a      	ands	r2, r1
 8018202:	701a      	strb	r2, [r3, #0]
              );

    /*
     * Check for a looped-back line.
     */
    NAKCILONG(CI_MAGICNUMBER, neg_magicnumber,
 8018204:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018206:	781b      	ldrb	r3, [r3, #0]
 8018208:	2210      	movs	r2, #16
 801820a:	4013      	ands	r3, r2
 801820c:	b2db      	uxtb	r3, r3
 801820e:	2b00      	cmp	r3, #0
 8018210:	d043      	beq.n	801829a <lcp_nakci+0x282>
 8018212:	687b      	ldr	r3, [r7, #4]
 8018214:	2b05      	cmp	r3, #5
 8018216:	dd40      	ble.n	801829a <lcp_nakci+0x282>
 8018218:	68bb      	ldr	r3, [r7, #8]
 801821a:	3301      	adds	r3, #1
 801821c:	781b      	ldrb	r3, [r3, #0]
 801821e:	2b06      	cmp	r3, #6
 8018220:	d13b      	bne.n	801829a <lcp_nakci+0x282>
 8018222:	68bb      	ldr	r3, [r7, #8]
 8018224:	781b      	ldrb	r3, [r3, #0]
 8018226:	2b05      	cmp	r3, #5
 8018228:	d137      	bne.n	801829a <lcp_nakci+0x282>
 801822a:	687b      	ldr	r3, [r7, #4]
 801822c:	3b06      	subs	r3, #6
 801822e:	607b      	str	r3, [r7, #4]
 8018230:	68bb      	ldr	r3, [r7, #8]
 8018232:	3302      	adds	r3, #2
 8018234:	60bb      	str	r3, [r7, #8]
 8018236:	68bb      	ldr	r3, [r7, #8]
 8018238:	1c5a      	adds	r2, r3, #1
 801823a:	60ba      	str	r2, [r7, #8]
 801823c:	781b      	ldrb	r3, [r3, #0]
 801823e:	021b      	lsls	r3, r3, #8
 8018240:	66bb      	str	r3, [r7, #104]	; 0x68
 8018242:	68bb      	ldr	r3, [r7, #8]
 8018244:	1c5a      	adds	r2, r3, #1
 8018246:	60ba      	str	r2, [r7, #8]
 8018248:	781b      	ldrb	r3, [r3, #0]
 801824a:	001a      	movs	r2, r3
 801824c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801824e:	4313      	orrs	r3, r2
 8018250:	66bb      	str	r3, [r7, #104]	; 0x68
 8018252:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018254:	021b      	lsls	r3, r3, #8
 8018256:	66bb      	str	r3, [r7, #104]	; 0x68
 8018258:	68bb      	ldr	r3, [r7, #8]
 801825a:	1c5a      	adds	r2, r3, #1
 801825c:	60ba      	str	r2, [r7, #8]
 801825e:	781b      	ldrb	r3, [r3, #0]
 8018260:	001a      	movs	r2, r3
 8018262:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8018264:	4313      	orrs	r3, r2
 8018266:	66bb      	str	r3, [r7, #104]	; 0x68
 8018268:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801826a:	021b      	lsls	r3, r3, #8
 801826c:	66bb      	str	r3, [r7, #104]	; 0x68
 801826e:	68bb      	ldr	r3, [r7, #8]
 8018270:	1c5a      	adds	r2, r3, #1
 8018272:	60ba      	str	r2, [r7, #8]
 8018274:	781b      	ldrb	r3, [r3, #0]
 8018276:	001a      	movs	r2, r3
 8018278:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801827a:	4313      	orrs	r3, r2
 801827c:	66bb      	str	r3, [r7, #104]	; 0x68
 801827e:	2338      	movs	r3, #56	; 0x38
 8018280:	18fb      	adds	r3, r7, r3
 8018282:	781a      	ldrb	r2, [r3, #0]
 8018284:	2110      	movs	r1, #16
 8018286:	430a      	orrs	r2, r1
 8018288:	701a      	strb	r2, [r3, #0]
 801828a:	f001 f92b 	bl	80194e4 <magic>
 801828e:	0002      	movs	r2, r0
 8018290:	2314      	movs	r3, #20
 8018292:	18fb      	adds	r3, r7, r3
 8018294:	609a      	str	r2, [r3, #8]
 8018296:	2301      	movs	r3, #1
 8018298:	67fb      	str	r3, [r7, #124]	; 0x7c
    /*
     * Peer shouldn't send Nak for protocol compression or
     * address/control compression requests; they should send
     * a Reject instead.  If they send a Nak, treat it as a Reject.
     */
    NAKCIVOID(CI_PCOMPRESSION, neg_pcompression);
 801829a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801829c:	781b      	ldrb	r3, [r3, #0]
 801829e:	2220      	movs	r2, #32
 80182a0:	4013      	ands	r3, r2
 80182a2:	b2db      	uxtb	r3, r3
 80182a4:	2b00      	cmp	r3, #0
 80182a6:	d01d      	beq.n	80182e4 <lcp_nakci+0x2cc>
 80182a8:	687b      	ldr	r3, [r7, #4]
 80182aa:	2b01      	cmp	r3, #1
 80182ac:	dd1a      	ble.n	80182e4 <lcp_nakci+0x2cc>
 80182ae:	68bb      	ldr	r3, [r7, #8]
 80182b0:	3301      	adds	r3, #1
 80182b2:	781b      	ldrb	r3, [r3, #0]
 80182b4:	2b02      	cmp	r3, #2
 80182b6:	d115      	bne.n	80182e4 <lcp_nakci+0x2cc>
 80182b8:	68bb      	ldr	r3, [r7, #8]
 80182ba:	781b      	ldrb	r3, [r3, #0]
 80182bc:	2b07      	cmp	r3, #7
 80182be:	d111      	bne.n	80182e4 <lcp_nakci+0x2cc>
 80182c0:	687b      	ldr	r3, [r7, #4]
 80182c2:	3b02      	subs	r3, #2
 80182c4:	607b      	str	r3, [r7, #4]
 80182c6:	68bb      	ldr	r3, [r7, #8]
 80182c8:	3302      	adds	r3, #2
 80182ca:	60bb      	str	r3, [r7, #8]
 80182cc:	2338      	movs	r3, #56	; 0x38
 80182ce:	18fb      	adds	r3, r7, r3
 80182d0:	781a      	ldrb	r2, [r3, #0]
 80182d2:	2120      	movs	r1, #32
 80182d4:	430a      	orrs	r2, r1
 80182d6:	701a      	strb	r2, [r3, #0]
 80182d8:	2314      	movs	r3, #20
 80182da:	18fb      	adds	r3, r7, r3
 80182dc:	781a      	ldrb	r2, [r3, #0]
 80182de:	2120      	movs	r1, #32
 80182e0:	438a      	bics	r2, r1
 80182e2:	701a      	strb	r2, [r3, #0]
    NAKCIVOID(CI_ACCOMPRESSION, neg_accompression);
 80182e4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80182e6:	781b      	ldrb	r3, [r3, #0]
 80182e8:	2240      	movs	r2, #64	; 0x40
 80182ea:	4013      	ands	r3, r2
 80182ec:	b2db      	uxtb	r3, r3
 80182ee:	2b00      	cmp	r3, #0
 80182f0:	d01d      	beq.n	801832e <lcp_nakci+0x316>
 80182f2:	687b      	ldr	r3, [r7, #4]
 80182f4:	2b01      	cmp	r3, #1
 80182f6:	dd1a      	ble.n	801832e <lcp_nakci+0x316>
 80182f8:	68bb      	ldr	r3, [r7, #8]
 80182fa:	3301      	adds	r3, #1
 80182fc:	781b      	ldrb	r3, [r3, #0]
 80182fe:	2b02      	cmp	r3, #2
 8018300:	d115      	bne.n	801832e <lcp_nakci+0x316>
 8018302:	68bb      	ldr	r3, [r7, #8]
 8018304:	781b      	ldrb	r3, [r3, #0]
 8018306:	2b08      	cmp	r3, #8
 8018308:	d111      	bne.n	801832e <lcp_nakci+0x316>
 801830a:	687b      	ldr	r3, [r7, #4]
 801830c:	3b02      	subs	r3, #2
 801830e:	607b      	str	r3, [r7, #4]
 8018310:	68bb      	ldr	r3, [r7, #8]
 8018312:	3302      	adds	r3, #2
 8018314:	60bb      	str	r3, [r7, #8]
 8018316:	2338      	movs	r3, #56	; 0x38
 8018318:	18fb      	adds	r3, r7, r3
 801831a:	781a      	ldrb	r2, [r3, #0]
 801831c:	2140      	movs	r1, #64	; 0x40
 801831e:	430a      	orrs	r2, r1
 8018320:	701a      	strb	r2, [r3, #0]
 8018322:	2314      	movs	r3, #20
 8018324:	18fb      	adds	r3, r7, r3
 8018326:	781a      	ldrb	r2, [r3, #0]
 8018328:	2140      	movs	r1, #64	; 0x40
 801832a:	438a      	bics	r2, r1
 801832c:	701a      	strb	r2, [r3, #0]

    /*
     * Nak for short sequence numbers shouldn't be sent, treat it
     * like a reject.
     */
    NAKCIVOID(CI_SSNHF, neg_ssnhf);
 801832e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018330:	785b      	ldrb	r3, [r3, #1]
 8018332:	2201      	movs	r2, #1
 8018334:	4013      	ands	r3, r2
 8018336:	b2db      	uxtb	r3, r3
 8018338:	2b00      	cmp	r3, #0
 801833a:	d01d      	beq.n	8018378 <lcp_nakci+0x360>
 801833c:	687b      	ldr	r3, [r7, #4]
 801833e:	2b01      	cmp	r3, #1
 8018340:	dd1a      	ble.n	8018378 <lcp_nakci+0x360>
 8018342:	68bb      	ldr	r3, [r7, #8]
 8018344:	3301      	adds	r3, #1
 8018346:	781b      	ldrb	r3, [r3, #0]
 8018348:	2b02      	cmp	r3, #2
 801834a:	d115      	bne.n	8018378 <lcp_nakci+0x360>
 801834c:	68bb      	ldr	r3, [r7, #8]
 801834e:	781b      	ldrb	r3, [r3, #0]
 8018350:	2b12      	cmp	r3, #18
 8018352:	d111      	bne.n	8018378 <lcp_nakci+0x360>
 8018354:	687b      	ldr	r3, [r7, #4]
 8018356:	3b02      	subs	r3, #2
 8018358:	607b      	str	r3, [r7, #4]
 801835a:	68bb      	ldr	r3, [r7, #8]
 801835c:	3302      	adds	r3, #2
 801835e:	60bb      	str	r3, [r7, #8]
 8018360:	2338      	movs	r3, #56	; 0x38
 8018362:	18fb      	adds	r3, r7, r3
 8018364:	785a      	ldrb	r2, [r3, #1]
 8018366:	2101      	movs	r1, #1
 8018368:	430a      	orrs	r2, r1
 801836a:	705a      	strb	r2, [r3, #1]
 801836c:	2314      	movs	r3, #20
 801836e:	18fb      	adds	r3, r7, r3
 8018370:	785a      	ldrb	r2, [r3, #1]
 8018372:	2101      	movs	r1, #1
 8018374:	438a      	bics	r2, r1
 8018376:	705a      	strb	r2, [r3, #1]

    /*
     * Nak of the endpoint discriminator option is not permitted,
     * treat it like a reject.
     */
    NAKCIENDP(CI_EPDISC, neg_endpoint);
 8018378:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801837a:	785b      	ldrb	r3, [r3, #1]
 801837c:	2202      	movs	r2, #2
 801837e:	4013      	ands	r3, r2
 8018380:	b2db      	uxtb	r3, r3
 8018382:	2b00      	cmp	r3, #0
 8018384:	d100      	bne.n	8018388 <lcp_nakci+0x370>
 8018386:	e12b      	b.n	80185e0 <lcp_nakci+0x5c8>
 8018388:	687b      	ldr	r3, [r7, #4]
 801838a:	2b02      	cmp	r3, #2
 801838c:	dc00      	bgt.n	8018390 <lcp_nakci+0x378>
 801838e:	e127      	b.n	80185e0 <lcp_nakci+0x5c8>
 8018390:	68bb      	ldr	r3, [r7, #8]
 8018392:	781b      	ldrb	r3, [r3, #0]
 8018394:	2b13      	cmp	r3, #19
 8018396:	d000      	beq.n	801839a <lcp_nakci+0x382>
 8018398:	e122      	b.n	80185e0 <lcp_nakci+0x5c8>
 801839a:	68bb      	ldr	r3, [r7, #8]
 801839c:	3301      	adds	r3, #1
 801839e:	781b      	ldrb	r3, [r3, #0]
 80183a0:	2b02      	cmp	r3, #2
 80183a2:	d800      	bhi.n	80183a6 <lcp_nakci+0x38e>
 80183a4:	e11c      	b.n	80185e0 <lcp_nakci+0x5c8>
 80183a6:	68bb      	ldr	r3, [r7, #8]
 80183a8:	3301      	adds	r3, #1
 80183aa:	781b      	ldrb	r3, [r3, #0]
 80183ac:	001a      	movs	r2, r3
 80183ae:	687b      	ldr	r3, [r7, #4]
 80183b0:	4293      	cmp	r3, r2
 80183b2:	da00      	bge.n	80183b6 <lcp_nakci+0x39e>
 80183b4:	e114      	b.n	80185e0 <lcp_nakci+0x5c8>
 80183b6:	68bb      	ldr	r3, [r7, #8]
 80183b8:	3301      	adds	r3, #1
 80183ba:	781b      	ldrb	r3, [r3, #0]
 80183bc:	001a      	movs	r2, r3
 80183be:	687b      	ldr	r3, [r7, #4]
 80183c0:	1a9b      	subs	r3, r3, r2
 80183c2:	607b      	str	r3, [r7, #4]
 80183c4:	68bb      	ldr	r3, [r7, #8]
 80183c6:	3301      	adds	r3, #1
 80183c8:	781b      	ldrb	r3, [r3, #0]
 80183ca:	001a      	movs	r2, r3
 80183cc:	68bb      	ldr	r3, [r7, #8]
 80183ce:	189b      	adds	r3, r3, r2
 80183d0:	60bb      	str	r3, [r7, #8]
 80183d2:	2338      	movs	r3, #56	; 0x38
 80183d4:	18fb      	adds	r3, r7, r3
 80183d6:	785a      	ldrb	r2, [r3, #1]
 80183d8:	2102      	movs	r1, #2
 80183da:	430a      	orrs	r2, r1
 80183dc:	705a      	strb	r2, [r3, #1]
 80183de:	2314      	movs	r3, #20
 80183e0:	18fb      	adds	r3, r7, r3
 80183e2:	785a      	ldrb	r2, [r3, #1]
 80183e4:	2102      	movs	r1, #2
 80183e6:	438a      	bics	r2, r1
 80183e8:	705a      	strb	r2, [r3, #1]
     * For the quality protocol, the Nak means `ask me to send you quality
     * reports', but if we didn't ask for them, we don't want them.
     * An option we don't recognize represents the peer asking to
     * negotiate some option we don't support, so ignore it.
     */
    while (len >= CILEN_VOID) {
 80183ea:	e0f9      	b.n	80185e0 <lcp_nakci+0x5c8>
	GETCHAR(citype, p);
 80183ec:	68bb      	ldr	r3, [r7, #8]
 80183ee:	1c5a      	adds	r2, r3, #1
 80183f0:	60ba      	str	r2, [r7, #8]
 80183f2:	2166      	movs	r1, #102	; 0x66
 80183f4:	187a      	adds	r2, r7, r1
 80183f6:	781b      	ldrb	r3, [r3, #0]
 80183f8:	7013      	strb	r3, [r2, #0]
	GETCHAR(cilen, p);
 80183fa:	68bb      	ldr	r3, [r7, #8]
 80183fc:	1c5a      	adds	r2, r3, #1
 80183fe:	60ba      	str	r2, [r7, #8]
 8018400:	781b      	ldrb	r3, [r3, #0]
 8018402:	663b      	str	r3, [r7, #96]	; 0x60
	if (cilen < CILEN_VOID || (len -= cilen) < 0)
 8018404:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8018406:	2b01      	cmp	r3, #1
 8018408:	dc00      	bgt.n	801840c <lcp_nakci+0x3f4>
 801840a:	e120      	b.n	801864e <lcp_nakci+0x636>
 801840c:	687a      	ldr	r2, [r7, #4]
 801840e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8018410:	1ad3      	subs	r3, r2, r3
 8018412:	607b      	str	r3, [r7, #4]
 8018414:	687b      	ldr	r3, [r7, #4]
 8018416:	2b00      	cmp	r3, #0
 8018418:	da00      	bge.n	801841c <lcp_nakci+0x404>
 801841a:	e118      	b.n	801864e <lcp_nakci+0x636>
	    goto bad;
	next = p + cilen - 2;
 801841c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801841e:	3b02      	subs	r3, #2
 8018420:	68ba      	ldr	r2, [r7, #8]
 8018422:	18d3      	adds	r3, r2, r3
 8018424:	65fb      	str	r3, [r7, #92]	; 0x5c

	switch (citype) {
 8018426:	187b      	adds	r3, r7, r1
 8018428:	781b      	ldrb	r3, [r3, #0]
 801842a:	2b13      	cmp	r3, #19
 801842c:	d900      	bls.n	8018430 <lcp_nakci+0x418>
 801842e:	e0ca      	b.n	80185c6 <lcp_nakci+0x5ae>
 8018430:	009a      	lsls	r2, r3, #2
 8018432:	4b91      	ldr	r3, [pc, #580]	; (8018678 <lcp_nakci+0x660>)
 8018434:	18d3      	adds	r3, r2, r3
 8018436:	681b      	ldr	r3, [r3, #0]
 8018438:	469f      	mov	pc, r3
	case CI_MRU:
	    if ((go->neg_mru && go->mru != PPP_DEFMRU)
 801843a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801843c:	781b      	ldrb	r3, [r3, #0]
 801843e:	2204      	movs	r2, #4
 8018440:	4013      	ands	r3, r2
 8018442:	b2db      	uxtb	r3, r3
 8018444:	2b00      	cmp	r3, #0
 8018446:	d005      	beq.n	8018454 <lcp_nakci+0x43c>
 8018448:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801844a:	885b      	ldrh	r3, [r3, #2]
 801844c:	4a8b      	ldr	r2, [pc, #556]	; (801867c <lcp_nakci+0x664>)
 801844e:	4293      	cmp	r3, r2
 8018450:	d000      	beq.n	8018454 <lcp_nakci+0x43c>
 8018452:	e0fe      	b.n	8018652 <lcp_nakci+0x63a>
		|| no.neg_mru || cilen != CILEN_SHORT)
 8018454:	2338      	movs	r3, #56	; 0x38
 8018456:	18fb      	adds	r3, r7, r3
 8018458:	781b      	ldrb	r3, [r3, #0]
 801845a:	2204      	movs	r2, #4
 801845c:	4013      	ands	r3, r2
 801845e:	b2db      	uxtb	r3, r3
 8018460:	2b00      	cmp	r3, #0
 8018462:	d000      	beq.n	8018466 <lcp_nakci+0x44e>
 8018464:	e0f5      	b.n	8018652 <lcp_nakci+0x63a>
 8018466:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8018468:	2b04      	cmp	r3, #4
 801846a:	d000      	beq.n	801846e <lcp_nakci+0x456>
 801846c:	e0f1      	b.n	8018652 <lcp_nakci+0x63a>
		goto bad;
	    GETSHORT(cishort, p);
 801846e:	68bb      	ldr	r3, [r7, #8]
 8018470:	1c5a      	adds	r2, r3, #1
 8018472:	60ba      	str	r2, [r7, #8]
 8018474:	781b      	ldrb	r3, [r3, #0]
 8018476:	b29a      	uxth	r2, r3
 8018478:	206e      	movs	r0, #110	; 0x6e
 801847a:	183b      	adds	r3, r7, r0
 801847c:	0212      	lsls	r2, r2, #8
 801847e:	801a      	strh	r2, [r3, #0]
 8018480:	68bb      	ldr	r3, [r7, #8]
 8018482:	1c5a      	adds	r2, r3, #1
 8018484:	60ba      	str	r2, [r7, #8]
 8018486:	781b      	ldrb	r3, [r3, #0]
 8018488:	b299      	uxth	r1, r3
 801848a:	183b      	adds	r3, r7, r0
 801848c:	183a      	adds	r2, r7, r0
 801848e:	8812      	ldrh	r2, [r2, #0]
 8018490:	430a      	orrs	r2, r1
 8018492:	801a      	strh	r2, [r3, #0]
	    if (cishort < PPP_DEFMRU) {
 8018494:	183b      	adds	r3, r7, r0
 8018496:	881b      	ldrh	r3, [r3, #0]
 8018498:	4a79      	ldr	r2, [pc, #484]	; (8018680 <lcp_nakci+0x668>)
 801849a:	4293      	cmp	r3, r2
 801849c:	d900      	bls.n	80184a0 <lcp_nakci+0x488>
 801849e:	e094      	b.n	80185ca <lcp_nakci+0x5b2>
		try_.neg_mru = 1;
 80184a0:	2414      	movs	r4, #20
 80184a2:	193b      	adds	r3, r7, r4
 80184a4:	781a      	ldrb	r2, [r3, #0]
 80184a6:	2104      	movs	r1, #4
 80184a8:	430a      	orrs	r2, r1
 80184aa:	701a      	strb	r2, [r3, #0]
		try_.mru = cishort;
 80184ac:	193b      	adds	r3, r7, r4
 80184ae:	183a      	adds	r2, r7, r0
 80184b0:	8812      	ldrh	r2, [r2, #0]
 80184b2:	805a      	strh	r2, [r3, #2]
	    }
	    break;
 80184b4:	e089      	b.n	80185ca <lcp_nakci+0x5b2>
	case CI_ASYNCMAP:
	    if ((go->neg_asyncmap && go->asyncmap != 0xFFFFFFFF)
 80184b6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80184b8:	781b      	ldrb	r3, [r3, #0]
 80184ba:	2208      	movs	r2, #8
 80184bc:	4013      	ands	r3, r2
 80184be:	b2db      	uxtb	r3, r3
 80184c0:	2b00      	cmp	r3, #0
 80184c2:	d004      	beq.n	80184ce <lcp_nakci+0x4b6>
 80184c4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80184c6:	685b      	ldr	r3, [r3, #4]
 80184c8:	3301      	adds	r3, #1
 80184ca:	d000      	beq.n	80184ce <lcp_nakci+0x4b6>
 80184cc:	e0c3      	b.n	8018656 <lcp_nakci+0x63e>
		|| no.neg_asyncmap || cilen != CILEN_LONG)
 80184ce:	2338      	movs	r3, #56	; 0x38
 80184d0:	18fb      	adds	r3, r7, r3
 80184d2:	781b      	ldrb	r3, [r3, #0]
 80184d4:	2208      	movs	r2, #8
 80184d6:	4013      	ands	r3, r2
 80184d8:	b2db      	uxtb	r3, r3
 80184da:	2b00      	cmp	r3, #0
 80184dc:	d000      	beq.n	80184e0 <lcp_nakci+0x4c8>
 80184de:	e0ba      	b.n	8018656 <lcp_nakci+0x63e>
 80184e0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80184e2:	2b06      	cmp	r3, #6
 80184e4:	d100      	bne.n	80184e8 <lcp_nakci+0x4d0>
 80184e6:	e072      	b.n	80185ce <lcp_nakci+0x5b6>
		goto bad;
 80184e8:	e0b5      	b.n	8018656 <lcp_nakci+0x63e>
#endif /* EAP_SUPPORT */
		)
		goto bad;
	    break;
	case CI_MAGICNUMBER:
	    if (go->neg_magicnumber || no.neg_magicnumber ||
 80184ea:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80184ec:	781b      	ldrb	r3, [r3, #0]
 80184ee:	2210      	movs	r2, #16
 80184f0:	4013      	ands	r3, r2
 80184f2:	b2db      	uxtb	r3, r3
 80184f4:	2b00      	cmp	r3, #0
 80184f6:	d000      	beq.n	80184fa <lcp_nakci+0x4e2>
 80184f8:	e0af      	b.n	801865a <lcp_nakci+0x642>
 80184fa:	2338      	movs	r3, #56	; 0x38
 80184fc:	18fb      	adds	r3, r7, r3
 80184fe:	781b      	ldrb	r3, [r3, #0]
 8018500:	2210      	movs	r2, #16
 8018502:	4013      	ands	r3, r2
 8018504:	b2db      	uxtb	r3, r3
 8018506:	2b00      	cmp	r3, #0
 8018508:	d000      	beq.n	801850c <lcp_nakci+0x4f4>
 801850a:	e0a6      	b.n	801865a <lcp_nakci+0x642>
 801850c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801850e:	2b06      	cmp	r3, #6
 8018510:	d05f      	beq.n	80185d2 <lcp_nakci+0x5ba>
		cilen != CILEN_LONG)
		goto bad;
 8018512:	e0a2      	b.n	801865a <lcp_nakci+0x642>
	    break;
	case CI_PCOMPRESSION:
	    if (go->neg_pcompression || no.neg_pcompression
 8018514:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018516:	781b      	ldrb	r3, [r3, #0]
 8018518:	2220      	movs	r2, #32
 801851a:	4013      	ands	r3, r2
 801851c:	b2db      	uxtb	r3, r3
 801851e:	2b00      	cmp	r3, #0
 8018520:	d000      	beq.n	8018524 <lcp_nakci+0x50c>
 8018522:	e09c      	b.n	801865e <lcp_nakci+0x646>
 8018524:	2338      	movs	r3, #56	; 0x38
 8018526:	18fb      	adds	r3, r7, r3
 8018528:	781b      	ldrb	r3, [r3, #0]
 801852a:	2220      	movs	r2, #32
 801852c:	4013      	ands	r3, r2
 801852e:	b2db      	uxtb	r3, r3
 8018530:	2b00      	cmp	r3, #0
 8018532:	d000      	beq.n	8018536 <lcp_nakci+0x51e>
 8018534:	e093      	b.n	801865e <lcp_nakci+0x646>
		|| cilen != CILEN_VOID)
 8018536:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8018538:	2b02      	cmp	r3, #2
 801853a:	d04c      	beq.n	80185d6 <lcp_nakci+0x5be>
		goto bad;
 801853c:	e08f      	b.n	801865e <lcp_nakci+0x646>
	    break;
	case CI_ACCOMPRESSION:
	    if (go->neg_accompression || no.neg_accompression
 801853e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8018540:	781b      	ldrb	r3, [r3, #0]
 8018542:	2240      	movs	r2, #64	; 0x40
 8018544:	4013      	ands	r3, r2
 8018546:	b2db      	uxtb	r3, r3
 8018548:	2b00      	cmp	r3, #0
 801854a:	d000      	beq.n	801854e <lcp_nakci+0x536>
 801854c:	e089      	b.n	8018662 <lcp_nakci+0x64a>
 801854e:	2338      	movs	r3, #56	; 0x38
 8018550:	18fb      	adds	r3, r7, r3
 8018552:	781b      	ldrb	r3, [r3, #0]
 8018554:	2240      	movs	r2, #64	; 0x40
 8018556:	4013      	ands	r3, r2
 8018558:	b2db      	uxtb	r3, r3
 801855a:	2b00      	cmp	r3, #0
 801855c:	d000      	beq.n	8018560 <lcp_nakci+0x548>
 801855e:	e080      	b.n	8018662 <lcp_nakci+0x64a>
		|| cilen != CILEN_VOID)
 8018560:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8018562:	2b02      	cmp	r3, #2
 8018564:	d039      	beq.n	80185da <lcp_nakci+0x5c2>
		goto bad;
 8018566:	e07c      	b.n	8018662 <lcp_nakci+0x64a>
	    if (go->neg_mrru || no.neg_mrru || cilen != CILEN_SHORT)
		goto bad;
	    break;
#endif /* HAVE_MULTILINK */
	case CI_SSNHF:
	    if (go->neg_ssnhf || no.neg_ssnhf || cilen != CILEN_VOID)
 8018568:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801856a:	785b      	ldrb	r3, [r3, #1]
 801856c:	2201      	movs	r2, #1
 801856e:	4013      	ands	r3, r2
 8018570:	b2db      	uxtb	r3, r3
 8018572:	2b00      	cmp	r3, #0
 8018574:	d000      	beq.n	8018578 <lcp_nakci+0x560>
 8018576:	e076      	b.n	8018666 <lcp_nakci+0x64e>
 8018578:	2338      	movs	r3, #56	; 0x38
 801857a:	18fb      	adds	r3, r7, r3
 801857c:	785b      	ldrb	r3, [r3, #1]
 801857e:	2201      	movs	r2, #1
 8018580:	4013      	ands	r3, r2
 8018582:	b2db      	uxtb	r3, r3
 8018584:	2b00      	cmp	r3, #0
 8018586:	d000      	beq.n	801858a <lcp_nakci+0x572>
 8018588:	e06d      	b.n	8018666 <lcp_nakci+0x64e>
 801858a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801858c:	2b02      	cmp	r3, #2
 801858e:	d000      	beq.n	8018592 <lcp_nakci+0x57a>
 8018590:	e069      	b.n	8018666 <lcp_nakci+0x64e>
		goto bad;
	    try_.neg_ssnhf = 1;
 8018592:	2314      	movs	r3, #20
 8018594:	18fb      	adds	r3, r7, r3
 8018596:	785a      	ldrb	r2, [r3, #1]
 8018598:	2101      	movs	r1, #1
 801859a:	430a      	orrs	r2, r1
 801859c:	705a      	strb	r2, [r3, #1]
	    break;
 801859e:	e01d      	b.n	80185dc <lcp_nakci+0x5c4>
	case CI_EPDISC:
	    if (go->neg_endpoint || no.neg_endpoint || cilen < CILEN_CHAR)
 80185a0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80185a2:	785b      	ldrb	r3, [r3, #1]
 80185a4:	2202      	movs	r2, #2
 80185a6:	4013      	ands	r3, r2
 80185a8:	b2db      	uxtb	r3, r3
 80185aa:	2b00      	cmp	r3, #0
 80185ac:	d15d      	bne.n	801866a <lcp_nakci+0x652>
 80185ae:	2338      	movs	r3, #56	; 0x38
 80185b0:	18fb      	adds	r3, r7, r3
 80185b2:	785b      	ldrb	r3, [r3, #1]
 80185b4:	2202      	movs	r2, #2
 80185b6:	4013      	ands	r3, r2
 80185b8:	b2db      	uxtb	r3, r3
 80185ba:	2b00      	cmp	r3, #0
 80185bc:	d155      	bne.n	801866a <lcp_nakci+0x652>
 80185be:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80185c0:	2b02      	cmp	r3, #2
 80185c2:	dd52      	ble.n	801866a <lcp_nakci+0x652>
		goto bad;
	    break;
 80185c4:	e00a      	b.n	80185dc <lcp_nakci+0x5c4>
	default:
	    break;
 80185c6:	46c0      	nop			; (mov r8, r8)
 80185c8:	e008      	b.n	80185dc <lcp_nakci+0x5c4>
	    break;
 80185ca:	46c0      	nop			; (mov r8, r8)
 80185cc:	e006      	b.n	80185dc <lcp_nakci+0x5c4>
	    break;
 80185ce:	46c0      	nop			; (mov r8, r8)
 80185d0:	e004      	b.n	80185dc <lcp_nakci+0x5c4>
	    break;
 80185d2:	46c0      	nop			; (mov r8, r8)
 80185d4:	e002      	b.n	80185dc <lcp_nakci+0x5c4>
	    break;
 80185d6:	46c0      	nop			; (mov r8, r8)
 80185d8:	e000      	b.n	80185dc <lcp_nakci+0x5c4>
	    break;
 80185da:	46c0      	nop			; (mov r8, r8)
	}
	p = next;
 80185dc:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80185de:	60bb      	str	r3, [r7, #8]
    while (len >= CILEN_VOID) {
 80185e0:	687b      	ldr	r3, [r7, #4]
 80185e2:	2b01      	cmp	r3, #1
 80185e4:	dd00      	ble.n	80185e8 <lcp_nakci+0x5d0>
 80185e6:	e701      	b.n	80183ec <lcp_nakci+0x3d4>

    /*
     * OK, the Nak is good.  Now we can update state.
     * If there are any options left we ignore them.
     */
    if (f->state != PPP_FSM_OPENED) {
 80185e8:	68fb      	ldr	r3, [r7, #12]
 80185ea:	7c1b      	ldrb	r3, [r3, #16]
 80185ec:	2b09      	cmp	r3, #9
 80185ee:	d02c      	beq.n	801864a <lcp_nakci+0x632>
	if (looped_back) {
 80185f0:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80185f2:	2b00      	cmp	r3, #0
 80185f4:	d01c      	beq.n	8018630 <lcp_nakci+0x618>
	    if (++try_.numloops >= pcb->settings.lcp_loopbackfail) {
 80185f6:	2114      	movs	r1, #20
 80185f8:	187b      	adds	r3, r7, r1
 80185fa:	7b1b      	ldrb	r3, [r3, #12]
 80185fc:	3301      	adds	r3, #1
 80185fe:	b2da      	uxtb	r2, r3
 8018600:	187b      	adds	r3, r7, r1
 8018602:	731a      	strb	r2, [r3, #12]
 8018604:	187b      	adds	r3, r7, r1
 8018606:	7b1a      	ldrb	r2, [r3, #12]
 8018608:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 801860a:	7a1b      	ldrb	r3, [r3, #8]
 801860c:	429a      	cmp	r2, r3
 801860e:	d313      	bcc.n	8018638 <lcp_nakci+0x620>
		ppp_notice("Serial line is looped back.");
 8018610:	4b1c      	ldr	r3, [pc, #112]	; (8018684 <lcp_nakci+0x66c>)
 8018612:	0018      	movs	r0, r3
 8018614:	f002 fdb7 	bl	801b186 <ppp_notice>
		pcb->err_code = PPPERR_LOOPBACK;
 8018618:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 801861a:	2225      	movs	r2, #37	; 0x25
 801861c:	210c      	movs	r1, #12
 801861e:	5499      	strb	r1, [r3, r2]
		lcp_close(f->pcb, "Loopback detected");
 8018620:	68fb      	ldr	r3, [r7, #12]
 8018622:	681b      	ldr	r3, [r3, #0]
 8018624:	4a18      	ldr	r2, [pc, #96]	; (8018688 <lcp_nakci+0x670>)
 8018626:	0011      	movs	r1, r2
 8018628:	0018      	movs	r0, r3
 801862a:	f7fe ff03 	bl	8017434 <lcp_close>
 801862e:	e003      	b.n	8018638 <lcp_nakci+0x620>
	    }
	} else
	    try_.numloops = 0;
 8018630:	2314      	movs	r3, #20
 8018632:	18fb      	adds	r3, r7, r3
 8018634:	2200      	movs	r2, #0
 8018636:	731a      	strb	r2, [r3, #12]
	*go = try_;
 8018638:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801863a:	2214      	movs	r2, #20
 801863c:	18ba      	adds	r2, r7, r2
 801863e:	ca13      	ldmia	r2!, {r0, r1, r4}
 8018640:	c313      	stmia	r3!, {r0, r1, r4}
 8018642:	ca13      	ldmia	r2!, {r0, r1, r4}
 8018644:	c313      	stmia	r3!, {r0, r1, r4}
 8018646:	ca13      	ldmia	r2!, {r0, r1, r4}
 8018648:	c313      	stmia	r3!, {r0, r1, r4}
    }

    return 1;
 801864a:	2301      	movs	r3, #1
 801864c:	e00f      	b.n	801866e <lcp_nakci+0x656>
	    goto bad;
 801864e:	46c0      	nop			; (mov r8, r8)
 8018650:	e00c      	b.n	801866c <lcp_nakci+0x654>
		goto bad;
 8018652:	46c0      	nop			; (mov r8, r8)
 8018654:	e00a      	b.n	801866c <lcp_nakci+0x654>
		goto bad;
 8018656:	46c0      	nop			; (mov r8, r8)
 8018658:	e008      	b.n	801866c <lcp_nakci+0x654>
		goto bad;
 801865a:	46c0      	nop			; (mov r8, r8)
 801865c:	e006      	b.n	801866c <lcp_nakci+0x654>
		goto bad;
 801865e:	46c0      	nop			; (mov r8, r8)
 8018660:	e004      	b.n	801866c <lcp_nakci+0x654>
		goto bad;
 8018662:	46c0      	nop			; (mov r8, r8)
 8018664:	e002      	b.n	801866c <lcp_nakci+0x654>
		goto bad;
 8018666:	46c0      	nop			; (mov r8, r8)
 8018668:	e000      	b.n	801866c <lcp_nakci+0x654>
		goto bad;
 801866a:	46c0      	nop			; (mov r8, r8)

bad:
    LCPDEBUG(("lcp_nakci: received bad Nak!"));
    return 0;
 801866c:	2300      	movs	r3, #0
}
 801866e:	0018      	movs	r0, r3
 8018670:	46bd      	mov	sp, r7
 8018672:	b020      	add	sp, #128	; 0x80
 8018674:	bdb0      	pop	{r4, r5, r7, pc}
 8018676:	46c0      	nop			; (mov r8, r8)
 8018678:	08021c0c 	.word	0x08021c0c
 801867c:	000005dc 	.word	0x000005dc
 8018680:	000005db 	.word	0x000005db
 8018684:	08021168 	.word	0x08021168
 8018688:	08021184 	.word	0x08021184

0801868c <lcp_rejci>:
 *
 * Returns:
 *	0 - Reject was bad.
 *	1 - Reject was good.
 */
static int lcp_rejci(fsm *f, u_char *p, int len) {
 801868c:	b5b0      	push	{r4, r5, r7, lr}
 801868e:	b094      	sub	sp, #80	; 0x50
 8018690:	af00      	add	r7, sp, #0
 8018692:	60f8      	str	r0, [r7, #12]
 8018694:	60b9      	str	r1, [r7, #8]
 8018696:	607a      	str	r2, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8018698:	68fb      	ldr	r3, [r7, #12]
 801869a:	681b      	ldr	r3, [r3, #0]
 801869c:	64bb      	str	r3, [r7, #72]	; 0x48
    lcp_options *go = &pcb->lcp_gotoptions;
 801869e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80186a0:	3368      	adds	r3, #104	; 0x68
 80186a2:	647b      	str	r3, [r7, #68]	; 0x44
    u_char cichar;
    u_short cishort;
    u32_t cilong;
    lcp_options try_;		/* options to request next time */

    try_ = *go;
 80186a4:	2414      	movs	r4, #20
 80186a6:	193b      	adds	r3, r7, r4
 80186a8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80186aa:	ca23      	ldmia	r2!, {r0, r1, r5}
 80186ac:	c323      	stmia	r3!, {r0, r1, r5}
 80186ae:	ca23      	ldmia	r2!, {r0, r1, r5}
 80186b0:	c323      	stmia	r3!, {r0, r1, r5}
 80186b2:	ca23      	ldmia	r2!, {r0, r1, r5}
 80186b4:	c323      	stmia	r3!, {r0, r1, r5}
		goto bad; \
	} \
	try_.neg = 0; \
    }

    REJCISHORT(CI_MRU, neg_mru, go->mru);
 80186b6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80186b8:	781b      	ldrb	r3, [r3, #0]
 80186ba:	2204      	movs	r2, #4
 80186bc:	4013      	ands	r3, r2
 80186be:	b2db      	uxtb	r3, r3
 80186c0:	2b00      	cmp	r3, #0
 80186c2:	d030      	beq.n	8018726 <lcp_rejci+0x9a>
 80186c4:	687b      	ldr	r3, [r7, #4]
 80186c6:	2b03      	cmp	r3, #3
 80186c8:	dd2d      	ble.n	8018726 <lcp_rejci+0x9a>
 80186ca:	68bb      	ldr	r3, [r7, #8]
 80186cc:	3301      	adds	r3, #1
 80186ce:	781b      	ldrb	r3, [r3, #0]
 80186d0:	2b04      	cmp	r3, #4
 80186d2:	d128      	bne.n	8018726 <lcp_rejci+0x9a>
 80186d4:	68bb      	ldr	r3, [r7, #8]
 80186d6:	781b      	ldrb	r3, [r3, #0]
 80186d8:	2b01      	cmp	r3, #1
 80186da:	d124      	bne.n	8018726 <lcp_rejci+0x9a>
 80186dc:	687b      	ldr	r3, [r7, #4]
 80186de:	3b04      	subs	r3, #4
 80186e0:	607b      	str	r3, [r7, #4]
 80186e2:	68bb      	ldr	r3, [r7, #8]
 80186e4:	3302      	adds	r3, #2
 80186e6:	60bb      	str	r3, [r7, #8]
 80186e8:	68bb      	ldr	r3, [r7, #8]
 80186ea:	1c5a      	adds	r2, r3, #1
 80186ec:	60ba      	str	r2, [r7, #8]
 80186ee:	781b      	ldrb	r3, [r3, #0]
 80186f0:	b29a      	uxth	r2, r3
 80186f2:	2042      	movs	r0, #66	; 0x42
 80186f4:	183b      	adds	r3, r7, r0
 80186f6:	0212      	lsls	r2, r2, #8
 80186f8:	801a      	strh	r2, [r3, #0]
 80186fa:	68bb      	ldr	r3, [r7, #8]
 80186fc:	1c5a      	adds	r2, r3, #1
 80186fe:	60ba      	str	r2, [r7, #8]
 8018700:	781b      	ldrb	r3, [r3, #0]
 8018702:	b299      	uxth	r1, r3
 8018704:	183b      	adds	r3, r7, r0
 8018706:	183a      	adds	r2, r7, r0
 8018708:	8812      	ldrh	r2, [r2, #0]
 801870a:	430a      	orrs	r2, r1
 801870c:	801a      	strh	r2, [r3, #0]
 801870e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018710:	885b      	ldrh	r3, [r3, #2]
 8018712:	183a      	adds	r2, r7, r0
 8018714:	8812      	ldrh	r2, [r2, #0]
 8018716:	429a      	cmp	r2, r3
 8018718:	d000      	beq.n	801871c <lcp_rejci+0x90>
 801871a:	e182      	b.n	8018a22 <lcp_rejci+0x396>
 801871c:	193b      	adds	r3, r7, r4
 801871e:	781a      	ldrb	r2, [r3, #0]
 8018720:	2104      	movs	r1, #4
 8018722:	438a      	bics	r2, r1
 8018724:	701a      	strb	r2, [r3, #0]
    REJCILONG(CI_ASYNCMAP, neg_asyncmap, go->asyncmap);
 8018726:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018728:	781b      	ldrb	r3, [r3, #0]
 801872a:	2208      	movs	r2, #8
 801872c:	4013      	ands	r3, r2
 801872e:	b2db      	uxtb	r3, r3
 8018730:	2b00      	cmp	r3, #0
 8018732:	d041      	beq.n	80187b8 <lcp_rejci+0x12c>
 8018734:	687b      	ldr	r3, [r7, #4]
 8018736:	2b05      	cmp	r3, #5
 8018738:	dd3e      	ble.n	80187b8 <lcp_rejci+0x12c>
 801873a:	68bb      	ldr	r3, [r7, #8]
 801873c:	3301      	adds	r3, #1
 801873e:	781b      	ldrb	r3, [r3, #0]
 8018740:	2b06      	cmp	r3, #6
 8018742:	d139      	bne.n	80187b8 <lcp_rejci+0x12c>
 8018744:	68bb      	ldr	r3, [r7, #8]
 8018746:	781b      	ldrb	r3, [r3, #0]
 8018748:	2b02      	cmp	r3, #2
 801874a:	d135      	bne.n	80187b8 <lcp_rejci+0x12c>
 801874c:	687b      	ldr	r3, [r7, #4]
 801874e:	3b06      	subs	r3, #6
 8018750:	607b      	str	r3, [r7, #4]
 8018752:	68bb      	ldr	r3, [r7, #8]
 8018754:	3302      	adds	r3, #2
 8018756:	60bb      	str	r3, [r7, #8]
 8018758:	68bb      	ldr	r3, [r7, #8]
 801875a:	1c5a      	adds	r2, r3, #1
 801875c:	60ba      	str	r2, [r7, #8]
 801875e:	781b      	ldrb	r3, [r3, #0]
 8018760:	021b      	lsls	r3, r3, #8
 8018762:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018764:	68bb      	ldr	r3, [r7, #8]
 8018766:	1c5a      	adds	r2, r3, #1
 8018768:	60ba      	str	r2, [r7, #8]
 801876a:	781b      	ldrb	r3, [r3, #0]
 801876c:	001a      	movs	r2, r3
 801876e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018770:	4313      	orrs	r3, r2
 8018772:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018774:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018776:	021b      	lsls	r3, r3, #8
 8018778:	63fb      	str	r3, [r7, #60]	; 0x3c
 801877a:	68bb      	ldr	r3, [r7, #8]
 801877c:	1c5a      	adds	r2, r3, #1
 801877e:	60ba      	str	r2, [r7, #8]
 8018780:	781b      	ldrb	r3, [r3, #0]
 8018782:	001a      	movs	r2, r3
 8018784:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018786:	4313      	orrs	r3, r2
 8018788:	63fb      	str	r3, [r7, #60]	; 0x3c
 801878a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801878c:	021b      	lsls	r3, r3, #8
 801878e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018790:	68bb      	ldr	r3, [r7, #8]
 8018792:	1c5a      	adds	r2, r3, #1
 8018794:	60ba      	str	r2, [r7, #8]
 8018796:	781b      	ldrb	r3, [r3, #0]
 8018798:	001a      	movs	r2, r3
 801879a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801879c:	4313      	orrs	r3, r2
 801879e:	63fb      	str	r3, [r7, #60]	; 0x3c
 80187a0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80187a2:	685b      	ldr	r3, [r3, #4]
 80187a4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80187a6:	429a      	cmp	r2, r3
 80187a8:	d000      	beq.n	80187ac <lcp_rejci+0x120>
 80187aa:	e13c      	b.n	8018a26 <lcp_rejci+0x39a>
 80187ac:	2314      	movs	r3, #20
 80187ae:	18fb      	adds	r3, r7, r3
 80187b0:	781a      	ldrb	r2, [r3, #0]
 80187b2:	2108      	movs	r1, #8
 80187b4:	438a      	bics	r2, r1
 80187b6:	701a      	strb	r2, [r3, #0]
    }
#endif /* EAP_SUPPORT */
#if LQR_SUPPORT
    REJCILQR(CI_QUALITY, neg_lqr, go->lqr_period);
#endif /* LQR_SUPPORT */
    REJCICBCP(CI_CALLBACK, neg_cbcp, CBCP_OPT);
 80187b8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80187ba:	781b      	ldrb	r3, [r3, #0]
 80187bc:	227f      	movs	r2, #127	; 0x7f
 80187be:	4393      	bics	r3, r2
 80187c0:	b2db      	uxtb	r3, r3
 80187c2:	2b00      	cmp	r3, #0
 80187c4:	d023      	beq.n	801880e <lcp_rejci+0x182>
 80187c6:	687b      	ldr	r3, [r7, #4]
 80187c8:	2b02      	cmp	r3, #2
 80187ca:	dd20      	ble.n	801880e <lcp_rejci+0x182>
 80187cc:	68bb      	ldr	r3, [r7, #8]
 80187ce:	3301      	adds	r3, #1
 80187d0:	781b      	ldrb	r3, [r3, #0]
 80187d2:	2b03      	cmp	r3, #3
 80187d4:	d11b      	bne.n	801880e <lcp_rejci+0x182>
 80187d6:	68bb      	ldr	r3, [r7, #8]
 80187d8:	781b      	ldrb	r3, [r3, #0]
 80187da:	2b0d      	cmp	r3, #13
 80187dc:	d117      	bne.n	801880e <lcp_rejci+0x182>
 80187de:	687b      	ldr	r3, [r7, #4]
 80187e0:	3b03      	subs	r3, #3
 80187e2:	607b      	str	r3, [r7, #4]
 80187e4:	68bb      	ldr	r3, [r7, #8]
 80187e6:	3302      	adds	r3, #2
 80187e8:	60bb      	str	r3, [r7, #8]
 80187ea:	68bb      	ldr	r3, [r7, #8]
 80187ec:	1c5a      	adds	r2, r3, #1
 80187ee:	60ba      	str	r2, [r7, #8]
 80187f0:	213b      	movs	r1, #59	; 0x3b
 80187f2:	187a      	adds	r2, r7, r1
 80187f4:	781b      	ldrb	r3, [r3, #0]
 80187f6:	7013      	strb	r3, [r2, #0]
 80187f8:	187b      	adds	r3, r7, r1
 80187fa:	781b      	ldrb	r3, [r3, #0]
 80187fc:	2b06      	cmp	r3, #6
 80187fe:	d000      	beq.n	8018802 <lcp_rejci+0x176>
 8018800:	e113      	b.n	8018a2a <lcp_rejci+0x39e>
 8018802:	2314      	movs	r3, #20
 8018804:	18fb      	adds	r3, r7, r3
 8018806:	781a      	ldrb	r2, [r3, #0]
 8018808:	217f      	movs	r1, #127	; 0x7f
 801880a:	400a      	ands	r2, r1
 801880c:	701a      	strb	r2, [r3, #0]
    REJCILONG(CI_MAGICNUMBER, neg_magicnumber, go->magicnumber);
 801880e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018810:	781b      	ldrb	r3, [r3, #0]
 8018812:	2210      	movs	r2, #16
 8018814:	4013      	ands	r3, r2
 8018816:	b2db      	uxtb	r3, r3
 8018818:	2b00      	cmp	r3, #0
 801881a:	d041      	beq.n	80188a0 <lcp_rejci+0x214>
 801881c:	687b      	ldr	r3, [r7, #4]
 801881e:	2b05      	cmp	r3, #5
 8018820:	dd3e      	ble.n	80188a0 <lcp_rejci+0x214>
 8018822:	68bb      	ldr	r3, [r7, #8]
 8018824:	3301      	adds	r3, #1
 8018826:	781b      	ldrb	r3, [r3, #0]
 8018828:	2b06      	cmp	r3, #6
 801882a:	d139      	bne.n	80188a0 <lcp_rejci+0x214>
 801882c:	68bb      	ldr	r3, [r7, #8]
 801882e:	781b      	ldrb	r3, [r3, #0]
 8018830:	2b05      	cmp	r3, #5
 8018832:	d135      	bne.n	80188a0 <lcp_rejci+0x214>
 8018834:	687b      	ldr	r3, [r7, #4]
 8018836:	3b06      	subs	r3, #6
 8018838:	607b      	str	r3, [r7, #4]
 801883a:	68bb      	ldr	r3, [r7, #8]
 801883c:	3302      	adds	r3, #2
 801883e:	60bb      	str	r3, [r7, #8]
 8018840:	68bb      	ldr	r3, [r7, #8]
 8018842:	1c5a      	adds	r2, r3, #1
 8018844:	60ba      	str	r2, [r7, #8]
 8018846:	781b      	ldrb	r3, [r3, #0]
 8018848:	021b      	lsls	r3, r3, #8
 801884a:	63fb      	str	r3, [r7, #60]	; 0x3c
 801884c:	68bb      	ldr	r3, [r7, #8]
 801884e:	1c5a      	adds	r2, r3, #1
 8018850:	60ba      	str	r2, [r7, #8]
 8018852:	781b      	ldrb	r3, [r3, #0]
 8018854:	001a      	movs	r2, r3
 8018856:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018858:	4313      	orrs	r3, r2
 801885a:	63fb      	str	r3, [r7, #60]	; 0x3c
 801885c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801885e:	021b      	lsls	r3, r3, #8
 8018860:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018862:	68bb      	ldr	r3, [r7, #8]
 8018864:	1c5a      	adds	r2, r3, #1
 8018866:	60ba      	str	r2, [r7, #8]
 8018868:	781b      	ldrb	r3, [r3, #0]
 801886a:	001a      	movs	r2, r3
 801886c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801886e:	4313      	orrs	r3, r2
 8018870:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018872:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018874:	021b      	lsls	r3, r3, #8
 8018876:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018878:	68bb      	ldr	r3, [r7, #8]
 801887a:	1c5a      	adds	r2, r3, #1
 801887c:	60ba      	str	r2, [r7, #8]
 801887e:	781b      	ldrb	r3, [r3, #0]
 8018880:	001a      	movs	r2, r3
 8018882:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018884:	4313      	orrs	r3, r2
 8018886:	63fb      	str	r3, [r7, #60]	; 0x3c
 8018888:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801888a:	689b      	ldr	r3, [r3, #8]
 801888c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801888e:	429a      	cmp	r2, r3
 8018890:	d000      	beq.n	8018894 <lcp_rejci+0x208>
 8018892:	e0cc      	b.n	8018a2e <lcp_rejci+0x3a2>
 8018894:	2314      	movs	r3, #20
 8018896:	18fb      	adds	r3, r7, r3
 8018898:	781a      	ldrb	r2, [r3, #0]
 801889a:	2110      	movs	r1, #16
 801889c:	438a      	bics	r2, r1
 801889e:	701a      	strb	r2, [r3, #0]
    REJCIVOID(CI_PCOMPRESSION, neg_pcompression);
 80188a0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80188a2:	781b      	ldrb	r3, [r3, #0]
 80188a4:	2220      	movs	r2, #32
 80188a6:	4013      	ands	r3, r2
 80188a8:	b2db      	uxtb	r3, r3
 80188aa:	2b00      	cmp	r3, #0
 80188ac:	d017      	beq.n	80188de <lcp_rejci+0x252>
 80188ae:	687b      	ldr	r3, [r7, #4]
 80188b0:	2b01      	cmp	r3, #1
 80188b2:	dd14      	ble.n	80188de <lcp_rejci+0x252>
 80188b4:	68bb      	ldr	r3, [r7, #8]
 80188b6:	3301      	adds	r3, #1
 80188b8:	781b      	ldrb	r3, [r3, #0]
 80188ba:	2b02      	cmp	r3, #2
 80188bc:	d10f      	bne.n	80188de <lcp_rejci+0x252>
 80188be:	68bb      	ldr	r3, [r7, #8]
 80188c0:	781b      	ldrb	r3, [r3, #0]
 80188c2:	2b07      	cmp	r3, #7
 80188c4:	d10b      	bne.n	80188de <lcp_rejci+0x252>
 80188c6:	687b      	ldr	r3, [r7, #4]
 80188c8:	3b02      	subs	r3, #2
 80188ca:	607b      	str	r3, [r7, #4]
 80188cc:	68bb      	ldr	r3, [r7, #8]
 80188ce:	3302      	adds	r3, #2
 80188d0:	60bb      	str	r3, [r7, #8]
 80188d2:	2314      	movs	r3, #20
 80188d4:	18fb      	adds	r3, r7, r3
 80188d6:	781a      	ldrb	r2, [r3, #0]
 80188d8:	2120      	movs	r1, #32
 80188da:	438a      	bics	r2, r1
 80188dc:	701a      	strb	r2, [r3, #0]
    REJCIVOID(CI_ACCOMPRESSION, neg_accompression);
 80188de:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80188e0:	781b      	ldrb	r3, [r3, #0]
 80188e2:	2240      	movs	r2, #64	; 0x40
 80188e4:	4013      	ands	r3, r2
 80188e6:	b2db      	uxtb	r3, r3
 80188e8:	2b00      	cmp	r3, #0
 80188ea:	d017      	beq.n	801891c <lcp_rejci+0x290>
 80188ec:	687b      	ldr	r3, [r7, #4]
 80188ee:	2b01      	cmp	r3, #1
 80188f0:	dd14      	ble.n	801891c <lcp_rejci+0x290>
 80188f2:	68bb      	ldr	r3, [r7, #8]
 80188f4:	3301      	adds	r3, #1
 80188f6:	781b      	ldrb	r3, [r3, #0]
 80188f8:	2b02      	cmp	r3, #2
 80188fa:	d10f      	bne.n	801891c <lcp_rejci+0x290>
 80188fc:	68bb      	ldr	r3, [r7, #8]
 80188fe:	781b      	ldrb	r3, [r3, #0]
 8018900:	2b08      	cmp	r3, #8
 8018902:	d10b      	bne.n	801891c <lcp_rejci+0x290>
 8018904:	687b      	ldr	r3, [r7, #4]
 8018906:	3b02      	subs	r3, #2
 8018908:	607b      	str	r3, [r7, #4]
 801890a:	68bb      	ldr	r3, [r7, #8]
 801890c:	3302      	adds	r3, #2
 801890e:	60bb      	str	r3, [r7, #8]
 8018910:	2314      	movs	r3, #20
 8018912:	18fb      	adds	r3, r7, r3
 8018914:	781a      	ldrb	r2, [r3, #0]
 8018916:	2140      	movs	r1, #64	; 0x40
 8018918:	438a      	bics	r2, r1
 801891a:	701a      	strb	r2, [r3, #0]
#ifdef HAVE_MULTILINK
    REJCISHORT(CI_MRRU, neg_mrru, go->mrru);
#endif /* HAVE_MULTILINK */
    REJCIVOID(CI_SSNHF, neg_ssnhf);
 801891c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801891e:	785b      	ldrb	r3, [r3, #1]
 8018920:	2201      	movs	r2, #1
 8018922:	4013      	ands	r3, r2
 8018924:	b2db      	uxtb	r3, r3
 8018926:	2b00      	cmp	r3, #0
 8018928:	d017      	beq.n	801895a <lcp_rejci+0x2ce>
 801892a:	687b      	ldr	r3, [r7, #4]
 801892c:	2b01      	cmp	r3, #1
 801892e:	dd14      	ble.n	801895a <lcp_rejci+0x2ce>
 8018930:	68bb      	ldr	r3, [r7, #8]
 8018932:	3301      	adds	r3, #1
 8018934:	781b      	ldrb	r3, [r3, #0]
 8018936:	2b02      	cmp	r3, #2
 8018938:	d10f      	bne.n	801895a <lcp_rejci+0x2ce>
 801893a:	68bb      	ldr	r3, [r7, #8]
 801893c:	781b      	ldrb	r3, [r3, #0]
 801893e:	2b12      	cmp	r3, #18
 8018940:	d10b      	bne.n	801895a <lcp_rejci+0x2ce>
 8018942:	687b      	ldr	r3, [r7, #4]
 8018944:	3b02      	subs	r3, #2
 8018946:	607b      	str	r3, [r7, #4]
 8018948:	68bb      	ldr	r3, [r7, #8]
 801894a:	3302      	adds	r3, #2
 801894c:	60bb      	str	r3, [r7, #8]
 801894e:	2314      	movs	r3, #20
 8018950:	18fb      	adds	r3, r7, r3
 8018952:	785a      	ldrb	r2, [r3, #1]
 8018954:	2101      	movs	r1, #1
 8018956:	438a      	bics	r2, r1
 8018958:	705a      	strb	r2, [r3, #1]
    REJCIENDP(CI_EPDISC, neg_endpoint, go->endpoint.class_,
 801895a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801895c:	785b      	ldrb	r3, [r3, #1]
 801895e:	2202      	movs	r2, #2
 8018960:	4013      	ands	r3, r2
 8018962:	b2db      	uxtb	r3, r3
 8018964:	2b00      	cmp	r3, #0
 8018966:	d04a      	beq.n	80189fe <lcp_rejci+0x372>
 8018968:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801896a:	7b9b      	ldrb	r3, [r3, #14]
 801896c:	3302      	adds	r3, #2
 801896e:	687a      	ldr	r2, [r7, #4]
 8018970:	429a      	cmp	r2, r3
 8018972:	dd44      	ble.n	80189fe <lcp_rejci+0x372>
 8018974:	68bb      	ldr	r3, [r7, #8]
 8018976:	781b      	ldrb	r3, [r3, #0]
 8018978:	2b13      	cmp	r3, #19
 801897a:	d140      	bne.n	80189fe <lcp_rejci+0x372>
 801897c:	68bb      	ldr	r3, [r7, #8]
 801897e:	3301      	adds	r3, #1
 8018980:	781b      	ldrb	r3, [r3, #0]
 8018982:	001a      	movs	r2, r3
 8018984:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018986:	7b9b      	ldrb	r3, [r3, #14]
 8018988:	3303      	adds	r3, #3
 801898a:	429a      	cmp	r2, r3
 801898c:	d137      	bne.n	80189fe <lcp_rejci+0x372>
 801898e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018990:	7b9b      	ldrb	r3, [r3, #14]
 8018992:	3303      	adds	r3, #3
 8018994:	687a      	ldr	r2, [r7, #4]
 8018996:	1ad3      	subs	r3, r2, r3
 8018998:	607b      	str	r3, [r7, #4]
 801899a:	68bb      	ldr	r3, [r7, #8]
 801899c:	3302      	adds	r3, #2
 801899e:	60bb      	str	r3, [r7, #8]
 80189a0:	68bb      	ldr	r3, [r7, #8]
 80189a2:	1c5a      	adds	r2, r3, #1
 80189a4:	60ba      	str	r2, [r7, #8]
 80189a6:	213b      	movs	r1, #59	; 0x3b
 80189a8:	187a      	adds	r2, r7, r1
 80189aa:	781b      	ldrb	r3, [r3, #0]
 80189ac:	7013      	strb	r3, [r2, #0]
 80189ae:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80189b0:	7b5b      	ldrb	r3, [r3, #13]
 80189b2:	187a      	adds	r2, r7, r1
 80189b4:	7812      	ldrb	r2, [r2, #0]
 80189b6:	429a      	cmp	r2, r3
 80189b8:	d13b      	bne.n	8018a32 <lcp_rejci+0x3a6>
 80189ba:	2300      	movs	r3, #0
 80189bc:	64fb      	str	r3, [r7, #76]	; 0x4c
 80189be:	e012      	b.n	80189e6 <lcp_rejci+0x35a>
 80189c0:	68bb      	ldr	r3, [r7, #8]
 80189c2:	1c5a      	adds	r2, r3, #1
 80189c4:	60ba      	str	r2, [r7, #8]
 80189c6:	213b      	movs	r1, #59	; 0x3b
 80189c8:	187a      	adds	r2, r7, r1
 80189ca:	781b      	ldrb	r3, [r3, #0]
 80189cc:	7013      	strb	r3, [r2, #0]
 80189ce:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80189d0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80189d2:	18d3      	adds	r3, r2, r3
 80189d4:	330f      	adds	r3, #15
 80189d6:	781b      	ldrb	r3, [r3, #0]
 80189d8:	187a      	adds	r2, r7, r1
 80189da:	7812      	ldrb	r2, [r2, #0]
 80189dc:	429a      	cmp	r2, r3
 80189de:	d12a      	bne.n	8018a36 <lcp_rejci+0x3aa>
 80189e0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80189e2:	3301      	adds	r3, #1
 80189e4:	64fb      	str	r3, [r7, #76]	; 0x4c
 80189e6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80189e8:	7b9b      	ldrb	r3, [r3, #14]
 80189ea:	001a      	movs	r2, r3
 80189ec:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80189ee:	4293      	cmp	r3, r2
 80189f0:	dbe6      	blt.n	80189c0 <lcp_rejci+0x334>
 80189f2:	2314      	movs	r3, #20
 80189f4:	18fb      	adds	r3, r7, r3
 80189f6:	785a      	ldrb	r2, [r3, #1]
 80189f8:	2102      	movs	r1, #2
 80189fa:	438a      	bics	r2, r1
 80189fc:	705a      	strb	r2, [r3, #1]
	      go->endpoint.value, go->endpoint.length);

    /*
     * If there are any remaining CIs, then this packet is bad.
     */
    if (len != 0)
 80189fe:	687b      	ldr	r3, [r7, #4]
 8018a00:	2b00      	cmp	r3, #0
 8018a02:	d11a      	bne.n	8018a3a <lcp_rejci+0x3ae>
	goto bad;
    /*
     * Now we can update state.
     */
    if (f->state != PPP_FSM_OPENED)
 8018a04:	68fb      	ldr	r3, [r7, #12]
 8018a06:	7c1b      	ldrb	r3, [r3, #16]
 8018a08:	2b09      	cmp	r3, #9
 8018a0a:	d008      	beq.n	8018a1e <lcp_rejci+0x392>
	*go = try_;
 8018a0c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018a0e:	2214      	movs	r2, #20
 8018a10:	18ba      	adds	r2, r7, r2
 8018a12:	ca13      	ldmia	r2!, {r0, r1, r4}
 8018a14:	c313      	stmia	r3!, {r0, r1, r4}
 8018a16:	ca13      	ldmia	r2!, {r0, r1, r4}
 8018a18:	c313      	stmia	r3!, {r0, r1, r4}
 8018a1a:	ca13      	ldmia	r2!, {r0, r1, r4}
 8018a1c:	c313      	stmia	r3!, {r0, r1, r4}
    return 1;
 8018a1e:	2301      	movs	r3, #1
 8018a20:	e00d      	b.n	8018a3e <lcp_rejci+0x3b2>
    REJCISHORT(CI_MRU, neg_mru, go->mru);
 8018a22:	46c0      	nop			; (mov r8, r8)
 8018a24:	e00a      	b.n	8018a3c <lcp_rejci+0x3b0>
    REJCILONG(CI_ASYNCMAP, neg_asyncmap, go->asyncmap);
 8018a26:	46c0      	nop			; (mov r8, r8)
 8018a28:	e008      	b.n	8018a3c <lcp_rejci+0x3b0>
    REJCICBCP(CI_CALLBACK, neg_cbcp, CBCP_OPT);
 8018a2a:	46c0      	nop			; (mov r8, r8)
 8018a2c:	e006      	b.n	8018a3c <lcp_rejci+0x3b0>
    REJCILONG(CI_MAGICNUMBER, neg_magicnumber, go->magicnumber);
 8018a2e:	46c0      	nop			; (mov r8, r8)
 8018a30:	e004      	b.n	8018a3c <lcp_rejci+0x3b0>
    REJCIENDP(CI_EPDISC, neg_endpoint, go->endpoint.class_,
 8018a32:	46c0      	nop			; (mov r8, r8)
 8018a34:	e002      	b.n	8018a3c <lcp_rejci+0x3b0>
 8018a36:	46c0      	nop			; (mov r8, r8)
 8018a38:	e000      	b.n	8018a3c <lcp_rejci+0x3b0>
	goto bad;
 8018a3a:	46c0      	nop			; (mov r8, r8)

bad:
    LCPDEBUG(("lcp_rejci: received bad Reject!"));
    return 0;
 8018a3c:	2300      	movs	r3, #0
}
 8018a3e:	0018      	movs	r0, r3
 8018a40:	46bd      	mov	sp, r7
 8018a42:	b014      	add	sp, #80	; 0x50
 8018a44:	bdb0      	pop	{r4, r5, r7, pc}
	...

08018a48 <lcp_reqci>:
 * CONFNAK; returns CONFREJ if it can't return CONFACK.
 *
 * inp = Requested CIs
 * lenp = Length of requested CIs
 */
static int lcp_reqci(fsm *f, u_char *inp, int *lenp, int reject_if_disagree) {
 8018a48:	b580      	push	{r7, lr}
 8018a4a:	b096      	sub	sp, #88	; 0x58
 8018a4c:	af00      	add	r7, sp, #0
 8018a4e:	60f8      	str	r0, [r7, #12]
 8018a50:	60b9      	str	r1, [r7, #8]
 8018a52:	607a      	str	r2, [r7, #4]
 8018a54:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 8018a56:	68fb      	ldr	r3, [r7, #12]
 8018a58:	681b      	ldr	r3, [r3, #0]
 8018a5a:	637b      	str	r3, [r7, #52]	; 0x34
    lcp_options *go = &pcb->lcp_gotoptions;
 8018a5c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8018a5e:	3368      	adds	r3, #104	; 0x68
 8018a60:	633b      	str	r3, [r7, #48]	; 0x30
    lcp_options *ho = &pcb->lcp_hisoptions;
 8018a62:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8018a64:	33b0      	adds	r3, #176	; 0xb0
 8018a66:	62fb      	str	r3, [r7, #44]	; 0x2c
    lcp_options *ao = &pcb->lcp_allowoptions;
 8018a68:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8018a6a:	338c      	adds	r3, #140	; 0x8c
 8018a6c:	62bb      	str	r3, [r7, #40]	; 0x28
    u_char *cip, *next;		/* Pointer to current and next CIs */
    int cilen, citype, cichar;	/* Parsed len, type, char value */
    u_short cishort;		/* Parsed short value */
    u32_t cilong;		/* Parse long value */
    int rc = CONFACK;		/* Final packet return code */
 8018a6e:	2302      	movs	r3, #2
 8018a70:	64bb      	str	r3, [r7, #72]	; 0x48
    int orc;			/* Individual option return code */
    u_char *p;			/* Pointer to next char to parse */
    u_char *rejp;		/* Pointer to next char in reject frame */
    struct pbuf *nakp;          /* Nak buffer */
    u_char *nakoutp;		/* Pointer to next char in Nak frame */
    int l = *lenp;		/* Length left */
 8018a72:	687b      	ldr	r3, [r7, #4]
 8018a74:	681b      	ldr	r3, [r3, #0]
 8018a76:	63bb      	str	r3, [r7, #56]	; 0x38

    /*
     * Reset all his options.
     */
    BZERO(ho, sizeof(*ho));
 8018a78:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018a7a:	2224      	movs	r2, #36	; 0x24
 8018a7c:	2100      	movs	r1, #0
 8018a7e:	0018      	movs	r0, r3
 8018a80:	f003 fed4 	bl	801c82c <memset>

    /*
     * Process all his options.
     */
    next = inp;
 8018a84:	68bb      	ldr	r3, [r7, #8]
 8018a86:	657b      	str	r3, [r7, #84]	; 0x54
    nakp = pbuf_alloc(PBUF_RAW, (u16_t)(PPP_CTRL_PBUF_MAX_SIZE), PPP_CTRL_PBUF_TYPE);
 8018a88:	23c1      	movs	r3, #193	; 0xc1
 8018a8a:	005a      	lsls	r2, r3, #1
 8018a8c:	2394      	movs	r3, #148	; 0x94
 8018a8e:	009b      	lsls	r3, r3, #2
 8018a90:	0019      	movs	r1, r3
 8018a92:	2000      	movs	r0, #0
 8018a94:	f7f0 fa86 	bl	8008fa4 <pbuf_alloc>
 8018a98:	0003      	movs	r3, r0
 8018a9a:	627b      	str	r3, [r7, #36]	; 0x24
    if(NULL == nakp)
 8018a9c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018a9e:	2b00      	cmp	r3, #0
 8018aa0:	d101      	bne.n	8018aa6 <lcp_reqci+0x5e>
        return 0;
 8018aa2:	2300      	movs	r3, #0
 8018aa4:	e258      	b.n	8018f58 <lcp_reqci+0x510>
    if(nakp->tot_len != nakp->len) {
 8018aa6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018aa8:	891a      	ldrh	r2, [r3, #8]
 8018aaa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018aac:	895b      	ldrh	r3, [r3, #10]
 8018aae:	429a      	cmp	r2, r3
 8018ab0:	d005      	beq.n	8018abe <lcp_reqci+0x76>
        pbuf_free(nakp);
 8018ab2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018ab4:	0018      	movs	r0, r3
 8018ab6:	f7f0 fded 	bl	8009694 <pbuf_free>
        return 0;
 8018aba:	2300      	movs	r3, #0
 8018abc:	e24c      	b.n	8018f58 <lcp_reqci+0x510>
    }

    nakoutp = (u_char*)nakp->payload;
 8018abe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018ac0:	685b      	ldr	r3, [r3, #4]
 8018ac2:	63fb      	str	r3, [r7, #60]	; 0x3c
    rejp = inp;
 8018ac4:	68bb      	ldr	r3, [r7, #8]
 8018ac6:	643b      	str	r3, [r7, #64]	; 0x40
    while (l) {
 8018ac8:	e213      	b.n	8018ef2 <lcp_reqci+0x4aa>
	orc = CONFACK;			/* Assume success */
 8018aca:	2302      	movs	r3, #2
 8018acc:	647b      	str	r3, [r7, #68]	; 0x44
	cip = p = next;			/* Remember begining of CI */
 8018ace:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8018ad0:	623b      	str	r3, [r7, #32]
 8018ad2:	6a3b      	ldr	r3, [r7, #32]
 8018ad4:	61fb      	str	r3, [r7, #28]
	if (l < 2 ||			/* Not enough data for CI header or */
 8018ad6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8018ad8:	2b01      	cmp	r3, #1
 8018ada:	dd0b      	ble.n	8018af4 <lcp_reqci+0xac>
	    p[1] < 2 ||			/*  CI length too small or */
 8018adc:	6a3b      	ldr	r3, [r7, #32]
 8018ade:	3301      	adds	r3, #1
 8018ae0:	781b      	ldrb	r3, [r3, #0]
	if (l < 2 ||			/* Not enough data for CI header or */
 8018ae2:	2b01      	cmp	r3, #1
 8018ae4:	d906      	bls.n	8018af4 <lcp_reqci+0xac>
	    p[1] > l) {			/*  CI length too big? */
 8018ae6:	6a3b      	ldr	r3, [r7, #32]
 8018ae8:	3301      	adds	r3, #1
 8018aea:	781b      	ldrb	r3, [r3, #0]
 8018aec:	001a      	movs	r2, r3
	    p[1] < 2 ||			/*  CI length too small or */
 8018aee:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8018af0:	4293      	cmp	r3, r2
 8018af2:	da08      	bge.n	8018b06 <lcp_reqci+0xbe>
	    LCPDEBUG(("lcp_reqci: bad CI length!"));
	    orc = CONFREJ;		/* Reject bad CI */
 8018af4:	2304      	movs	r3, #4
 8018af6:	647b      	str	r3, [r7, #68]	; 0x44
	    cilen = l;			/* Reject till end of packet */
 8018af8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8018afa:	653b      	str	r3, [r7, #80]	; 0x50
	    l = 0;			/* Don't loop again */
 8018afc:	2300      	movs	r3, #0
 8018afe:	63bb      	str	r3, [r7, #56]	; 0x38
	    citype = 0;
 8018b00:	2300      	movs	r3, #0
 8018b02:	64fb      	str	r3, [r7, #76]	; 0x4c
	    goto endswitch;
 8018b04:	e1c4      	b.n	8018e90 <lcp_reqci+0x448>
	}
	GETCHAR(citype, p);		/* Parse CI type */
 8018b06:	6a3b      	ldr	r3, [r7, #32]
 8018b08:	1c5a      	adds	r2, r3, #1
 8018b0a:	623a      	str	r2, [r7, #32]
 8018b0c:	781b      	ldrb	r3, [r3, #0]
 8018b0e:	64fb      	str	r3, [r7, #76]	; 0x4c
	GETCHAR(cilen, p);		/* Parse CI length */
 8018b10:	6a3b      	ldr	r3, [r7, #32]
 8018b12:	1c5a      	adds	r2, r3, #1
 8018b14:	623a      	str	r2, [r7, #32]
 8018b16:	781b      	ldrb	r3, [r3, #0]
 8018b18:	653b      	str	r3, [r7, #80]	; 0x50
	l -= cilen;			/* Adjust remaining length */
 8018b1a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8018b1c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8018b1e:	1ad3      	subs	r3, r2, r3
 8018b20:	63bb      	str	r3, [r7, #56]	; 0x38
	next += cilen;			/* Step to next CI */
 8018b22:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8018b24:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8018b26:	18d3      	adds	r3, r2, r3
 8018b28:	657b      	str	r3, [r7, #84]	; 0x54
 8018b2a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8018b2c:	2b13      	cmp	r3, #19
 8018b2e:	d900      	bls.n	8018b32 <lcp_reqci+0xea>
 8018b30:	e1ab      	b.n	8018e8a <lcp_reqci+0x442>
 8018b32:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8018b34:	009a      	lsls	r2, r3, #2
 8018b36:	4bda      	ldr	r3, [pc, #872]	; (8018ea0 <lcp_reqci+0x458>)
 8018b38:	18d3      	adds	r3, r2, r3
 8018b3a:	681b      	ldr	r3, [r3, #0]
 8018b3c:	469f      	mov	pc, r3

	switch (citype) {		/* Check CI type */
	case CI_MRU:
	    if (!ao->neg_mru ||		/* Allow option? */
 8018b3e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018b40:	781b      	ldrb	r3, [r3, #0]
 8018b42:	2204      	movs	r2, #4
 8018b44:	4013      	ands	r3, r2
 8018b46:	b2db      	uxtb	r3, r3
 8018b48:	2b00      	cmp	r3, #0
 8018b4a:	d002      	beq.n	8018b52 <lcp_reqci+0x10a>
 8018b4c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8018b4e:	2b04      	cmp	r3, #4
 8018b50:	d002      	beq.n	8018b58 <lcp_reqci+0x110>
		cilen != CILEN_SHORT) {	/* Check CI length */
		orc = CONFREJ;		/* Reject CI */
 8018b52:	2304      	movs	r3, #4
 8018b54:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8018b56:	e19b      	b.n	8018e90 <lcp_reqci+0x448>
	    }
	    GETSHORT(cishort, p);	/* Parse MRU */
 8018b58:	6a3b      	ldr	r3, [r7, #32]
 8018b5a:	1c5a      	adds	r2, r3, #1
 8018b5c:	623a      	str	r2, [r7, #32]
 8018b5e:	781b      	ldrb	r3, [r3, #0]
 8018b60:	b29a      	uxth	r2, r3
 8018b62:	2012      	movs	r0, #18
 8018b64:	183b      	adds	r3, r7, r0
 8018b66:	0212      	lsls	r2, r2, #8
 8018b68:	801a      	strh	r2, [r3, #0]
 8018b6a:	6a3b      	ldr	r3, [r7, #32]
 8018b6c:	1c5a      	adds	r2, r3, #1
 8018b6e:	623a      	str	r2, [r7, #32]
 8018b70:	781b      	ldrb	r3, [r3, #0]
 8018b72:	b299      	uxth	r1, r3
 8018b74:	183b      	adds	r3, r7, r0
 8018b76:	183a      	adds	r2, r7, r0
 8018b78:	8812      	ldrh	r2, [r2, #0]
 8018b7a:	430a      	orrs	r2, r1
 8018b7c:	801a      	strh	r2, [r3, #0]
	    /*
	     * He must be able to receive at least our minimum.
	     * No need to check a maximum.  If he sends a large number,
	     * we'll just ignore it.
	     */
	    if (cishort < PPP_MINMRU) {
 8018b7e:	183b      	adds	r3, r7, r0
 8018b80:	881b      	ldrh	r3, [r3, #0]
 8018b82:	2b7f      	cmp	r3, #127	; 0x7f
 8018b84:	d816      	bhi.n	8018bb4 <lcp_reqci+0x16c>
		orc = CONFNAK;		/* Nak CI */
 8018b86:	2303      	movs	r3, #3
 8018b88:	647b      	str	r3, [r7, #68]	; 0x44
		PUTCHAR(CI_MRU, nakoutp);
 8018b8a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018b8c:	1c5a      	adds	r2, r3, #1
 8018b8e:	63fa      	str	r2, [r7, #60]	; 0x3c
 8018b90:	2201      	movs	r2, #1
 8018b92:	701a      	strb	r2, [r3, #0]
		PUTCHAR(CILEN_SHORT, nakoutp);
 8018b94:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018b96:	1c5a      	adds	r2, r3, #1
 8018b98:	63fa      	str	r2, [r7, #60]	; 0x3c
 8018b9a:	2204      	movs	r2, #4
 8018b9c:	701a      	strb	r2, [r3, #0]
		PUTSHORT(PPP_MINMRU, nakoutp);	/* Give him a hint */
 8018b9e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018ba0:	1c5a      	adds	r2, r3, #1
 8018ba2:	63fa      	str	r2, [r7, #60]	; 0x3c
 8018ba4:	2200      	movs	r2, #0
 8018ba6:	701a      	strb	r2, [r3, #0]
 8018ba8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018baa:	1c5a      	adds	r2, r3, #1
 8018bac:	63fa      	str	r2, [r7, #60]	; 0x3c
 8018bae:	2280      	movs	r2, #128	; 0x80
 8018bb0:	701a      	strb	r2, [r3, #0]
		break;
 8018bb2:	e16d      	b.n	8018e90 <lcp_reqci+0x448>
	    }
	    ho->neg_mru = 1;		/* Remember he sent MRU */
 8018bb4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018bb6:	781a      	ldrb	r2, [r3, #0]
 8018bb8:	2104      	movs	r1, #4
 8018bba:	430a      	orrs	r2, r1
 8018bbc:	701a      	strb	r2, [r3, #0]
	    ho->mru = cishort;		/* And remember value */
 8018bbe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018bc0:	2212      	movs	r2, #18
 8018bc2:	18ba      	adds	r2, r7, r2
 8018bc4:	8812      	ldrh	r2, [r2, #0]
 8018bc6:	805a      	strh	r2, [r3, #2]
	    break;
 8018bc8:	e162      	b.n	8018e90 <lcp_reqci+0x448>

	case CI_ASYNCMAP:
	    if (!ao->neg_asyncmap ||
 8018bca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018bcc:	781b      	ldrb	r3, [r3, #0]
 8018bce:	2208      	movs	r2, #8
 8018bd0:	4013      	ands	r3, r2
 8018bd2:	b2db      	uxtb	r3, r3
 8018bd4:	2b00      	cmp	r3, #0
 8018bd6:	d002      	beq.n	8018bde <lcp_reqci+0x196>
 8018bd8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8018bda:	2b06      	cmp	r3, #6
 8018bdc:	d002      	beq.n	8018be4 <lcp_reqci+0x19c>
		cilen != CILEN_LONG) {
		orc = CONFREJ;
 8018bde:	2304      	movs	r3, #4
 8018be0:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8018be2:	e155      	b.n	8018e90 <lcp_reqci+0x448>
	    }
	    GETLONG(cilong, p);
 8018be4:	6a3b      	ldr	r3, [r7, #32]
 8018be6:	1c5a      	adds	r2, r3, #1
 8018be8:	623a      	str	r2, [r7, #32]
 8018bea:	781b      	ldrb	r3, [r3, #0]
 8018bec:	021b      	lsls	r3, r3, #8
 8018bee:	617b      	str	r3, [r7, #20]
 8018bf0:	6a3b      	ldr	r3, [r7, #32]
 8018bf2:	1c5a      	adds	r2, r3, #1
 8018bf4:	623a      	str	r2, [r7, #32]
 8018bf6:	781b      	ldrb	r3, [r3, #0]
 8018bf8:	001a      	movs	r2, r3
 8018bfa:	697b      	ldr	r3, [r7, #20]
 8018bfc:	4313      	orrs	r3, r2
 8018bfe:	617b      	str	r3, [r7, #20]
 8018c00:	697b      	ldr	r3, [r7, #20]
 8018c02:	021b      	lsls	r3, r3, #8
 8018c04:	617b      	str	r3, [r7, #20]
 8018c06:	6a3b      	ldr	r3, [r7, #32]
 8018c08:	1c5a      	adds	r2, r3, #1
 8018c0a:	623a      	str	r2, [r7, #32]
 8018c0c:	781b      	ldrb	r3, [r3, #0]
 8018c0e:	001a      	movs	r2, r3
 8018c10:	697b      	ldr	r3, [r7, #20]
 8018c12:	4313      	orrs	r3, r2
 8018c14:	617b      	str	r3, [r7, #20]
 8018c16:	697b      	ldr	r3, [r7, #20]
 8018c18:	021b      	lsls	r3, r3, #8
 8018c1a:	617b      	str	r3, [r7, #20]
 8018c1c:	6a3b      	ldr	r3, [r7, #32]
 8018c1e:	1c5a      	adds	r2, r3, #1
 8018c20:	623a      	str	r2, [r7, #32]
 8018c22:	781b      	ldrb	r3, [r3, #0]
 8018c24:	001a      	movs	r2, r3
 8018c26:	697b      	ldr	r3, [r7, #20]
 8018c28:	4313      	orrs	r3, r2
 8018c2a:	617b      	str	r3, [r7, #20]

	    /*
	     * Asyncmap must have set at least the bits
	     * which are set in lcp_allowoptions[unit].asyncmap.
	     */
	    if ((ao->asyncmap & ~cilong) != 0) {
 8018c2c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018c2e:	685b      	ldr	r3, [r3, #4]
 8018c30:	697a      	ldr	r2, [r7, #20]
 8018c32:	43d2      	mvns	r2, r2
 8018c34:	4013      	ands	r3, r2
 8018c36:	d035      	beq.n	8018ca4 <lcp_reqci+0x25c>
		orc = CONFNAK;
 8018c38:	2303      	movs	r3, #3
 8018c3a:	647b      	str	r3, [r7, #68]	; 0x44
		PUTCHAR(CI_ASYNCMAP, nakoutp);
 8018c3c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018c3e:	1c5a      	adds	r2, r3, #1
 8018c40:	63fa      	str	r2, [r7, #60]	; 0x3c
 8018c42:	2202      	movs	r2, #2
 8018c44:	701a      	strb	r2, [r3, #0]
		PUTCHAR(CILEN_LONG, nakoutp);
 8018c46:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018c48:	1c5a      	adds	r2, r3, #1
 8018c4a:	63fa      	str	r2, [r7, #60]	; 0x3c
 8018c4c:	2206      	movs	r2, #6
 8018c4e:	701a      	strb	r2, [r3, #0]
		PUTLONG(ao->asyncmap | cilong, nakoutp);
 8018c50:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018c52:	685a      	ldr	r2, [r3, #4]
 8018c54:	697b      	ldr	r3, [r7, #20]
 8018c56:	4313      	orrs	r3, r2
 8018c58:	0e19      	lsrs	r1, r3, #24
 8018c5a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018c5c:	1c5a      	adds	r2, r3, #1
 8018c5e:	63fa      	str	r2, [r7, #60]	; 0x3c
 8018c60:	b2ca      	uxtb	r2, r1
 8018c62:	701a      	strb	r2, [r3, #0]
 8018c64:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018c66:	685a      	ldr	r2, [r3, #4]
 8018c68:	697b      	ldr	r3, [r7, #20]
 8018c6a:	4313      	orrs	r3, r2
 8018c6c:	0c19      	lsrs	r1, r3, #16
 8018c6e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018c70:	1c5a      	adds	r2, r3, #1
 8018c72:	63fa      	str	r2, [r7, #60]	; 0x3c
 8018c74:	b2ca      	uxtb	r2, r1
 8018c76:	701a      	strb	r2, [r3, #0]
 8018c78:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018c7a:	685a      	ldr	r2, [r3, #4]
 8018c7c:	697b      	ldr	r3, [r7, #20]
 8018c7e:	4313      	orrs	r3, r2
 8018c80:	0a19      	lsrs	r1, r3, #8
 8018c82:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018c84:	1c5a      	adds	r2, r3, #1
 8018c86:	63fa      	str	r2, [r7, #60]	; 0x3c
 8018c88:	b2ca      	uxtb	r2, r1
 8018c8a:	701a      	strb	r2, [r3, #0]
 8018c8c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018c8e:	685b      	ldr	r3, [r3, #4]
 8018c90:	b2d9      	uxtb	r1, r3
 8018c92:	697b      	ldr	r3, [r7, #20]
 8018c94:	b2da      	uxtb	r2, r3
 8018c96:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018c98:	1c58      	adds	r0, r3, #1
 8018c9a:	63f8      	str	r0, [r7, #60]	; 0x3c
 8018c9c:	430a      	orrs	r2, r1
 8018c9e:	b2d2      	uxtb	r2, r2
 8018ca0:	701a      	strb	r2, [r3, #0]
		break;
 8018ca2:	e0f5      	b.n	8018e90 <lcp_reqci+0x448>
	    }
	    ho->neg_asyncmap = 1;
 8018ca4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018ca6:	781a      	ldrb	r2, [r3, #0]
 8018ca8:	2108      	movs	r1, #8
 8018caa:	430a      	orrs	r2, r1
 8018cac:	701a      	strb	r2, [r3, #0]
	    ho->asyncmap = cilong;
 8018cae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018cb0:	697a      	ldr	r2, [r7, #20]
 8018cb2:	605a      	str	r2, [r3, #4]
	    break;
 8018cb4:	e0ec      	b.n	8018e90 <lcp_reqci+0x448>
#endif /* EAP_SUPPORT */
		)) {
		/*
		 * Reject the option if we're not willing to authenticate.
		 */
		ppp_dbglog("No auth is possible");
 8018cb6:	4b7b      	ldr	r3, [pc, #492]	; (8018ea4 <lcp_reqci+0x45c>)
 8018cb8:	0018      	movs	r0, r3
 8018cba:	f002 fa8c 	bl	801b1d6 <ppp_dbglog>
		orc = CONFREJ;
 8018cbe:	2304      	movs	r3, #4
 8018cc0:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8018cc2:	e0e5      	b.n	8018e90 <lcp_reqci+0x448>
	    }
	    break;
#endif /* LQR_SUPPORT */

	case CI_MAGICNUMBER:
	    if (!(ao->neg_magicnumber || go->neg_magicnumber) ||
 8018cc4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018cc6:	781b      	ldrb	r3, [r3, #0]
 8018cc8:	2210      	movs	r2, #16
 8018cca:	4013      	ands	r3, r2
 8018ccc:	b2db      	uxtb	r3, r3
 8018cce:	2b00      	cmp	r3, #0
 8018cd0:	d106      	bne.n	8018ce0 <lcp_reqci+0x298>
 8018cd2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8018cd4:	781b      	ldrb	r3, [r3, #0]
 8018cd6:	2210      	movs	r2, #16
 8018cd8:	4013      	ands	r3, r2
 8018cda:	b2db      	uxtb	r3, r3
 8018cdc:	2b00      	cmp	r3, #0
 8018cde:	d002      	beq.n	8018ce6 <lcp_reqci+0x29e>
 8018ce0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8018ce2:	2b06      	cmp	r3, #6
 8018ce4:	d002      	beq.n	8018cec <lcp_reqci+0x2a4>
		cilen != CILEN_LONG) {
		orc = CONFREJ;
 8018ce6:	2304      	movs	r3, #4
 8018ce8:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8018cea:	e0d1      	b.n	8018e90 <lcp_reqci+0x448>
	    }
	    GETLONG(cilong, p);
 8018cec:	6a3b      	ldr	r3, [r7, #32]
 8018cee:	1c5a      	adds	r2, r3, #1
 8018cf0:	623a      	str	r2, [r7, #32]
 8018cf2:	781b      	ldrb	r3, [r3, #0]
 8018cf4:	021b      	lsls	r3, r3, #8
 8018cf6:	617b      	str	r3, [r7, #20]
 8018cf8:	6a3b      	ldr	r3, [r7, #32]
 8018cfa:	1c5a      	adds	r2, r3, #1
 8018cfc:	623a      	str	r2, [r7, #32]
 8018cfe:	781b      	ldrb	r3, [r3, #0]
 8018d00:	001a      	movs	r2, r3
 8018d02:	697b      	ldr	r3, [r7, #20]
 8018d04:	4313      	orrs	r3, r2
 8018d06:	617b      	str	r3, [r7, #20]
 8018d08:	697b      	ldr	r3, [r7, #20]
 8018d0a:	021b      	lsls	r3, r3, #8
 8018d0c:	617b      	str	r3, [r7, #20]
 8018d0e:	6a3b      	ldr	r3, [r7, #32]
 8018d10:	1c5a      	adds	r2, r3, #1
 8018d12:	623a      	str	r2, [r7, #32]
 8018d14:	781b      	ldrb	r3, [r3, #0]
 8018d16:	001a      	movs	r2, r3
 8018d18:	697b      	ldr	r3, [r7, #20]
 8018d1a:	4313      	orrs	r3, r2
 8018d1c:	617b      	str	r3, [r7, #20]
 8018d1e:	697b      	ldr	r3, [r7, #20]
 8018d20:	021b      	lsls	r3, r3, #8
 8018d22:	617b      	str	r3, [r7, #20]
 8018d24:	6a3b      	ldr	r3, [r7, #32]
 8018d26:	1c5a      	adds	r2, r3, #1
 8018d28:	623a      	str	r2, [r7, #32]
 8018d2a:	781b      	ldrb	r3, [r3, #0]
 8018d2c:	001a      	movs	r2, r3
 8018d2e:	697b      	ldr	r3, [r7, #20]
 8018d30:	4313      	orrs	r3, r2
 8018d32:	617b      	str	r3, [r7, #20]

	    /*
	     * He must have a different magic number.
	     */
	    if (go->neg_magicnumber &&
 8018d34:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8018d36:	781b      	ldrb	r3, [r3, #0]
 8018d38:	2210      	movs	r2, #16
 8018d3a:	4013      	ands	r3, r2
 8018d3c:	b2db      	uxtb	r3, r3
 8018d3e:	2b00      	cmp	r3, #0
 8018d40:	d030      	beq.n	8018da4 <lcp_reqci+0x35c>
		cilong == go->magicnumber) {
 8018d42:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8018d44:	689b      	ldr	r3, [r3, #8]
	    if (go->neg_magicnumber &&
 8018d46:	697a      	ldr	r2, [r7, #20]
 8018d48:	429a      	cmp	r2, r3
 8018d4a:	d12b      	bne.n	8018da4 <lcp_reqci+0x35c>
		cilong = magic();	/* Don't put magic() inside macro! */
 8018d4c:	f000 fbca 	bl	80194e4 <magic>
 8018d50:	0003      	movs	r3, r0
 8018d52:	617b      	str	r3, [r7, #20]
		orc = CONFNAK;
 8018d54:	2303      	movs	r3, #3
 8018d56:	647b      	str	r3, [r7, #68]	; 0x44
		PUTCHAR(CI_MAGICNUMBER, nakoutp);
 8018d58:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018d5a:	1c5a      	adds	r2, r3, #1
 8018d5c:	63fa      	str	r2, [r7, #60]	; 0x3c
 8018d5e:	2205      	movs	r2, #5
 8018d60:	701a      	strb	r2, [r3, #0]
		PUTCHAR(CILEN_LONG, nakoutp);
 8018d62:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018d64:	1c5a      	adds	r2, r3, #1
 8018d66:	63fa      	str	r2, [r7, #60]	; 0x3c
 8018d68:	2206      	movs	r2, #6
 8018d6a:	701a      	strb	r2, [r3, #0]
		PUTLONG(cilong, nakoutp);
 8018d6c:	697b      	ldr	r3, [r7, #20]
 8018d6e:	0e19      	lsrs	r1, r3, #24
 8018d70:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018d72:	1c5a      	adds	r2, r3, #1
 8018d74:	63fa      	str	r2, [r7, #60]	; 0x3c
 8018d76:	b2ca      	uxtb	r2, r1
 8018d78:	701a      	strb	r2, [r3, #0]
 8018d7a:	697b      	ldr	r3, [r7, #20]
 8018d7c:	0c19      	lsrs	r1, r3, #16
 8018d7e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018d80:	1c5a      	adds	r2, r3, #1
 8018d82:	63fa      	str	r2, [r7, #60]	; 0x3c
 8018d84:	b2ca      	uxtb	r2, r1
 8018d86:	701a      	strb	r2, [r3, #0]
 8018d88:	697b      	ldr	r3, [r7, #20]
 8018d8a:	0a19      	lsrs	r1, r3, #8
 8018d8c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018d8e:	1c5a      	adds	r2, r3, #1
 8018d90:	63fa      	str	r2, [r7, #60]	; 0x3c
 8018d92:	b2ca      	uxtb	r2, r1
 8018d94:	701a      	strb	r2, [r3, #0]
 8018d96:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8018d98:	1c5a      	adds	r2, r3, #1
 8018d9a:	63fa      	str	r2, [r7, #60]	; 0x3c
 8018d9c:	697a      	ldr	r2, [r7, #20]
 8018d9e:	b2d2      	uxtb	r2, r2
 8018da0:	701a      	strb	r2, [r3, #0]
		break;
 8018da2:	e075      	b.n	8018e90 <lcp_reqci+0x448>
	    }
	    ho->neg_magicnumber = 1;
 8018da4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018da6:	781a      	ldrb	r2, [r3, #0]
 8018da8:	2110      	movs	r1, #16
 8018daa:	430a      	orrs	r2, r1
 8018dac:	701a      	strb	r2, [r3, #0]
	    ho->magicnumber = cilong;
 8018dae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018db0:	697a      	ldr	r2, [r7, #20]
 8018db2:	609a      	str	r2, [r3, #8]
	    break;
 8018db4:	e06c      	b.n	8018e90 <lcp_reqci+0x448>


	case CI_PCOMPRESSION:
	    if (!ao->neg_pcompression ||
 8018db6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018db8:	781b      	ldrb	r3, [r3, #0]
 8018dba:	2220      	movs	r2, #32
 8018dbc:	4013      	ands	r3, r2
 8018dbe:	b2db      	uxtb	r3, r3
 8018dc0:	2b00      	cmp	r3, #0
 8018dc2:	d002      	beq.n	8018dca <lcp_reqci+0x382>
 8018dc4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8018dc6:	2b02      	cmp	r3, #2
 8018dc8:	d002      	beq.n	8018dd0 <lcp_reqci+0x388>
		cilen != CILEN_VOID) {
		orc = CONFREJ;
 8018dca:	2304      	movs	r3, #4
 8018dcc:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8018dce:	e05f      	b.n	8018e90 <lcp_reqci+0x448>
	    }
	    ho->neg_pcompression = 1;
 8018dd0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018dd2:	781a      	ldrb	r2, [r3, #0]
 8018dd4:	2120      	movs	r1, #32
 8018dd6:	430a      	orrs	r2, r1
 8018dd8:	701a      	strb	r2, [r3, #0]
	    break;
 8018dda:	e059      	b.n	8018e90 <lcp_reqci+0x448>

	case CI_ACCOMPRESSION:
	    if (!ao->neg_accompression ||
 8018ddc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018dde:	781b      	ldrb	r3, [r3, #0]
 8018de0:	2240      	movs	r2, #64	; 0x40
 8018de2:	4013      	ands	r3, r2
 8018de4:	b2db      	uxtb	r3, r3
 8018de6:	2b00      	cmp	r3, #0
 8018de8:	d002      	beq.n	8018df0 <lcp_reqci+0x3a8>
 8018dea:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8018dec:	2b02      	cmp	r3, #2
 8018dee:	d002      	beq.n	8018df6 <lcp_reqci+0x3ae>
		cilen != CILEN_VOID) {
		orc = CONFREJ;
 8018df0:	2304      	movs	r3, #4
 8018df2:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8018df4:	e04c      	b.n	8018e90 <lcp_reqci+0x448>
	    }
	    ho->neg_accompression = 1;
 8018df6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018df8:	781a      	ldrb	r2, [r3, #0]
 8018dfa:	2140      	movs	r1, #64	; 0x40
 8018dfc:	430a      	orrs	r2, r1
 8018dfe:	701a      	strb	r2, [r3, #0]
	    break;
 8018e00:	e046      	b.n	8018e90 <lcp_reqci+0x448>
	    ho->mrru = cishort;
	    break;
#endif /* HAVE_MULTILINK */

	case CI_SSNHF:
	    if (!ao->neg_ssnhf
 8018e02:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018e04:	785b      	ldrb	r3, [r3, #1]
 8018e06:	2201      	movs	r2, #1
 8018e08:	4013      	ands	r3, r2
 8018e0a:	b2db      	uxtb	r3, r3
 8018e0c:	2b00      	cmp	r3, #0
 8018e0e:	d002      	beq.n	8018e16 <lcp_reqci+0x3ce>
#ifdef HAVE_MULTILINK
		|| !multilink
#endif /* HAVE_MULTILINK */
		|| cilen != CILEN_VOID) {
 8018e10:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8018e12:	2b02      	cmp	r3, #2
 8018e14:	d002      	beq.n	8018e1c <lcp_reqci+0x3d4>
		orc = CONFREJ;
 8018e16:	2304      	movs	r3, #4
 8018e18:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8018e1a:	e039      	b.n	8018e90 <lcp_reqci+0x448>
	    }
	    ho->neg_ssnhf = 1;
 8018e1c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018e1e:	785a      	ldrb	r2, [r3, #1]
 8018e20:	2101      	movs	r1, #1
 8018e22:	430a      	orrs	r2, r1
 8018e24:	705a      	strb	r2, [r3, #1]
	    break;
 8018e26:	e033      	b.n	8018e90 <lcp_reqci+0x448>

	case CI_EPDISC:
	    if (!ao->neg_endpoint ||
 8018e28:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8018e2a:	785b      	ldrb	r3, [r3, #1]
 8018e2c:	2202      	movs	r2, #2
 8018e2e:	4013      	ands	r3, r2
 8018e30:	b2db      	uxtb	r3, r3
 8018e32:	2b00      	cmp	r3, #0
 8018e34:	d005      	beq.n	8018e42 <lcp_reqci+0x3fa>
 8018e36:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8018e38:	2b02      	cmp	r3, #2
 8018e3a:	dd02      	ble.n	8018e42 <lcp_reqci+0x3fa>
		cilen < CILEN_CHAR ||
 8018e3c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8018e3e:	2b17      	cmp	r3, #23
 8018e40:	dd02      	ble.n	8018e48 <lcp_reqci+0x400>
		cilen > CILEN_CHAR + MAX_ENDP_LEN) {
		orc = CONFREJ;
 8018e42:	2304      	movs	r3, #4
 8018e44:	647b      	str	r3, [r7, #68]	; 0x44
		break;
 8018e46:	e023      	b.n	8018e90 <lcp_reqci+0x448>
	    }
	    GETCHAR(cichar, p);
 8018e48:	6a3b      	ldr	r3, [r7, #32]
 8018e4a:	1c5a      	adds	r2, r3, #1
 8018e4c:	623a      	str	r2, [r7, #32]
 8018e4e:	781b      	ldrb	r3, [r3, #0]
 8018e50:	61bb      	str	r3, [r7, #24]
	    cilen -= CILEN_CHAR;
 8018e52:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8018e54:	3b03      	subs	r3, #3
 8018e56:	653b      	str	r3, [r7, #80]	; 0x50
	    ho->neg_endpoint = 1;
 8018e58:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018e5a:	785a      	ldrb	r2, [r3, #1]
 8018e5c:	2102      	movs	r1, #2
 8018e5e:	430a      	orrs	r2, r1
 8018e60:	705a      	strb	r2, [r3, #1]
	    ho->endpoint.class_ = cichar;
 8018e62:	69bb      	ldr	r3, [r7, #24]
 8018e64:	b2da      	uxtb	r2, r3
 8018e66:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018e68:	735a      	strb	r2, [r3, #13]
	    ho->endpoint.length = cilen;
 8018e6a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8018e6c:	b2da      	uxtb	r2, r3
 8018e6e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018e70:	739a      	strb	r2, [r3, #14]
	    MEMCPY(ho->endpoint.value, p, cilen);
 8018e72:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8018e74:	330f      	adds	r3, #15
 8018e76:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8018e78:	6a39      	ldr	r1, [r7, #32]
 8018e7a:	0018      	movs	r0, r3
 8018e7c:	f003 fcba 	bl	801c7f4 <memcpy>
	    INCPTR(cilen, p);
 8018e80:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8018e82:	6a3a      	ldr	r2, [r7, #32]
 8018e84:	18d3      	adds	r3, r2, r3
 8018e86:	623b      	str	r3, [r7, #32]
	    break;
 8018e88:	e002      	b.n	8018e90 <lcp_reqci+0x448>

	default:
	    LCPDEBUG(("lcp_reqci: rcvd unknown option %d", citype));
	    orc = CONFREJ;
 8018e8a:	2304      	movs	r3, #4
 8018e8c:	647b      	str	r3, [r7, #68]	; 0x44
	    break;
 8018e8e:	46c0      	nop			; (mov r8, r8)
	}

endswitch:
	if (orc == CONFACK &&		/* Good CI */
 8018e90:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018e92:	2b02      	cmp	r3, #2
 8018e94:	d108      	bne.n	8018ea8 <lcp_reqci+0x460>
 8018e96:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8018e98:	2b02      	cmp	r3, #2
 8018e9a:	d005      	beq.n	8018ea8 <lcp_reqci+0x460>
	    rc != CONFACK)		/*  but prior CI wasnt? */
	    continue;			/* Don't send this one */
 8018e9c:	e029      	b.n	8018ef2 <lcp_reqci+0x4aa>
 8018e9e:	46c0      	nop			; (mov r8, r8)
 8018ea0:	08021c5c 	.word	0x08021c5c
 8018ea4:	08021198 	.word	0x08021198

	if (orc == CONFNAK) {		/* Nak this CI? */
 8018ea8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018eaa:	2b03      	cmp	r3, #3
 8018eac:	d10e      	bne.n	8018ecc <lcp_reqci+0x484>
	    if (reject_if_disagree	/* Getting fed up with sending NAKs? */
 8018eae:	683b      	ldr	r3, [r7, #0]
 8018eb0:	2b00      	cmp	r3, #0
 8018eb2:	d005      	beq.n	8018ec0 <lcp_reqci+0x478>
		&& citype != CI_MAGICNUMBER) {
 8018eb4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8018eb6:	2b05      	cmp	r3, #5
 8018eb8:	d002      	beq.n	8018ec0 <lcp_reqci+0x478>
		orc = CONFREJ;		/* Get tough if so */
 8018eba:	2304      	movs	r3, #4
 8018ebc:	647b      	str	r3, [r7, #68]	; 0x44
 8018ebe:	e005      	b.n	8018ecc <lcp_reqci+0x484>
	    } else {
		if (rc == CONFREJ)	/* Rejecting prior CI? */
 8018ec0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8018ec2:	2b04      	cmp	r3, #4
 8018ec4:	d100      	bne.n	8018ec8 <lcp_reqci+0x480>
		    continue;		/* Don't send this one */
 8018ec6:	e014      	b.n	8018ef2 <lcp_reqci+0x4aa>
		rc = CONFNAK;
 8018ec8:	2303      	movs	r3, #3
 8018eca:	64bb      	str	r3, [r7, #72]	; 0x48
	    }
	}
	if (orc == CONFREJ) {		/* Reject this CI */
 8018ecc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018ece:	2b04      	cmp	r3, #4
 8018ed0:	d10f      	bne.n	8018ef2 <lcp_reqci+0x4aa>
	    rc = CONFREJ;
 8018ed2:	2304      	movs	r3, #4
 8018ed4:	64bb      	str	r3, [r7, #72]	; 0x48
	    if (cip != rejp)		/* Need to move rejected CI? */
 8018ed6:	69fa      	ldr	r2, [r7, #28]
 8018ed8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8018eda:	429a      	cmp	r2, r3
 8018edc:	d005      	beq.n	8018eea <lcp_reqci+0x4a2>
		MEMCPY(rejp, cip, cilen); /* Move it */
 8018ede:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8018ee0:	69f9      	ldr	r1, [r7, #28]
 8018ee2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8018ee4:	0018      	movs	r0, r3
 8018ee6:	f003 fc85 	bl	801c7f4 <memcpy>
	    INCPTR(cilen, rejp);	/* Update output pointer */
 8018eea:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8018eec:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8018eee:	18d3      	adds	r3, r2, r3
 8018ef0:	643b      	str	r3, [r7, #64]	; 0x40
    while (l) {
 8018ef2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8018ef4:	2b00      	cmp	r3, #0
 8018ef6:	d000      	beq.n	8018efa <lcp_reqci+0x4b2>
 8018ef8:	e5e7      	b.n	8018aca <lcp_reqci+0x82>
     * code would go here.  The extra NAKs would go at *nakoutp.
     * At present there are no cases where we want to ask the
     * peer to negotiate an option.
     */

    switch (rc) {
 8018efa:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8018efc:	2b04      	cmp	r3, #4
 8018efe:	d01f      	beq.n	8018f40 <lcp_reqci+0x4f8>
 8018f00:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8018f02:	2b04      	cmp	r3, #4
 8018f04:	dc22      	bgt.n	8018f4c <lcp_reqci+0x504>
 8018f06:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8018f08:	2b02      	cmp	r3, #2
 8018f0a:	d003      	beq.n	8018f14 <lcp_reqci+0x4cc>
 8018f0c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8018f0e:	2b03      	cmp	r3, #3
 8018f10:	d006      	beq.n	8018f20 <lcp_reqci+0x4d8>
	break;
    case CONFREJ:
	*lenp = rejp - inp;
	break;
    default:
	break;
 8018f12:	e01b      	b.n	8018f4c <lcp_reqci+0x504>
	*lenp = next - inp;
 8018f14:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8018f16:	68bb      	ldr	r3, [r7, #8]
 8018f18:	1ad2      	subs	r2, r2, r3
 8018f1a:	687b      	ldr	r3, [r7, #4]
 8018f1c:	601a      	str	r2, [r3, #0]
	break;
 8018f1e:	e016      	b.n	8018f4e <lcp_reqci+0x506>
	*lenp = nakoutp - (u_char*)nakp->payload;
 8018f20:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018f22:	685b      	ldr	r3, [r3, #4]
 8018f24:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8018f26:	1ad2      	subs	r2, r2, r3
 8018f28:	687b      	ldr	r3, [r7, #4]
 8018f2a:	601a      	str	r2, [r3, #0]
	MEMCPY(inp, nakp->payload, *lenp);
 8018f2c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018f2e:	6859      	ldr	r1, [r3, #4]
 8018f30:	687b      	ldr	r3, [r7, #4]
 8018f32:	681b      	ldr	r3, [r3, #0]
 8018f34:	001a      	movs	r2, r3
 8018f36:	68bb      	ldr	r3, [r7, #8]
 8018f38:	0018      	movs	r0, r3
 8018f3a:	f003 fc5b 	bl	801c7f4 <memcpy>
	break;
 8018f3e:	e006      	b.n	8018f4e <lcp_reqci+0x506>
	*lenp = rejp - inp;
 8018f40:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8018f42:	68bb      	ldr	r3, [r7, #8]
 8018f44:	1ad2      	subs	r2, r2, r3
 8018f46:	687b      	ldr	r3, [r7, #4]
 8018f48:	601a      	str	r2, [r3, #0]
	break;
 8018f4a:	e000      	b.n	8018f4e <lcp_reqci+0x506>
	break;
 8018f4c:	46c0      	nop			; (mov r8, r8)
    }

    pbuf_free(nakp);
 8018f4e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018f50:	0018      	movs	r0, r3
 8018f52:	f7f0 fb9f 	bl	8009694 <pbuf_free>
    LCPDEBUG(("lcp_reqci: returning CONF%s.", CODENAME(rc)));
    return (rc);			/* Return final code */
 8018f56:	6cbb      	ldr	r3, [r7, #72]	; 0x48
}
 8018f58:	0018      	movs	r0, r3
 8018f5a:	46bd      	mov	sp, r7
 8018f5c:	b016      	add	sp, #88	; 0x58
 8018f5e:	bd80      	pop	{r7, pc}

08018f60 <lcp_up>:


/*
 * lcp_up - LCP has come UP.
 */
static void lcp_up(fsm *f) {
 8018f60:	b590      	push	{r4, r7, lr}
 8018f62:	b08d      	sub	sp, #52	; 0x34
 8018f64:	af02      	add	r7, sp, #8
 8018f66:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8018f68:	687b      	ldr	r3, [r7, #4]
 8018f6a:	681b      	ldr	r3, [r3, #0]
 8018f6c:	627b      	str	r3, [r7, #36]	; 0x24
    lcp_options *wo = &pcb->lcp_wantoptions;
 8018f6e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018f70:	3344      	adds	r3, #68	; 0x44
 8018f72:	623b      	str	r3, [r7, #32]
    lcp_options *ho = &pcb->lcp_hisoptions;
 8018f74:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018f76:	33b0      	adds	r3, #176	; 0xb0
 8018f78:	61fb      	str	r3, [r7, #28]
    lcp_options *go = &pcb->lcp_gotoptions;
 8018f7a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018f7c:	3368      	adds	r3, #104	; 0x68
 8018f7e:	61bb      	str	r3, [r7, #24]
    lcp_options *ao = &pcb->lcp_allowoptions;
 8018f80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8018f82:	338c      	adds	r3, #140	; 0x8c
 8018f84:	617b      	str	r3, [r7, #20]
    int mtu, mru;

    if (!go->neg_magicnumber)
 8018f86:	69bb      	ldr	r3, [r7, #24]
 8018f88:	781b      	ldrb	r3, [r3, #0]
 8018f8a:	2210      	movs	r2, #16
 8018f8c:	4013      	ands	r3, r2
 8018f8e:	b2db      	uxtb	r3, r3
 8018f90:	2b00      	cmp	r3, #0
 8018f92:	d102      	bne.n	8018f9a <lcp_up+0x3a>
	go->magicnumber = 0;
 8018f94:	69bb      	ldr	r3, [r7, #24]
 8018f96:	2200      	movs	r2, #0
 8018f98:	609a      	str	r2, [r3, #8]
    if (!ho->neg_magicnumber)
 8018f9a:	69fb      	ldr	r3, [r7, #28]
 8018f9c:	781b      	ldrb	r3, [r3, #0]
 8018f9e:	2210      	movs	r2, #16
 8018fa0:	4013      	ands	r3, r2
 8018fa2:	b2db      	uxtb	r3, r3
 8018fa4:	2b00      	cmp	r3, #0
 8018fa6:	d102      	bne.n	8018fae <lcp_up+0x4e>
	ho->magicnumber = 0;
 8018fa8:	69fb      	ldr	r3, [r7, #28]
 8018faa:	2200      	movs	r2, #0
 8018fac:	609a      	str	r2, [r3, #8]
     * the value we got in the negotiation.
     * Note on the MTU: the link MTU can be the MRU the peer wanted,
     * the interface MTU is set to the lowest of that, the
     * MTU we want to use, and our link MRU.
     */
    mtu = ho->neg_mru? ho->mru: PPP_MRU;
 8018fae:	69fb      	ldr	r3, [r7, #28]
 8018fb0:	781b      	ldrb	r3, [r3, #0]
 8018fb2:	2204      	movs	r2, #4
 8018fb4:	4013      	ands	r3, r2
 8018fb6:	b2db      	uxtb	r3, r3
 8018fb8:	2b00      	cmp	r3, #0
 8018fba:	d002      	beq.n	8018fc2 <lcp_up+0x62>
 8018fbc:	69fb      	ldr	r3, [r7, #28]
 8018fbe:	885b      	ldrh	r3, [r3, #2]
 8018fc0:	e000      	b.n	8018fc4 <lcp_up+0x64>
 8018fc2:	4b42      	ldr	r3, [pc, #264]	; (80190cc <lcp_up+0x16c>)
 8018fc4:	613b      	str	r3, [r7, #16]
    mru = go->neg_mru? LWIP_MAX(wo->mru, go->mru): PPP_MRU;
 8018fc6:	69bb      	ldr	r3, [r7, #24]
 8018fc8:	781b      	ldrb	r3, [r3, #0]
 8018fca:	2204      	movs	r2, #4
 8018fcc:	4013      	ands	r3, r2
 8018fce:	b2db      	uxtb	r3, r3
 8018fd0:	2b00      	cmp	r3, #0
 8018fd2:	d00c      	beq.n	8018fee <lcp_up+0x8e>
 8018fd4:	69bb      	ldr	r3, [r7, #24]
 8018fd6:	885a      	ldrh	r2, [r3, #2]
 8018fd8:	6a3b      	ldr	r3, [r7, #32]
 8018fda:	885b      	ldrh	r3, [r3, #2]
 8018fdc:	1c18      	adds	r0, r3, #0
 8018fde:	1c11      	adds	r1, r2, #0
 8018fe0:	b28a      	uxth	r2, r1
 8018fe2:	b283      	uxth	r3, r0
 8018fe4:	429a      	cmp	r2, r3
 8018fe6:	d200      	bcs.n	8018fea <lcp_up+0x8a>
 8018fe8:	1c01      	adds	r1, r0, #0
 8018fea:	b28b      	uxth	r3, r1
 8018fec:	e000      	b.n	8018ff0 <lcp_up+0x90>
 8018fee:	4b37      	ldr	r3, [pc, #220]	; (80190cc <lcp_up+0x16c>)
 8018ff0:	60fb      	str	r3, [r7, #12]
#ifdef HAVE_MULTILINK
    if (!(multilink && go->neg_mrru && ho->neg_mrru))
#endif /* HAVE_MULTILINK */
	netif_set_mtu(pcb, LWIP_MIN(LWIP_MIN(mtu, mru), ao->mru));
 8018ff2:	697b      	ldr	r3, [r7, #20]
 8018ff4:	885b      	ldrh	r3, [r3, #2]
 8018ff6:	0019      	movs	r1, r3
 8018ff8:	693a      	ldr	r2, [r7, #16]
 8018ffa:	68fb      	ldr	r3, [r7, #12]
 8018ffc:	4293      	cmp	r3, r2
 8018ffe:	dd00      	ble.n	8019002 <lcp_up+0xa2>
 8019000:	0013      	movs	r3, r2
 8019002:	000a      	movs	r2, r1
 8019004:	429a      	cmp	r2, r3
 8019006:	dd00      	ble.n	801900a <lcp_up+0xaa>
 8019008:	001a      	movs	r2, r3
 801900a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801900c:	0011      	movs	r1, r2
 801900e:	0018      	movs	r0, r3
 8019010:	f000 ff20 	bl	8019e54 <netif_set_mtu>
    ppp_send_config(pcb, mtu,
		    (ho->neg_asyncmap? ho->asyncmap: 0xffffffff),
 8019014:	69fb      	ldr	r3, [r7, #28]
 8019016:	781b      	ldrb	r3, [r3, #0]
 8019018:	2208      	movs	r2, #8
 801901a:	4013      	ands	r3, r2
 801901c:	b2db      	uxtb	r3, r3
    ppp_send_config(pcb, mtu,
 801901e:	2b00      	cmp	r3, #0
 8019020:	d002      	beq.n	8019028 <lcp_up+0xc8>
 8019022:	69fb      	ldr	r3, [r7, #28]
 8019024:	685a      	ldr	r2, [r3, #4]
 8019026:	e001      	b.n	801902c <lcp_up+0xcc>
 8019028:	2301      	movs	r3, #1
 801902a:	425a      	negs	r2, r3
		    ho->neg_pcompression, ho->neg_accompression);
 801902c:	69fb      	ldr	r3, [r7, #28]
 801902e:	781b      	ldrb	r3, [r3, #0]
 8019030:	069b      	lsls	r3, r3, #26
 8019032:	0fdb      	lsrs	r3, r3, #31
 8019034:	b2db      	uxtb	r3, r3
    ppp_send_config(pcb, mtu,
 8019036:	001c      	movs	r4, r3
		    ho->neg_pcompression, ho->neg_accompression);
 8019038:	69fb      	ldr	r3, [r7, #28]
 801903a:	781b      	ldrb	r3, [r3, #0]
 801903c:	065b      	lsls	r3, r3, #25
 801903e:	0fdb      	lsrs	r3, r3, #31
 8019040:	b2db      	uxtb	r3, r3
    ppp_send_config(pcb, mtu,
 8019042:	6939      	ldr	r1, [r7, #16]
 8019044:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8019046:	9300      	str	r3, [sp, #0]
 8019048:	0023      	movs	r3, r4
 801904a:	f000 fde5 	bl	8019c18 <ppp_send_config>
    ppp_recv_config(pcb, mru,
		    (pcb->settings.lax_recv? 0: go->neg_asyncmap? go->asyncmap: 0xffffffff),
 801904e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019050:	781b      	ldrb	r3, [r3, #0]
 8019052:	2208      	movs	r2, #8
 8019054:	4013      	ands	r3, r2
 8019056:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, mru,
 8019058:	2b00      	cmp	r3, #0
 801905a:	d10c      	bne.n	8019076 <lcp_up+0x116>
		    (pcb->settings.lax_recv? 0: go->neg_asyncmap? go->asyncmap: 0xffffffff),
 801905c:	69bb      	ldr	r3, [r7, #24]
 801905e:	781b      	ldrb	r3, [r3, #0]
 8019060:	2208      	movs	r2, #8
 8019062:	4013      	ands	r3, r2
 8019064:	b2db      	uxtb	r3, r3
 8019066:	2b00      	cmp	r3, #0
 8019068:	d002      	beq.n	8019070 <lcp_up+0x110>
 801906a:	69bb      	ldr	r3, [r7, #24]
 801906c:	685a      	ldr	r2, [r3, #4]
 801906e:	e003      	b.n	8019078 <lcp_up+0x118>
 8019070:	2301      	movs	r3, #1
 8019072:	425a      	negs	r2, r3
 8019074:	e000      	b.n	8019078 <lcp_up+0x118>
    ppp_recv_config(pcb, mru,
 8019076:	2200      	movs	r2, #0
		    go->neg_pcompression, go->neg_accompression);
 8019078:	69bb      	ldr	r3, [r7, #24]
 801907a:	781b      	ldrb	r3, [r3, #0]
 801907c:	069b      	lsls	r3, r3, #26
 801907e:	0fdb      	lsrs	r3, r3, #31
 8019080:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, mru,
 8019082:	001c      	movs	r4, r3
		    go->neg_pcompression, go->neg_accompression);
 8019084:	69bb      	ldr	r3, [r7, #24]
 8019086:	781b      	ldrb	r3, [r3, #0]
 8019088:	065b      	lsls	r3, r3, #25
 801908a:	0fdb      	lsrs	r3, r3, #31
 801908c:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, mru,
 801908e:	68f9      	ldr	r1, [r7, #12]
 8019090:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8019092:	9300      	str	r3, [sp, #0]
 8019094:	0023      	movs	r3, r4
 8019096:	f000 fddc 	bl	8019c52 <ppp_recv_config>

    if (ho->neg_mru)
 801909a:	69fb      	ldr	r3, [r7, #28]
 801909c:	781b      	ldrb	r3, [r3, #0]
 801909e:	2204      	movs	r2, #4
 80190a0:	4013      	ands	r3, r2
 80190a2:	b2db      	uxtb	r3, r3
 80190a4:	2b00      	cmp	r3, #0
 80190a6:	d004      	beq.n	80190b2 <lcp_up+0x152>
	pcb->peer_mru = ho->mru;
 80190a8:	69fb      	ldr	r3, [r7, #28]
 80190aa:	8859      	ldrh	r1, [r3, #2]
 80190ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80190ae:	22d4      	movs	r2, #212	; 0xd4
 80190b0:	5299      	strh	r1, [r3, r2]

    lcp_echo_lowerup(f->pcb);  /* Enable echo messages */
 80190b2:	687b      	ldr	r3, [r7, #4]
 80190b4:	681b      	ldr	r3, [r3, #0]
 80190b6:	0018      	movs	r0, r3
 80190b8:	f000 f9b0 	bl	801941c <lcp_echo_lowerup>

    link_established(pcb);
 80190bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80190be:	0018      	movs	r0, r3
 80190c0:	f7fa fdc6 	bl	8013c50 <link_established>
}
 80190c4:	46c0      	nop			; (mov r8, r8)
 80190c6:	46bd      	mov	sp, r7
 80190c8:	b00b      	add	sp, #44	; 0x2c
 80190ca:	bd90      	pop	{r4, r7, pc}
 80190cc:	000005dc 	.word	0x000005dc

080190d0 <lcp_down>:
/*
 * lcp_down - LCP has gone DOWN.
 *
 * Alert other protocols.
 */
static void lcp_down(fsm *f) {
 80190d0:	b590      	push	{r4, r7, lr}
 80190d2:	b087      	sub	sp, #28
 80190d4:	af02      	add	r7, sp, #8
 80190d6:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 80190d8:	687b      	ldr	r3, [r7, #4]
 80190da:	681b      	ldr	r3, [r3, #0]
 80190dc:	60fb      	str	r3, [r7, #12]
    lcp_options *go = &pcb->lcp_gotoptions;
 80190de:	68fb      	ldr	r3, [r7, #12]
 80190e0:	3368      	adds	r3, #104	; 0x68
 80190e2:	60bb      	str	r3, [r7, #8]

    lcp_echo_lowerdown(f->pcb);
 80190e4:	687b      	ldr	r3, [r7, #4]
 80190e6:	681b      	ldr	r3, [r3, #0]
 80190e8:	0018      	movs	r0, r3
 80190ea:	f000 f9b9 	bl	8019460 <lcp_echo_lowerdown>

    link_down(pcb);
 80190ee:	68fb      	ldr	r3, [r7, #12]
 80190f0:	0018      	movs	r0, r3
 80190f2:	f7fa fd53 	bl	8013b9c <link_down>

    ppp_send_config(pcb, PPP_MRU, 0xffffffff, 0, 0);
 80190f6:	2301      	movs	r3, #1
 80190f8:	425a      	negs	r2, r3
 80190fa:	4916      	ldr	r1, [pc, #88]	; (8019154 <lcp_down+0x84>)
 80190fc:	68f8      	ldr	r0, [r7, #12]
 80190fe:	2300      	movs	r3, #0
 8019100:	9300      	str	r3, [sp, #0]
 8019102:	2300      	movs	r3, #0
 8019104:	f000 fd88 	bl	8019c18 <ppp_send_config>
    ppp_recv_config(pcb, PPP_MRU,
		    (go->neg_asyncmap? go->asyncmap: 0xffffffff),
 8019108:	68bb      	ldr	r3, [r7, #8]
 801910a:	781b      	ldrb	r3, [r3, #0]
 801910c:	2208      	movs	r2, #8
 801910e:	4013      	ands	r3, r2
 8019110:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, PPP_MRU,
 8019112:	2b00      	cmp	r3, #0
 8019114:	d002      	beq.n	801911c <lcp_down+0x4c>
 8019116:	68bb      	ldr	r3, [r7, #8]
 8019118:	685a      	ldr	r2, [r3, #4]
 801911a:	e001      	b.n	8019120 <lcp_down+0x50>
 801911c:	2301      	movs	r3, #1
 801911e:	425a      	negs	r2, r3
		    go->neg_pcompression, go->neg_accompression);
 8019120:	68bb      	ldr	r3, [r7, #8]
 8019122:	781b      	ldrb	r3, [r3, #0]
 8019124:	069b      	lsls	r3, r3, #26
 8019126:	0fdb      	lsrs	r3, r3, #31
 8019128:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, PPP_MRU,
 801912a:	001c      	movs	r4, r3
		    go->neg_pcompression, go->neg_accompression);
 801912c:	68bb      	ldr	r3, [r7, #8]
 801912e:	781b      	ldrb	r3, [r3, #0]
 8019130:	065b      	lsls	r3, r3, #25
 8019132:	0fdb      	lsrs	r3, r3, #31
 8019134:	b2db      	uxtb	r3, r3
    ppp_recv_config(pcb, PPP_MRU,
 8019136:	4907      	ldr	r1, [pc, #28]	; (8019154 <lcp_down+0x84>)
 8019138:	68f8      	ldr	r0, [r7, #12]
 801913a:	9300      	str	r3, [sp, #0]
 801913c:	0023      	movs	r3, r4
 801913e:	f000 fd88 	bl	8019c52 <ppp_recv_config>
    pcb->peer_mru = PPP_MRU;
 8019142:	68fb      	ldr	r3, [r7, #12]
 8019144:	22d4      	movs	r2, #212	; 0xd4
 8019146:	4903      	ldr	r1, [pc, #12]	; (8019154 <lcp_down+0x84>)
 8019148:	5299      	strh	r1, [r3, r2]
}
 801914a:	46c0      	nop			; (mov r8, r8)
 801914c:	46bd      	mov	sp, r7
 801914e:	b005      	add	sp, #20
 8019150:	bd90      	pop	{r4, r7, pc}
 8019152:	46c0      	nop			; (mov r8, r8)
 8019154:	000005dc 	.word	0x000005dc

08019158 <lcp_starting>:


/*
 * lcp_starting - LCP needs the lower layer up.
 */
static void lcp_starting(fsm *f) {
 8019158:	b580      	push	{r7, lr}
 801915a:	b084      	sub	sp, #16
 801915c:	af00      	add	r7, sp, #0
 801915e:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8019160:	687b      	ldr	r3, [r7, #4]
 8019162:	681b      	ldr	r3, [r3, #0]
 8019164:	60fb      	str	r3, [r7, #12]
    link_required(pcb);
 8019166:	68fb      	ldr	r3, [r7, #12]
 8019168:	0018      	movs	r0, r3
 801916a:	f7fa fced 	bl	8013b48 <link_required>
}
 801916e:	46c0      	nop			; (mov r8, r8)
 8019170:	46bd      	mov	sp, r7
 8019172:	b004      	add	sp, #16
 8019174:	bd80      	pop	{r7, pc}

08019176 <lcp_finished>:


/*
 * lcp_finished - LCP has finished with the lower layer.
 */
static void lcp_finished(fsm *f) {
 8019176:	b580      	push	{r7, lr}
 8019178:	b084      	sub	sp, #16
 801917a:	af00      	add	r7, sp, #0
 801917c:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 801917e:	687b      	ldr	r3, [r7, #4]
 8019180:	681b      	ldr	r3, [r3, #0]
 8019182:	60fb      	str	r3, [r7, #12]
    link_terminated(pcb);
 8019184:	68fb      	ldr	r3, [r7, #12]
 8019186:	0018      	movs	r0, r3
 8019188:	f7fa fce6 	bl	8013b58 <link_terminated>
}
 801918c:	46c0      	nop			; (mov r8, r8)
 801918e:	46bd      	mov	sp, r7
 8019190:	b004      	add	sp, #16
 8019192:	bd80      	pop	{r7, pc}

08019194 <LcpLinkFailure>:

/*
 * Time to shut down the link because there is nothing out there.
 */

static void LcpLinkFailure(fsm *f) {
 8019194:	b580      	push	{r7, lr}
 8019196:	b084      	sub	sp, #16
 8019198:	af00      	add	r7, sp, #0
 801919a:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 801919c:	687b      	ldr	r3, [r7, #4]
 801919e:	681b      	ldr	r3, [r3, #0]
 80191a0:	60fb      	str	r3, [r7, #12]
    if (f->state == PPP_FSM_OPENED) {
 80191a2:	687b      	ldr	r3, [r7, #4]
 80191a4:	7c1b      	ldrb	r3, [r3, #16]
 80191a6:	2b09      	cmp	r3, #9
 80191a8:	d116      	bne.n	80191d8 <LcpLinkFailure+0x44>
	ppp_info("No response to %d echo-requests", pcb->lcp_echos_pending);
 80191aa:	68fb      	ldr	r3, [r7, #12]
 80191ac:	22d6      	movs	r2, #214	; 0xd6
 80191ae:	5c9b      	ldrb	r3, [r3, r2]
 80191b0:	001a      	movs	r2, r3
 80191b2:	4b0b      	ldr	r3, [pc, #44]	; (80191e0 <LcpLinkFailure+0x4c>)
 80191b4:	0011      	movs	r1, r2
 80191b6:	0018      	movs	r0, r3
 80191b8:	f001 fff9 	bl	801b1ae <ppp_info>
        ppp_notice("Serial link appears to be disconnected.");
 80191bc:	4b09      	ldr	r3, [pc, #36]	; (80191e4 <LcpLinkFailure+0x50>)
 80191be:	0018      	movs	r0, r3
 80191c0:	f001 ffe1 	bl	801b186 <ppp_notice>
	pcb->err_code = PPPERR_PEERDEAD;
 80191c4:	68fb      	ldr	r3, [r7, #12]
 80191c6:	2225      	movs	r2, #37	; 0x25
 80191c8:	2109      	movs	r1, #9
 80191ca:	5499      	strb	r1, [r3, r2]
	lcp_close(pcb, "Peer not responding");
 80191cc:	4a06      	ldr	r2, [pc, #24]	; (80191e8 <LcpLinkFailure+0x54>)
 80191ce:	68fb      	ldr	r3, [r7, #12]
 80191d0:	0011      	movs	r1, r2
 80191d2:	0018      	movs	r0, r3
 80191d4:	f7fe f92e 	bl	8017434 <lcp_close>
    }
}
 80191d8:	46c0      	nop			; (mov r8, r8)
 80191da:	46bd      	mov	sp, r7
 80191dc:	b004      	add	sp, #16
 80191de:	bd80      	pop	{r7, pc}
 80191e0:	080211ac 	.word	0x080211ac
 80191e4:	080211cc 	.word	0x080211cc
 80191e8:	080211f4 	.word	0x080211f4

080191ec <LcpEchoCheck>:

/*
 * Timer expired for the LCP echo requests from this process.
 */

static void LcpEchoCheck(fsm *f) {
 80191ec:	b580      	push	{r7, lr}
 80191ee:	b084      	sub	sp, #16
 80191f0:	af00      	add	r7, sp, #0
 80191f2:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 80191f4:	687b      	ldr	r3, [r7, #4]
 80191f6:	681b      	ldr	r3, [r3, #0]
 80191f8:	60fb      	str	r3, [r7, #12]

    LcpSendEchoRequest (f);
 80191fa:	687b      	ldr	r3, [r7, #4]
 80191fc:	0018      	movs	r0, r3
 80191fe:	f000 f8ad 	bl	801935c <LcpSendEchoRequest>
    if (f->state != PPP_FSM_OPENED)
 8019202:	687b      	ldr	r3, [r7, #4]
 8019204:	7c1b      	ldrb	r3, [r3, #16]
 8019206:	2b09      	cmp	r3, #9
 8019208:	d127      	bne.n	801925a <LcpEchoCheck+0x6e>
	return;

    /*
     * Start the timer for the next interval.
     */
    if (pcb->lcp_echo_timer_running)
 801920a:	68fb      	ldr	r3, [r7, #12]
 801920c:	2226      	movs	r2, #38	; 0x26
 801920e:	5c9b      	ldrb	r3, [r3, r2]
 8019210:	2210      	movs	r2, #16
 8019212:	4013      	ands	r3, r2
 8019214:	b2db      	uxtb	r3, r3
 8019216:	2b00      	cmp	r3, #0
 8019218:	d003      	beq.n	8019222 <LcpEchoCheck+0x36>
	ppp_warn("assertion lcp_echo_timer_running==0 failed");
 801921a:	4b12      	ldr	r3, [pc, #72]	; (8019264 <LcpEchoCheck+0x78>)
 801921c:	0018      	movs	r0, r3
 801921e:	f001 ff9e 	bl	801b15e <ppp_warn>
    TIMEOUT (LcpEchoTimeout, f, pcb->settings.lcp_echo_interval);
 8019222:	687a      	ldr	r2, [r7, #4]
 8019224:	4b10      	ldr	r3, [pc, #64]	; (8019268 <LcpEchoCheck+0x7c>)
 8019226:	0011      	movs	r1, r2
 8019228:	0018      	movs	r0, r3
 801922a:	f7f8 fd3d 	bl	8011ca8 <sys_untimeout>
 801922e:	68fb      	ldr	r3, [r7, #12]
 8019230:	7a5b      	ldrb	r3, [r3, #9]
 8019232:	001a      	movs	r2, r3
 8019234:	0013      	movs	r3, r2
 8019236:	015b      	lsls	r3, r3, #5
 8019238:	1a9b      	subs	r3, r3, r2
 801923a:	009b      	lsls	r3, r3, #2
 801923c:	189b      	adds	r3, r3, r2
 801923e:	00db      	lsls	r3, r3, #3
 8019240:	0018      	movs	r0, r3
 8019242:	687a      	ldr	r2, [r7, #4]
 8019244:	4b08      	ldr	r3, [pc, #32]	; (8019268 <LcpEchoCheck+0x7c>)
 8019246:	0019      	movs	r1, r3
 8019248:	f7f8 fd06 	bl	8011c58 <sys_timeout>
    pcb->lcp_echo_timer_running = 1;
 801924c:	68fb      	ldr	r3, [r7, #12]
 801924e:	2226      	movs	r2, #38	; 0x26
 8019250:	5c99      	ldrb	r1, [r3, r2]
 8019252:	2010      	movs	r0, #16
 8019254:	4301      	orrs	r1, r0
 8019256:	5499      	strb	r1, [r3, r2]
 8019258:	e000      	b.n	801925c <LcpEchoCheck+0x70>
	return;
 801925a:	46c0      	nop			; (mov r8, r8)
}
 801925c:	46bd      	mov	sp, r7
 801925e:	b004      	add	sp, #16
 8019260:	bd80      	pop	{r7, pc}
 8019262:	46c0      	nop			; (mov r8, r8)
 8019264:	08021208 	.word	0x08021208
 8019268:	0801926d 	.word	0x0801926d

0801926c <LcpEchoTimeout>:

/*
 * LcpEchoTimeout - Timer expired on the LCP echo
 */

static void LcpEchoTimeout(void *arg) {
 801926c:	b580      	push	{r7, lr}
 801926e:	b084      	sub	sp, #16
 8019270:	af00      	add	r7, sp, #0
 8019272:	6078      	str	r0, [r7, #4]
    fsm *f = (fsm*)arg;
 8019274:	687b      	ldr	r3, [r7, #4]
 8019276:	60fb      	str	r3, [r7, #12]
    ppp_pcb *pcb = f->pcb;
 8019278:	68fb      	ldr	r3, [r7, #12]
 801927a:	681b      	ldr	r3, [r3, #0]
 801927c:	60bb      	str	r3, [r7, #8]
    if (pcb->lcp_echo_timer_running != 0) {
 801927e:	68bb      	ldr	r3, [r7, #8]
 8019280:	2226      	movs	r2, #38	; 0x26
 8019282:	5c9b      	ldrb	r3, [r3, r2]
 8019284:	2210      	movs	r2, #16
 8019286:	4013      	ands	r3, r2
 8019288:	b2db      	uxtb	r3, r3
 801928a:	2b00      	cmp	r3, #0
 801928c:	d009      	beq.n	80192a2 <LcpEchoTimeout+0x36>
        pcb->lcp_echo_timer_running = 0;
 801928e:	68bb      	ldr	r3, [r7, #8]
 8019290:	2226      	movs	r2, #38	; 0x26
 8019292:	5c99      	ldrb	r1, [r3, r2]
 8019294:	2010      	movs	r0, #16
 8019296:	4381      	bics	r1, r0
 8019298:	5499      	strb	r1, [r3, r2]
        LcpEchoCheck ((fsm *) arg);
 801929a:	687b      	ldr	r3, [r7, #4]
 801929c:	0018      	movs	r0, r3
 801929e:	f7ff ffa5 	bl	80191ec <LcpEchoCheck>
    }
}
 80192a2:	46c0      	nop			; (mov r8, r8)
 80192a4:	46bd      	mov	sp, r7
 80192a6:	b004      	add	sp, #16
 80192a8:	bd80      	pop	{r7, pc}
	...

080192ac <lcp_received_echo_reply>:

/*
 * LcpEchoReply - LCP has received a reply to the echo
 */

static void lcp_received_echo_reply(fsm *f, int id, u_char *inp, int len) {
 80192ac:	b580      	push	{r7, lr}
 80192ae:	b088      	sub	sp, #32
 80192b0:	af00      	add	r7, sp, #0
 80192b2:	60f8      	str	r0, [r7, #12]
 80192b4:	60b9      	str	r1, [r7, #8]
 80192b6:	607a      	str	r2, [r7, #4]
 80192b8:	603b      	str	r3, [r7, #0]
    ppp_pcb *pcb = f->pcb;
 80192ba:	68fb      	ldr	r3, [r7, #12]
 80192bc:	681b      	ldr	r3, [r3, #0]
 80192be:	61fb      	str	r3, [r7, #28]
    lcp_options *go = &pcb->lcp_gotoptions;
 80192c0:	69fb      	ldr	r3, [r7, #28]
 80192c2:	3368      	adds	r3, #104	; 0x68
 80192c4:	61bb      	str	r3, [r7, #24]
    u32_t magic_val;
    LWIP_UNUSED_ARG(id);

    /* Check the magic number - don't count replies from ourselves. */
    if (len < 4) {
 80192c6:	683b      	ldr	r3, [r7, #0]
 80192c8:	2b03      	cmp	r3, #3
 80192ca:	dc06      	bgt.n	80192da <lcp_received_echo_reply+0x2e>
	ppp_dbglog("lcp: received short Echo-Reply, length %d", len);
 80192cc:	683a      	ldr	r2, [r7, #0]
 80192ce:	4b21      	ldr	r3, [pc, #132]	; (8019354 <lcp_received_echo_reply+0xa8>)
 80192d0:	0011      	movs	r1, r2
 80192d2:	0018      	movs	r0, r3
 80192d4:	f001 ff7f 	bl	801b1d6 <ppp_dbglog>
	return;
 80192d8:	e038      	b.n	801934c <lcp_received_echo_reply+0xa0>
    }
    GETLONG(magic_val, inp);
 80192da:	687b      	ldr	r3, [r7, #4]
 80192dc:	1c5a      	adds	r2, r3, #1
 80192de:	607a      	str	r2, [r7, #4]
 80192e0:	781b      	ldrb	r3, [r3, #0]
 80192e2:	021b      	lsls	r3, r3, #8
 80192e4:	617b      	str	r3, [r7, #20]
 80192e6:	687b      	ldr	r3, [r7, #4]
 80192e8:	1c5a      	adds	r2, r3, #1
 80192ea:	607a      	str	r2, [r7, #4]
 80192ec:	781b      	ldrb	r3, [r3, #0]
 80192ee:	001a      	movs	r2, r3
 80192f0:	697b      	ldr	r3, [r7, #20]
 80192f2:	4313      	orrs	r3, r2
 80192f4:	617b      	str	r3, [r7, #20]
 80192f6:	697b      	ldr	r3, [r7, #20]
 80192f8:	021b      	lsls	r3, r3, #8
 80192fa:	617b      	str	r3, [r7, #20]
 80192fc:	687b      	ldr	r3, [r7, #4]
 80192fe:	1c5a      	adds	r2, r3, #1
 8019300:	607a      	str	r2, [r7, #4]
 8019302:	781b      	ldrb	r3, [r3, #0]
 8019304:	001a      	movs	r2, r3
 8019306:	697b      	ldr	r3, [r7, #20]
 8019308:	4313      	orrs	r3, r2
 801930a:	617b      	str	r3, [r7, #20]
 801930c:	697b      	ldr	r3, [r7, #20]
 801930e:	021b      	lsls	r3, r3, #8
 8019310:	617b      	str	r3, [r7, #20]
 8019312:	687b      	ldr	r3, [r7, #4]
 8019314:	1c5a      	adds	r2, r3, #1
 8019316:	607a      	str	r2, [r7, #4]
 8019318:	781b      	ldrb	r3, [r3, #0]
 801931a:	001a      	movs	r2, r3
 801931c:	697b      	ldr	r3, [r7, #20]
 801931e:	4313      	orrs	r3, r2
 8019320:	617b      	str	r3, [r7, #20]
    if (go->neg_magicnumber
 8019322:	69bb      	ldr	r3, [r7, #24]
 8019324:	781b      	ldrb	r3, [r3, #0]
 8019326:	2210      	movs	r2, #16
 8019328:	4013      	ands	r3, r2
 801932a:	b2db      	uxtb	r3, r3
 801932c:	2b00      	cmp	r3, #0
 801932e:	d009      	beq.n	8019344 <lcp_received_echo_reply+0x98>
	&& magic_val == go->magicnumber) {
 8019330:	69bb      	ldr	r3, [r7, #24]
 8019332:	689b      	ldr	r3, [r3, #8]
 8019334:	697a      	ldr	r2, [r7, #20]
 8019336:	429a      	cmp	r2, r3
 8019338:	d104      	bne.n	8019344 <lcp_received_echo_reply+0x98>
	ppp_warn("appear to have received our own echo-reply!");
 801933a:	4b07      	ldr	r3, [pc, #28]	; (8019358 <lcp_received_echo_reply+0xac>)
 801933c:	0018      	movs	r0, r3
 801933e:	f001 ff0e 	bl	801b15e <ppp_warn>
	return;
 8019342:	e003      	b.n	801934c <lcp_received_echo_reply+0xa0>
    }

    /* Reset the number of outstanding echo frames */
    pcb->lcp_echos_pending = 0;
 8019344:	69fb      	ldr	r3, [r7, #28]
 8019346:	22d6      	movs	r2, #214	; 0xd6
 8019348:	2100      	movs	r1, #0
 801934a:	5499      	strb	r1, [r3, r2]
}
 801934c:	46bd      	mov	sp, r7
 801934e:	b008      	add	sp, #32
 8019350:	bd80      	pop	{r7, pc}
 8019352:	46c0      	nop			; (mov r8, r8)
 8019354:	08021234 	.word	0x08021234
 8019358:	08021260 	.word	0x08021260

0801935c <LcpSendEchoRequest>:

/*
 * LcpSendEchoRequest - Send an echo request frame to the peer
 */

static void LcpSendEchoRequest(fsm *f) {
 801935c:	b590      	push	{r4, r7, lr}
 801935e:	b08b      	sub	sp, #44	; 0x2c
 8019360:	af02      	add	r7, sp, #8
 8019362:	6078      	str	r0, [r7, #4]
    ppp_pcb *pcb = f->pcb;
 8019364:	687b      	ldr	r3, [r7, #4]
 8019366:	681b      	ldr	r3, [r3, #0]
 8019368:	61fb      	str	r3, [r7, #28]
    lcp_options *go = &pcb->lcp_gotoptions;
 801936a:	69fb      	ldr	r3, [r7, #28]
 801936c:	3368      	adds	r3, #104	; 0x68
 801936e:	61bb      	str	r3, [r7, #24]
    u_char pkt[4], *pktp;

    /*
     * Detect the failure of the peer at this point.
     */
    if (pcb->settings.lcp_echo_fails != 0) {
 8019370:	69fb      	ldr	r3, [r7, #28]
 8019372:	7a9b      	ldrb	r3, [r3, #10]
 8019374:	2b00      	cmp	r3, #0
 8019376:	d00e      	beq.n	8019396 <LcpSendEchoRequest+0x3a>
        if (pcb->lcp_echos_pending >= pcb->settings.lcp_echo_fails) {
 8019378:	69fb      	ldr	r3, [r7, #28]
 801937a:	22d6      	movs	r2, #214	; 0xd6
 801937c:	5c9a      	ldrb	r2, [r3, r2]
 801937e:	69fb      	ldr	r3, [r7, #28]
 8019380:	7a9b      	ldrb	r3, [r3, #10]
 8019382:	429a      	cmp	r2, r3
 8019384:	d307      	bcc.n	8019396 <LcpSendEchoRequest+0x3a>
            LcpLinkFailure(f);
 8019386:	687b      	ldr	r3, [r7, #4]
 8019388:	0018      	movs	r0, r3
 801938a:	f7ff ff03 	bl	8019194 <LcpLinkFailure>
            pcb->lcp_echos_pending = 0;
 801938e:	69fb      	ldr	r3, [r7, #28]
 8019390:	22d6      	movs	r2, #214	; 0xd6
 8019392:	2100      	movs	r1, #0
 8019394:	5499      	strb	r1, [r3, r2]
#endif

    /*
     * Make and send the echo request frame.
     */
    if (f->state == PPP_FSM_OPENED) {
 8019396:	687b      	ldr	r3, [r7, #4]
 8019398:	7c1b      	ldrb	r3, [r3, #16]
 801939a:	2b09      	cmp	r3, #9
 801939c:	d13a      	bne.n	8019414 <LcpSendEchoRequest+0xb8>
        lcp_magic = go->magicnumber;
 801939e:	69bb      	ldr	r3, [r7, #24]
 80193a0:	689b      	ldr	r3, [r3, #8]
 80193a2:	617b      	str	r3, [r7, #20]
	pktp = pkt;
 80193a4:	240c      	movs	r4, #12
 80193a6:	193b      	adds	r3, r7, r4
 80193a8:	613b      	str	r3, [r7, #16]
	PUTLONG(lcp_magic, pktp);
 80193aa:	697b      	ldr	r3, [r7, #20]
 80193ac:	0e19      	lsrs	r1, r3, #24
 80193ae:	693b      	ldr	r3, [r7, #16]
 80193b0:	1c5a      	adds	r2, r3, #1
 80193b2:	613a      	str	r2, [r7, #16]
 80193b4:	b2ca      	uxtb	r2, r1
 80193b6:	701a      	strb	r2, [r3, #0]
 80193b8:	697b      	ldr	r3, [r7, #20]
 80193ba:	0c19      	lsrs	r1, r3, #16
 80193bc:	693b      	ldr	r3, [r7, #16]
 80193be:	1c5a      	adds	r2, r3, #1
 80193c0:	613a      	str	r2, [r7, #16]
 80193c2:	b2ca      	uxtb	r2, r1
 80193c4:	701a      	strb	r2, [r3, #0]
 80193c6:	697b      	ldr	r3, [r7, #20]
 80193c8:	0a19      	lsrs	r1, r3, #8
 80193ca:	693b      	ldr	r3, [r7, #16]
 80193cc:	1c5a      	adds	r2, r3, #1
 80193ce:	613a      	str	r2, [r7, #16]
 80193d0:	b2ca      	uxtb	r2, r1
 80193d2:	701a      	strb	r2, [r3, #0]
 80193d4:	693b      	ldr	r3, [r7, #16]
 80193d6:	1c5a      	adds	r2, r3, #1
 80193d8:	613a      	str	r2, [r7, #16]
 80193da:	697a      	ldr	r2, [r7, #20]
 80193dc:	b2d2      	uxtb	r2, r2
 80193de:	701a      	strb	r2, [r3, #0]
        fsm_sdata(f, ECHOREQ, pcb->lcp_echo_number++, pkt, pktp - pkt);
 80193e0:	69fb      	ldr	r3, [r7, #28]
 80193e2:	22d7      	movs	r2, #215	; 0xd7
 80193e4:	5c9a      	ldrb	r2, [r3, r2]
 80193e6:	1c53      	adds	r3, r2, #1
 80193e8:	b2d8      	uxtb	r0, r3
 80193ea:	69fb      	ldr	r3, [r7, #28]
 80193ec:	21d7      	movs	r1, #215	; 0xd7
 80193ee:	5458      	strb	r0, [r3, r1]
 80193f0:	193b      	adds	r3, r7, r4
 80193f2:	6939      	ldr	r1, [r7, #16]
 80193f4:	1acb      	subs	r3, r1, r3
 80193f6:	1939      	adds	r1, r7, r4
 80193f8:	6878      	ldr	r0, [r7, #4]
 80193fa:	9300      	str	r3, [sp, #0]
 80193fc:	000b      	movs	r3, r1
 80193fe:	2109      	movs	r1, #9
 8019400:	f7fb fc1e 	bl	8014c40 <fsm_sdata>
	++pcb->lcp_echos_pending;
 8019404:	69fb      	ldr	r3, [r7, #28]
 8019406:	22d6      	movs	r2, #214	; 0xd6
 8019408:	5c9b      	ldrb	r3, [r3, r2]
 801940a:	3301      	adds	r3, #1
 801940c:	b2d9      	uxtb	r1, r3
 801940e:	69fb      	ldr	r3, [r7, #28]
 8019410:	22d6      	movs	r2, #214	; 0xd6
 8019412:	5499      	strb	r1, [r3, r2]
    }
}
 8019414:	46c0      	nop			; (mov r8, r8)
 8019416:	46bd      	mov	sp, r7
 8019418:	b009      	add	sp, #36	; 0x24
 801941a:	bd90      	pop	{r4, r7, pc}

0801941c <lcp_echo_lowerup>:

/*
 * lcp_echo_lowerup - Start the timer for the LCP frame
 */

static void lcp_echo_lowerup(ppp_pcb *pcb) {
 801941c:	b580      	push	{r7, lr}
 801941e:	b084      	sub	sp, #16
 8019420:	af00      	add	r7, sp, #0
 8019422:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 8019424:	687b      	ldr	r3, [r7, #4]
 8019426:	3328      	adds	r3, #40	; 0x28
 8019428:	60fb      	str	r3, [r7, #12]

    /* Clear the parameters for generating echo frames */
    pcb->lcp_echos_pending      = 0;
 801942a:	687b      	ldr	r3, [r7, #4]
 801942c:	22d6      	movs	r2, #214	; 0xd6
 801942e:	2100      	movs	r1, #0
 8019430:	5499      	strb	r1, [r3, r2]
    pcb->lcp_echo_number        = 0;
 8019432:	687b      	ldr	r3, [r7, #4]
 8019434:	22d7      	movs	r2, #215	; 0xd7
 8019436:	2100      	movs	r1, #0
 8019438:	5499      	strb	r1, [r3, r2]
    pcb->lcp_echo_timer_running = 0;
 801943a:	687b      	ldr	r3, [r7, #4]
 801943c:	2226      	movs	r2, #38	; 0x26
 801943e:	5c99      	ldrb	r1, [r3, r2]
 8019440:	2010      	movs	r0, #16
 8019442:	4381      	bics	r1, r0
 8019444:	5499      	strb	r1, [r3, r2]
  
    /* If a timeout interval is specified then start the timer */
    if (pcb->settings.lcp_echo_interval != 0)
 8019446:	687b      	ldr	r3, [r7, #4]
 8019448:	7a5b      	ldrb	r3, [r3, #9]
 801944a:	2b00      	cmp	r3, #0
 801944c:	d003      	beq.n	8019456 <lcp_echo_lowerup+0x3a>
        LcpEchoCheck (f);
 801944e:	68fb      	ldr	r3, [r7, #12]
 8019450:	0018      	movs	r0, r3
 8019452:	f7ff fecb 	bl	80191ec <LcpEchoCheck>
}
 8019456:	46c0      	nop			; (mov r8, r8)
 8019458:	46bd      	mov	sp, r7
 801945a:	b004      	add	sp, #16
 801945c:	bd80      	pop	{r7, pc}
	...

08019460 <lcp_echo_lowerdown>:

/*
 * lcp_echo_lowerdown - Stop the timer for the LCP frame
 */

static void lcp_echo_lowerdown(ppp_pcb *pcb) {
 8019460:	b580      	push	{r7, lr}
 8019462:	b084      	sub	sp, #16
 8019464:	af00      	add	r7, sp, #0
 8019466:	6078      	str	r0, [r7, #4]
    fsm *f = &pcb->lcp_fsm;
 8019468:	687b      	ldr	r3, [r7, #4]
 801946a:	3328      	adds	r3, #40	; 0x28
 801946c:	60fb      	str	r3, [r7, #12]

    if (pcb->lcp_echo_timer_running != 0) {
 801946e:	687b      	ldr	r3, [r7, #4]
 8019470:	2226      	movs	r2, #38	; 0x26
 8019472:	5c9b      	ldrb	r3, [r3, r2]
 8019474:	2210      	movs	r2, #16
 8019476:	4013      	ands	r3, r2
 8019478:	b2db      	uxtb	r3, r3
 801947a:	2b00      	cmp	r3, #0
 801947c:	d00b      	beq.n	8019496 <lcp_echo_lowerdown+0x36>
        UNTIMEOUT (LcpEchoTimeout, f);
 801947e:	68fa      	ldr	r2, [r7, #12]
 8019480:	4b07      	ldr	r3, [pc, #28]	; (80194a0 <lcp_echo_lowerdown+0x40>)
 8019482:	0011      	movs	r1, r2
 8019484:	0018      	movs	r0, r3
 8019486:	f7f8 fc0f 	bl	8011ca8 <sys_untimeout>
        pcb->lcp_echo_timer_running = 0;
 801948a:	687b      	ldr	r3, [r7, #4]
 801948c:	2226      	movs	r2, #38	; 0x26
 801948e:	5c99      	ldrb	r1, [r3, r2]
 8019490:	2010      	movs	r0, #16
 8019492:	4381      	bics	r1, r0
 8019494:	5499      	strb	r1, [r3, r2]
    }
}
 8019496:	46c0      	nop			; (mov r8, r8)
 8019498:	46bd      	mov	sp, r7
 801949a:	b004      	add	sp, #16
 801949c:	bd80      	pop	{r7, pc}
 801949e:	46c0      	nop			; (mov r8, r8)
 80194a0:	0801926d 	.word	0x0801926d

080194a4 <magic_init>:
 * in startup(), then the idle counter and timer values may
 * repeat after each boot and the real time clock may not be
 * operational.  Thus we call it again on the first random
 * event.
 */
void magic_init(void) {
 80194a4:	b580      	push	{r7, lr}
 80194a6:	af00      	add	r7, sp, #0
  magic_randomseed += sys_jiffies();
 80194a8:	f003 f95a 	bl	801c760 <sys_jiffies>
 80194ac:	0002      	movs	r2, r0
 80194ae:	4b04      	ldr	r3, [pc, #16]	; (80194c0 <magic_init+0x1c>)
 80194b0:	681b      	ldr	r3, [r3, #0]
 80194b2:	18d2      	adds	r2, r2, r3
 80194b4:	4b02      	ldr	r3, [pc, #8]	; (80194c0 <magic_init+0x1c>)
 80194b6:	601a      	str	r2, [r3, #0]
#ifndef LWIP_RAND
  /* Initialize the Borland random number generator. */
  srand((unsigned)magic_randomseed);
#endif /* LWIP_RAND */
}
 80194b8:	46c0      	nop			; (mov r8, r8)
 80194ba:	46bd      	mov	sp, r7
 80194bc:	bd80      	pop	{r7, pc}
 80194be:	46c0      	nop			; (mov r8, r8)
 80194c0:	200013b4 	.word	0x200013b4

080194c4 <magic_randomize>:
 * this function is called at *truely random* times by the polling
 * and network functions.  Here we only get 16 bits of new random
 * value but we use the previous value to randomize the other 16
 * bits.
 */
void magic_randomize(void) {
 80194c4:	b580      	push	{r7, lr}
 80194c6:	af00      	add	r7, sp, #0
    magic_randomized = !0;
    magic_init();
    /* The initialization function also updates the seed. */
  } else {
#endif /* LWIP_RAND */
    magic_randomseed += sys_jiffies();
 80194c8:	f003 f94a 	bl	801c760 <sys_jiffies>
 80194cc:	0002      	movs	r2, r0
 80194ce:	4b04      	ldr	r3, [pc, #16]	; (80194e0 <magic_randomize+0x1c>)
 80194d0:	681b      	ldr	r3, [r3, #0]
 80194d2:	18d2      	adds	r2, r2, r3
 80194d4:	4b02      	ldr	r3, [pc, #8]	; (80194e0 <magic_randomize+0x1c>)
 80194d6:	601a      	str	r2, [r3, #0]
#ifndef LWIP_RAND
  }
#endif /* LWIP_RAND */
}
 80194d8:	46c0      	nop			; (mov r8, r8)
 80194da:	46bd      	mov	sp, r7
 80194dc:	bd80      	pop	{r7, pc}
 80194de:	46c0      	nop			; (mov r8, r8)
 80194e0:	200013b4 	.word	0x200013b4

080194e4 <magic>:
 * seed which is randomized by truely random events.
 * Thus the numbers will be truely random unless there have been no
 * operator or network events in which case it will be pseudo random
 * seeded by the real time clock.
 */
u32_t magic(void) {
 80194e4:	b580      	push	{r7, lr}
 80194e6:	af00      	add	r7, sp, #0
#ifdef LWIP_RAND
  return LWIP_RAND() + magic_randomseed;
 80194e8:	f003 f920 	bl	801c72c <sys_rand>
 80194ec:	0002      	movs	r2, r0
 80194ee:	4b03      	ldr	r3, [pc, #12]	; (80194fc <magic+0x18>)
 80194f0:	681b      	ldr	r3, [r3, #0]
 80194f2:	18d3      	adds	r3, r2, r3
#else /* LWIP_RAND */
  return ((u32_t)rand() << 16) + (u32_t)rand() + magic_randomseed;
#endif /* LWIP_RAND */
}
 80194f4:	0018      	movs	r0, r3
 80194f6:	46bd      	mov	sp, r7
 80194f8:	bd80      	pop	{r7, pc}
 80194fa:	46c0      	nop			; (mov r8, r8)
 80194fc:	200013b4 	.word	0x200013b4

08019500 <ppp_set_notify_phase_callback>:
  pcb->settings.refuse_mppe_128 = !!(flags & PPP_MPPE_REFUSE_128);
}
#endif /* MPPE_SUPPORT */

#if PPP_NOTIFY_PHASE
void ppp_set_notify_phase_callback(ppp_pcb *pcb, ppp_notify_phase_cb_fn notify_phase_cb) {
 8019500:	b580      	push	{r7, lr}
 8019502:	b082      	sub	sp, #8
 8019504:	af00      	add	r7, sp, #0
 8019506:	6078      	str	r0, [r7, #4]
 8019508:	6039      	str	r1, [r7, #0]
  pcb->notify_phase_cb = notify_phase_cb;
 801950a:	687b      	ldr	r3, [r7, #4]
 801950c:	683a      	ldr	r2, [r7, #0]
 801950e:	619a      	str	r2, [r3, #24]
  notify_phase_cb(pcb, pcb->phase, pcb->ctx_cb);
 8019510:	687b      	ldr	r3, [r7, #4]
 8019512:	2224      	movs	r2, #36	; 0x24
 8019514:	5c99      	ldrb	r1, [r3, r2]
 8019516:	687b      	ldr	r3, [r7, #4]
 8019518:	69da      	ldr	r2, [r3, #28]
 801951a:	6878      	ldr	r0, [r7, #4]
 801951c:	683b      	ldr	r3, [r7, #0]
 801951e:	4798      	blx	r3
}
 8019520:	46c0      	nop			; (mov r8, r8)
 8019522:	46bd      	mov	sp, r7
 8019524:	b002      	add	sp, #8
 8019526:	bd80      	pop	{r7, pc}

08019528 <ppp_connect>:
 * the connection.
 *
 * If this port connects to a modem, the modem connection must be
 * established before calling this.
 */
err_t ppp_connect(ppp_pcb *pcb, u16_t holdoff) {
 8019528:	b580      	push	{r7, lr}
 801952a:	b082      	sub	sp, #8
 801952c:	af00      	add	r7, sp, #0
 801952e:	6078      	str	r0, [r7, #4]
 8019530:	000a      	movs	r2, r1
 8019532:	1cbb      	adds	r3, r7, #2
 8019534:	801a      	strh	r2, [r3, #0]
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb->phase != PPP_PHASE_DEAD) {
 8019536:	687b      	ldr	r3, [r7, #4]
 8019538:	2224      	movs	r2, #36	; 0x24
 801953a:	5c9b      	ldrb	r3, [r3, r2]
 801953c:	2b00      	cmp	r3, #0
 801953e:	d002      	beq.n	8019546 <ppp_connect+0x1e>
    return ERR_ALREADY;
 8019540:	2309      	movs	r3, #9
 8019542:	425b      	negs	r3, r3
 8019544:	e01f      	b.n	8019586 <ppp_connect+0x5e>
  }

  PPPDEBUG(LOG_DEBUG, ("ppp_connect[%d]: holdoff=%d\n", pcb->netif->num, holdoff));

  magic_randomize();
 8019546:	f7ff ffbd 	bl	80194c4 <magic_randomize>

  if (holdoff == 0) {
 801954a:	1cbb      	adds	r3, r7, #2
 801954c:	881b      	ldrh	r3, [r3, #0]
 801954e:	2b00      	cmp	r3, #0
 8019550:	d105      	bne.n	801955e <ppp_connect+0x36>
    ppp_do_connect(pcb);
 8019552:	687b      	ldr	r3, [r7, #4]
 8019554:	0018      	movs	r0, r3
 8019556:	f000 f8b1 	bl	80196bc <ppp_do_connect>
    return ERR_OK;
 801955a:	2300      	movs	r3, #0
 801955c:	e013      	b.n	8019586 <ppp_connect+0x5e>
  }

  new_phase(pcb, PPP_PHASE_HOLDOFF);
 801955e:	687b      	ldr	r3, [r7, #4]
 8019560:	2102      	movs	r1, #2
 8019562:	0018      	movs	r0, r3
 8019564:	f000 fb3d 	bl	8019be2 <new_phase>
  sys_timeout((u32_t)(holdoff*1000), ppp_do_connect, pcb);
 8019568:	1cbb      	adds	r3, r7, #2
 801956a:	881a      	ldrh	r2, [r3, #0]
 801956c:	0013      	movs	r3, r2
 801956e:	015b      	lsls	r3, r3, #5
 8019570:	1a9b      	subs	r3, r3, r2
 8019572:	009b      	lsls	r3, r3, #2
 8019574:	189b      	adds	r3, r3, r2
 8019576:	00db      	lsls	r3, r3, #3
 8019578:	0018      	movs	r0, r3
 801957a:	687a      	ldr	r2, [r7, #4]
 801957c:	4b04      	ldr	r3, [pc, #16]	; (8019590 <ppp_connect+0x68>)
 801957e:	0019      	movs	r1, r3
 8019580:	f7f8 fb6a 	bl	8011c58 <sys_timeout>
  return ERR_OK;
 8019584:	2300      	movs	r3, #0
}
 8019586:	0018      	movs	r0, r3
 8019588:	46bd      	mov	sp, r7
 801958a:	b002      	add	sp, #8
 801958c:	bd80      	pop	{r7, pc}
 801958e:	46c0      	nop			; (mov r8, r8)
 8019590:	080196bd 	.word	0x080196bd

08019594 <ppp_close>:
 *
 * Return 0 on success, an error code on failure.
 */
err_t
ppp_close(ppp_pcb *pcb, u8_t nocarrier)
{
 8019594:	b590      	push	{r4, r7, lr}
 8019596:	b083      	sub	sp, #12
 8019598:	af00      	add	r7, sp, #0
 801959a:	6078      	str	r0, [r7, #4]
 801959c:	000a      	movs	r2, r1
 801959e:	1cfb      	adds	r3, r7, #3
 80195a0:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT_CORE_LOCKED();

  pcb->err_code = PPPERR_USER;
 80195a2:	687b      	ldr	r3, [r7, #4]
 80195a4:	2225      	movs	r2, #37	; 0x25
 80195a6:	2105      	movs	r1, #5
 80195a8:	5499      	strb	r1, [r3, r2]

  /* holdoff phase, cancel the reconnection */
  if (pcb->phase == PPP_PHASE_HOLDOFF) {
 80195aa:	687b      	ldr	r3, [r7, #4]
 80195ac:	2224      	movs	r2, #36	; 0x24
 80195ae:	5c9b      	ldrb	r3, [r3, r2]
 80195b0:	2b02      	cmp	r3, #2
 80195b2:	d10a      	bne.n	80195ca <ppp_close+0x36>
    sys_untimeout(ppp_do_connect, pcb);
 80195b4:	687a      	ldr	r2, [r7, #4]
 80195b6:	4b29      	ldr	r3, [pc, #164]	; (801965c <ppp_close+0xc8>)
 80195b8:	0011      	movs	r1, r2
 80195ba:	0018      	movs	r0, r3
 80195bc:	f7f8 fb74 	bl	8011ca8 <sys_untimeout>
    new_phase(pcb, PPP_PHASE_DEAD);
 80195c0:	687b      	ldr	r3, [r7, #4]
 80195c2:	2100      	movs	r1, #0
 80195c4:	0018      	movs	r0, r3
 80195c6:	f000 fb0c 	bl	8019be2 <new_phase>
  }

  /* dead phase, nothing to do, call the status callback to be consistent */
  if (pcb->phase == PPP_PHASE_DEAD) {
 80195ca:	687b      	ldr	r3, [r7, #4]
 80195cc:	2224      	movs	r2, #36	; 0x24
 80195ce:	5c9b      	ldrb	r3, [r3, r2]
 80195d0:	2b00      	cmp	r3, #0
 80195d2:	d10c      	bne.n	80195ee <ppp_close+0x5a>
    pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
 80195d4:	687b      	ldr	r3, [r7, #4]
 80195d6:	695c      	ldr	r4, [r3, #20]
 80195d8:	687b      	ldr	r3, [r7, #4]
 80195da:	2225      	movs	r2, #37	; 0x25
 80195dc:	5c9b      	ldrb	r3, [r3, r2]
 80195de:	0019      	movs	r1, r3
 80195e0:	687b      	ldr	r3, [r7, #4]
 80195e2:	69da      	ldr	r2, [r3, #28]
 80195e4:	687b      	ldr	r3, [r7, #4]
 80195e6:	0018      	movs	r0, r3
 80195e8:	47a0      	blx	r4
    return ERR_OK;
 80195ea:	2300      	movs	r3, #0
 80195ec:	e031      	b.n	8019652 <ppp_close+0xbe>
  }

  /* Already terminating, nothing to do */
  if (pcb->phase >= PPP_PHASE_TERMINATE) {
 80195ee:	687b      	ldr	r3, [r7, #4]
 80195f0:	2224      	movs	r2, #36	; 0x24
 80195f2:	5c9b      	ldrb	r3, [r3, r2]
 80195f4:	2b0a      	cmp	r3, #10
 80195f6:	d902      	bls.n	80195fe <ppp_close+0x6a>
    return ERR_INPROGRESS;
 80195f8:	2305      	movs	r3, #5
 80195fa:	425b      	negs	r3, r3
 80195fc:	e029      	b.n	8019652 <ppp_close+0xbe>
  }

  /* LCP not open, close link protocol */
  if (pcb->phase < PPP_PHASE_ESTABLISH) {
 80195fe:	687b      	ldr	r3, [r7, #4]
 8019600:	2224      	movs	r2, #36	; 0x24
 8019602:	5c9b      	ldrb	r3, [r3, r2]
 8019604:	2b05      	cmp	r3, #5
 8019606:	d80a      	bhi.n	801961e <ppp_close+0x8a>
    new_phase(pcb, PPP_PHASE_DISCONNECT);
 8019608:	687b      	ldr	r3, [r7, #4]
 801960a:	210c      	movs	r1, #12
 801960c:	0018      	movs	r0, r3
 801960e:	f000 fae8 	bl	8019be2 <new_phase>
    ppp_link_terminated(pcb);
 8019612:	687b      	ldr	r3, [r7, #4]
 8019614:	0018      	movs	r0, r3
 8019616:	f000 fad4 	bl	8019bc2 <ppp_link_terminated>
    return ERR_OK;
 801961a:	2300      	movs	r3, #0
 801961c:	e019      	b.n	8019652 <ppp_close+0xbe>
   * to prevent changing the PPP phase FSM in transition phases.
   *
   * Always using nocarrier = 0 is still recommended, this is going to
   * take a little longer time, but is a safer choice from FSM point of view.
   */
  if (nocarrier && pcb->phase == PPP_PHASE_RUNNING) {
 801961e:	1cfb      	adds	r3, r7, #3
 8019620:	781b      	ldrb	r3, [r3, #0]
 8019622:	2b00      	cmp	r3, #0
 8019624:	d00e      	beq.n	8019644 <ppp_close+0xb0>
 8019626:	687b      	ldr	r3, [r7, #4]
 8019628:	2224      	movs	r2, #36	; 0x24
 801962a:	5c9b      	ldrb	r3, [r3, r2]
 801962c:	2b0a      	cmp	r3, #10
 801962e:	d109      	bne.n	8019644 <ppp_close+0xb0>
    PPPDEBUG(LOG_DEBUG, ("ppp_close[%d]: carrier lost -> lcp_lowerdown\n", pcb->netif->num));
    lcp_lowerdown(pcb);
 8019630:	687b      	ldr	r3, [r7, #4]
 8019632:	0018      	movs	r0, r3
 8019634:	f7fd ffa2 	bl	801757c <lcp_lowerdown>
    /* forced link termination, this will force link protocol to disconnect. */
    link_terminated(pcb);
 8019638:	687b      	ldr	r3, [r7, #4]
 801963a:	0018      	movs	r0, r3
 801963c:	f7fa fa8c 	bl	8013b58 <link_terminated>
    return ERR_OK;
 8019640:	2300      	movs	r3, #0
 8019642:	e006      	b.n	8019652 <ppp_close+0xbe>
  }

  /* Disconnect */
  PPPDEBUG(LOG_DEBUG, ("ppp_close[%d]: kill_link -> lcp_close\n", pcb->netif->num));
  /* LCP soft close request. */
  lcp_close(pcb, "User request");
 8019644:	4a06      	ldr	r2, [pc, #24]	; (8019660 <ppp_close+0xcc>)
 8019646:	687b      	ldr	r3, [r7, #4]
 8019648:	0011      	movs	r1, r2
 801964a:	0018      	movs	r0, r3
 801964c:	f7fd fef2 	bl	8017434 <lcp_close>
  return ERR_OK;
 8019650:	2300      	movs	r3, #0
}
 8019652:	0018      	movs	r0, r3
 8019654:	46bd      	mov	sp, r7
 8019656:	b003      	add	sp, #12
 8019658:	bd90      	pop	{r4, r7, pc}
 801965a:	46c0      	nop			; (mov r8, r8)
 801965c:	080196bd 	.word	0x080196bd
 8019660:	08021294 	.word	0x08021294

08019664 <ppp_free>:
 * You must use ppp_close() before if you wish to terminate
 * an established PPP session.
 *
 * Return 0 on success, an error code on failure.
 */
err_t ppp_free(ppp_pcb *pcb) {
 8019664:	b5b0      	push	{r4, r5, r7, lr}
 8019666:	b084      	sub	sp, #16
 8019668:	af00      	add	r7, sp, #0
 801966a:	6078      	str	r0, [r7, #4]
  err_t err;
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb->phase != PPP_PHASE_DEAD) {
 801966c:	687b      	ldr	r3, [r7, #4]
 801966e:	2224      	movs	r2, #36	; 0x24
 8019670:	5c9b      	ldrb	r3, [r3, r2]
 8019672:	2b00      	cmp	r3, #0
 8019674:	d002      	beq.n	801967c <ppp_free+0x18>
    return ERR_CONN;
 8019676:	230b      	movs	r3, #11
 8019678:	425b      	negs	r3, r3
 801967a:	e019      	b.n	80196b0 <ppp_free+0x4c>
  }

  PPPDEBUG(LOG_DEBUG, ("ppp_free[%d]\n", pcb->netif->num));

  netif_remove(pcb->netif);
 801967c:	687b      	ldr	r3, [r7, #4]
 801967e:	6a1b      	ldr	r3, [r3, #32]
 8019680:	0018      	movs	r0, r3
 8019682:	f7ef fafb 	bl	8008c7c <netif_remove>

  err = pcb->link_cb->free(pcb, pcb->link_ctx_cb);
 8019686:	687b      	ldr	r3, [r7, #4]
 8019688:	68db      	ldr	r3, [r3, #12]
 801968a:	689a      	ldr	r2, [r3, #8]
 801968c:	687b      	ldr	r3, [r7, #4]
 801968e:	6919      	ldr	r1, [r3, #16]
 8019690:	250f      	movs	r5, #15
 8019692:	197c      	adds	r4, r7, r5
 8019694:	687b      	ldr	r3, [r7, #4]
 8019696:	0018      	movs	r0, r3
 8019698:	4790      	blx	r2
 801969a:	0003      	movs	r3, r0
 801969c:	7023      	strb	r3, [r4, #0]

  LWIP_MEMPOOL_FREE(PPP_PCB, pcb);
 801969e:	687a      	ldr	r2, [r7, #4]
 80196a0:	4b05      	ldr	r3, [pc, #20]	; (80196b8 <ppp_free+0x54>)
 80196a2:	0011      	movs	r1, r2
 80196a4:	0018      	movs	r0, r3
 80196a6:	f7ef f8d9 	bl	800885c <memp_free_pool>
  return err;
 80196aa:	197b      	adds	r3, r7, r5
 80196ac:	781b      	ldrb	r3, [r3, #0]
 80196ae:	b25b      	sxtb	r3, r3
}
 80196b0:	0018      	movs	r0, r3
 80196b2:	46bd      	mov	sp, r7
 80196b4:	b004      	add	sp, #16
 80196b6:	bdb0      	pop	{r4, r5, r7, pc}
 80196b8:	08021cac 	.word	0x08021cac

080196bc <ppp_do_connect>:

/**********************************/
/*** LOCAL FUNCTION DEFINITIONS ***/
/**********************************/

static void ppp_do_connect(void *arg) {
 80196bc:	b580      	push	{r7, lr}
 80196be:	b084      	sub	sp, #16
 80196c0:	af00      	add	r7, sp, #0
 80196c2:	6078      	str	r0, [r7, #4]
  ppp_pcb *pcb = (ppp_pcb*)arg;
 80196c4:	687b      	ldr	r3, [r7, #4]
 80196c6:	60fb      	str	r3, [r7, #12]

  LWIP_ASSERT("pcb->phase == PPP_PHASE_DEAD || pcb->phase == PPP_PHASE_HOLDOFF", pcb->phase == PPP_PHASE_DEAD || pcb->phase == PPP_PHASE_HOLDOFF);
 80196c8:	68fb      	ldr	r3, [r7, #12]
 80196ca:	2224      	movs	r2, #36	; 0x24
 80196cc:	5c9b      	ldrb	r3, [r3, r2]
 80196ce:	2b00      	cmp	r3, #0
 80196d0:	d00b      	beq.n	80196ea <ppp_do_connect+0x2e>
 80196d2:	68fb      	ldr	r3, [r7, #12]
 80196d4:	2224      	movs	r2, #36	; 0x24
 80196d6:	5c9b      	ldrb	r3, [r3, r2]
 80196d8:	2b02      	cmp	r3, #2
 80196da:	d006      	beq.n	80196ea <ppp_do_connect+0x2e>
 80196dc:	4b0b      	ldr	r3, [pc, #44]	; (801970c <ppp_do_connect+0x50>)
 80196de:	22ce      	movs	r2, #206	; 0xce
 80196e0:	32ff      	adds	r2, #255	; 0xff
 80196e2:	490b      	ldr	r1, [pc, #44]	; (8019710 <ppp_do_connect+0x54>)
 80196e4:	480b      	ldr	r0, [pc, #44]	; (8019714 <ppp_do_connect+0x58>)
 80196e6:	f7e8 fd71 	bl	80021cc <app_debug_rtt_raw>

  new_phase(pcb, PPP_PHASE_INITIALIZE);
 80196ea:	68fb      	ldr	r3, [r7, #12]
 80196ec:	2103      	movs	r1, #3
 80196ee:	0018      	movs	r0, r3
 80196f0:	f000 fa77 	bl	8019be2 <new_phase>
  pcb->link_cb->connect(pcb, pcb->link_ctx_cb);
 80196f4:	68fb      	ldr	r3, [r7, #12]
 80196f6:	68db      	ldr	r3, [r3, #12]
 80196f8:	681a      	ldr	r2, [r3, #0]
 80196fa:	68fb      	ldr	r3, [r7, #12]
 80196fc:	6919      	ldr	r1, [r3, #16]
 80196fe:	68fb      	ldr	r3, [r7, #12]
 8019700:	0018      	movs	r0, r3
 8019702:	4790      	blx	r2
}
 8019704:	46c0      	nop			; (mov r8, r8)
 8019706:	46bd      	mov	sp, r7
 8019708:	b004      	add	sp, #16
 801970a:	bd80      	pop	{r7, pc}
 801970c:	080212a4 	.word	0x080212a4
 8019710:	080212d0 	.word	0x080212d0
 8019714:	08021310 	.word	0x08021310

08019718 <ppp_netif_init_cb>:

/*
 * ppp_netif_init_cb - netif init callback
 */
static err_t ppp_netif_init_cb(struct netif *netif) {
 8019718:	b580      	push	{r7, lr}
 801971a:	b082      	sub	sp, #8
 801971c:	af00      	add	r7, sp, #0
 801971e:	6078      	str	r0, [r7, #4]
  netif->name[0] = 'p';
 8019720:	687b      	ldr	r3, [r7, #4]
 8019722:	2232      	movs	r2, #50	; 0x32
 8019724:	2170      	movs	r1, #112	; 0x70
 8019726:	5499      	strb	r1, [r3, r2]
  netif->name[1] = 'p';
 8019728:	687b      	ldr	r3, [r7, #4]
 801972a:	2233      	movs	r2, #51	; 0x33
 801972c:	2170      	movs	r1, #112	; 0x70
 801972e:	5499      	strb	r1, [r3, r2]
#if PPP_IPV4_SUPPORT
  netif->output = ppp_netif_output_ip4;
 8019730:	687b      	ldr	r3, [r7, #4]
 8019732:	4a05      	ldr	r2, [pc, #20]	; (8019748 <ppp_netif_init_cb+0x30>)
 8019734:	615a      	str	r2, [r3, #20]
#endif /* PPP_IPV4_SUPPORT */
#if PPP_IPV6_SUPPORT
  netif->output_ip6 = ppp_netif_output_ip6;
#endif /* PPP_IPV6_SUPPORT */
  netif->flags = NETIF_FLAG_UP;
 8019736:	687b      	ldr	r3, [r7, #4]
 8019738:	2231      	movs	r2, #49	; 0x31
 801973a:	2101      	movs	r1, #1
 801973c:	5499      	strb	r1, [r3, r2]
#if LWIP_NETIF_HOSTNAME
  /* @todo: Initialize interface hostname */
  /* netif_set_hostname(netif, "lwip"); */
#endif /* LWIP_NETIF_HOSTNAME */
  return ERR_OK;
 801973e:	2300      	movs	r3, #0
}
 8019740:	0018      	movs	r0, r3
 8019742:	46bd      	mov	sp, r7
 8019744:	b002      	add	sp, #8
 8019746:	bd80      	pop	{r7, pc}
 8019748:	0801974d 	.word	0x0801974d

0801974c <ppp_netif_output_ip4>:

#if PPP_IPV4_SUPPORT
/*
 * Send an IPv4 packet on the given connection.
 */
static err_t ppp_netif_output_ip4(struct netif *netif, struct pbuf *pb, const ip4_addr_t *ipaddr) {
 801974c:	b580      	push	{r7, lr}
 801974e:	b084      	sub	sp, #16
 8019750:	af00      	add	r7, sp, #0
 8019752:	60f8      	str	r0, [r7, #12]
 8019754:	60b9      	str	r1, [r7, #8]
 8019756:	607a      	str	r2, [r7, #4]
  LWIP_UNUSED_ARG(ipaddr);
  return ppp_netif_output(netif, pb, PPP_IP);
 8019758:	68b9      	ldr	r1, [r7, #8]
 801975a:	68fb      	ldr	r3, [r7, #12]
 801975c:	2221      	movs	r2, #33	; 0x21
 801975e:	0018      	movs	r0, r3
 8019760:	f000 f805 	bl	801976e <ppp_netif_output>
 8019764:	0003      	movs	r3, r0
}
 8019766:	0018      	movs	r0, r3
 8019768:	46bd      	mov	sp, r7
 801976a:	b004      	add	sp, #16
 801976c:	bd80      	pop	{r7, pc}

0801976e <ppp_netif_output>:
  LWIP_UNUSED_ARG(ipaddr);
  return ppp_netif_output(netif, pb, PPP_IPV6);
}
#endif /* PPP_IPV6_SUPPORT */

static err_t ppp_netif_output(struct netif *netif, struct pbuf *pb, u16_t protocol) {
 801976e:	b5b0      	push	{r4, r5, r7, lr}
 8019770:	b088      	sub	sp, #32
 8019772:	af00      	add	r7, sp, #0
 8019774:	60f8      	str	r0, [r7, #12]
 8019776:	60b9      	str	r1, [r7, #8]
 8019778:	1dbb      	adds	r3, r7, #6
 801977a:	801a      	strh	r2, [r3, #0]
  ppp_pcb *pcb = (ppp_pcb*)netif->state;
 801977c:	68fb      	ldr	r3, [r7, #12]
 801977e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8019780:	617b      	str	r3, [r7, #20]
  err_t err;
  struct pbuf *fpb = NULL;
 8019782:	2300      	movs	r3, #0
 8019784:	61bb      	str	r3, [r7, #24]

  /* Check that the link is up. */
  if (0
 8019786:	1dbb      	adds	r3, r7, #6
 8019788:	881b      	ldrh	r3, [r3, #0]
 801978a:	2b21      	cmp	r3, #33	; 0x21
 801978c:	d107      	bne.n	801979e <ppp_netif_output+0x30>
#if PPP_IPV4_SUPPORT
      || (protocol == PPP_IP && !pcb->if4_up)
 801978e:	697b      	ldr	r3, [r7, #20]
 8019790:	2226      	movs	r2, #38	; 0x26
 8019792:	5c9b      	ldrb	r3, [r3, r2]
 8019794:	2208      	movs	r2, #8
 8019796:	4013      	ands	r3, r2
 8019798:	b2db      	uxtb	r3, r3
 801979a:	2b00      	cmp	r3, #0
 801979c:	d03d      	beq.n	801981a <ppp_netif_output+0xac>
#if VJ_SUPPORT
  /*
   * Attempt Van Jacobson header compression if VJ is configured and
   * this is an IP packet.
   */
  if (protocol == PPP_IP && pcb->vj_enabled) {
 801979e:	1dbb      	adds	r3, r7, #6
 80197a0:	881b      	ldrh	r3, [r3, #0]
 80197a2:	2b21      	cmp	r3, #33	; 0x21
 80197a4:	d127      	bne.n	80197f6 <ppp_netif_output+0x88>
 80197a6:	697b      	ldr	r3, [r7, #20]
 80197a8:	2226      	movs	r2, #38	; 0x26
 80197aa:	5c9b      	ldrb	r3, [r3, r2]
 80197ac:	2220      	movs	r2, #32
 80197ae:	4013      	ands	r3, r2
 80197b0:	b2db      	uxtb	r3, r3
 80197b2:	2b00      	cmp	r3, #0
 80197b4:	d01f      	beq.n	80197f6 <ppp_netif_output+0x88>
    switch (vj_compress_tcp(&pcb->vj_comp, &pb)) {
 80197b6:	697b      	ldr	r3, [r7, #20]
 80197b8:	33dc      	adds	r3, #220	; 0xdc
 80197ba:	2208      	movs	r2, #8
 80197bc:	18ba      	adds	r2, r7, r2
 80197be:	0011      	movs	r1, r2
 80197c0:	0018      	movs	r0, r3
 80197c2:	f001 fd73 	bl	801b2ac <vj_compress_tcp>
 80197c6:	0003      	movs	r3, r0
 80197c8:	2b80      	cmp	r3, #128	; 0x80
 80197ca:	d005      	beq.n	80197d8 <ppp_netif_output+0x6a>
 80197cc:	dc10      	bgt.n	80197f0 <ppp_netif_output+0x82>
 80197ce:	2b40      	cmp	r3, #64	; 0x40
 80197d0:	d013      	beq.n	80197fa <ppp_netif_output+0x8c>
 80197d2:	2b70      	cmp	r3, #112	; 0x70
 80197d4:	d006      	beq.n	80197e4 <ppp_netif_output+0x76>
 80197d6:	e00b      	b.n	80197f0 <ppp_netif_output+0x82>
           protocol = PPP_IP; */
        break;
      case TYPE_COMPRESSED_TCP:
        /* vj_compress_tcp() returns a new allocated pbuf, indicate we should free
         * our duplicated pbuf later */
        fpb = pb;
 80197d8:	68bb      	ldr	r3, [r7, #8]
 80197da:	61bb      	str	r3, [r7, #24]
        protocol = PPP_VJC_COMP;
 80197dc:	1dbb      	adds	r3, r7, #6
 80197de:	222d      	movs	r2, #45	; 0x2d
 80197e0:	801a      	strh	r2, [r3, #0]
        break;
 80197e2:	e00b      	b.n	80197fc <ppp_netif_output+0x8e>
      case TYPE_UNCOMPRESSED_TCP:
        /* vj_compress_tcp() returns a new allocated pbuf, indicate we should free
         * our duplicated pbuf later */
        fpb = pb;
 80197e4:	68bb      	ldr	r3, [r7, #8]
 80197e6:	61bb      	str	r3, [r7, #24]
        protocol = PPP_VJC_UNCOMP;
 80197e8:	1dbb      	adds	r3, r7, #6
 80197ea:	222f      	movs	r2, #47	; 0x2f
 80197ec:	801a      	strh	r2, [r3, #0]
        break;
 80197ee:	e005      	b.n	80197fc <ppp_netif_output+0x8e>
      default:
        PPPDEBUG(LOG_WARNING, ("ppp_netif_output[%d]: bad IP packet\n", pcb->netif->num));
        LINK_STATS_INC(link.proterr);
        LINK_STATS_INC(link.drop);
        MIB2_STATS_NETIF_INC(pcb->netif, ifoutdiscards);
        return ERR_VAL;
 80197f0:	2306      	movs	r3, #6
 80197f2:	425b      	negs	r3, r3
 80197f4:	e021      	b.n	801983a <ppp_netif_output+0xcc>
    }
  }
 80197f6:	46c0      	nop			; (mov r8, r8)
 80197f8:	e000      	b.n	80197fc <ppp_netif_output+0x8e>
        break;
 80197fa:	46c0      	nop			; (mov r8, r8)
    PPPDEBUG(LOG_ERR, ("ppp_netif_output[%d]: bad CCP transmit method\n", pcb->netif->num));
    goto err_rte_drop; /* Cannot really happen, we only negotiate what we are able to do */
  }
#endif /* CCP_SUPPORT */

  err = pcb->link_cb->netif_output(pcb, pcb->link_ctx_cb, pb, protocol);
 80197fc:	697b      	ldr	r3, [r7, #20]
 80197fe:	68db      	ldr	r3, [r3, #12]
 8019800:	691d      	ldr	r5, [r3, #16]
 8019802:	697b      	ldr	r3, [r7, #20]
 8019804:	6919      	ldr	r1, [r3, #16]
 8019806:	68ba      	ldr	r2, [r7, #8]
 8019808:	231f      	movs	r3, #31
 801980a:	18fc      	adds	r4, r7, r3
 801980c:	1dbb      	adds	r3, r7, #6
 801980e:	881b      	ldrh	r3, [r3, #0]
 8019810:	6978      	ldr	r0, [r7, #20]
 8019812:	47a8      	blx	r5
 8019814:	0003      	movs	r3, r0
 8019816:	7023      	strb	r3, [r4, #0]
  goto err;
 8019818:	e004      	b.n	8019824 <ppp_netif_output+0xb6>
    goto err_rte_drop;
 801981a:	46c0      	nop			; (mov r8, r8)

err_rte_drop:
  err = ERR_RTE;
 801981c:	231f      	movs	r3, #31
 801981e:	18fb      	adds	r3, r7, r3
 8019820:	22fc      	movs	r2, #252	; 0xfc
 8019822:	701a      	strb	r2, [r3, #0]
  LINK_STATS_INC(link.rterr);
  LINK_STATS_INC(link.drop);
  MIB2_STATS_NETIF_INC(netif, ifoutdiscards);
err:
  if (fpb) {
 8019824:	69bb      	ldr	r3, [r7, #24]
 8019826:	2b00      	cmp	r3, #0
 8019828:	d003      	beq.n	8019832 <ppp_netif_output+0xc4>
    pbuf_free(fpb);
 801982a:	69bb      	ldr	r3, [r7, #24]
 801982c:	0018      	movs	r0, r3
 801982e:	f7ef ff31 	bl	8009694 <pbuf_free>
  }
  return err;
 8019832:	231f      	movs	r3, #31
 8019834:	18fb      	adds	r3, r7, r3
 8019836:	781b      	ldrb	r3, [r3, #0]
 8019838:	b25b      	sxtb	r3, r3
}
 801983a:	0018      	movs	r0, r3
 801983c:	46bd      	mov	sp, r7
 801983e:	b008      	add	sp, #32
 8019840:	bdb0      	pop	{r4, r5, r7, pc}
	...

08019844 <ppp_init>:
/*** PRIVATE FUNCTION DEFINITIONS ***/
/************************************/

/* Initialize the PPP subsystem. */
int ppp_init(void)
{
 8019844:	b580      	push	{r7, lr}
 8019846:	af00      	add	r7, sp, #0
#if PPPOS_SUPPORT
  LWIP_MEMPOOL_INIT(PPPOS_PCB);
 8019848:	4b06      	ldr	r3, [pc, #24]	; (8019864 <ppp_init+0x20>)
 801984a:	0018      	movs	r0, r3
 801984c:	f7ee ff24 	bl	8008698 <memp_init_pool>
#endif
#if LWIP_PPP_API && LWIP_MPU_COMPATIBLE
  LWIP_MEMPOOL_INIT(PPPAPI_MSG);
#endif

  LWIP_MEMPOOL_INIT(PPP_PCB);
 8019850:	4b05      	ldr	r3, [pc, #20]	; (8019868 <ppp_init+0x24>)
 8019852:	0018      	movs	r0, r3
 8019854:	f7ee ff20 	bl	8008698 <memp_init_pool>

  /*
   * Initialize magic number generator now so that protocols may
   * use magic numbers in initialization.
   */
  magic_init();
 8019858:	f7ff fe24 	bl	80194a4 <magic_init>

  return 0;
 801985c:	2300      	movs	r3, #0
}
 801985e:	0018      	movs	r0, r3
 8019860:	46bd      	mov	sp, r7
 8019862:	bd80      	pop	{r7, pc}
 8019864:	08021cc8 	.word	0x08021cc8
 8019868:	08021cac 	.word	0x08021cac

0801986c <ppp_new>:
 * attempt to negotiate the LCP session.
 *
 * Return a new PPP connection control block pointer
 * on success or a null pointer on failure.
 */
ppp_pcb *ppp_new(struct netif *pppif, const struct link_callbacks *callbacks, void *link_ctx_cb, ppp_link_status_cb_fn link_status_cb, void *ctx_cb) {
 801986c:	b590      	push	{r4, r7, lr}
 801986e:	b08d      	sub	sp, #52	; 0x34
 8019870:	af04      	add	r7, sp, #16
 8019872:	60f8      	str	r0, [r7, #12]
 8019874:	60b9      	str	r1, [r7, #8]
 8019876:	607a      	str	r2, [r7, #4]
 8019878:	603b      	str	r3, [r7, #0]
  const struct protent *protp;
  int i;

  /* PPP is single-threaded: without a callback,
   * there is no way to know when the link is up. */
  if (link_status_cb == NULL) {
 801987a:	683b      	ldr	r3, [r7, #0]
 801987c:	2b00      	cmp	r3, #0
 801987e:	d101      	bne.n	8019884 <ppp_new+0x18>
    return NULL;
 8019880:	2300      	movs	r3, #0
 8019882:	e065      	b.n	8019950 <ppp_new+0xe4>
  }

  pcb = (ppp_pcb*)LWIP_MEMPOOL_ALLOC(PPP_PCB);
 8019884:	4b34      	ldr	r3, [pc, #208]	; (8019958 <ppp_new+0xec>)
 8019886:	0018      	movs	r0, r3
 8019888:	f7ee ff7c 	bl	8008784 <memp_malloc_pool>
 801988c:	0003      	movs	r3, r0
 801988e:	61bb      	str	r3, [r7, #24]
  if (pcb == NULL) {
 8019890:	69bb      	ldr	r3, [r7, #24]
 8019892:	2b00      	cmp	r3, #0
 8019894:	d101      	bne.n	801989a <ppp_new+0x2e>
    return NULL;
 8019896:	2300      	movs	r3, #0
 8019898:	e05a      	b.n	8019950 <ppp_new+0xe4>
  }

  memset(pcb, 0, sizeof(ppp_pcb));
 801989a:	4a30      	ldr	r2, [pc, #192]	; (801995c <ppp_new+0xf0>)
 801989c:	69bb      	ldr	r3, [r7, #24]
 801989e:	2100      	movs	r1, #0
 80198a0:	0018      	movs	r0, r3
 80198a2:	f002 ffc3 	bl	801c82c <memset>
  pcb->settings.eap_timeout_time = EAP_DEFTIMEOUT;
  pcb->settings.eap_max_transmits = EAP_DEFTRANSMITS;
#endif /* PPP_SERVER */
#endif /* EAP_SUPPORT */

  pcb->settings.lcp_loopbackfail = LCP_DEFLOOPBACKFAIL;
 80198a6:	69bb      	ldr	r3, [r7, #24]
 80198a8:	220a      	movs	r2, #10
 80198aa:	721a      	strb	r2, [r3, #8]
  pcb->settings.lcp_echo_interval = LCP_ECHOINTERVAL;
 80198ac:	69bb      	ldr	r3, [r7, #24]
 80198ae:	2200      	movs	r2, #0
 80198b0:	725a      	strb	r2, [r3, #9]
  pcb->settings.lcp_echo_fails = LCP_MAXECHOFAILS;
 80198b2:	69bb      	ldr	r3, [r7, #24]
 80198b4:	2203      	movs	r2, #3
 80198b6:	729a      	strb	r2, [r3, #10]

  pcb->settings.fsm_timeout_time = FSM_DEFTIMEOUT;
 80198b8:	69bb      	ldr	r3, [r7, #24]
 80198ba:	2206      	movs	r2, #6
 80198bc:	711a      	strb	r2, [r3, #4]
  pcb->settings.fsm_max_conf_req_transmits = FSM_DEFMAXCONFREQS;
 80198be:	69bb      	ldr	r3, [r7, #24]
 80198c0:	220a      	movs	r2, #10
 80198c2:	715a      	strb	r2, [r3, #5]
  pcb->settings.fsm_max_term_transmits = FSM_DEFMAXTERMREQS;
 80198c4:	69bb      	ldr	r3, [r7, #24]
 80198c6:	2202      	movs	r2, #2
 80198c8:	719a      	strb	r2, [r3, #6]
  pcb->settings.fsm_max_nak_loops = FSM_DEFMAXNAKLOOPS;
 80198ca:	69bb      	ldr	r3, [r7, #24]
 80198cc:	2205      	movs	r2, #5
 80198ce:	71da      	strb	r2, [r3, #7]

  pcb->netif = pppif;
 80198d0:	69bb      	ldr	r3, [r7, #24]
 80198d2:	68fa      	ldr	r2, [r7, #12]
 80198d4:	621a      	str	r2, [r3, #32]
  MIB2_INIT_NETIF(pppif, snmp_ifType_ppp, 0);
  if (!netif_add(pcb->netif,
 80198d6:	69bb      	ldr	r3, [r7, #24]
 80198d8:	6a18      	ldr	r0, [r3, #32]
 80198da:	4c21      	ldr	r4, [pc, #132]	; (8019960 <ppp_new+0xf4>)
 80198dc:	4a21      	ldr	r2, [pc, #132]	; (8019964 <ppp_new+0xf8>)
 80198de:	4920      	ldr	r1, [pc, #128]	; (8019960 <ppp_new+0xf4>)
 80198e0:	2300      	movs	r3, #0
 80198e2:	9302      	str	r3, [sp, #8]
 80198e4:	4b20      	ldr	r3, [pc, #128]	; (8019968 <ppp_new+0xfc>)
 80198e6:	9301      	str	r3, [sp, #4]
 80198e8:	69bb      	ldr	r3, [r7, #24]
 80198ea:	9300      	str	r3, [sp, #0]
 80198ec:	0023      	movs	r3, r4
 80198ee:	f7ef f807 	bl	8008900 <netif_add>
 80198f2:	1e03      	subs	r3, r0, #0
 80198f4:	d107      	bne.n	8019906 <ppp_new+0x9a>
#if LWIP_IPV4
                 IP4_ADDR_ANY4, IP4_ADDR_BROADCAST, IP4_ADDR_ANY4,
#endif /* LWIP_IPV4 */
                 (void *)pcb, ppp_netif_init_cb, NULL)) {
    LWIP_MEMPOOL_FREE(PPP_PCB, pcb);
 80198f6:	69ba      	ldr	r2, [r7, #24]
 80198f8:	4b17      	ldr	r3, [pc, #92]	; (8019958 <ppp_new+0xec>)
 80198fa:	0011      	movs	r1, r2
 80198fc:	0018      	movs	r0, r3
 80198fe:	f7ee ffad 	bl	800885c <memp_free_pool>
    PPPDEBUG(LOG_ERR, ("ppp_new: netif_add failed\n"));
    return NULL;
 8019902:	2300      	movs	r3, #0
 8019904:	e024      	b.n	8019950 <ppp_new+0xe4>
  }

  pcb->link_cb = callbacks;
 8019906:	69bb      	ldr	r3, [r7, #24]
 8019908:	68ba      	ldr	r2, [r7, #8]
 801990a:	60da      	str	r2, [r3, #12]
  pcb->link_ctx_cb = link_ctx_cb;
 801990c:	69bb      	ldr	r3, [r7, #24]
 801990e:	687a      	ldr	r2, [r7, #4]
 8019910:	611a      	str	r2, [r3, #16]
  pcb->link_status_cb = link_status_cb;
 8019912:	69bb      	ldr	r3, [r7, #24]
 8019914:	683a      	ldr	r2, [r7, #0]
 8019916:	615a      	str	r2, [r3, #20]
  pcb->ctx_cb = ctx_cb;
 8019918:	69bb      	ldr	r3, [r7, #24]
 801991a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801991c:	61da      	str	r2, [r3, #28]

  /*
   * Initialize each protocol.
   */
  for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 801991e:	2300      	movs	r3, #0
 8019920:	61fb      	str	r3, [r7, #28]
 8019922:	e007      	b.n	8019934 <ppp_new+0xc8>
      (*protp->init)(pcb);
 8019924:	697b      	ldr	r3, [r7, #20]
 8019926:	685b      	ldr	r3, [r3, #4]
 8019928:	69ba      	ldr	r2, [r7, #24]
 801992a:	0010      	movs	r0, r2
 801992c:	4798      	blx	r3
  for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 801992e:	69fb      	ldr	r3, [r7, #28]
 8019930:	3301      	adds	r3, #1
 8019932:	61fb      	str	r3, [r7, #28]
 8019934:	4b0d      	ldr	r3, [pc, #52]	; (801996c <ppp_new+0x100>)
 8019936:	69fa      	ldr	r2, [r7, #28]
 8019938:	0092      	lsls	r2, r2, #2
 801993a:	58d3      	ldr	r3, [r2, r3]
 801993c:	617b      	str	r3, [r7, #20]
 801993e:	697b      	ldr	r3, [r7, #20]
 8019940:	2b00      	cmp	r3, #0
 8019942:	d1ef      	bne.n	8019924 <ppp_new+0xb8>
  }

  new_phase(pcb, PPP_PHASE_DEAD);
 8019944:	69bb      	ldr	r3, [r7, #24]
 8019946:	2100      	movs	r1, #0
 8019948:	0018      	movs	r0, r3
 801994a:	f000 f94a 	bl	8019be2 <new_phase>
  return pcb;
 801994e:	69bb      	ldr	r3, [r7, #24]
}
 8019950:	0018      	movs	r0, r3
 8019952:	46bd      	mov	sp, r7
 8019954:	b009      	add	sp, #36	; 0x24
 8019956:	bd90      	pop	{r4, r7, pc}
 8019958:	08021cac 	.word	0x08021cac
 801995c:	00001264 	.word	0x00001264
 8019960:	08021a50 	.word	0x08021a50
 8019964:	08021a54 	.word	0x08021a54
 8019968:	08019719 	.word	0x08019719
 801996c:	08021cbc 	.word	0x08021cbc

08019970 <ppp_start>:

/** Initiate LCP open request */
void ppp_start(ppp_pcb *pcb) {
 8019970:	b580      	push	{r7, lr}
 8019972:	b082      	sub	sp, #8
 8019974:	af00      	add	r7, sp, #0
 8019976:	6078      	str	r0, [r7, #4]
  pcb->mppe_keys_set = 0;
  memset(&pcb->mppe_comp, 0, sizeof(pcb->mppe_comp));
  memset(&pcb->mppe_decomp, 0, sizeof(pcb->mppe_decomp));
#endif /* MPPE_SUPPORT */
#if VJ_SUPPORT
  vj_compress_init(&pcb->vj_comp);
 8019978:	687b      	ldr	r3, [r7, #4]
 801997a:	33dc      	adds	r3, #220	; 0xdc
 801997c:	0018      	movs	r0, r3
 801997e:	f001 fc3e 	bl	801b1fe <vj_compress_init>
#endif /* VJ_SUPPORT */

  /* Start protocol */
  new_phase(pcb, PPP_PHASE_ESTABLISH);
 8019982:	687b      	ldr	r3, [r7, #4]
 8019984:	2106      	movs	r1, #6
 8019986:	0018      	movs	r0, r3
 8019988:	f000 f92b 	bl	8019be2 <new_phase>
  lcp_open(pcb);
 801998c:	687b      	ldr	r3, [r7, #4]
 801998e:	0018      	movs	r0, r3
 8019990:	f7fd fd1a 	bl	80173c8 <lcp_open>
  lcp_lowerup(pcb);
 8019994:	687b      	ldr	r3, [r7, #4]
 8019996:	0018      	movs	r0, r3
 8019998:	f7fd fd90 	bl	80174bc <lcp_lowerup>
  PPPDEBUG(LOG_DEBUG, ("ppp_start[%d]: finished\n", pcb->netif->num));
}
 801999c:	46c0      	nop			; (mov r8, r8)
 801999e:	46bd      	mov	sp, r7
 80199a0:	b002      	add	sp, #8
 80199a2:	bd80      	pop	{r7, pc}

080199a4 <ppp_link_end>:
  pcb->err_code = PPPERR_OPEN;
  pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
}

/** Called when link is normally down (i.e. it was asked to end) */
void ppp_link_end(ppp_pcb *pcb) {
 80199a4:	b590      	push	{r4, r7, lr}
 80199a6:	b083      	sub	sp, #12
 80199a8:	af00      	add	r7, sp, #0
 80199aa:	6078      	str	r0, [r7, #4]
  PPPDEBUG(LOG_DEBUG, ("ppp_link_end[%d]\n", pcb->netif->num));
  new_phase(pcb, PPP_PHASE_DEAD);
 80199ac:	687b      	ldr	r3, [r7, #4]
 80199ae:	2100      	movs	r1, #0
 80199b0:	0018      	movs	r0, r3
 80199b2:	f000 f916 	bl	8019be2 <new_phase>
  if (pcb->err_code == PPPERR_NONE) {
 80199b6:	687b      	ldr	r3, [r7, #4]
 80199b8:	2225      	movs	r2, #37	; 0x25
 80199ba:	5c9b      	ldrb	r3, [r3, r2]
 80199bc:	2b00      	cmp	r3, #0
 80199be:	d103      	bne.n	80199c8 <ppp_link_end+0x24>
    pcb->err_code = PPPERR_CONNECT;
 80199c0:	687b      	ldr	r3, [r7, #4]
 80199c2:	2225      	movs	r2, #37	; 0x25
 80199c4:	2106      	movs	r1, #6
 80199c6:	5499      	strb	r1, [r3, r2]
  }
  pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
 80199c8:	687b      	ldr	r3, [r7, #4]
 80199ca:	695c      	ldr	r4, [r3, #20]
 80199cc:	687b      	ldr	r3, [r7, #4]
 80199ce:	2225      	movs	r2, #37	; 0x25
 80199d0:	5c9b      	ldrb	r3, [r3, r2]
 80199d2:	0019      	movs	r1, r3
 80199d4:	687b      	ldr	r3, [r7, #4]
 80199d6:	69da      	ldr	r2, [r3, #28]
 80199d8:	687b      	ldr	r3, [r7, #4]
 80199da:	0018      	movs	r0, r3
 80199dc:	47a0      	blx	r4
}
 80199de:	46c0      	nop			; (mov r8, r8)
 80199e0:	46bd      	mov	sp, r7
 80199e2:	b003      	add	sp, #12
 80199e4:	bd90      	pop	{r4, r7, pc}
	...

080199e8 <ppp_input>:

/*
 * Pass the processed input packet to the appropriate handler.
 * This function and all handlers run in the context of the tcpip_thread
 */
void ppp_input(ppp_pcb *pcb, struct pbuf *pb) {
 80199e8:	b590      	push	{r4, r7, lr}
 80199ea:	b087      	sub	sp, #28
 80199ec:	af00      	add	r7, sp, #0
 80199ee:	6078      	str	r0, [r7, #4]
 80199f0:	6039      	str	r1, [r7, #0]
  u16_t protocol;
#if PPP_DEBUG && PPP_PROTOCOLNAME
    const char *pname;
#endif /* PPP_DEBUG && PPP_PROTOCOLNAME */

  magic_randomize();
 80199f2:	f7ff fd67 	bl	80194c4 <magic_randomize>

  if (pb->len < 2) {
 80199f6:	683b      	ldr	r3, [r7, #0]
 80199f8:	895b      	ldrh	r3, [r3, #10]
 80199fa:	2b01      	cmp	r3, #1
 80199fc:	d800      	bhi.n	8019a00 <ppp_input+0x18>
 80199fe:	e0b6      	b.n	8019b6e <ppp_input+0x186>
    PPPDEBUG(LOG_ERR, ("ppp_input[%d]: packet too short\n", pcb->netif->num));
    goto drop;
  }
  protocol = (((u8_t *)pb->payload)[0] << 8) | ((u8_t*)pb->payload)[1];
 8019a00:	683b      	ldr	r3, [r7, #0]
 8019a02:	685b      	ldr	r3, [r3, #4]
 8019a04:	781b      	ldrb	r3, [r3, #0]
 8019a06:	021b      	lsls	r3, r3, #8
 8019a08:	b21a      	sxth	r2, r3
 8019a0a:	683b      	ldr	r3, [r7, #0]
 8019a0c:	685b      	ldr	r3, [r3, #4]
 8019a0e:	3301      	adds	r3, #1
 8019a10:	781b      	ldrb	r3, [r3, #0]
 8019a12:	b21b      	sxth	r3, r3
 8019a14:	4313      	orrs	r3, r2
 8019a16:	b21a      	sxth	r2, r3
 8019a18:	2412      	movs	r4, #18
 8019a1a:	193b      	adds	r3, r7, r4
 8019a1c:	801a      	strh	r2, [r3, #0]

#if PRINTPKT_SUPPORT
  ppp_dump_packet(pcb, "rcvd", (unsigned char *)pb->payload, pb->len);
#endif /* PRINTPKT_SUPPORT */

  pbuf_remove_header(pb, sizeof(protocol));
 8019a1e:	683b      	ldr	r3, [r7, #0]
 8019a20:	2102      	movs	r1, #2
 8019a22:	0018      	movs	r0, r3
 8019a24:	f7ef fd5e 	bl	80094e4 <pbuf_remove_header>
  MIB2_STATS_NETIF_ADD(pcb->netif, ifinoctets, pb->tot_len);

  /*
   * Toss all non-LCP packets unless LCP is OPEN.
   */
  if (protocol != PPP_LCP && pcb->lcp_fsm.state != PPP_FSM_OPENED) {
 8019a28:	193b      	adds	r3, r7, r4
 8019a2a:	881b      	ldrh	r3, [r3, #0]
 8019a2c:	4a57      	ldr	r2, [pc, #348]	; (8019b8c <ppp_input+0x1a4>)
 8019a2e:	4293      	cmp	r3, r2
 8019a30:	d009      	beq.n	8019a46 <ppp_input+0x5e>
 8019a32:	687b      	ldr	r3, [r7, #4]
 8019a34:	2238      	movs	r2, #56	; 0x38
 8019a36:	5c9b      	ldrb	r3, [r3, r2]
 8019a38:	2b09      	cmp	r3, #9
 8019a3a:	d004      	beq.n	8019a46 <ppp_input+0x5e>
    ppp_dbglog("Discarded non-LCP packet when LCP not open");
 8019a3c:	4b54      	ldr	r3, [pc, #336]	; (8019b90 <ppp_input+0x1a8>)
 8019a3e:	0018      	movs	r0, r3
 8019a40:	f001 fbc9 	bl	801b1d6 <ppp_dbglog>
    goto drop;
 8019a44:	e09a      	b.n	8019b7c <ppp_input+0x194>

  /*
   * Until we get past the authentication phase, toss all packets
   * except LCP, LQR and authentication packets.
   */
  if (pcb->phase <= PPP_PHASE_AUTHENTICATE
 8019a46:	687b      	ldr	r3, [r7, #4]
 8019a48:	2224      	movs	r2, #36	; 0x24
 8019a4a:	5c9b      	ldrb	r3, [r3, r2]
 8019a4c:	2b07      	cmp	r3, #7
 8019a4e:	d810      	bhi.n	8019a72 <ppp_input+0x8a>
   && !(protocol == PPP_LCP
 8019a50:	2112      	movs	r1, #18
 8019a52:	187b      	adds	r3, r7, r1
 8019a54:	881b      	ldrh	r3, [r3, #0]
 8019a56:	4a4d      	ldr	r2, [pc, #308]	; (8019b8c <ppp_input+0x1a4>)
 8019a58:	4293      	cmp	r3, r2
 8019a5a:	d00a      	beq.n	8019a72 <ppp_input+0x8a>
#endif /* CHAP_SUPPORT */
#if EAP_SUPPORT
   || protocol == PPP_EAP
#endif /* EAP_SUPPORT */
   )) {
    ppp_dbglog("discarding proto 0x%x in phase %d", protocol, pcb->phase);
 8019a5c:	187b      	adds	r3, r7, r1
 8019a5e:	8819      	ldrh	r1, [r3, #0]
 8019a60:	687b      	ldr	r3, [r7, #4]
 8019a62:	2224      	movs	r2, #36	; 0x24
 8019a64:	5c9b      	ldrb	r3, [r3, r2]
 8019a66:	001a      	movs	r2, r3
 8019a68:	4b4a      	ldr	r3, [pc, #296]	; (8019b94 <ppp_input+0x1ac>)
 8019a6a:	0018      	movs	r0, r3
 8019a6c:	f001 fbb3 	bl	801b1d6 <ppp_dbglog>
    goto drop;
 8019a70:	e084      	b.n	8019b7c <ppp_input+0x194>
      pbuf_remove_header(pb, 2);
    }
  }
#endif /* CCP_SUPPORT */

  switch(protocol) {
 8019a72:	2312      	movs	r3, #18
 8019a74:	18fb      	adds	r3, r7, r3
 8019a76:	881b      	ldrh	r3, [r3, #0]
 8019a78:	2b2f      	cmp	r3, #47	; 0x2f
 8019a7a:	d027      	beq.n	8019acc <ppp_input+0xe4>
 8019a7c:	dc3f      	bgt.n	8019afe <ppp_input+0x116>
 8019a7e:	2b21      	cmp	r3, #33	; 0x21
 8019a80:	d002      	beq.n	8019a88 <ppp_input+0xa0>
 8019a82:	2b2d      	cmp	r3, #45	; 0x2d
 8019a84:	d008      	beq.n	8019a98 <ppp_input+0xb0>
 8019a86:	e03a      	b.n	8019afe <ppp_input+0x116>

#if PPP_IPV4_SUPPORT
    case PPP_IP:            /* Internet Protocol */
      PPPDEBUG(LOG_INFO, ("ppp_input[%d]: ip in pbuf len=%d\n", pcb->netif->num, pb->tot_len));
      ip4_input(pb, pcb->netif);
 8019a88:	683a      	ldr	r2, [r7, #0]
 8019a8a:	687b      	ldr	r3, [r7, #4]
 8019a8c:	6a1b      	ldr	r3, [r3, #32]
 8019a8e:	0019      	movs	r1, r3
 8019a90:	0010      	movs	r0, r2
 8019a92:	f7f9 faa7 	bl	8012fe4 <ip4_input>
      return;
 8019a96:	e075      	b.n	8019b84 <ppp_input+0x19c>
      /*
       * Clip off the VJ header and prepend the rebuilt TCP/IP header and
       * pass the result to IP.
       */
      PPPDEBUG(LOG_INFO, ("ppp_input[%d]: vj_comp in pbuf len=%d\n", pcb->netif->num, pb->tot_len));
      if (pcb->vj_enabled && vj_uncompress_tcp(&pb, &pcb->vj_comp) >= 0) {
 8019a98:	687b      	ldr	r3, [r7, #4]
 8019a9a:	2226      	movs	r2, #38	; 0x26
 8019a9c:	5c9b      	ldrb	r3, [r3, r2]
 8019a9e:	2220      	movs	r2, #32
 8019aa0:	4013      	ands	r3, r2
 8019aa2:	b2db      	uxtb	r3, r3
 8019aa4:	2b00      	cmp	r3, #0
 8019aa6:	d064      	beq.n	8019b72 <ppp_input+0x18a>
 8019aa8:	687b      	ldr	r3, [r7, #4]
 8019aaa:	33dc      	adds	r3, #220	; 0xdc
 8019aac:	001a      	movs	r2, r3
 8019aae:	003b      	movs	r3, r7
 8019ab0:	0011      	movs	r1, r2
 8019ab2:	0018      	movs	r0, r3
 8019ab4:	f002 f8fe 	bl	801bcb4 <vj_uncompress_tcp>
 8019ab8:	1e03      	subs	r3, r0, #0
 8019aba:	db5a      	blt.n	8019b72 <ppp_input+0x18a>
        ip4_input(pb, pcb->netif);
 8019abc:	683a      	ldr	r2, [r7, #0]
 8019abe:	687b      	ldr	r3, [r7, #4]
 8019ac0:	6a1b      	ldr	r3, [r3, #32]
 8019ac2:	0019      	movs	r1, r3
 8019ac4:	0010      	movs	r0, r2
 8019ac6:	f7f9 fa8d 	bl	8012fe4 <ip4_input>
        return;
 8019aca:	e05b      	b.n	8019b84 <ppp_input+0x19c>
      /*
       * Process the TCP/IP header for VJ header compression and then pass
       * the packet to IP.
       */
      PPPDEBUG(LOG_INFO, ("ppp_input[%d]: vj_un in pbuf len=%d\n", pcb->netif->num, pb->tot_len));
      if (pcb->vj_enabled && vj_uncompress_uncomp(pb, &pcb->vj_comp) >= 0) {
 8019acc:	687b      	ldr	r3, [r7, #4]
 8019ace:	2226      	movs	r2, #38	; 0x26
 8019ad0:	5c9b      	ldrb	r3, [r3, r2]
 8019ad2:	2220      	movs	r2, #32
 8019ad4:	4013      	ands	r3, r2
 8019ad6:	b2db      	uxtb	r3, r3
 8019ad8:	2b00      	cmp	r3, #0
 8019ada:	d04c      	beq.n	8019b76 <ppp_input+0x18e>
 8019adc:	683a      	ldr	r2, [r7, #0]
 8019ade:	687b      	ldr	r3, [r7, #4]
 8019ae0:	33dc      	adds	r3, #220	; 0xdc
 8019ae2:	0019      	movs	r1, r3
 8019ae4:	0010      	movs	r0, r2
 8019ae6:	f002 f877 	bl	801bbd8 <vj_uncompress_uncomp>
 8019aea:	1e03      	subs	r3, r0, #0
 8019aec:	db43      	blt.n	8019b76 <ppp_input+0x18e>
        ip4_input(pb, pcb->netif);
 8019aee:	683a      	ldr	r2, [r7, #0]
 8019af0:	687b      	ldr	r3, [r7, #4]
 8019af2:	6a1b      	ldr	r3, [r3, #32]
 8019af4:	0019      	movs	r1, r3
 8019af6:	0010      	movs	r0, r2
 8019af8:	f7f9 fa74 	bl	8012fe4 <ip4_input>
        return;
 8019afc:	e042      	b.n	8019b84 <ppp_input+0x19c>
      const struct protent *protp;

      /*
       * Upcall the proper protocol input routine.
       */
      for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 8019afe:	2300      	movs	r3, #0
 8019b00:	617b      	str	r3, [r7, #20]
 8019b02:	e01b      	b.n	8019b3c <ppp_input+0x154>
        if (protp->protocol == protocol) {
 8019b04:	68fb      	ldr	r3, [r7, #12]
 8019b06:	881b      	ldrh	r3, [r3, #0]
 8019b08:	2212      	movs	r2, #18
 8019b0a:	18ba      	adds	r2, r7, r2
 8019b0c:	8812      	ldrh	r2, [r2, #0]
 8019b0e:	429a      	cmp	r2, r3
 8019b10:	d111      	bne.n	8019b36 <ppp_input+0x14e>
          pb = pbuf_coalesce(pb, PBUF_RAW);
 8019b12:	683b      	ldr	r3, [r7, #0]
 8019b14:	2100      	movs	r1, #0
 8019b16:	0018      	movs	r0, r3
 8019b18:	f7f0 fa74 	bl	800a004 <pbuf_coalesce>
 8019b1c:	0003      	movs	r3, r0
 8019b1e:	603b      	str	r3, [r7, #0]
          (*protp->input)(pcb, (u8_t*)pb->payload, pb->len);
 8019b20:	68fb      	ldr	r3, [r7, #12]
 8019b22:	689c      	ldr	r4, [r3, #8]
 8019b24:	683b      	ldr	r3, [r7, #0]
 8019b26:	6859      	ldr	r1, [r3, #4]
 8019b28:	683b      	ldr	r3, [r7, #0]
 8019b2a:	895b      	ldrh	r3, [r3, #10]
 8019b2c:	001a      	movs	r2, r3
 8019b2e:	687b      	ldr	r3, [r7, #4]
 8019b30:	0018      	movs	r0, r3
 8019b32:	47a0      	blx	r4
          goto out;
 8019b34:	e022      	b.n	8019b7c <ppp_input+0x194>
      for (i = 0; (protp = protocols[i]) != NULL; ++i) {
 8019b36:	697b      	ldr	r3, [r7, #20]
 8019b38:	3301      	adds	r3, #1
 8019b3a:	617b      	str	r3, [r7, #20]
 8019b3c:	4b16      	ldr	r3, [pc, #88]	; (8019b98 <ppp_input+0x1b0>)
 8019b3e:	697a      	ldr	r2, [r7, #20]
 8019b40:	0092      	lsls	r2, r2, #2
 8019b42:	58d3      	ldr	r3, [r2, r3]
 8019b44:	60fb      	str	r3, [r7, #12]
 8019b46:	68fb      	ldr	r3, [r7, #12]
 8019b48:	2b00      	cmp	r3, #0
 8019b4a:	d1db      	bne.n	8019b04 <ppp_input+0x11c>
        ppp_warn("Unsupported protocol '%s' (0x%x) received", pname, protocol);
      } else
#endif /* PPP_PROTOCOLNAME */
        ppp_warn("Unsupported protocol 0x%x received", protocol);
#endif /* PPP_DEBUG */
        if (pbuf_add_header(pb, sizeof(protocol))) {
 8019b4c:	683b      	ldr	r3, [r7, #0]
 8019b4e:	2102      	movs	r1, #2
 8019b50:	0018      	movs	r0, r3
 8019b52:	f7ef fcb7 	bl	80094c4 <pbuf_add_header>
 8019b56:	1e03      	subs	r3, r0, #0
 8019b58:	d10f      	bne.n	8019b7a <ppp_input+0x192>
          PPPDEBUG(LOG_WARNING, ("ppp_input[%d]: Dropping (pbuf_add_header failed)\n", pcb->netif->num));
          goto drop;
        }
        lcp_sprotrej(pcb, (u8_t*)pb->payload, pb->len);
 8019b5a:	683b      	ldr	r3, [r7, #0]
 8019b5c:	6859      	ldr	r1, [r3, #4]
 8019b5e:	683b      	ldr	r3, [r7, #0]
 8019b60:	895b      	ldrh	r3, [r3, #10]
 8019b62:	001a      	movs	r2, r3
 8019b64:	687b      	ldr	r3, [r7, #4]
 8019b66:	0018      	movs	r0, r3
 8019b68:	f7fd fe46 	bl	80177f8 <lcp_sprotrej>
      }
      break;
 8019b6c:	e006      	b.n	8019b7c <ppp_input+0x194>
    goto drop;
 8019b6e:	46c0      	nop			; (mov r8, r8)
 8019b70:	e004      	b.n	8019b7c <ppp_input+0x194>
      break;
 8019b72:	46c0      	nop			; (mov r8, r8)
 8019b74:	e002      	b.n	8019b7c <ppp_input+0x194>
      break;
 8019b76:	46c0      	nop			; (mov r8, r8)
 8019b78:	e000      	b.n	8019b7c <ppp_input+0x194>
          goto drop;
 8019b7a:	46c0      	nop			; (mov r8, r8)
drop:
  LINK_STATS_INC(link.drop);
  MIB2_STATS_NETIF_INC(pcb->netif, ifindiscards);

out:
  pbuf_free(pb);
 8019b7c:	683b      	ldr	r3, [r7, #0]
 8019b7e:	0018      	movs	r0, r3
 8019b80:	f7ef fd88 	bl	8009694 <pbuf_free>
}
 8019b84:	46bd      	mov	sp, r7
 8019b86:	b007      	add	sp, #28
 8019b88:	bd90      	pop	{r4, r7, pc}
 8019b8a:	46c0      	nop			; (mov r8, r8)
 8019b8c:	0000c021 	.word	0x0000c021
 8019b90:	0802133c 	.word	0x0802133c
 8019b94:	08021368 	.word	0x08021368
 8019b98:	08021cbc 	.word	0x08021cbc

08019b9c <ppp_write>:
 *
 * IPv4 and IPv6 packets from lwIP are sent, respectively,
 * with ppp_netif_output_ip4() and ppp_netif_output_ip6()
 * functions (which are callbacks of the netif PPP interface).
 */
err_t ppp_write(ppp_pcb *pcb, struct pbuf *p) {
 8019b9c:	b590      	push	{r4, r7, lr}
 8019b9e:	b083      	sub	sp, #12
 8019ba0:	af00      	add	r7, sp, #0
 8019ba2:	6078      	str	r0, [r7, #4]
 8019ba4:	6039      	str	r1, [r7, #0]
#if PRINTPKT_SUPPORT
  ppp_dump_packet(pcb, "sent", (unsigned char *)p->payload+2, p->len-2);
#endif /* PRINTPKT_SUPPORT */
  return pcb->link_cb->write(pcb, pcb->link_ctx_cb, p);
 8019ba6:	687b      	ldr	r3, [r7, #4]
 8019ba8:	68db      	ldr	r3, [r3, #12]
 8019baa:	68dc      	ldr	r4, [r3, #12]
 8019bac:	687b      	ldr	r3, [r7, #4]
 8019bae:	6919      	ldr	r1, [r3, #16]
 8019bb0:	683a      	ldr	r2, [r7, #0]
 8019bb2:	687b      	ldr	r3, [r7, #4]
 8019bb4:	0018      	movs	r0, r3
 8019bb6:	47a0      	blx	r4
 8019bb8:	0003      	movs	r3, r0
}
 8019bba:	0018      	movs	r0, r3
 8019bbc:	46bd      	mov	sp, r7
 8019bbe:	b003      	add	sp, #12
 8019bc0:	bd90      	pop	{r4, r7, pc}

08019bc2 <ppp_link_terminated>:

void ppp_link_terminated(ppp_pcb *pcb) {
 8019bc2:	b580      	push	{r7, lr}
 8019bc4:	b082      	sub	sp, #8
 8019bc6:	af00      	add	r7, sp, #0
 8019bc8:	6078      	str	r0, [r7, #4]
  PPPDEBUG(LOG_DEBUG, ("ppp_link_terminated[%d]\n", pcb->netif->num));
  pcb->link_cb->disconnect(pcb, pcb->link_ctx_cb);
 8019bca:	687b      	ldr	r3, [r7, #4]
 8019bcc:	68db      	ldr	r3, [r3, #12]
 8019bce:	685a      	ldr	r2, [r3, #4]
 8019bd0:	687b      	ldr	r3, [r7, #4]
 8019bd2:	6919      	ldr	r1, [r3, #16]
 8019bd4:	687b      	ldr	r3, [r7, #4]
 8019bd6:	0018      	movs	r0, r3
 8019bd8:	4790      	blx	r2
  PPPDEBUG(LOG_DEBUG, ("ppp_link_terminated[%d]: finished.\n", pcb->netif->num));
}
 8019bda:	46c0      	nop			; (mov r8, r8)
 8019bdc:	46bd      	mov	sp, r7
 8019bde:	b002      	add	sp, #8
 8019be0:	bd80      	pop	{r7, pc}

08019be2 <new_phase>:
 */

/*
 * new_phase - signal the start of a new phase of pppd's operation.
 */
void new_phase(ppp_pcb *pcb, int p) {
 8019be2:	b590      	push	{r4, r7, lr}
 8019be4:	b083      	sub	sp, #12
 8019be6:	af00      	add	r7, sp, #0
 8019be8:	6078      	str	r0, [r7, #4]
 8019bea:	6039      	str	r1, [r7, #0]
  pcb->phase = p;
 8019bec:	683b      	ldr	r3, [r7, #0]
 8019bee:	b2d9      	uxtb	r1, r3
 8019bf0:	687b      	ldr	r3, [r7, #4]
 8019bf2:	2224      	movs	r2, #36	; 0x24
 8019bf4:	5499      	strb	r1, [r3, r2]
  PPPDEBUG(LOG_DEBUG, ("ppp phase changed[%d]: phase=%d\n", pcb->netif->num, pcb->phase));
#if PPP_NOTIFY_PHASE
  if (pcb->notify_phase_cb != NULL) {
 8019bf6:	687b      	ldr	r3, [r7, #4]
 8019bf8:	699b      	ldr	r3, [r3, #24]
 8019bfa:	2b00      	cmp	r3, #0
 8019bfc:	d008      	beq.n	8019c10 <new_phase+0x2e>
    pcb->notify_phase_cb(pcb, p, pcb->ctx_cb);
 8019bfe:	687b      	ldr	r3, [r7, #4]
 8019c00:	699c      	ldr	r4, [r3, #24]
 8019c02:	683b      	ldr	r3, [r7, #0]
 8019c04:	b2d9      	uxtb	r1, r3
 8019c06:	687b      	ldr	r3, [r7, #4]
 8019c08:	69da      	ldr	r2, [r3, #28]
 8019c0a:	687b      	ldr	r3, [r7, #4]
 8019c0c:	0018      	movs	r0, r3
 8019c0e:	47a0      	blx	r4
  }
#endif /* PPP_NOTIFY_PHASE */
}
 8019c10:	46c0      	nop			; (mov r8, r8)
 8019c12:	46bd      	mov	sp, r7
 8019c14:	b003      	add	sp, #12
 8019c16:	bd90      	pop	{r4, r7, pc}

08019c18 <ppp_send_config>:

/*
 * ppp_send_config - configure the transmit-side characteristics of
 * the ppp interface.
 */
int ppp_send_config(ppp_pcb *pcb, int mtu, u32_t accm, int pcomp, int accomp) {
 8019c18:	b5b0      	push	{r4, r5, r7, lr}
 8019c1a:	b086      	sub	sp, #24
 8019c1c:	af02      	add	r7, sp, #8
 8019c1e:	60f8      	str	r0, [r7, #12]
 8019c20:	60b9      	str	r1, [r7, #8]
 8019c22:	607a      	str	r2, [r7, #4]
 8019c24:	603b      	str	r3, [r7, #0]
  LWIP_UNUSED_ARG(mtu);
  /* pcb->mtu = mtu; -- set correctly with netif_set_mtu */

  if (pcb->link_cb->send_config) {
 8019c26:	68fb      	ldr	r3, [r7, #12]
 8019c28:	68db      	ldr	r3, [r3, #12]
 8019c2a:	695b      	ldr	r3, [r3, #20]
 8019c2c:	2b00      	cmp	r3, #0
 8019c2e:	d00b      	beq.n	8019c48 <ppp_send_config+0x30>
    pcb->link_cb->send_config(pcb, pcb->link_ctx_cb, accm, pcomp, accomp);
 8019c30:	68fb      	ldr	r3, [r7, #12]
 8019c32:	68db      	ldr	r3, [r3, #12]
 8019c34:	695c      	ldr	r4, [r3, #20]
 8019c36:	68fb      	ldr	r3, [r7, #12]
 8019c38:	6919      	ldr	r1, [r3, #16]
 8019c3a:	683d      	ldr	r5, [r7, #0]
 8019c3c:	687a      	ldr	r2, [r7, #4]
 8019c3e:	68f8      	ldr	r0, [r7, #12]
 8019c40:	6a3b      	ldr	r3, [r7, #32]
 8019c42:	9300      	str	r3, [sp, #0]
 8019c44:	002b      	movs	r3, r5
 8019c46:	47a0      	blx	r4
  }

  PPPDEBUG(LOG_INFO, ("ppp_send_config[%d]\n", pcb->netif->num) );
  return 0;
 8019c48:	2300      	movs	r3, #0
}
 8019c4a:	0018      	movs	r0, r3
 8019c4c:	46bd      	mov	sp, r7
 8019c4e:	b004      	add	sp, #16
 8019c50:	bdb0      	pop	{r4, r5, r7, pc}

08019c52 <ppp_recv_config>:

/*
 * ppp_recv_config - configure the receive-side characteristics of
 * the ppp interface.
 */
int ppp_recv_config(ppp_pcb *pcb, int mru, u32_t accm, int pcomp, int accomp) {
 8019c52:	b5b0      	push	{r4, r5, r7, lr}
 8019c54:	b086      	sub	sp, #24
 8019c56:	af02      	add	r7, sp, #8
 8019c58:	60f8      	str	r0, [r7, #12]
 8019c5a:	60b9      	str	r1, [r7, #8]
 8019c5c:	607a      	str	r2, [r7, #4]
 8019c5e:	603b      	str	r3, [r7, #0]
  LWIP_UNUSED_ARG(mru);

  if (pcb->link_cb->recv_config) {
 8019c60:	68fb      	ldr	r3, [r7, #12]
 8019c62:	68db      	ldr	r3, [r3, #12]
 8019c64:	699b      	ldr	r3, [r3, #24]
 8019c66:	2b00      	cmp	r3, #0
 8019c68:	d00b      	beq.n	8019c82 <ppp_recv_config+0x30>
    pcb->link_cb->recv_config(pcb, pcb->link_ctx_cb, accm, pcomp, accomp);
 8019c6a:	68fb      	ldr	r3, [r7, #12]
 8019c6c:	68db      	ldr	r3, [r3, #12]
 8019c6e:	699c      	ldr	r4, [r3, #24]
 8019c70:	68fb      	ldr	r3, [r7, #12]
 8019c72:	6919      	ldr	r1, [r3, #16]
 8019c74:	683d      	ldr	r5, [r7, #0]
 8019c76:	687a      	ldr	r2, [r7, #4]
 8019c78:	68f8      	ldr	r0, [r7, #12]
 8019c7a:	6a3b      	ldr	r3, [r7, #32]
 8019c7c:	9300      	str	r3, [sp, #0]
 8019c7e:	002b      	movs	r3, r5
 8019c80:	47a0      	blx	r4
  }

  PPPDEBUG(LOG_INFO, ("ppp_recv_config[%d]\n", pcb->netif->num));
  return 0;
 8019c82:	2300      	movs	r3, #0
}
 8019c84:	0018      	movs	r0, r3
 8019c86:	46bd      	mov	sp, r7
 8019c88:	b004      	add	sp, #16
 8019c8a:	bdb0      	pop	{r4, r5, r7, pc}

08019c8c <sifaddr>:

#if PPP_IPV4_SUPPORT
/*
 * sifaddr - Config the interface IP addresses and netmask.
 */
int sifaddr(ppp_pcb *pcb, u32_t our_adr, u32_t his_adr, u32_t netmask) {
 8019c8c:	b580      	push	{r7, lr}
 8019c8e:	b088      	sub	sp, #32
 8019c90:	af00      	add	r7, sp, #0
 8019c92:	60f8      	str	r0, [r7, #12]
 8019c94:	60b9      	str	r1, [r7, #8]
 8019c96:	607a      	str	r2, [r7, #4]
 8019c98:	603b      	str	r3, [r7, #0]
  ip4_addr_t ip, nm, gw;

  ip4_addr_set_u32(&ip, our_adr);
 8019c9a:	68bb      	ldr	r3, [r7, #8]
 8019c9c:	61fb      	str	r3, [r7, #28]
  ip4_addr_set_u32(&nm, netmask);
 8019c9e:	683b      	ldr	r3, [r7, #0]
 8019ca0:	61bb      	str	r3, [r7, #24]
  ip4_addr_set_u32(&gw, his_adr);
 8019ca2:	687b      	ldr	r3, [r7, #4]
 8019ca4:	617b      	str	r3, [r7, #20]
  netif_set_addr(pcb->netif, &ip, &nm, &gw);
 8019ca6:	68fb      	ldr	r3, [r7, #12]
 8019ca8:	6a18      	ldr	r0, [r3, #32]
 8019caa:	2314      	movs	r3, #20
 8019cac:	18fb      	adds	r3, r7, r3
 8019cae:	2218      	movs	r2, #24
 8019cb0:	18ba      	adds	r2, r7, r2
 8019cb2:	211c      	movs	r1, #28
 8019cb4:	1879      	adds	r1, r7, r1
 8019cb6:	f7ee ff95 	bl	8008be4 <netif_set_addr>
  return 1;
 8019cba:	2301      	movs	r3, #1
}
 8019cbc:	0018      	movs	r0, r3
 8019cbe:	46bd      	mov	sp, r7
 8019cc0:	b008      	add	sp, #32
 8019cc2:	bd80      	pop	{r7, pc}

08019cc4 <cifaddr>:
/********************************************************************
 *
 * cifaddr - Clear the interface IP addresses, and delete routes
 * through the interface if possible.
 */
int cifaddr(ppp_pcb *pcb, u32_t our_adr, u32_t his_adr) {
 8019cc4:	b580      	push	{r7, lr}
 8019cc6:	b084      	sub	sp, #16
 8019cc8:	af00      	add	r7, sp, #0
 8019cca:	60f8      	str	r0, [r7, #12]
 8019ccc:	60b9      	str	r1, [r7, #8]
 8019cce:	607a      	str	r2, [r7, #4]
  LWIP_UNUSED_ARG(our_adr);
  LWIP_UNUSED_ARG(his_adr);

  netif_set_addr(pcb->netif, IP4_ADDR_ANY4, IP4_ADDR_BROADCAST, IP4_ADDR_ANY4);
 8019cd0:	68fb      	ldr	r3, [r7, #12]
 8019cd2:	6a18      	ldr	r0, [r3, #32]
 8019cd4:	4b04      	ldr	r3, [pc, #16]	; (8019ce8 <cifaddr+0x24>)
 8019cd6:	4a05      	ldr	r2, [pc, #20]	; (8019cec <cifaddr+0x28>)
 8019cd8:	4903      	ldr	r1, [pc, #12]	; (8019ce8 <cifaddr+0x24>)
 8019cda:	f7ee ff83 	bl	8008be4 <netif_set_addr>
  return 1;
 8019cde:	2301      	movs	r3, #1
}
 8019ce0:	0018      	movs	r0, r3
 8019ce2:	46bd      	mov	sp, r7
 8019ce4:	b004      	add	sp, #16
 8019ce6:	bd80      	pop	{r7, pc}
 8019ce8:	08021a50 	.word	0x08021a50
 8019cec:	08021a54 	.word	0x08021a54

08019cf0 <sdns>:

#if LWIP_DNS
/*
 * sdns - Config the DNS servers
 */
int sdns(ppp_pcb *pcb, u32_t ns1, u32_t ns2) {
 8019cf0:	b590      	push	{r4, r7, lr}
 8019cf2:	b087      	sub	sp, #28
 8019cf4:	af00      	add	r7, sp, #0
 8019cf6:	60f8      	str	r0, [r7, #12]
 8019cf8:	60b9      	str	r1, [r7, #8]
 8019cfa:	607a      	str	r2, [r7, #4]
  ip_addr_t ns;
  LWIP_UNUSED_ARG(pcb);

  ip_addr_set_ip4_u32_val(ns, ns1);
 8019cfc:	68bb      	ldr	r3, [r7, #8]
 8019cfe:	617b      	str	r3, [r7, #20]
  dns_setserver(0, &ns);
 8019d00:	2414      	movs	r4, #20
 8019d02:	193b      	adds	r3, r7, r4
 8019d04:	0019      	movs	r1, r3
 8019d06:	2000      	movs	r0, #0
 8019d08:	f7ec fc94 	bl	8006634 <dns_setserver>
  ip_addr_set_ip4_u32_val(ns, ns2);
 8019d0c:	687b      	ldr	r3, [r7, #4]
 8019d0e:	617b      	str	r3, [r7, #20]
  dns_setserver(1, &ns);
 8019d10:	193b      	adds	r3, r7, r4
 8019d12:	0019      	movs	r1, r3
 8019d14:	2001      	movs	r0, #1
 8019d16:	f7ec fc8d 	bl	8006634 <dns_setserver>
  return 1;
 8019d1a:	2301      	movs	r3, #1
}
 8019d1c:	0018      	movs	r0, r3
 8019d1e:	46bd      	mov	sp, r7
 8019d20:	b007      	add	sp, #28
 8019d22:	bd90      	pop	{r4, r7, pc}

08019d24 <cdns>:

/********************************************************************
 *
 * cdns - Clear the DNS servers
 */
int cdns(ppp_pcb *pcb, u32_t ns1, u32_t ns2) {
 8019d24:	b580      	push	{r7, lr}
 8019d26:	b086      	sub	sp, #24
 8019d28:	af00      	add	r7, sp, #0
 8019d2a:	60f8      	str	r0, [r7, #12]
 8019d2c:	60b9      	str	r1, [r7, #8]
 8019d2e:	607a      	str	r2, [r7, #4]
  const ip_addr_t *nsa;
  ip_addr_t nsb;
  LWIP_UNUSED_ARG(pcb);

  nsa = dns_getserver(0);
 8019d30:	2000      	movs	r0, #0
 8019d32:	f7ec fca5 	bl	8006680 <dns_getserver>
 8019d36:	0003      	movs	r3, r0
 8019d38:	617b      	str	r3, [r7, #20]
  ip_addr_set_ip4_u32_val(nsb, ns1);
 8019d3a:	68bb      	ldr	r3, [r7, #8]
 8019d3c:	613b      	str	r3, [r7, #16]
  if (ip_addr_cmp(nsa, &nsb)) {
 8019d3e:	697b      	ldr	r3, [r7, #20]
 8019d40:	681a      	ldr	r2, [r3, #0]
 8019d42:	693b      	ldr	r3, [r7, #16]
 8019d44:	429a      	cmp	r2, r3
 8019d46:	d104      	bne.n	8019d52 <cdns+0x2e>
    dns_setserver(0, IP_ADDR_ANY);
 8019d48:	4b0d      	ldr	r3, [pc, #52]	; (8019d80 <cdns+0x5c>)
 8019d4a:	0019      	movs	r1, r3
 8019d4c:	2000      	movs	r0, #0
 8019d4e:	f7ec fc71 	bl	8006634 <dns_setserver>
  }
  nsa = dns_getserver(1);
 8019d52:	2001      	movs	r0, #1
 8019d54:	f7ec fc94 	bl	8006680 <dns_getserver>
 8019d58:	0003      	movs	r3, r0
 8019d5a:	617b      	str	r3, [r7, #20]
  ip_addr_set_ip4_u32_val(nsb, ns2);
 8019d5c:	687b      	ldr	r3, [r7, #4]
 8019d5e:	613b      	str	r3, [r7, #16]
  if (ip_addr_cmp(nsa, &nsb)) {
 8019d60:	697b      	ldr	r3, [r7, #20]
 8019d62:	681a      	ldr	r2, [r3, #0]
 8019d64:	693b      	ldr	r3, [r7, #16]
 8019d66:	429a      	cmp	r2, r3
 8019d68:	d104      	bne.n	8019d74 <cdns+0x50>
    dns_setserver(1, IP_ADDR_ANY);
 8019d6a:	4b05      	ldr	r3, [pc, #20]	; (8019d80 <cdns+0x5c>)
 8019d6c:	0019      	movs	r1, r3
 8019d6e:	2001      	movs	r0, #1
 8019d70:	f7ec fc60 	bl	8006634 <dns_setserver>
  }
  return 1;
 8019d74:	2301      	movs	r3, #1
}
 8019d76:	0018      	movs	r0, r3
 8019d78:	46bd      	mov	sp, r7
 8019d7a:	b006      	add	sp, #24
 8019d7c:	bd80      	pop	{r7, pc}
 8019d7e:	46c0      	nop			; (mov r8, r8)
 8019d80:	08021a50 	.word	0x08021a50

08019d84 <sifvjcomp>:
#if VJ_SUPPORT
/********************************************************************
 *
 * sifvjcomp - config tcp header compression
 */
int sifvjcomp(ppp_pcb *pcb, int vjcomp, int cidcomp, int maxcid) {
 8019d84:	b590      	push	{r4, r7, lr}
 8019d86:	b085      	sub	sp, #20
 8019d88:	af00      	add	r7, sp, #0
 8019d8a:	60f8      	str	r0, [r7, #12]
 8019d8c:	60b9      	str	r1, [r7, #8]
 8019d8e:	607a      	str	r2, [r7, #4]
 8019d90:	603b      	str	r3, [r7, #0]
  pcb->vj_enabled = vjcomp;
 8019d92:	68bb      	ldr	r3, [r7, #8]
 8019d94:	1c1a      	adds	r2, r3, #0
 8019d96:	2301      	movs	r3, #1
 8019d98:	4013      	ands	r3, r2
 8019d9a:	b2d9      	uxtb	r1, r3
 8019d9c:	68fb      	ldr	r3, [r7, #12]
 8019d9e:	2226      	movs	r2, #38	; 0x26
 8019da0:	2001      	movs	r0, #1
 8019da2:	4001      	ands	r1, r0
 8019da4:	014c      	lsls	r4, r1, #5
 8019da6:	5c99      	ldrb	r1, [r3, r2]
 8019da8:	2020      	movs	r0, #32
 8019daa:	4381      	bics	r1, r0
 8019dac:	1c08      	adds	r0, r1, #0
 8019dae:	1c21      	adds	r1, r4, #0
 8019db0:	4301      	orrs	r1, r0
 8019db2:	5499      	strb	r1, [r3, r2]
  pcb->vj_comp.compressSlot = cidcomp;
 8019db4:	687b      	ldr	r3, [r7, #4]
 8019db6:	b2d9      	uxtb	r1, r3
 8019db8:	68fb      	ldr	r3, [r7, #12]
 8019dba:	22e5      	movs	r2, #229	; 0xe5
 8019dbc:	5499      	strb	r1, [r3, r2]
  pcb->vj_comp.maxSlotIndex = maxcid;
 8019dbe:	683b      	ldr	r3, [r7, #0]
 8019dc0:	b2d9      	uxtb	r1, r3
 8019dc2:	68fb      	ldr	r3, [r7, #12]
 8019dc4:	22e4      	movs	r2, #228	; 0xe4
 8019dc6:	5499      	strb	r1, [r3, r2]
  PPPDEBUG(LOG_INFO, ("sifvjcomp[%d]: VJ compress enable=%d slot=%d max slot=%d\n",
            pcb->netif->num, vjcomp, cidcomp, maxcid));
  return 0;
 8019dc8:	2300      	movs	r3, #0
}
 8019dca:	0018      	movs	r0, r3
 8019dcc:	46bd      	mov	sp, r7
 8019dce:	b005      	add	sp, #20
 8019dd0:	bd90      	pop	{r4, r7, pc}

08019dd2 <sifup>:
#endif /* VJ_SUPPORT */

/*
 * sifup - Config the interface up and enable IP packets to pass.
 */
int sifup(ppp_pcb *pcb) {
 8019dd2:	b590      	push	{r4, r7, lr}
 8019dd4:	b083      	sub	sp, #12
 8019dd6:	af00      	add	r7, sp, #0
 8019dd8:	6078      	str	r0, [r7, #4]
  pcb->if4_up = 1;
 8019dda:	687b      	ldr	r3, [r7, #4]
 8019ddc:	2226      	movs	r2, #38	; 0x26
 8019dde:	5c99      	ldrb	r1, [r3, r2]
 8019de0:	2008      	movs	r0, #8
 8019de2:	4301      	orrs	r1, r0
 8019de4:	5499      	strb	r1, [r3, r2]
  pcb->err_code = PPPERR_NONE;
 8019de6:	687b      	ldr	r3, [r7, #4]
 8019de8:	2225      	movs	r2, #37	; 0x25
 8019dea:	2100      	movs	r1, #0
 8019dec:	5499      	strb	r1, [r3, r2]
  netif_set_link_up(pcb->netif);
 8019dee:	687b      	ldr	r3, [r7, #4]
 8019df0:	6a1b      	ldr	r3, [r3, #32]
 8019df2:	0018      	movs	r0, r3
 8019df4:	f7ee fff2 	bl	8008ddc <netif_set_link_up>

  PPPDEBUG(LOG_DEBUG, ("sifup[%d]: err_code=%d\n", pcb->netif->num, pcb->err_code));
  pcb->link_status_cb(pcb, pcb->err_code, pcb->ctx_cb);
 8019df8:	687b      	ldr	r3, [r7, #4]
 8019dfa:	695c      	ldr	r4, [r3, #20]
 8019dfc:	687b      	ldr	r3, [r7, #4]
 8019dfe:	2225      	movs	r2, #37	; 0x25
 8019e00:	5c9b      	ldrb	r3, [r3, r2]
 8019e02:	0019      	movs	r1, r3
 8019e04:	687b      	ldr	r3, [r7, #4]
 8019e06:	69da      	ldr	r2, [r3, #28]
 8019e08:	687b      	ldr	r3, [r7, #4]
 8019e0a:	0018      	movs	r0, r3
 8019e0c:	47a0      	blx	r4
  return 1;
 8019e0e:	2301      	movs	r3, #1
}
 8019e10:	0018      	movs	r0, r3
 8019e12:	46bd      	mov	sp, r7
 8019e14:	b003      	add	sp, #12
 8019e16:	bd90      	pop	{r4, r7, pc}

08019e18 <sifdown>:
/********************************************************************
 *
 * sifdown - Disable the indicated protocol and config the interface
 *           down if there are no remaining protocols.
 */
int sifdown(ppp_pcb *pcb) {
 8019e18:	b580      	push	{r7, lr}
 8019e1a:	b082      	sub	sp, #8
 8019e1c:	af00      	add	r7, sp, #0
 8019e1e:	6078      	str	r0, [r7, #4]

  pcb->if4_up = 0;
 8019e20:	687b      	ldr	r3, [r7, #4]
 8019e22:	2226      	movs	r2, #38	; 0x26
 8019e24:	5c99      	ldrb	r1, [r3, r2]
 8019e26:	2008      	movs	r0, #8
 8019e28:	4381      	bics	r1, r0
 8019e2a:	5499      	strb	r1, [r3, r2]
   /* set the interface down if IPv6 is down as well */
   && !pcb->if6_up
#endif /* PPP_IPV6_SUPPORT */
  ) {
    /* make sure the netif link callback is called */
    netif_set_link_down(pcb->netif);
 8019e2c:	687b      	ldr	r3, [r7, #4]
 8019e2e:	6a1b      	ldr	r3, [r3, #32]
 8019e30:	0018      	movs	r0, r3
 8019e32:	f7ef f803 	bl	8008e3c <netif_set_link_down>
  }
  PPPDEBUG(LOG_DEBUG, ("sifdown[%d]: err_code=%d\n", pcb->netif->num, pcb->err_code));
  return 1;
 8019e36:	2301      	movs	r3, #1
}
 8019e38:	0018      	movs	r0, r3
 8019e3a:	46bd      	mov	sp, r7
 8019e3c:	b002      	add	sp, #8
 8019e3e:	bd80      	pop	{r7, pc}

08019e40 <get_mask>:
 * Here we scan through the system's list of interfaces, looking for
 * any non-point-to-point interfaces which might appear to be on the same
 * network as `addr'.  If we find any, we OR in their netmask to the
 * user-specified netmask.
 */
u32_t get_mask(u32_t addr) {
 8019e40:	b580      	push	{r7, lr}
 8019e42:	b082      	sub	sp, #8
 8019e44:	af00      	add	r7, sp, #0
 8019e46:	6078      	str	r0, [r7, #4]
   */
  /* return mask; */
  return mask;
#endif /* 0 */
  LWIP_UNUSED_ARG(addr);
  return IPADDR_BROADCAST;
 8019e48:	2301      	movs	r3, #1
 8019e4a:	425b      	negs	r3, r3
}
 8019e4c:	0018      	movs	r0, r3
 8019e4e:	46bd      	mov	sp, r7
 8019e50:	b002      	add	sp, #8
 8019e52:	bd80      	pop	{r7, pc}

08019e54 <netif_set_mtu>:
#endif /* DEMAND_SUPPORT */

/*
 * netif_set_mtu - set the MTU on the PPP network interface.
 */
void netif_set_mtu(ppp_pcb *pcb, int mtu) {
 8019e54:	b580      	push	{r7, lr}
 8019e56:	b082      	sub	sp, #8
 8019e58:	af00      	add	r7, sp, #0
 8019e5a:	6078      	str	r0, [r7, #4]
 8019e5c:	6039      	str	r1, [r7, #0]

  pcb->netif->mtu = mtu;
 8019e5e:	687b      	ldr	r3, [r7, #4]
 8019e60:	6a1b      	ldr	r3, [r3, #32]
 8019e62:	683a      	ldr	r2, [r7, #0]
 8019e64:	b292      	uxth	r2, r2
 8019e66:	851a      	strh	r2, [r3, #40]	; 0x28
  PPPDEBUG(LOG_INFO, ("netif_set_mtu[%d]: mtu=%d\n", pcb->netif->num, mtu));
}
 8019e68:	46c0      	nop			; (mov r8, r8)
 8019e6a:	46bd      	mov	sp, r7
 8019e6c:	b002      	add	sp, #8
 8019e6e:	bd80      	pop	{r7, pc}

08019e70 <pppos_create>:
 *
 * Return 0 on success, an error code on failure.
 */
ppp_pcb *pppos_create(struct netif *pppif, pppos_output_cb_fn output_cb,
       ppp_link_status_cb_fn link_status_cb, void *ctx_cb)
{
 8019e70:	b590      	push	{r4, r7, lr}
 8019e72:	b089      	sub	sp, #36	; 0x24
 8019e74:	af02      	add	r7, sp, #8
 8019e76:	60f8      	str	r0, [r7, #12]
 8019e78:	60b9      	str	r1, [r7, #8]
 8019e7a:	607a      	str	r2, [r7, #4]
 8019e7c:	603b      	str	r3, [r7, #0]
  pppos_pcb *pppos;
  ppp_pcb *ppp;
  LWIP_ASSERT_CORE_LOCKED();

  pppos = (pppos_pcb *)LWIP_MEMPOOL_ALLOC(PPPOS_PCB);
 8019e7e:	4b19      	ldr	r3, [pc, #100]	; (8019ee4 <pppos_create+0x74>)
 8019e80:	0018      	movs	r0, r3
 8019e82:	f7ee fc7f 	bl	8008784 <memp_malloc_pool>
 8019e86:	0003      	movs	r3, r0
 8019e88:	617b      	str	r3, [r7, #20]
  if (pppos == NULL) {
 8019e8a:	697b      	ldr	r3, [r7, #20]
 8019e8c:	2b00      	cmp	r3, #0
 8019e8e:	d101      	bne.n	8019e94 <pppos_create+0x24>
    return NULL;
 8019e90:	2300      	movs	r3, #0
 8019e92:	e022      	b.n	8019eda <pppos_create+0x6a>
  }

  ppp = ppp_new(pppif, &pppos_callbacks, pppos, link_status_cb, ctx_cb);
 8019e94:	687c      	ldr	r4, [r7, #4]
 8019e96:	697a      	ldr	r2, [r7, #20]
 8019e98:	4913      	ldr	r1, [pc, #76]	; (8019ee8 <pppos_create+0x78>)
 8019e9a:	68f8      	ldr	r0, [r7, #12]
 8019e9c:	683b      	ldr	r3, [r7, #0]
 8019e9e:	9300      	str	r3, [sp, #0]
 8019ea0:	0023      	movs	r3, r4
 8019ea2:	f7ff fce3 	bl	801986c <ppp_new>
 8019ea6:	0003      	movs	r3, r0
 8019ea8:	613b      	str	r3, [r7, #16]
  if (ppp == NULL) {
 8019eaa:	693b      	ldr	r3, [r7, #16]
 8019eac:	2b00      	cmp	r3, #0
 8019eae:	d107      	bne.n	8019ec0 <pppos_create+0x50>
    LWIP_MEMPOOL_FREE(PPPOS_PCB, pppos);
 8019eb0:	697a      	ldr	r2, [r7, #20]
 8019eb2:	4b0c      	ldr	r3, [pc, #48]	; (8019ee4 <pppos_create+0x74>)
 8019eb4:	0011      	movs	r1, r2
 8019eb6:	0018      	movs	r0, r3
 8019eb8:	f7ee fcd0 	bl	800885c <memp_free_pool>
    return NULL;
 8019ebc:	2300      	movs	r3, #0
 8019ebe:	e00c      	b.n	8019eda <pppos_create+0x6a>
  }

  memset(pppos, 0, sizeof(pppos_pcb));
 8019ec0:	697b      	ldr	r3, [r7, #20]
 8019ec2:	2260      	movs	r2, #96	; 0x60
 8019ec4:	2100      	movs	r1, #0
 8019ec6:	0018      	movs	r0, r3
 8019ec8:	f002 fcb0 	bl	801c82c <memset>
  pppos->ppp = ppp;
 8019ecc:	697b      	ldr	r3, [r7, #20]
 8019ece:	693a      	ldr	r2, [r7, #16]
 8019ed0:	601a      	str	r2, [r3, #0]
  pppos->output_cb = output_cb;
 8019ed2:	697b      	ldr	r3, [r7, #20]
 8019ed4:	68ba      	ldr	r2, [r7, #8]
 8019ed6:	605a      	str	r2, [r3, #4]
  return ppp;
 8019ed8:	693b      	ldr	r3, [r7, #16]
}
 8019eda:	0018      	movs	r0, r3
 8019edc:	46bd      	mov	sp, r7
 8019ede:	b007      	add	sp, #28
 8019ee0:	bd90      	pop	{r4, r7, pc}
 8019ee2:	46c0      	nop			; (mov r8, r8)
 8019ee4:	08021cc8 	.word	0x08021cc8
 8019ee8:	08021cd8 	.word	0x08021cd8

08019eec <pppos_write>:

/* Called by PPP core */
static err_t
pppos_write(ppp_pcb *ppp, void *ctx, struct pbuf *p)
{
 8019eec:	b5f0      	push	{r4, r5, r6, r7, lr}
 8019eee:	b08d      	sub	sp, #52	; 0x34
 8019ef0:	af02      	add	r7, sp, #8
 8019ef2:	60f8      	str	r0, [r7, #12]
 8019ef4:	60b9      	str	r1, [r7, #8]
 8019ef6:	607a      	str	r2, [r7, #4]
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 8019ef8:	68bb      	ldr	r3, [r7, #8]
 8019efa:	61fb      	str	r3, [r7, #28]
  LWIP_UNUSED_ARG(ppp);

  /* Grab an output buffer. Using PBUF_POOL here for tx is ok since the pbuf
     gets freed by 'pppos_output_last' before this function returns and thus
     cannot starve rx. */
  nb = pbuf_alloc(PBUF_RAW, 0, PBUF_POOL);
 8019efc:	23c1      	movs	r3, #193	; 0xc1
 8019efe:	005b      	lsls	r3, r3, #1
 8019f00:	001a      	movs	r2, r3
 8019f02:	2100      	movs	r1, #0
 8019f04:	2000      	movs	r0, #0
 8019f06:	f7ef f84d 	bl	8008fa4 <pbuf_alloc>
 8019f0a:	0003      	movs	r3, r0
 8019f0c:	61bb      	str	r3, [r7, #24]
  if (nb == NULL) {
 8019f0e:	69bb      	ldr	r3, [r7, #24]
 8019f10:	2b00      	cmp	r3, #0
 8019f12:	d106      	bne.n	8019f22 <pppos_write+0x36>
    PPPDEBUG(LOG_WARNING, ("pppos_write[%d]: alloc fail\n", ppp->netif->num));
    LINK_STATS_INC(link.memerr);
    LINK_STATS_INC(link.drop);
    MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
    pbuf_free(p);
 8019f14:	687b      	ldr	r3, [r7, #4]
 8019f16:	0018      	movs	r0, r3
 8019f18:	f7ef fbbc 	bl	8009694 <pbuf_free>
    return ERR_MEM;
 8019f1c:	2301      	movs	r3, #1
 8019f1e:	425b      	negs	r3, r3
 8019f20:	e05f      	b.n	8019fe2 <pppos_write+0xf6>
  }

  /* Set nb->tot_len to actual payload length */
  nb->tot_len = p->len;
 8019f22:	687b      	ldr	r3, [r7, #4]
 8019f24:	895a      	ldrh	r2, [r3, #10]
 8019f26:	69bb      	ldr	r3, [r7, #24]
 8019f28:	811a      	strh	r2, [r3, #8]

  /* If the link has been idle, we'll send a fresh flag character to
   * flush any noise. */
  err = ERR_OK;
 8019f2a:	2421      	movs	r4, #33	; 0x21
 8019f2c:	193b      	adds	r3, r7, r4
 8019f2e:	2200      	movs	r2, #0
 8019f30:	701a      	strb	r2, [r3, #0]
  if ((sys_now() - pppos->last_xmit) >= PPP_MAXIDLEFLAG) {
 8019f32:	f002 fc0d 	bl	801c750 <sys_now>
 8019f36:	0002      	movs	r2, r0
 8019f38:	69fb      	ldr	r3, [r7, #28]
 8019f3a:	689b      	ldr	r3, [r3, #8]
 8019f3c:	1ad3      	subs	r3, r2, r3
 8019f3e:	2b63      	cmp	r3, #99	; 0x63
 8019f40:	d90f      	bls.n	8019f62 <pppos_write+0x76>
    err = pppos_output_append(pppos, err,  nb, PPP_FLAG, 0, NULL);
 8019f42:	0023      	movs	r3, r4
 8019f44:	18fc      	adds	r4, r7, r3
 8019f46:	69ba      	ldr	r2, [r7, #24]
 8019f48:	18fb      	adds	r3, r7, r3
 8019f4a:	2100      	movs	r1, #0
 8019f4c:	5659      	ldrsb	r1, [r3, r1]
 8019f4e:	69f8      	ldr	r0, [r7, #28]
 8019f50:	2300      	movs	r3, #0
 8019f52:	9301      	str	r3, [sp, #4]
 8019f54:	2300      	movs	r3, #0
 8019f56:	9300      	str	r3, [sp, #0]
 8019f58:	237e      	movs	r3, #126	; 0x7e
 8019f5a:	f000 fbe3 	bl	801a724 <pppos_output_append>
 8019f5e:	0003      	movs	r3, r0
 8019f60:	7023      	strb	r3, [r4, #0]
  }

  /* Load output buffer. */
  fcs_out = PPP_INITFCS;
 8019f62:	2316      	movs	r3, #22
 8019f64:	18fb      	adds	r3, r7, r3
 8019f66:	2201      	movs	r2, #1
 8019f68:	4252      	negs	r2, r2
 8019f6a:	801a      	strh	r2, [r3, #0]
  s = (u8_t*)p->payload;
 8019f6c:	687b      	ldr	r3, [r7, #4]
 8019f6e:	685b      	ldr	r3, [r3, #4]
 8019f70:	627b      	str	r3, [r7, #36]	; 0x24
  n = p->len;
 8019f72:	2322      	movs	r3, #34	; 0x22
 8019f74:	18fb      	adds	r3, r7, r3
 8019f76:	687a      	ldr	r2, [r7, #4]
 8019f78:	8952      	ldrh	r2, [r2, #10]
 8019f7a:	801a      	strh	r2, [r3, #0]
  while (n-- > 0) {
 8019f7c:	e014      	b.n	8019fa8 <pppos_write+0xbc>
    err = pppos_output_append(pppos, err,  nb, *s++, 1, &fcs_out);
 8019f7e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019f80:	1c5a      	adds	r2, r3, #1
 8019f82:	627a      	str	r2, [r7, #36]	; 0x24
 8019f84:	781d      	ldrb	r5, [r3, #0]
 8019f86:	2321      	movs	r3, #33	; 0x21
 8019f88:	18fc      	adds	r4, r7, r3
 8019f8a:	69ba      	ldr	r2, [r7, #24]
 8019f8c:	18fb      	adds	r3, r7, r3
 8019f8e:	2100      	movs	r1, #0
 8019f90:	5659      	ldrsb	r1, [r3, r1]
 8019f92:	69f8      	ldr	r0, [r7, #28]
 8019f94:	2316      	movs	r3, #22
 8019f96:	18fb      	adds	r3, r7, r3
 8019f98:	9301      	str	r3, [sp, #4]
 8019f9a:	2301      	movs	r3, #1
 8019f9c:	9300      	str	r3, [sp, #0]
 8019f9e:	002b      	movs	r3, r5
 8019fa0:	f000 fbc0 	bl	801a724 <pppos_output_append>
 8019fa4:	0003      	movs	r3, r0
 8019fa6:	7023      	strb	r3, [r4, #0]
  while (n-- > 0) {
 8019fa8:	2222      	movs	r2, #34	; 0x22
 8019faa:	18bb      	adds	r3, r7, r2
 8019fac:	881b      	ldrh	r3, [r3, #0]
 8019fae:	18ba      	adds	r2, r7, r2
 8019fb0:	1e59      	subs	r1, r3, #1
 8019fb2:	8011      	strh	r1, [r2, #0]
 8019fb4:	2b00      	cmp	r3, #0
 8019fb6:	d1e2      	bne.n	8019f7e <pppos_write+0x92>
  }

  err = pppos_output_last(pppos, err, nb, &fcs_out);
 8019fb8:	2621      	movs	r6, #33	; 0x21
 8019fba:	19bc      	adds	r4, r7, r6
 8019fbc:	2316      	movs	r3, #22
 8019fbe:	18fd      	adds	r5, r7, r3
 8019fc0:	69ba      	ldr	r2, [r7, #24]
 8019fc2:	19bb      	adds	r3, r7, r6
 8019fc4:	2100      	movs	r1, #0
 8019fc6:	5659      	ldrsb	r1, [r3, r1]
 8019fc8:	69f8      	ldr	r0, [r7, #28]
 8019fca:	002b      	movs	r3, r5
 8019fcc:	f000 fc44 	bl	801a858 <pppos_output_last>
 8019fd0:	0003      	movs	r3, r0
 8019fd2:	7023      	strb	r3, [r4, #0]
  if (err == ERR_OK) {
    PPPDEBUG(LOG_INFO, ("pppos_write[%d]: len=%d\n", ppp->netif->num, p->len));
  } else {
    PPPDEBUG(LOG_WARNING, ("pppos_write[%d]: output failed len=%d\n", ppp->netif->num, p->len));
  }
  pbuf_free(p);
 8019fd4:	687b      	ldr	r3, [r7, #4]
 8019fd6:	0018      	movs	r0, r3
 8019fd8:	f7ef fb5c 	bl	8009694 <pbuf_free>
  return err;
 8019fdc:	19bb      	adds	r3, r7, r6
 8019fde:	781b      	ldrb	r3, [r3, #0]
 8019fe0:	b25b      	sxtb	r3, r3
}
 8019fe2:	0018      	movs	r0, r3
 8019fe4:	46bd      	mov	sp, r7
 8019fe6:	b00b      	add	sp, #44	; 0x2c
 8019fe8:	bdf0      	pop	{r4, r5, r6, r7, pc}

08019fea <pppos_netif_output>:

/* Called by PPP core */
static err_t
pppos_netif_output(ppp_pcb *ppp, void *ctx, struct pbuf *pb, u16_t protocol)
{
 8019fea:	b5f0      	push	{r4, r5, r6, r7, lr}
 8019fec:	b08d      	sub	sp, #52	; 0x34
 8019fee:	af02      	add	r7, sp, #8
 8019ff0:	60f8      	str	r0, [r7, #12]
 8019ff2:	60b9      	str	r1, [r7, #8]
 8019ff4:	607a      	str	r2, [r7, #4]
 8019ff6:	001a      	movs	r2, r3
 8019ff8:	1cbb      	adds	r3, r7, #2
 8019ffa:	801a      	strh	r2, [r3, #0]
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 8019ffc:	68bb      	ldr	r3, [r7, #8]
 8019ffe:	61bb      	str	r3, [r7, #24]
  LWIP_UNUSED_ARG(ppp);

  /* Grab an output buffer. Using PBUF_POOL here for tx is ok since the pbuf
     gets freed by 'pppos_output_last' before this function returns and thus
     cannot starve rx. */
  nb = pbuf_alloc(PBUF_RAW, 0, PBUF_POOL);
 801a000:	23c1      	movs	r3, #193	; 0xc1
 801a002:	005b      	lsls	r3, r3, #1
 801a004:	001a      	movs	r2, r3
 801a006:	2100      	movs	r1, #0
 801a008:	2000      	movs	r0, #0
 801a00a:	f7ee ffcb 	bl	8008fa4 <pbuf_alloc>
 801a00e:	0003      	movs	r3, r0
 801a010:	617b      	str	r3, [r7, #20]
  if (nb == NULL) {
 801a012:	697b      	ldr	r3, [r7, #20]
 801a014:	2b00      	cmp	r3, #0
 801a016:	d102      	bne.n	801a01e <pppos_netif_output+0x34>
    PPPDEBUG(LOG_WARNING, ("pppos_netif_output[%d]: alloc fail\n", ppp->netif->num));
    LINK_STATS_INC(link.memerr);
    LINK_STATS_INC(link.drop);
    MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
    return ERR_MEM;
 801a018:	2301      	movs	r3, #1
 801a01a:	425b      	negs	r3, r3
 801a01c:	e0c1      	b.n	801a1a2 <pppos_netif_output+0x1b8>
  }

  /* Set nb->tot_len to actual payload length */
  nb->tot_len = pb->tot_len;
 801a01e:	687b      	ldr	r3, [r7, #4]
 801a020:	891a      	ldrh	r2, [r3, #8]
 801a022:	697b      	ldr	r3, [r7, #20]
 801a024:	811a      	strh	r2, [r3, #8]

  /* If the link has been idle, we'll send a fresh flag character to
   * flush any noise. */
  err = ERR_OK;
 801a026:	2423      	movs	r4, #35	; 0x23
 801a028:	193b      	adds	r3, r7, r4
 801a02a:	2200      	movs	r2, #0
 801a02c:	701a      	strb	r2, [r3, #0]
  if ((sys_now() - pppos->last_xmit) >= PPP_MAXIDLEFLAG) {
 801a02e:	f002 fb8f 	bl	801c750 <sys_now>
 801a032:	0002      	movs	r2, r0
 801a034:	69bb      	ldr	r3, [r7, #24]
 801a036:	689b      	ldr	r3, [r3, #8]
 801a038:	1ad3      	subs	r3, r2, r3
 801a03a:	2b63      	cmp	r3, #99	; 0x63
 801a03c:	d90f      	bls.n	801a05e <pppos_netif_output+0x74>
    err = pppos_output_append(pppos, err,  nb, PPP_FLAG, 0, NULL);
 801a03e:	0023      	movs	r3, r4
 801a040:	18fc      	adds	r4, r7, r3
 801a042:	697a      	ldr	r2, [r7, #20]
 801a044:	18fb      	adds	r3, r7, r3
 801a046:	2100      	movs	r1, #0
 801a048:	5659      	ldrsb	r1, [r3, r1]
 801a04a:	69b8      	ldr	r0, [r7, #24]
 801a04c:	2300      	movs	r3, #0
 801a04e:	9301      	str	r3, [sp, #4]
 801a050:	2300      	movs	r3, #0
 801a052:	9300      	str	r3, [sp, #0]
 801a054:	237e      	movs	r3, #126	; 0x7e
 801a056:	f000 fb65 	bl	801a724 <pppos_output_append>
 801a05a:	0003      	movs	r3, r0
 801a05c:	7023      	strb	r3, [r4, #0]
  }

  fcs_out = PPP_INITFCS;
 801a05e:	2612      	movs	r6, #18
 801a060:	19bb      	adds	r3, r7, r6
 801a062:	2201      	movs	r2, #1
 801a064:	4252      	negs	r2, r2
 801a066:	801a      	strh	r2, [r3, #0]
  if (!pppos->accomp) {
 801a068:	69bb      	ldr	r3, [r7, #24]
 801a06a:	222c      	movs	r2, #44	; 0x2c
 801a06c:	5c9b      	ldrb	r3, [r3, r2]
 801a06e:	2204      	movs	r2, #4
 801a070:	4013      	ands	r3, r2
 801a072:	b2db      	uxtb	r3, r3
 801a074:	2b00      	cmp	r3, #0
 801a076:	d11e      	bne.n	801a0b6 <pppos_netif_output+0xcc>
    err = pppos_output_append(pppos, err,  nb, PPP_ALLSTATIONS, 1, &fcs_out);
 801a078:	2523      	movs	r5, #35	; 0x23
 801a07a:	197c      	adds	r4, r7, r5
 801a07c:	697a      	ldr	r2, [r7, #20]
 801a07e:	197b      	adds	r3, r7, r5
 801a080:	2100      	movs	r1, #0
 801a082:	5659      	ldrsb	r1, [r3, r1]
 801a084:	69b8      	ldr	r0, [r7, #24]
 801a086:	19bb      	adds	r3, r7, r6
 801a088:	9301      	str	r3, [sp, #4]
 801a08a:	2301      	movs	r3, #1
 801a08c:	9300      	str	r3, [sp, #0]
 801a08e:	23ff      	movs	r3, #255	; 0xff
 801a090:	f000 fb48 	bl	801a724 <pppos_output_append>
 801a094:	0003      	movs	r3, r0
 801a096:	7023      	strb	r3, [r4, #0]
    err = pppos_output_append(pppos, err,  nb, PPP_UI, 1, &fcs_out);
 801a098:	197c      	adds	r4, r7, r5
 801a09a:	697a      	ldr	r2, [r7, #20]
 801a09c:	197b      	adds	r3, r7, r5
 801a09e:	2100      	movs	r1, #0
 801a0a0:	5659      	ldrsb	r1, [r3, r1]
 801a0a2:	69b8      	ldr	r0, [r7, #24]
 801a0a4:	19bb      	adds	r3, r7, r6
 801a0a6:	9301      	str	r3, [sp, #4]
 801a0a8:	2301      	movs	r3, #1
 801a0aa:	9300      	str	r3, [sp, #0]
 801a0ac:	2303      	movs	r3, #3
 801a0ae:	f000 fb39 	bl	801a724 <pppos_output_append>
 801a0b2:	0003      	movs	r3, r0
 801a0b4:	7023      	strb	r3, [r4, #0]
  }
  if (!pppos->pcomp || protocol > 0xFF) {
 801a0b6:	69bb      	ldr	r3, [r7, #24]
 801a0b8:	222c      	movs	r2, #44	; 0x2c
 801a0ba:	5c9b      	ldrb	r3, [r3, r2]
 801a0bc:	2202      	movs	r2, #2
 801a0be:	4013      	ands	r3, r2
 801a0c0:	b2db      	uxtb	r3, r3
 801a0c2:	2b00      	cmp	r3, #0
 801a0c4:	d003      	beq.n	801a0ce <pppos_netif_output+0xe4>
 801a0c6:	1cbb      	adds	r3, r7, #2
 801a0c8:	881b      	ldrh	r3, [r3, #0]
 801a0ca:	2bff      	cmp	r3, #255	; 0xff
 801a0cc:	d915      	bls.n	801a0fa <pppos_netif_output+0x110>
    err = pppos_output_append(pppos, err,  nb, (protocol >> 8) & 0xFF, 1, &fcs_out);
 801a0ce:	1cbb      	adds	r3, r7, #2
 801a0d0:	881b      	ldrh	r3, [r3, #0]
 801a0d2:	0a1b      	lsrs	r3, r3, #8
 801a0d4:	b29b      	uxth	r3, r3
 801a0d6:	b2dd      	uxtb	r5, r3
 801a0d8:	2323      	movs	r3, #35	; 0x23
 801a0da:	18fc      	adds	r4, r7, r3
 801a0dc:	697a      	ldr	r2, [r7, #20]
 801a0de:	18fb      	adds	r3, r7, r3
 801a0e0:	2100      	movs	r1, #0
 801a0e2:	5659      	ldrsb	r1, [r3, r1]
 801a0e4:	69b8      	ldr	r0, [r7, #24]
 801a0e6:	2312      	movs	r3, #18
 801a0e8:	18fb      	adds	r3, r7, r3
 801a0ea:	9301      	str	r3, [sp, #4]
 801a0ec:	2301      	movs	r3, #1
 801a0ee:	9300      	str	r3, [sp, #0]
 801a0f0:	002b      	movs	r3, r5
 801a0f2:	f000 fb17 	bl	801a724 <pppos_output_append>
 801a0f6:	0003      	movs	r3, r0
 801a0f8:	7023      	strb	r3, [r4, #0]
  }
  err = pppos_output_append(pppos, err,  nb, protocol & 0xFF, 1, &fcs_out);
 801a0fa:	1cbb      	adds	r3, r7, #2
 801a0fc:	881b      	ldrh	r3, [r3, #0]
 801a0fe:	b2dd      	uxtb	r5, r3
 801a100:	2323      	movs	r3, #35	; 0x23
 801a102:	18fc      	adds	r4, r7, r3
 801a104:	697a      	ldr	r2, [r7, #20]
 801a106:	18fb      	adds	r3, r7, r3
 801a108:	2100      	movs	r1, #0
 801a10a:	5659      	ldrsb	r1, [r3, r1]
 801a10c:	69b8      	ldr	r0, [r7, #24]
 801a10e:	2312      	movs	r3, #18
 801a110:	18fb      	adds	r3, r7, r3
 801a112:	9301      	str	r3, [sp, #4]
 801a114:	2301      	movs	r3, #1
 801a116:	9300      	str	r3, [sp, #0]
 801a118:	002b      	movs	r3, r5
 801a11a:	f000 fb03 	bl	801a724 <pppos_output_append>
 801a11e:	0003      	movs	r3, r0
 801a120:	7023      	strb	r3, [r4, #0]

  /* Load packet. */
  for(p = pb; p; p = p->next) {
 801a122:	687b      	ldr	r3, [r7, #4]
 801a124:	627b      	str	r3, [r7, #36]	; 0x24
 801a126:	e028      	b.n	801a17a <pppos_netif_output+0x190>
    u16_t n = p->len;
 801a128:	2320      	movs	r3, #32
 801a12a:	18fb      	adds	r3, r7, r3
 801a12c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801a12e:	8952      	ldrh	r2, [r2, #10]
 801a130:	801a      	strh	r2, [r3, #0]
    u8_t *s = (u8_t*)p->payload;
 801a132:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a134:	685b      	ldr	r3, [r3, #4]
 801a136:	61fb      	str	r3, [r7, #28]

    while (n-- > 0) {
 801a138:	e014      	b.n	801a164 <pppos_netif_output+0x17a>
      err = pppos_output_append(pppos, err,  nb, *s++, 1, &fcs_out);
 801a13a:	69fb      	ldr	r3, [r7, #28]
 801a13c:	1c5a      	adds	r2, r3, #1
 801a13e:	61fa      	str	r2, [r7, #28]
 801a140:	781d      	ldrb	r5, [r3, #0]
 801a142:	2323      	movs	r3, #35	; 0x23
 801a144:	18fc      	adds	r4, r7, r3
 801a146:	697a      	ldr	r2, [r7, #20]
 801a148:	18fb      	adds	r3, r7, r3
 801a14a:	2100      	movs	r1, #0
 801a14c:	5659      	ldrsb	r1, [r3, r1]
 801a14e:	69b8      	ldr	r0, [r7, #24]
 801a150:	2312      	movs	r3, #18
 801a152:	18fb      	adds	r3, r7, r3
 801a154:	9301      	str	r3, [sp, #4]
 801a156:	2301      	movs	r3, #1
 801a158:	9300      	str	r3, [sp, #0]
 801a15a:	002b      	movs	r3, r5
 801a15c:	f000 fae2 	bl	801a724 <pppos_output_append>
 801a160:	0003      	movs	r3, r0
 801a162:	7023      	strb	r3, [r4, #0]
    while (n-- > 0) {
 801a164:	2220      	movs	r2, #32
 801a166:	18bb      	adds	r3, r7, r2
 801a168:	881b      	ldrh	r3, [r3, #0]
 801a16a:	18ba      	adds	r2, r7, r2
 801a16c:	1e59      	subs	r1, r3, #1
 801a16e:	8011      	strh	r1, [r2, #0]
 801a170:	2b00      	cmp	r3, #0
 801a172:	d1e2      	bne.n	801a13a <pppos_netif_output+0x150>
  for(p = pb; p; p = p->next) {
 801a174:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a176:	681b      	ldr	r3, [r3, #0]
 801a178:	627b      	str	r3, [r7, #36]	; 0x24
 801a17a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a17c:	2b00      	cmp	r3, #0
 801a17e:	d1d3      	bne.n	801a128 <pppos_netif_output+0x13e>
    }
  }

  err = pppos_output_last(pppos, err, nb, &fcs_out);
 801a180:	2623      	movs	r6, #35	; 0x23
 801a182:	19bc      	adds	r4, r7, r6
 801a184:	2312      	movs	r3, #18
 801a186:	18fd      	adds	r5, r7, r3
 801a188:	697a      	ldr	r2, [r7, #20]
 801a18a:	19bb      	adds	r3, r7, r6
 801a18c:	2100      	movs	r1, #0
 801a18e:	5659      	ldrsb	r1, [r3, r1]
 801a190:	69b8      	ldr	r0, [r7, #24]
 801a192:	002b      	movs	r3, r5
 801a194:	f000 fb60 	bl	801a858 <pppos_output_last>
 801a198:	0003      	movs	r3, r0
 801a19a:	7023      	strb	r3, [r4, #0]
  if (err == ERR_OK) {
    PPPDEBUG(LOG_INFO, ("pppos_netif_output[%d]: proto=0x%"X16_F", len = %d\n", ppp->netif->num, protocol, pb->tot_len));
  } else {
    PPPDEBUG(LOG_WARNING, ("pppos_netif_output[%d]: output failed proto=0x%"X16_F", len = %d\n", ppp->netif->num, protocol, pb->tot_len));
  }
  return err;
 801a19c:	19bb      	adds	r3, r7, r6
 801a19e:	781b      	ldrb	r3, [r3, #0]
 801a1a0:	b25b      	sxtb	r3, r3
}
 801a1a2:	0018      	movs	r0, r3
 801a1a4:	46bd      	mov	sp, r7
 801a1a6:	b00b      	add	sp, #44	; 0x2c
 801a1a8:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801a1aa <pppos_connect>:

static void
pppos_connect(ppp_pcb *ppp, void *ctx)
{
 801a1aa:	b580      	push	{r7, lr}
 801a1ac:	b084      	sub	sp, #16
 801a1ae:	af00      	add	r7, sp, #0
 801a1b0:	6078      	str	r0, [r7, #4]
 801a1b2:	6039      	str	r1, [r7, #0]
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801a1b4:	683b      	ldr	r3, [r7, #0]
 801a1b6:	60fb      	str	r3, [r7, #12]
  /* input pbuf left over from last session? */
  pppos_input_free_current_packet(pppos);
#endif /* PPP_INPROC_IRQ_SAFE */

  /* reset PPPoS control block to its initial state */
  memset(&pppos->last_xmit, 0, sizeof(pppos_pcb) - offsetof(pppos_pcb, last_xmit));
 801a1b8:	68fb      	ldr	r3, [r7, #12]
 801a1ba:	3308      	adds	r3, #8
 801a1bc:	2258      	movs	r2, #88	; 0x58
 801a1be:	2100      	movs	r1, #0
 801a1c0:	0018      	movs	r0, r3
 801a1c2:	f002 fb33 	bl	801c82c <memset>

  /*
   * Default the in and out accm so that escape and flag characters
   * are always escaped.
   */
  pppos->in_accm[15] = 0x60; /* no need to protect since RX is not running */
 801a1c6:	68fb      	ldr	r3, [r7, #12]
 801a1c8:	223c      	movs	r2, #60	; 0x3c
 801a1ca:	2160      	movs	r1, #96	; 0x60
 801a1cc:	5499      	strb	r1, [r3, r2]
  pppos->out_accm[15] = 0x60;
 801a1ce:	68fb      	ldr	r3, [r7, #12]
 801a1d0:	2260      	movs	r2, #96	; 0x60
 801a1d2:	76da      	strb	r2, [r3, #27]
  PPPOS_PROTECT(lev);
  pppos->open = 1;
 801a1d4:	68fb      	ldr	r3, [r7, #12]
 801a1d6:	222c      	movs	r2, #44	; 0x2c
 801a1d8:	5c99      	ldrb	r1, [r3, r2]
 801a1da:	2001      	movs	r0, #1
 801a1dc:	4301      	orrs	r1, r0
 801a1de:	5499      	strb	r1, [r3, r2]

  /*
   * Start the connection and handle incoming events (packet or timeout).
   */
  PPPDEBUG(LOG_INFO, ("pppos_connect: unit %d: connecting\n", ppp->netif->num));
  ppp_start(ppp); /* notify upper layers */
 801a1e0:	687b      	ldr	r3, [r7, #4]
 801a1e2:	0018      	movs	r0, r3
 801a1e4:	f7ff fbc4 	bl	8019970 <ppp_start>
}
 801a1e8:	46c0      	nop			; (mov r8, r8)
 801a1ea:	46bd      	mov	sp, r7
 801a1ec:	b004      	add	sp, #16
 801a1ee:	bd80      	pop	{r7, pc}

0801a1f0 <pppos_disconnect>:
}
#endif /* PPP_SERVER */

static void
pppos_disconnect(ppp_pcb *ppp, void *ctx)
{
 801a1f0:	b580      	push	{r7, lr}
 801a1f2:	b084      	sub	sp, #16
 801a1f4:	af00      	add	r7, sp, #0
 801a1f6:	6078      	str	r0, [r7, #4]
 801a1f8:	6039      	str	r1, [r7, #0]
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801a1fa:	683b      	ldr	r3, [r7, #0]
 801a1fc:	60fb      	str	r3, [r7, #12]
  PPPOS_DECL_PROTECT(lev);

  PPPOS_PROTECT(lev);
  pppos->open = 0;
 801a1fe:	68fb      	ldr	r3, [r7, #12]
 801a200:	222c      	movs	r2, #44	; 0x2c
 801a202:	5c99      	ldrb	r1, [r3, r2]
 801a204:	2001      	movs	r0, #1
 801a206:	4381      	bics	r1, r0
 801a208:	5499      	strb	r1, [r3, r2]
   * pppos_input_free_current_packet() here because
   * rx IRQ might still call pppos_input().
   */
#if !PPP_INPROC_IRQ_SAFE
  /* input pbuf left ? */
  pppos_input_free_current_packet(pppos);
 801a20a:	68fb      	ldr	r3, [r7, #12]
 801a20c:	0018      	movs	r0, r3
 801a20e:	f000 fa50 	bl	801a6b2 <pppos_input_free_current_packet>
#endif /* !PPP_INPROC_IRQ_SAFE */

  ppp_link_end(ppp); /* notify upper layers */
 801a212:	687b      	ldr	r3, [r7, #4]
 801a214:	0018      	movs	r0, r3
 801a216:	f7ff fbc5 	bl	80199a4 <ppp_link_end>
}
 801a21a:	46c0      	nop			; (mov r8, r8)
 801a21c:	46bd      	mov	sp, r7
 801a21e:	b004      	add	sp, #16
 801a220:	bd80      	pop	{r7, pc}
	...

0801a224 <pppos_destroy>:

static err_t
pppos_destroy(ppp_pcb *ppp, void *ctx)
{
 801a224:	b580      	push	{r7, lr}
 801a226:	b084      	sub	sp, #16
 801a228:	af00      	add	r7, sp, #0
 801a22a:	6078      	str	r0, [r7, #4]
 801a22c:	6039      	str	r1, [r7, #0]
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801a22e:	683b      	ldr	r3, [r7, #0]
 801a230:	60fb      	str	r3, [r7, #12]
#if PPP_INPROC_IRQ_SAFE
  /* input pbuf left ? */
  pppos_input_free_current_packet(pppos);
#endif /* PPP_INPROC_IRQ_SAFE */

  LWIP_MEMPOOL_FREE(PPPOS_PCB, pppos);
 801a232:	68fa      	ldr	r2, [r7, #12]
 801a234:	4b04      	ldr	r3, [pc, #16]	; (801a248 <pppos_destroy+0x24>)
 801a236:	0011      	movs	r1, r2
 801a238:	0018      	movs	r0, r3
 801a23a:	f7ee fb0f 	bl	800885c <memp_free_pool>
  return ERR_OK;
 801a23e:	2300      	movs	r3, #0
}
 801a240:	0018      	movs	r0, r3
 801a242:	46bd      	mov	sp, r7
 801a244:	b004      	add	sp, #16
 801a246:	bd80      	pop	{r7, pc}
 801a248:	08021cc8 	.word	0x08021cc8

0801a24c <pppos_input>:
 * @param s received data
 * @param l length of received data
 */
void
pppos_input(ppp_pcb *ppp, u8_t *s, int l)
{
 801a24c:	b580      	push	{r7, lr}
 801a24e:	b08a      	sub	sp, #40	; 0x28
 801a250:	af00      	add	r7, sp, #0
 801a252:	60f8      	str	r0, [r7, #12]
 801a254:	60b9      	str	r1, [r7, #8]
 801a256:	607a      	str	r2, [r7, #4]
  pppos_pcb *pppos = (pppos_pcb *)ppp->link_ctx_cb;
 801a258:	68fb      	ldr	r3, [r7, #12]
 801a25a:	691b      	ldr	r3, [r3, #16]
 801a25c:	623b      	str	r3, [r7, #32]
#if !PPP_INPROC_IRQ_SAFE
  LWIP_ASSERT_CORE_LOCKED();
#endif

  PPPDEBUG(LOG_DEBUG, ("pppos_input[%d]: got %d bytes\n", ppp->netif->num, l));
  while (l-- > 0) {
 801a25e:	e1ae      	b.n	801a5be <pppos_input+0x372>
    cur_char = *s++;
 801a260:	68bb      	ldr	r3, [r7, #8]
 801a262:	1c5a      	adds	r2, r3, #1
 801a264:	60ba      	str	r2, [r7, #8]
 801a266:	2027      	movs	r0, #39	; 0x27
 801a268:	183a      	adds	r2, r7, r0
 801a26a:	781b      	ldrb	r3, [r3, #0]
 801a26c:	7013      	strb	r3, [r2, #0]
    /* ppp_input can disconnect the interface, we need to abort to prevent a memory
     * leak if there are remaining bytes because pppos_connect and pppos_listen
     * functions expect input buffer to be free. Furthermore there are no real
     * reason to continue reading bytes if we are disconnected.
     */
    if (!pppos->open) {
 801a26e:	6a3b      	ldr	r3, [r7, #32]
 801a270:	222c      	movs	r2, #44	; 0x2c
 801a272:	5c9b      	ldrb	r3, [r3, r2]
 801a274:	2201      	movs	r2, #1
 801a276:	4013      	ands	r3, r2
 801a278:	b2db      	uxtb	r3, r3
 801a27a:	2b00      	cmp	r3, #0
 801a27c:	d100      	bne.n	801a280 <pppos_input+0x34>
 801a27e:	e1a5      	b.n	801a5cc <pppos_input+0x380>
      PPPOS_UNPROTECT(lev);
      return;
    }
    escaped = ESCAPE_P(pppos->in_accm, cur_char);
 801a280:	183b      	adds	r3, r7, r0
 801a282:	781b      	ldrb	r3, [r3, #0]
 801a284:	08db      	lsrs	r3, r3, #3
 801a286:	b2db      	uxtb	r3, r3
 801a288:	0019      	movs	r1, r3
 801a28a:	6a3b      	ldr	r3, [r7, #32]
 801a28c:	222d      	movs	r2, #45	; 0x2d
 801a28e:	185b      	adds	r3, r3, r1
 801a290:	189b      	adds	r3, r3, r2
 801a292:	781b      	ldrb	r3, [r3, #0]
 801a294:	b25b      	sxtb	r3, r3
 801a296:	183a      	adds	r2, r7, r0
 801a298:	7812      	ldrb	r2, [r2, #0]
 801a29a:	2107      	movs	r1, #7
 801a29c:	400a      	ands	r2, r1
 801a29e:	2101      	movs	r1, #1
 801a2a0:	4091      	lsls	r1, r2
 801a2a2:	000a      	movs	r2, r1
 801a2a4:	b252      	sxtb	r2, r2
 801a2a6:	4013      	ands	r3, r2
 801a2a8:	b25a      	sxtb	r2, r3
 801a2aa:	211f      	movs	r1, #31
 801a2ac:	187b      	adds	r3, r7, r1
 801a2ae:	701a      	strb	r2, [r3, #0]
    PPPOS_UNPROTECT(lev);
    /* Handle special characters. */
    if (escaped) {
 801a2b0:	187b      	adds	r3, r7, r1
 801a2b2:	781b      	ldrb	r3, [r3, #0]
 801a2b4:	2b00      	cmp	r3, #0
 801a2b6:	d100      	bne.n	801a2ba <pppos_input+0x6e>
 801a2b8:	e086      	b.n	801a3c8 <pppos_input+0x17c>
      /* Check for escape sequences. */
      /* XXX Note that this does not handle an escaped 0x5d character which
       * would appear as an escape character.  Since this is an ASCII ']'
       * and there is no reason that I know of to escape it, I won't complicate
       * the code to handle this case. GLL */
      if (cur_char == PPP_ESCAPE) {
 801a2ba:	183b      	adds	r3, r7, r0
 801a2bc:	781b      	ldrb	r3, [r3, #0]
 801a2be:	2b7d      	cmp	r3, #125	; 0x7d
 801a2c0:	d104      	bne.n	801a2cc <pppos_input+0x80>
        pppos->in_escaped = 1;
 801a2c2:	6a3b      	ldr	r3, [r7, #32]
 801a2c4:	225d      	movs	r2, #93	; 0x5d
 801a2c6:	2101      	movs	r1, #1
 801a2c8:	5499      	strb	r1, [r3, r2]
 801a2ca:	e178      	b.n	801a5be <pppos_input+0x372>
      /* Check for the flag character. */
      } else if (cur_char == PPP_FLAG) {
 801a2cc:	2327      	movs	r3, #39	; 0x27
 801a2ce:	18fb      	adds	r3, r7, r3
 801a2d0:	781b      	ldrb	r3, [r3, #0]
 801a2d2:	2b7e      	cmp	r3, #126	; 0x7e
 801a2d4:	d000      	beq.n	801a2d8 <pppos_input+0x8c>
 801a2d6:	e172      	b.n	801a5be <pppos_input+0x372>
        /* If this is just an extra flag character, ignore it. */
        if (pppos->in_state <= PDADDRESS) {
 801a2d8:	6a3b      	ldr	r3, [r7, #32]
 801a2da:	225c      	movs	r2, #92	; 0x5c
 801a2dc:	5c9b      	ldrb	r3, [r3, r2]
 801a2de:	2b02      	cmp	r3, #2
 801a2e0:	d964      	bls.n	801a3ac <pppos_input+0x160>
          /* ignore it */;
        /* If we haven't received the packet header, drop what has come in. */
        } else if (pppos->in_state < PDDATA) {
 801a2e2:	6a3b      	ldr	r3, [r7, #32]
 801a2e4:	225c      	movs	r2, #92	; 0x5c
 801a2e6:	5c9b      	ldrb	r3, [r3, r2]
 801a2e8:	2b05      	cmp	r3, #5
 801a2ea:	d804      	bhi.n	801a2f6 <pppos_input+0xaa>
          PPPDEBUG(LOG_WARNING,
                   ("pppos_input[%d]: Dropping incomplete packet %d\n",
                    ppp->netif->num, pppos->in_state));
          LINK_STATS_INC(link.lenerr);
          pppos_input_drop(pppos);
 801a2ec:	6a3b      	ldr	r3, [r7, #32]
 801a2ee:	0018      	movs	r0, r3
 801a2f0:	f000 fa05 	bl	801a6fe <pppos_input_drop>
 801a2f4:	e05a      	b.n	801a3ac <pppos_input+0x160>
        /* If the fcs is invalid, drop the packet. */
        } else if (pppos->in_fcs != PPP_GOODFCS) {
 801a2f6:	6a3b      	ldr	r3, [r7, #32]
 801a2f8:	225a      	movs	r2, #90	; 0x5a
 801a2fa:	5a9b      	ldrh	r3, [r3, r2]
 801a2fc:	4ab5      	ldr	r2, [pc, #724]	; (801a5d4 <pppos_input+0x388>)
 801a2fe:	4293      	cmp	r3, r2
 801a300:	d004      	beq.n	801a30c <pppos_input+0xc0>
          PPPDEBUG(LOG_INFO,
                   ("pppos_input[%d]: Dropping bad fcs 0x%"X16_F" proto=0x%"X16_F"\n",
                    ppp->netif->num, pppos->in_fcs, pppos->in_protocol));
          /* Note: If you get lots of these, check for UART frame errors or try different baud rate */
          LINK_STATS_INC(link.chkerr);
          pppos_input_drop(pppos);
 801a302:	6a3b      	ldr	r3, [r7, #32]
 801a304:	0018      	movs	r0, r3
 801a306:	f000 f9fa 	bl	801a6fe <pppos_input_drop>
 801a30a:	e04f      	b.n	801a3ac <pppos_input+0x160>
        /* Otherwise it's a good packet so pass it on. */
        } else {
          struct pbuf *inp;
          /* Trim off the checksum. */
          if(pppos->in_tail->len > 2) {
 801a30c:	6a3b      	ldr	r3, [r7, #32]
 801a30e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a310:	895b      	ldrh	r3, [r3, #10]
 801a312:	2b02      	cmp	r3, #2
 801a314:	d91c      	bls.n	801a350 <pppos_input+0x104>
            pppos->in_tail->len -= 2;
 801a316:	6a3b      	ldr	r3, [r7, #32]
 801a318:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a31a:	895a      	ldrh	r2, [r3, #10]
 801a31c:	6a3b      	ldr	r3, [r7, #32]
 801a31e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a320:	3a02      	subs	r2, #2
 801a322:	b292      	uxth	r2, r2
 801a324:	815a      	strh	r2, [r3, #10]

            pppos->in_tail->tot_len = pppos->in_tail->len;
 801a326:	6a3b      	ldr	r3, [r7, #32]
 801a328:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801a32a:	6a3b      	ldr	r3, [r7, #32]
 801a32c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a32e:	8952      	ldrh	r2, [r2, #10]
 801a330:	811a      	strh	r2, [r3, #8]
            if (pppos->in_tail != pppos->in_head) {
 801a332:	6a3b      	ldr	r3, [r7, #32]
 801a334:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801a336:	6a3b      	ldr	r3, [r7, #32]
 801a338:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801a33a:	429a      	cmp	r2, r3
 801a33c:	d027      	beq.n	801a38e <pppos_input+0x142>
              pbuf_cat(pppos->in_head, pppos->in_tail);
 801a33e:	6a3b      	ldr	r3, [r7, #32]
 801a340:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 801a342:	6a3b      	ldr	r3, [r7, #32]
 801a344:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a346:	0019      	movs	r1, r3
 801a348:	0010      	movs	r0, r2
 801a34a:	f7ef fa83 	bl	8009854 <pbuf_cat>
 801a34e:	e01e      	b.n	801a38e <pppos_input+0x142>
            }
          } else {
            pppos->in_tail->tot_len = pppos->in_tail->len;
 801a350:	6a3b      	ldr	r3, [r7, #32]
 801a352:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801a354:	6a3b      	ldr	r3, [r7, #32]
 801a356:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a358:	8952      	ldrh	r2, [r2, #10]
 801a35a:	811a      	strh	r2, [r3, #8]
            if (pppos->in_tail != pppos->in_head) {
 801a35c:	6a3b      	ldr	r3, [r7, #32]
 801a35e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801a360:	6a3b      	ldr	r3, [r7, #32]
 801a362:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801a364:	429a      	cmp	r2, r3
 801a366:	d007      	beq.n	801a378 <pppos_input+0x12c>
              pbuf_cat(pppos->in_head, pppos->in_tail);
 801a368:	6a3b      	ldr	r3, [r7, #32]
 801a36a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 801a36c:	6a3b      	ldr	r3, [r7, #32]
 801a36e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a370:	0019      	movs	r1, r3
 801a372:	0010      	movs	r0, r2
 801a374:	f7ef fa6e 	bl	8009854 <pbuf_cat>
            }

            pbuf_realloc(pppos->in_head, pppos->in_head->tot_len - 2);
 801a378:	6a3b      	ldr	r3, [r7, #32]
 801a37a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 801a37c:	6a3b      	ldr	r3, [r7, #32]
 801a37e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801a380:	891b      	ldrh	r3, [r3, #8]
 801a382:	3b02      	subs	r3, #2
 801a384:	b29b      	uxth	r3, r3
 801a386:	0019      	movs	r1, r3
 801a388:	0010      	movs	r0, r2
 801a38a:	f7ee ff89 	bl	80092a0 <pbuf_realloc>
          }

          /* Dispatch the packet thereby consuming it. */
          inp = pppos->in_head;
 801a38e:	6a3b      	ldr	r3, [r7, #32]
 801a390:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801a392:	613b      	str	r3, [r7, #16]
          /* Packet consumed, release our references. */
          pppos->in_head = NULL;
 801a394:	6a3b      	ldr	r3, [r7, #32]
 801a396:	2200      	movs	r2, #0
 801a398:	651a      	str	r2, [r3, #80]	; 0x50
          pppos->in_tail = NULL;
 801a39a:	6a3b      	ldr	r3, [r7, #32]
 801a39c:	2200      	movs	r2, #0
 801a39e:	655a      	str	r2, [r3, #84]	; 0x54
            pbuf_free(inp);
            LINK_STATS_INC(link.drop);
            MIB2_STATS_NETIF_INC(ppp->netif, ifindiscards);
          }
#else /* PPP_INPROC_IRQ_SAFE */
          ppp_input(ppp, inp);
 801a3a0:	693a      	ldr	r2, [r7, #16]
 801a3a2:	68fb      	ldr	r3, [r7, #12]
 801a3a4:	0011      	movs	r1, r2
 801a3a6:	0018      	movs	r0, r3
 801a3a8:	f7ff fb1e 	bl	80199e8 <ppp_input>
#endif /* PPP_INPROC_IRQ_SAFE */
        }

        /* Prepare for a new packet. */
        pppos->in_fcs = PPP_INITFCS;
 801a3ac:	6a3b      	ldr	r3, [r7, #32]
 801a3ae:	225a      	movs	r2, #90	; 0x5a
 801a3b0:	2101      	movs	r1, #1
 801a3b2:	4249      	negs	r1, r1
 801a3b4:	5299      	strh	r1, [r3, r2]
        pppos->in_state = PDADDRESS;
 801a3b6:	6a3b      	ldr	r3, [r7, #32]
 801a3b8:	225c      	movs	r2, #92	; 0x5c
 801a3ba:	2102      	movs	r1, #2
 801a3bc:	5499      	strb	r1, [r3, r2]
        pppos->in_escaped = 0;
 801a3be:	6a3b      	ldr	r3, [r7, #32]
 801a3c0:	225d      	movs	r2, #93	; 0x5d
 801a3c2:	2100      	movs	r1, #0
 801a3c4:	5499      	strb	r1, [r3, r2]
 801a3c6:	e0fa      	b.n	801a5be <pppos_input+0x372>
                 ("pppos_input[%d]: Dropping ACCM char <%d>\n", ppp->netif->num, cur_char));
      }
    /* Process other characters. */
    } else {
      /* Unencode escaped characters. */
      if (pppos->in_escaped) {
 801a3c8:	6a3b      	ldr	r3, [r7, #32]
 801a3ca:	225d      	movs	r2, #93	; 0x5d
 801a3cc:	5c9b      	ldrb	r3, [r3, r2]
 801a3ce:	2b00      	cmp	r3, #0
 801a3d0:	d00a      	beq.n	801a3e8 <pppos_input+0x19c>
        pppos->in_escaped = 0;
 801a3d2:	6a3b      	ldr	r3, [r7, #32]
 801a3d4:	225d      	movs	r2, #93	; 0x5d
 801a3d6:	2100      	movs	r1, #0
 801a3d8:	5499      	strb	r1, [r3, r2]
        cur_char ^= PPP_TRANS;
 801a3da:	2227      	movs	r2, #39	; 0x27
 801a3dc:	18bb      	adds	r3, r7, r2
 801a3de:	18ba      	adds	r2, r7, r2
 801a3e0:	7812      	ldrb	r2, [r2, #0]
 801a3e2:	2120      	movs	r1, #32
 801a3e4:	404a      	eors	r2, r1
 801a3e6:	701a      	strb	r2, [r3, #0]
      }

      /* Process character relative to current state. */
      switch(pppos->in_state) {
 801a3e8:	6a3b      	ldr	r3, [r7, #32]
 801a3ea:	225c      	movs	r2, #92	; 0x5c
 801a3ec:	5c9b      	ldrb	r3, [r3, r2]
 801a3ee:	2b06      	cmp	r3, #6
 801a3f0:	d900      	bls.n	801a3f4 <pppos_input+0x1a8>
 801a3f2:	e0ca      	b.n	801a58a <pppos_input+0x33e>
 801a3f4:	009a      	lsls	r2, r3, #2
 801a3f6:	4b78      	ldr	r3, [pc, #480]	; (801a5d8 <pppos_input+0x38c>)
 801a3f8:	18d3      	adds	r3, r2, r3
 801a3fa:	681b      	ldr	r3, [r3, #0]
 801a3fc:	469f      	mov	pc, r3
        case PDIDLE:                    /* Idle state - waiting. */
          /* Drop the character if it's not 0xff
           * we would have processed a flag character above. */
          if (cur_char != PPP_ALLSTATIONS) {
 801a3fe:	2327      	movs	r3, #39	; 0x27
 801a400:	18fb      	adds	r3, r7, r3
 801a402:	781b      	ldrb	r3, [r3, #0]
 801a404:	2bff      	cmp	r3, #255	; 0xff
 801a406:	d000      	beq.n	801a40a <pppos_input+0x1be>
 801a408:	e0c1      	b.n	801a58e <pppos_input+0x342>
          /* no break */
          /* Fall through */

        case PDSTART:                   /* Process start flag. */
          /* Prepare for a new packet. */
          pppos->in_fcs = PPP_INITFCS;
 801a40a:	6a3b      	ldr	r3, [r7, #32]
 801a40c:	225a      	movs	r2, #90	; 0x5a
 801a40e:	2101      	movs	r1, #1
 801a410:	4249      	negs	r1, r1
 801a412:	5299      	strh	r1, [r3, r2]
          /* no break */
          /* Fall through */

        case PDADDRESS:                 /* Process address field. */
          if (cur_char == PPP_ALLSTATIONS) {
 801a414:	2327      	movs	r3, #39	; 0x27
 801a416:	18fb      	adds	r3, r7, r3
 801a418:	781b      	ldrb	r3, [r3, #0]
 801a41a:	2bff      	cmp	r3, #255	; 0xff
 801a41c:	d104      	bne.n	801a428 <pppos_input+0x1dc>
            pppos->in_state = PDCONTROL;
 801a41e:	6a3b      	ldr	r3, [r7, #32]
 801a420:	225c      	movs	r2, #92	; 0x5c
 801a422:	2103      	movs	r1, #3
 801a424:	5499      	strb	r1, [r3, r2]
            break;
 801a426:	e0b3      	b.n	801a590 <pppos_input+0x344>
          /* Else assume compressed address and control fields so
           * fall through to get the protocol... */
          /* Fall through */
        case PDCONTROL:                 /* Process control field. */
          /* If we don't get a valid control code, restart. */
          if (cur_char == PPP_UI) {
 801a428:	2327      	movs	r3, #39	; 0x27
 801a42a:	18fb      	adds	r3, r7, r3
 801a42c:	781b      	ldrb	r3, [r3, #0]
 801a42e:	2b03      	cmp	r3, #3
 801a430:	d104      	bne.n	801a43c <pppos_input+0x1f0>
            pppos->in_state = PDPROTOCOL1;
 801a432:	6a3b      	ldr	r3, [r7, #32]
 801a434:	225c      	movs	r2, #92	; 0x5c
 801a436:	2104      	movs	r1, #4
 801a438:	5499      	strb	r1, [r3, r2]
            break;
 801a43a:	e0a9      	b.n	801a590 <pppos_input+0x344>
          /* Fall through */

      case PDPROTOCOL1:               /* Process protocol field 1. */
          /* If the lower bit is set, this is the end of the protocol
           * field. */
          if (cur_char & 1) {
 801a43c:	2127      	movs	r1, #39	; 0x27
 801a43e:	187b      	adds	r3, r7, r1
 801a440:	781b      	ldrb	r3, [r3, #0]
 801a442:	2201      	movs	r2, #1
 801a444:	4013      	ands	r3, r2
 801a446:	d00a      	beq.n	801a45e <pppos_input+0x212>
            pppos->in_protocol = cur_char;
 801a448:	187b      	adds	r3, r7, r1
 801a44a:	781b      	ldrb	r3, [r3, #0]
 801a44c:	b299      	uxth	r1, r3
 801a44e:	6a3b      	ldr	r3, [r7, #32]
 801a450:	2258      	movs	r2, #88	; 0x58
 801a452:	5299      	strh	r1, [r3, r2]
            pppos->in_state = PDDATA;
 801a454:	6a3b      	ldr	r3, [r7, #32]
 801a456:	225c      	movs	r2, #92	; 0x5c
 801a458:	2106      	movs	r1, #6
 801a45a:	5499      	strb	r1, [r3, r2]
          } else {
            pppos->in_protocol = (u16_t)cur_char << 8;
            pppos->in_state = PDPROTOCOL2;
          }
          break;
 801a45c:	e098      	b.n	801a590 <pppos_input+0x344>
            pppos->in_protocol = (u16_t)cur_char << 8;
 801a45e:	2327      	movs	r3, #39	; 0x27
 801a460:	18fb      	adds	r3, r7, r3
 801a462:	781b      	ldrb	r3, [r3, #0]
 801a464:	b29b      	uxth	r3, r3
 801a466:	021b      	lsls	r3, r3, #8
 801a468:	b299      	uxth	r1, r3
 801a46a:	6a3b      	ldr	r3, [r7, #32]
 801a46c:	2258      	movs	r2, #88	; 0x58
 801a46e:	5299      	strh	r1, [r3, r2]
            pppos->in_state = PDPROTOCOL2;
 801a470:	6a3b      	ldr	r3, [r7, #32]
 801a472:	225c      	movs	r2, #92	; 0x5c
 801a474:	2105      	movs	r1, #5
 801a476:	5499      	strb	r1, [r3, r2]
          break;
 801a478:	e08a      	b.n	801a590 <pppos_input+0x344>
        case PDPROTOCOL2:               /* Process protocol field 2. */
          pppos->in_protocol |= cur_char;
 801a47a:	6a3b      	ldr	r3, [r7, #32]
 801a47c:	2258      	movs	r2, #88	; 0x58
 801a47e:	5a9a      	ldrh	r2, [r3, r2]
 801a480:	2327      	movs	r3, #39	; 0x27
 801a482:	18fb      	adds	r3, r7, r3
 801a484:	781b      	ldrb	r3, [r3, #0]
 801a486:	b29b      	uxth	r3, r3
 801a488:	4313      	orrs	r3, r2
 801a48a:	b299      	uxth	r1, r3
 801a48c:	6a3b      	ldr	r3, [r7, #32]
 801a48e:	2258      	movs	r2, #88	; 0x58
 801a490:	5299      	strh	r1, [r3, r2]
          pppos->in_state = PDDATA;
 801a492:	6a3b      	ldr	r3, [r7, #32]
 801a494:	225c      	movs	r2, #92	; 0x5c
 801a496:	2106      	movs	r1, #6
 801a498:	5499      	strb	r1, [r3, r2]
          break;
 801a49a:	e079      	b.n	801a590 <pppos_input+0x344>
        case PDDATA:                    /* Process data byte. */
          /* Make space to receive processed data. */
          if (pppos->in_tail == NULL || pppos->in_tail->len == PBUF_POOL_BUFSIZE) {
 801a49c:	6a3b      	ldr	r3, [r7, #32]
 801a49e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a4a0:	2b00      	cmp	r3, #0
 801a4a2:	d006      	beq.n	801a4b2 <pppos_input+0x266>
 801a4a4:	6a3b      	ldr	r3, [r7, #32]
 801a4a6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a4a8:	895a      	ldrh	r2, [r3, #10]
 801a4aa:	2394      	movs	r3, #148	; 0x94
 801a4ac:	009b      	lsls	r3, r3, #2
 801a4ae:	429a      	cmp	r2, r3
 801a4b0:	d15b      	bne.n	801a56a <pppos_input+0x31e>
            u16_t pbuf_alloc_len;
            if (pppos->in_tail != NULL) {
 801a4b2:	6a3b      	ldr	r3, [r7, #32]
 801a4b4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a4b6:	2b00      	cmp	r3, #0
 801a4b8:	d016      	beq.n	801a4e8 <pppos_input+0x29c>
              pppos->in_tail->tot_len = pppos->in_tail->len;
 801a4ba:	6a3b      	ldr	r3, [r7, #32]
 801a4bc:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801a4be:	6a3b      	ldr	r3, [r7, #32]
 801a4c0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a4c2:	8952      	ldrh	r2, [r2, #10]
 801a4c4:	811a      	strh	r2, [r3, #8]
              if (pppos->in_tail != pppos->in_head) {
 801a4c6:	6a3b      	ldr	r3, [r7, #32]
 801a4c8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801a4ca:	6a3b      	ldr	r3, [r7, #32]
 801a4cc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801a4ce:	429a      	cmp	r2, r3
 801a4d0:	d00a      	beq.n	801a4e8 <pppos_input+0x29c>
                pbuf_cat(pppos->in_head, pppos->in_tail);
 801a4d2:	6a3b      	ldr	r3, [r7, #32]
 801a4d4:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 801a4d6:	6a3b      	ldr	r3, [r7, #32]
 801a4d8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a4da:	0019      	movs	r1, r3
 801a4dc:	0010      	movs	r0, r2
 801a4de:	f7ef f9b9 	bl	8009854 <pbuf_cat>
                /* give up the in_tail reference now */
                pppos->in_tail = NULL;
 801a4e2:	6a3b      	ldr	r3, [r7, #32]
 801a4e4:	2200      	movs	r2, #0
 801a4e6:	655a      	str	r2, [r3, #84]	; 0x54
              }
            }
            /* If we haven't started a packet, we need a packet header. */
            pbuf_alloc_len = 0;
 801a4e8:	211c      	movs	r1, #28
 801a4ea:	187b      	adds	r3, r7, r1
 801a4ec:	2200      	movs	r2, #0
 801a4ee:	801a      	strh	r2, [r3, #0]
             */
            if (pppos->in_head == NULL) {
              pbuf_alloc_len = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN;
            }
#endif /* IP_FORWARD || LWIP_IPV6_FORWARD */
            next_pbuf = pbuf_alloc(PBUF_RAW, pbuf_alloc_len, PBUF_POOL);
 801a4f0:	23c1      	movs	r3, #193	; 0xc1
 801a4f2:	005a      	lsls	r2, r3, #1
 801a4f4:	187b      	adds	r3, r7, r1
 801a4f6:	881b      	ldrh	r3, [r3, #0]
 801a4f8:	0019      	movs	r1, r3
 801a4fa:	2000      	movs	r0, #0
 801a4fc:	f7ee fd52 	bl	8008fa4 <pbuf_alloc>
 801a500:	0003      	movs	r3, r0
 801a502:	61bb      	str	r3, [r7, #24]
            if (next_pbuf == NULL) {
 801a504:	69bb      	ldr	r3, [r7, #24]
 801a506:	2b00      	cmp	r3, #0
 801a508:	d108      	bne.n	801a51c <pppos_input+0x2d0>
              /* No free buffers.  Drop the input packet and let the
               * higher layers deal with it.  Continue processing
               * the received pbuf chain in case a new packet starts. */
              PPPDEBUG(LOG_ERR, ("pppos_input[%d]: NO FREE PBUFS!\n", ppp->netif->num));
              LINK_STATS_INC(link.memerr);
              pppos_input_drop(pppos);
 801a50a:	6a3b      	ldr	r3, [r7, #32]
 801a50c:	0018      	movs	r0, r3
 801a50e:	f000 f8f6 	bl	801a6fe <pppos_input_drop>
              pppos->in_state = PDSTART;  /* Wait for flag sequence. */
 801a512:	6a3b      	ldr	r3, [r7, #32]
 801a514:	225c      	movs	r2, #92	; 0x5c
 801a516:	2101      	movs	r1, #1
 801a518:	5499      	strb	r1, [r3, r2]
              break;
 801a51a:	e039      	b.n	801a590 <pppos_input+0x344>
            }
            if (pppos->in_head == NULL) {
 801a51c:	6a3b      	ldr	r3, [r7, #32]
 801a51e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801a520:	2b00      	cmp	r3, #0
 801a522:	d11f      	bne.n	801a564 <pppos_input+0x318>
              u8_t *payload = ((u8_t*)next_pbuf->payload) + pbuf_alloc_len;
 801a524:	69bb      	ldr	r3, [r7, #24]
 801a526:	685a      	ldr	r2, [r3, #4]
 801a528:	231c      	movs	r3, #28
 801a52a:	18fb      	adds	r3, r7, r3
 801a52c:	881b      	ldrh	r3, [r3, #0]
 801a52e:	18d3      	adds	r3, r2, r3
 801a530:	617b      	str	r3, [r7, #20]
#if PPP_INPROC_IRQ_SAFE
              ((struct pppos_input_header*)payload)->ppp = ppp;
              payload += sizeof(struct pppos_input_header);
              next_pbuf->len += sizeof(struct pppos_input_header);
#endif /* PPP_INPROC_IRQ_SAFE */
              next_pbuf->len += sizeof(pppos->in_protocol);
 801a532:	69bb      	ldr	r3, [r7, #24]
 801a534:	895b      	ldrh	r3, [r3, #10]
 801a536:	3302      	adds	r3, #2
 801a538:	b29a      	uxth	r2, r3
 801a53a:	69bb      	ldr	r3, [r7, #24]
 801a53c:	815a      	strh	r2, [r3, #10]
              *(payload++) = pppos->in_protocol >> 8;
 801a53e:	6a3b      	ldr	r3, [r7, #32]
 801a540:	2258      	movs	r2, #88	; 0x58
 801a542:	5a9b      	ldrh	r3, [r3, r2]
 801a544:	0a1b      	lsrs	r3, r3, #8
 801a546:	b299      	uxth	r1, r3
 801a548:	697b      	ldr	r3, [r7, #20]
 801a54a:	1c5a      	adds	r2, r3, #1
 801a54c:	617a      	str	r2, [r7, #20]
 801a54e:	b2ca      	uxtb	r2, r1
 801a550:	701a      	strb	r2, [r3, #0]
              *(payload) = pppos->in_protocol & 0xFF;
 801a552:	6a3b      	ldr	r3, [r7, #32]
 801a554:	2258      	movs	r2, #88	; 0x58
 801a556:	5a9b      	ldrh	r3, [r3, r2]
 801a558:	b2da      	uxtb	r2, r3
 801a55a:	697b      	ldr	r3, [r7, #20]
 801a55c:	701a      	strb	r2, [r3, #0]
              pppos->in_head = next_pbuf;
 801a55e:	6a3b      	ldr	r3, [r7, #32]
 801a560:	69ba      	ldr	r2, [r7, #24]
 801a562:	651a      	str	r2, [r3, #80]	; 0x50
            }
            pppos->in_tail = next_pbuf;
 801a564:	6a3b      	ldr	r3, [r7, #32]
 801a566:	69ba      	ldr	r2, [r7, #24]
 801a568:	655a      	str	r2, [r3, #84]	; 0x54
          }
          /* Load character into buffer. */
          ((u8_t*)pppos->in_tail->payload)[pppos->in_tail->len++] = cur_char;
 801a56a:	6a3b      	ldr	r3, [r7, #32]
 801a56c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a56e:	6859      	ldr	r1, [r3, #4]
 801a570:	6a3b      	ldr	r3, [r7, #32]
 801a572:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a574:	895a      	ldrh	r2, [r3, #10]
 801a576:	1c50      	adds	r0, r2, #1
 801a578:	b280      	uxth	r0, r0
 801a57a:	8158      	strh	r0, [r3, #10]
 801a57c:	0013      	movs	r3, r2
 801a57e:	18cb      	adds	r3, r1, r3
 801a580:	2227      	movs	r2, #39	; 0x27
 801a582:	18ba      	adds	r2, r7, r2
 801a584:	7812      	ldrb	r2, [r2, #0]
 801a586:	701a      	strb	r2, [r3, #0]
          break;
 801a588:	e002      	b.n	801a590 <pppos_input+0x344>
        default:
          break;
 801a58a:	46c0      	nop			; (mov r8, r8)
 801a58c:	e000      	b.n	801a590 <pppos_input+0x344>
            break;
 801a58e:	46c0      	nop			; (mov r8, r8)
      }

      /* update the frame check sequence number. */
      pppos->in_fcs = PPP_FCS(pppos->in_fcs, cur_char);
 801a590:	6a3b      	ldr	r3, [r7, #32]
 801a592:	225a      	movs	r2, #90	; 0x5a
 801a594:	5a9b      	ldrh	r3, [r3, r2]
 801a596:	0a1b      	lsrs	r3, r3, #8
 801a598:	b29a      	uxth	r2, r3
 801a59a:	6a3b      	ldr	r3, [r7, #32]
 801a59c:	215a      	movs	r1, #90	; 0x5a
 801a59e:	5a5b      	ldrh	r3, [r3, r1]
 801a5a0:	0019      	movs	r1, r3
 801a5a2:	2327      	movs	r3, #39	; 0x27
 801a5a4:	18fb      	adds	r3, r7, r3
 801a5a6:	781b      	ldrb	r3, [r3, #0]
 801a5a8:	404b      	eors	r3, r1
 801a5aa:	21ff      	movs	r1, #255	; 0xff
 801a5ac:	4019      	ands	r1, r3
 801a5ae:	4b0b      	ldr	r3, [pc, #44]	; (801a5dc <pppos_input+0x390>)
 801a5b0:	0049      	lsls	r1, r1, #1
 801a5b2:	5acb      	ldrh	r3, [r1, r3]
 801a5b4:	4053      	eors	r3, r2
 801a5b6:	b299      	uxth	r1, r3
 801a5b8:	6a3b      	ldr	r3, [r7, #32]
 801a5ba:	225a      	movs	r2, #90	; 0x5a
 801a5bc:	5299      	strh	r1, [r3, r2]
  while (l-- > 0) {
 801a5be:	687b      	ldr	r3, [r7, #4]
 801a5c0:	1e5a      	subs	r2, r3, #1
 801a5c2:	607a      	str	r2, [r7, #4]
 801a5c4:	2b00      	cmp	r3, #0
 801a5c6:	dd00      	ble.n	801a5ca <pppos_input+0x37e>
 801a5c8:	e64a      	b.n	801a260 <pppos_input+0x14>
 801a5ca:	e000      	b.n	801a5ce <pppos_input+0x382>
      return;
 801a5cc:	46c0      	nop			; (mov r8, r8)
    }
  } /* while (l-- > 0), all bytes processed */
}
 801a5ce:	46bd      	mov	sp, r7
 801a5d0:	b00a      	add	sp, #40	; 0x28
 801a5d2:	bd80      	pop	{r7, pc}
 801a5d4:	0000f0b8 	.word	0x0000f0b8
 801a5d8:	08021ef4 	.word	0x08021ef4
 801a5dc:	08021cf4 	.word	0x08021cf4

0801a5e0 <pppos_send_config>:
}
#endif /* PPP_INPROC_IRQ_SAFE */

static void
pppos_send_config(ppp_pcb *ppp, void *ctx, u32_t accm, int pcomp, int accomp)
{
 801a5e0:	b590      	push	{r4, r7, lr}
 801a5e2:	b087      	sub	sp, #28
 801a5e4:	af00      	add	r7, sp, #0
 801a5e6:	60f8      	str	r0, [r7, #12]
 801a5e8:	60b9      	str	r1, [r7, #8]
 801a5ea:	607a      	str	r2, [r7, #4]
 801a5ec:	603b      	str	r3, [r7, #0]
  int i;
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801a5ee:	68bb      	ldr	r3, [r7, #8]
 801a5f0:	613b      	str	r3, [r7, #16]
  LWIP_UNUSED_ARG(ppp);

  pppos->pcomp = pcomp;
 801a5f2:	683b      	ldr	r3, [r7, #0]
 801a5f4:	1c1a      	adds	r2, r3, #0
 801a5f6:	2301      	movs	r3, #1
 801a5f8:	4013      	ands	r3, r2
 801a5fa:	b2d9      	uxtb	r1, r3
 801a5fc:	693b      	ldr	r3, [r7, #16]
 801a5fe:	222c      	movs	r2, #44	; 0x2c
 801a600:	2001      	movs	r0, #1
 801a602:	4001      	ands	r1, r0
 801a604:	184c      	adds	r4, r1, r1
 801a606:	5c99      	ldrb	r1, [r3, r2]
 801a608:	2002      	movs	r0, #2
 801a60a:	4381      	bics	r1, r0
 801a60c:	1c08      	adds	r0, r1, #0
 801a60e:	1c21      	adds	r1, r4, #0
 801a610:	4301      	orrs	r1, r0
 801a612:	5499      	strb	r1, [r3, r2]
  pppos->accomp = accomp;
 801a614:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801a616:	1c1a      	adds	r2, r3, #0
 801a618:	2301      	movs	r3, #1
 801a61a:	4013      	ands	r3, r2
 801a61c:	b2d9      	uxtb	r1, r3
 801a61e:	693b      	ldr	r3, [r7, #16]
 801a620:	222c      	movs	r2, #44	; 0x2c
 801a622:	2001      	movs	r0, #1
 801a624:	4001      	ands	r1, r0
 801a626:	008c      	lsls	r4, r1, #2
 801a628:	5c99      	ldrb	r1, [r3, r2]
 801a62a:	2004      	movs	r0, #4
 801a62c:	4381      	bics	r1, r0
 801a62e:	1c08      	adds	r0, r1, #0
 801a630:	1c21      	adds	r1, r4, #0
 801a632:	4301      	orrs	r1, r0
 801a634:	5499      	strb	r1, [r3, r2]

  /* Load the ACCM bits for the 32 control codes. */
  for (i = 0; i < 32/8; i++) {
 801a636:	2300      	movs	r3, #0
 801a638:	617b      	str	r3, [r7, #20]
 801a63a:	e00e      	b.n	801a65a <pppos_send_config+0x7a>
    pppos->out_accm[i] = (u8_t)((accm >> (8 * i)) & 0xFF);
 801a63c:	697b      	ldr	r3, [r7, #20]
 801a63e:	00db      	lsls	r3, r3, #3
 801a640:	687a      	ldr	r2, [r7, #4]
 801a642:	40da      	lsrs	r2, r3
 801a644:	0013      	movs	r3, r2
 801a646:	b2d9      	uxtb	r1, r3
 801a648:	693a      	ldr	r2, [r7, #16]
 801a64a:	697b      	ldr	r3, [r7, #20]
 801a64c:	18d3      	adds	r3, r2, r3
 801a64e:	330c      	adds	r3, #12
 801a650:	1c0a      	adds	r2, r1, #0
 801a652:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < 32/8; i++) {
 801a654:	697b      	ldr	r3, [r7, #20]
 801a656:	3301      	adds	r3, #1
 801a658:	617b      	str	r3, [r7, #20]
 801a65a:	697b      	ldr	r3, [r7, #20]
 801a65c:	2b03      	cmp	r3, #3
 801a65e:	dded      	ble.n	801a63c <pppos_send_config+0x5c>
  }

  PPPDEBUG(LOG_INFO, ("pppos_send_config[%d]: out_accm=%X %X %X %X\n",
            pppos->ppp->netif->num,
            pppos->out_accm[0], pppos->out_accm[1], pppos->out_accm[2], pppos->out_accm[3]));
}
 801a660:	46c0      	nop			; (mov r8, r8)
 801a662:	46c0      	nop			; (mov r8, r8)
 801a664:	46bd      	mov	sp, r7
 801a666:	b007      	add	sp, #28
 801a668:	bd90      	pop	{r4, r7, pc}

0801a66a <pppos_recv_config>:

static void
pppos_recv_config(ppp_pcb *ppp, void *ctx, u32_t accm, int pcomp, int accomp)
{
 801a66a:	b580      	push	{r7, lr}
 801a66c:	b086      	sub	sp, #24
 801a66e:	af00      	add	r7, sp, #0
 801a670:	60f8      	str	r0, [r7, #12]
 801a672:	60b9      	str	r1, [r7, #8]
 801a674:	607a      	str	r2, [r7, #4]
 801a676:	603b      	str	r3, [r7, #0]
  int i;
  pppos_pcb *pppos = (pppos_pcb *)ctx;
 801a678:	68bb      	ldr	r3, [r7, #8]
 801a67a:	613b      	str	r3, [r7, #16]
  LWIP_UNUSED_ARG(pcomp);
  LWIP_UNUSED_ARG(accomp);

  /* Load the ACCM bits for the 32 control codes. */
  PPPOS_PROTECT(lev);
  for (i = 0; i < 32 / 8; i++) {
 801a67c:	2300      	movs	r3, #0
 801a67e:	617b      	str	r3, [r7, #20]
 801a680:	e00f      	b.n	801a6a2 <pppos_recv_config+0x38>
    pppos->in_accm[i] = (u8_t)(accm >> (i * 8));
 801a682:	697b      	ldr	r3, [r7, #20]
 801a684:	00db      	lsls	r3, r3, #3
 801a686:	687a      	ldr	r2, [r7, #4]
 801a688:	40da      	lsrs	r2, r3
 801a68a:	0013      	movs	r3, r2
 801a68c:	b2d8      	uxtb	r0, r3
 801a68e:	693a      	ldr	r2, [r7, #16]
 801a690:	212d      	movs	r1, #45	; 0x2d
 801a692:	697b      	ldr	r3, [r7, #20]
 801a694:	18d3      	adds	r3, r2, r3
 801a696:	185b      	adds	r3, r3, r1
 801a698:	1c02      	adds	r2, r0, #0
 801a69a:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < 32 / 8; i++) {
 801a69c:	697b      	ldr	r3, [r7, #20]
 801a69e:	3301      	adds	r3, #1
 801a6a0:	617b      	str	r3, [r7, #20]
 801a6a2:	697b      	ldr	r3, [r7, #20]
 801a6a4:	2b03      	cmp	r3, #3
 801a6a6:	ddec      	ble.n	801a682 <pppos_recv_config+0x18>
  PPPOS_UNPROTECT(lev);

  PPPDEBUG(LOG_INFO, ("pppos_recv_config[%d]: in_accm=%X %X %X %X\n",
            pppos->ppp->netif->num,
            pppos->in_accm[0], pppos->in_accm[1], pppos->in_accm[2], pppos->in_accm[3]));
}
 801a6a8:	46c0      	nop			; (mov r8, r8)
 801a6aa:	46c0      	nop			; (mov r8, r8)
 801a6ac:	46bd      	mov	sp, r7
 801a6ae:	b006      	add	sp, #24
 801a6b0:	bd80      	pop	{r7, pc}

0801a6b2 <pppos_input_free_current_packet>:
/*
 * Drop the input packet.
 */
static void
pppos_input_free_current_packet(pppos_pcb *pppos)
{
 801a6b2:	b580      	push	{r7, lr}
 801a6b4:	b082      	sub	sp, #8
 801a6b6:	af00      	add	r7, sp, #0
 801a6b8:	6078      	str	r0, [r7, #4]
  if (pppos->in_head != NULL) {
 801a6ba:	687b      	ldr	r3, [r7, #4]
 801a6bc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801a6be:	2b00      	cmp	r3, #0
 801a6c0:	d016      	beq.n	801a6f0 <pppos_input_free_current_packet+0x3e>
    if (pppos->in_tail && (pppos->in_tail != pppos->in_head)) {
 801a6c2:	687b      	ldr	r3, [r7, #4]
 801a6c4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a6c6:	2b00      	cmp	r3, #0
 801a6c8:	d00a      	beq.n	801a6e0 <pppos_input_free_current_packet+0x2e>
 801a6ca:	687b      	ldr	r3, [r7, #4]
 801a6cc:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 801a6ce:	687b      	ldr	r3, [r7, #4]
 801a6d0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801a6d2:	429a      	cmp	r2, r3
 801a6d4:	d004      	beq.n	801a6e0 <pppos_input_free_current_packet+0x2e>
      pbuf_free(pppos->in_tail);
 801a6d6:	687b      	ldr	r3, [r7, #4]
 801a6d8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801a6da:	0018      	movs	r0, r3
 801a6dc:	f7ee ffda 	bl	8009694 <pbuf_free>
    }
    pbuf_free(pppos->in_head);
 801a6e0:	687b      	ldr	r3, [r7, #4]
 801a6e2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 801a6e4:	0018      	movs	r0, r3
 801a6e6:	f7ee ffd5 	bl	8009694 <pbuf_free>
    pppos->in_head = NULL;
 801a6ea:	687b      	ldr	r3, [r7, #4]
 801a6ec:	2200      	movs	r2, #0
 801a6ee:	651a      	str	r2, [r3, #80]	; 0x50
  }
  pppos->in_tail = NULL;
 801a6f0:	687b      	ldr	r3, [r7, #4]
 801a6f2:	2200      	movs	r2, #0
 801a6f4:	655a      	str	r2, [r3, #84]	; 0x54
}
 801a6f6:	46c0      	nop			; (mov r8, r8)
 801a6f8:	46bd      	mov	sp, r7
 801a6fa:	b002      	add	sp, #8
 801a6fc:	bd80      	pop	{r7, pc}

0801a6fe <pppos_input_drop>:
/*
 * Drop the input packet and increase error counters.
 */
static void
pppos_input_drop(pppos_pcb *pppos)
{
 801a6fe:	b580      	push	{r7, lr}
 801a700:	b082      	sub	sp, #8
 801a702:	af00      	add	r7, sp, #0
 801a704:	6078      	str	r0, [r7, #4]
#if 0
    PPPDEBUG(LOG_INFO, ("pppos_input_drop: %d:%.*H\n", pppos->in_head->len, min(60, pppos->in_head->len * 2), pppos->in_head->payload));
#endif
    PPPDEBUG(LOG_INFO, ("pppos_input_drop: pbuf len=%d, addr %p\n", pppos->in_head->len, (void*)pppos->in_head));
  }
  pppos_input_free_current_packet(pppos);
 801a706:	687b      	ldr	r3, [r7, #4]
 801a708:	0018      	movs	r0, r3
 801a70a:	f7ff ffd2 	bl	801a6b2 <pppos_input_free_current_packet>
#if VJ_SUPPORT
  vj_uncompress_err(&pppos->ppp->vj_comp);
 801a70e:	687b      	ldr	r3, [r7, #4]
 801a710:	681b      	ldr	r3, [r3, #0]
 801a712:	33dc      	adds	r3, #220	; 0xdc
 801a714:	0018      	movs	r0, r3
 801a716:	f001 fa4f 	bl	801bbb8 <vj_uncompress_err>
#endif /* VJ_SUPPORT */

  LINK_STATS_INC(link.drop);
  MIB2_STATS_NETIF_INC(pppos->ppp->netif, ifindiscards);
}
 801a71a:	46c0      	nop			; (mov r8, r8)
 801a71c:	46bd      	mov	sp, r7
 801a71e:	b002      	add	sp, #8
 801a720:	bd80      	pop	{r7, pc}
	...

0801a724 <pppos_output_append>:
 * If pbuf is full, send the pbuf and reuse it.
 * Return the current pbuf.
 */
static err_t
pppos_output_append(pppos_pcb *pppos, err_t err, struct pbuf *nb, u8_t c, u8_t accm, u16_t *fcs)
{
 801a724:	b590      	push	{r4, r7, lr}
 801a726:	b087      	sub	sp, #28
 801a728:	af00      	add	r7, sp, #0
 801a72a:	60f8      	str	r0, [r7, #12]
 801a72c:	0008      	movs	r0, r1
 801a72e:	607a      	str	r2, [r7, #4]
 801a730:	0019      	movs	r1, r3
 801a732:	240b      	movs	r4, #11
 801a734:	193b      	adds	r3, r7, r4
 801a736:	1c02      	adds	r2, r0, #0
 801a738:	701a      	strb	r2, [r3, #0]
 801a73a:	230a      	movs	r3, #10
 801a73c:	18fb      	adds	r3, r7, r3
 801a73e:	1c0a      	adds	r2, r1, #0
 801a740:	701a      	strb	r2, [r3, #0]
  if (err != ERR_OK) {
 801a742:	193b      	adds	r3, r7, r4
 801a744:	781b      	ldrb	r3, [r3, #0]
 801a746:	b25b      	sxtb	r3, r3
 801a748:	2b00      	cmp	r3, #0
 801a74a:	d003      	beq.n	801a754 <pppos_output_append+0x30>
    return err;
 801a74c:	193b      	adds	r3, r7, r4
 801a74e:	781b      	ldrb	r3, [r3, #0]
 801a750:	b25b      	sxtb	r3, r3
 801a752:	e07a      	b.n	801a84a <pppos_output_append+0x126>
  }

  /* Make sure there is room for the character and an escape code.
   * Sure we don't quite fill the buffer if the character doesn't
   * get escaped but is one character worth complicating this? */
  if ((PBUF_POOL_BUFSIZE - nb->len) < 2) {
 801a754:	687b      	ldr	r3, [r7, #4]
 801a756:	895b      	ldrh	r3, [r3, #10]
 801a758:	001a      	movs	r2, r3
 801a75a:	2394      	movs	r3, #148	; 0x94
 801a75c:	009b      	lsls	r3, r3, #2
 801a75e:	1a9b      	subs	r3, r3, r2
 801a760:	2b01      	cmp	r3, #1
 801a762:	d81a      	bhi.n	801a79a <pppos_output_append+0x76>
    u32_t l = pppos->output_cb(pppos->ppp, (u8_t*)nb->payload, nb->len, pppos->ppp->ctx_cb);
 801a764:	68fb      	ldr	r3, [r7, #12]
 801a766:	685c      	ldr	r4, [r3, #4]
 801a768:	68fb      	ldr	r3, [r7, #12]
 801a76a:	6818      	ldr	r0, [r3, #0]
 801a76c:	687b      	ldr	r3, [r7, #4]
 801a76e:	6859      	ldr	r1, [r3, #4]
 801a770:	687b      	ldr	r3, [r7, #4]
 801a772:	895b      	ldrh	r3, [r3, #10]
 801a774:	001a      	movs	r2, r3
 801a776:	68fb      	ldr	r3, [r7, #12]
 801a778:	681b      	ldr	r3, [r3, #0]
 801a77a:	69db      	ldr	r3, [r3, #28]
 801a77c:	47a0      	blx	r4
 801a77e:	0003      	movs	r3, r0
 801a780:	617b      	str	r3, [r7, #20]
    if (l != nb->len) {
 801a782:	687b      	ldr	r3, [r7, #4]
 801a784:	895b      	ldrh	r3, [r3, #10]
 801a786:	001a      	movs	r2, r3
 801a788:	697b      	ldr	r3, [r7, #20]
 801a78a:	4293      	cmp	r3, r2
 801a78c:	d002      	beq.n	801a794 <pppos_output_append+0x70>
      return ERR_IF;
 801a78e:	230c      	movs	r3, #12
 801a790:	425b      	negs	r3, r3
 801a792:	e05a      	b.n	801a84a <pppos_output_append+0x126>
    }
    nb->len = 0;
 801a794:	687b      	ldr	r3, [r7, #4]
 801a796:	2200      	movs	r2, #0
 801a798:	815a      	strh	r2, [r3, #10]
  }

  /* Update FCS before checking for special characters. */
  if (fcs) {
 801a79a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801a79c:	2b00      	cmp	r3, #0
 801a79e:	d013      	beq.n	801a7c8 <pppos_output_append+0xa4>
    *fcs = PPP_FCS(*fcs, c);
 801a7a0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801a7a2:	881b      	ldrh	r3, [r3, #0]
 801a7a4:	0a1b      	lsrs	r3, r3, #8
 801a7a6:	b29a      	uxth	r2, r3
 801a7a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801a7aa:	881b      	ldrh	r3, [r3, #0]
 801a7ac:	0019      	movs	r1, r3
 801a7ae:	230a      	movs	r3, #10
 801a7b0:	18fb      	adds	r3, r7, r3
 801a7b2:	781b      	ldrb	r3, [r3, #0]
 801a7b4:	404b      	eors	r3, r1
 801a7b6:	21ff      	movs	r1, #255	; 0xff
 801a7b8:	4019      	ands	r1, r3
 801a7ba:	4b26      	ldr	r3, [pc, #152]	; (801a854 <pppos_output_append+0x130>)
 801a7bc:	0049      	lsls	r1, r1, #1
 801a7be:	5acb      	ldrh	r3, [r1, r3]
 801a7c0:	4053      	eors	r3, r2
 801a7c2:	b29a      	uxth	r2, r3
 801a7c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801a7c6:	801a      	strh	r2, [r3, #0]
  }

  /* Copy to output buffer escaping special characters. */
  if (accm && ESCAPE_P(pppos->out_accm, c)) {
 801a7c8:	2328      	movs	r3, #40	; 0x28
 801a7ca:	18fb      	adds	r3, r7, r3
 801a7cc:	781b      	ldrb	r3, [r3, #0]
 801a7ce:	2b00      	cmp	r3, #0
 801a7d0:	d02d      	beq.n	801a82e <pppos_output_append+0x10a>
 801a7d2:	240a      	movs	r4, #10
 801a7d4:	193b      	adds	r3, r7, r4
 801a7d6:	781b      	ldrb	r3, [r3, #0]
 801a7d8:	08db      	lsrs	r3, r3, #3
 801a7da:	b2db      	uxtb	r3, r3
 801a7dc:	001a      	movs	r2, r3
 801a7de:	68fb      	ldr	r3, [r7, #12]
 801a7e0:	189b      	adds	r3, r3, r2
 801a7e2:	7b1b      	ldrb	r3, [r3, #12]
 801a7e4:	0019      	movs	r1, r3
 801a7e6:	193b      	adds	r3, r7, r4
 801a7e8:	781b      	ldrb	r3, [r3, #0]
 801a7ea:	2207      	movs	r2, #7
 801a7ec:	4013      	ands	r3, r2
 801a7ee:	4119      	asrs	r1, r3
 801a7f0:	000b      	movs	r3, r1
 801a7f2:	2201      	movs	r2, #1
 801a7f4:	4013      	ands	r3, r2
 801a7f6:	d01a      	beq.n	801a82e <pppos_output_append+0x10a>
    *((u8_t*)nb->payload + nb->len++) = PPP_ESCAPE;
 801a7f8:	687b      	ldr	r3, [r7, #4]
 801a7fa:	685a      	ldr	r2, [r3, #4]
 801a7fc:	687b      	ldr	r3, [r7, #4]
 801a7fe:	895b      	ldrh	r3, [r3, #10]
 801a800:	1c59      	adds	r1, r3, #1
 801a802:	b288      	uxth	r0, r1
 801a804:	6879      	ldr	r1, [r7, #4]
 801a806:	8148      	strh	r0, [r1, #10]
 801a808:	18d3      	adds	r3, r2, r3
 801a80a:	227d      	movs	r2, #125	; 0x7d
 801a80c:	701a      	strb	r2, [r3, #0]
    *((u8_t*)nb->payload + nb->len++) = c ^ PPP_TRANS;
 801a80e:	687b      	ldr	r3, [r7, #4]
 801a810:	685a      	ldr	r2, [r3, #4]
 801a812:	687b      	ldr	r3, [r7, #4]
 801a814:	895b      	ldrh	r3, [r3, #10]
 801a816:	1c59      	adds	r1, r3, #1
 801a818:	b288      	uxth	r0, r1
 801a81a:	6879      	ldr	r1, [r7, #4]
 801a81c:	8148      	strh	r0, [r1, #10]
 801a81e:	18d3      	adds	r3, r2, r3
 801a820:	193a      	adds	r2, r7, r4
 801a822:	7812      	ldrb	r2, [r2, #0]
 801a824:	2120      	movs	r1, #32
 801a826:	404a      	eors	r2, r1
 801a828:	b2d2      	uxtb	r2, r2
 801a82a:	701a      	strb	r2, [r3, #0]
 801a82c:	e00c      	b.n	801a848 <pppos_output_append+0x124>
  } else {
    *((u8_t*)nb->payload + nb->len++) = c;
 801a82e:	687b      	ldr	r3, [r7, #4]
 801a830:	685a      	ldr	r2, [r3, #4]
 801a832:	687b      	ldr	r3, [r7, #4]
 801a834:	895b      	ldrh	r3, [r3, #10]
 801a836:	1c59      	adds	r1, r3, #1
 801a838:	b288      	uxth	r0, r1
 801a83a:	6879      	ldr	r1, [r7, #4]
 801a83c:	8148      	strh	r0, [r1, #10]
 801a83e:	18d3      	adds	r3, r2, r3
 801a840:	220a      	movs	r2, #10
 801a842:	18ba      	adds	r2, r7, r2
 801a844:	7812      	ldrb	r2, [r2, #0]
 801a846:	701a      	strb	r2, [r3, #0]
  }

  return ERR_OK;
 801a848:	2300      	movs	r3, #0
}
 801a84a:	0018      	movs	r0, r3
 801a84c:	46bd      	mov	sp, r7
 801a84e:	b007      	add	sp, #28
 801a850:	bd90      	pop	{r4, r7, pc}
 801a852:	46c0      	nop			; (mov r8, r8)
 801a854:	08021cf4 	.word	0x08021cf4

0801a858 <pppos_output_last>:

static err_t
pppos_output_last(pppos_pcb *pppos, err_t err, struct pbuf *nb, u16_t *fcs)
{
 801a858:	b5f0      	push	{r4, r5, r6, r7, lr}
 801a85a:	b089      	sub	sp, #36	; 0x24
 801a85c:	af02      	add	r7, sp, #8
 801a85e:	60f8      	str	r0, [r7, #12]
 801a860:	607a      	str	r2, [r7, #4]
 801a862:	603b      	str	r3, [r7, #0]
 801a864:	260b      	movs	r6, #11
 801a866:	19bb      	adds	r3, r7, r6
 801a868:	1c0a      	adds	r2, r1, #0
 801a86a:	701a      	strb	r2, [r3, #0]
  ppp_pcb *ppp = pppos->ppp;
 801a86c:	68fb      	ldr	r3, [r7, #12]
 801a86e:	681b      	ldr	r3, [r3, #0]
 801a870:	617b      	str	r3, [r7, #20]

  /* Add FCS and trailing flag. */
  err = pppos_output_append(pppos, err,  nb, ~(*fcs) & 0xFF, 1, NULL);
 801a872:	683b      	ldr	r3, [r7, #0]
 801a874:	881b      	ldrh	r3, [r3, #0]
 801a876:	b2db      	uxtb	r3, r3
 801a878:	43db      	mvns	r3, r3
 801a87a:	b2dd      	uxtb	r5, r3
 801a87c:	19bc      	adds	r4, r7, r6
 801a87e:	687a      	ldr	r2, [r7, #4]
 801a880:	19bb      	adds	r3, r7, r6
 801a882:	2100      	movs	r1, #0
 801a884:	5659      	ldrsb	r1, [r3, r1]
 801a886:	68f8      	ldr	r0, [r7, #12]
 801a888:	2300      	movs	r3, #0
 801a88a:	9301      	str	r3, [sp, #4]
 801a88c:	2301      	movs	r3, #1
 801a88e:	9300      	str	r3, [sp, #0]
 801a890:	002b      	movs	r3, r5
 801a892:	f7ff ff47 	bl	801a724 <pppos_output_append>
 801a896:	0003      	movs	r3, r0
 801a898:	7023      	strb	r3, [r4, #0]
  err = pppos_output_append(pppos, err,  nb, (~(*fcs) >> 8) & 0xFF, 1, NULL);
 801a89a:	683b      	ldr	r3, [r7, #0]
 801a89c:	881b      	ldrh	r3, [r3, #0]
 801a89e:	43db      	mvns	r3, r3
 801a8a0:	121b      	asrs	r3, r3, #8
 801a8a2:	b2dd      	uxtb	r5, r3
 801a8a4:	19bc      	adds	r4, r7, r6
 801a8a6:	687a      	ldr	r2, [r7, #4]
 801a8a8:	19bb      	adds	r3, r7, r6
 801a8aa:	2100      	movs	r1, #0
 801a8ac:	5659      	ldrsb	r1, [r3, r1]
 801a8ae:	68f8      	ldr	r0, [r7, #12]
 801a8b0:	2300      	movs	r3, #0
 801a8b2:	9301      	str	r3, [sp, #4]
 801a8b4:	2301      	movs	r3, #1
 801a8b6:	9300      	str	r3, [sp, #0]
 801a8b8:	002b      	movs	r3, r5
 801a8ba:	f7ff ff33 	bl	801a724 <pppos_output_append>
 801a8be:	0003      	movs	r3, r0
 801a8c0:	7023      	strb	r3, [r4, #0]
  err = pppos_output_append(pppos, err,  nb, PPP_FLAG, 0, NULL);
 801a8c2:	0035      	movs	r5, r6
 801a8c4:	197c      	adds	r4, r7, r5
 801a8c6:	687a      	ldr	r2, [r7, #4]
 801a8c8:	197b      	adds	r3, r7, r5
 801a8ca:	2100      	movs	r1, #0
 801a8cc:	5659      	ldrsb	r1, [r3, r1]
 801a8ce:	68f8      	ldr	r0, [r7, #12]
 801a8d0:	2300      	movs	r3, #0
 801a8d2:	9301      	str	r3, [sp, #4]
 801a8d4:	2300      	movs	r3, #0
 801a8d6:	9300      	str	r3, [sp, #0]
 801a8d8:	237e      	movs	r3, #126	; 0x7e
 801a8da:	f7ff ff23 	bl	801a724 <pppos_output_append>
 801a8de:	0003      	movs	r3, r0
 801a8e0:	7023      	strb	r3, [r4, #0]

  if (err != ERR_OK) {
 801a8e2:	197b      	adds	r3, r7, r5
 801a8e4:	781b      	ldrb	r3, [r3, #0]
 801a8e6:	b25b      	sxtb	r3, r3
 801a8e8:	2b00      	cmp	r3, #0
 801a8ea:	d125      	bne.n	801a938 <pppos_output_last+0xe0>
    goto failed;
  }

  /* Send remaining buffer if not empty */
  if (nb->len > 0) {
 801a8ec:	687b      	ldr	r3, [r7, #4]
 801a8ee:	895b      	ldrh	r3, [r3, #10]
 801a8f0:	2b00      	cmp	r3, #0
 801a8f2:	d016      	beq.n	801a922 <pppos_output_last+0xca>
    u32_t l = pppos->output_cb(ppp, (u8_t*)nb->payload, nb->len, ppp->ctx_cb);
 801a8f4:	68fb      	ldr	r3, [r7, #12]
 801a8f6:	685c      	ldr	r4, [r3, #4]
 801a8f8:	687b      	ldr	r3, [r7, #4]
 801a8fa:	6859      	ldr	r1, [r3, #4]
 801a8fc:	687b      	ldr	r3, [r7, #4]
 801a8fe:	895b      	ldrh	r3, [r3, #10]
 801a900:	001a      	movs	r2, r3
 801a902:	697b      	ldr	r3, [r7, #20]
 801a904:	69db      	ldr	r3, [r3, #28]
 801a906:	6978      	ldr	r0, [r7, #20]
 801a908:	47a0      	blx	r4
 801a90a:	0003      	movs	r3, r0
 801a90c:	613b      	str	r3, [r7, #16]
    if (l != nb->len) {
 801a90e:	687b      	ldr	r3, [r7, #4]
 801a910:	895b      	ldrh	r3, [r3, #10]
 801a912:	001a      	movs	r2, r3
 801a914:	693b      	ldr	r3, [r7, #16]
 801a916:	4293      	cmp	r3, r2
 801a918:	d003      	beq.n	801a922 <pppos_output_last+0xca>
      err = ERR_IF;
 801a91a:	197b      	adds	r3, r7, r5
 801a91c:	22f4      	movs	r2, #244	; 0xf4
 801a91e:	701a      	strb	r2, [r3, #0]
      goto failed;
 801a920:	e00b      	b.n	801a93a <pppos_output_last+0xe2>
    }
  }

  pppos->last_xmit = sys_now();
 801a922:	f001 ff15 	bl	801c750 <sys_now>
 801a926:	0002      	movs	r2, r0
 801a928:	68fb      	ldr	r3, [r7, #12]
 801a92a:	609a      	str	r2, [r3, #8]
  MIB2_STATS_NETIF_ADD(ppp->netif, ifoutoctets, nb->tot_len);
  MIB2_STATS_NETIF_INC(ppp->netif, ifoutucastpkts);
  LINK_STATS_INC(link.xmit);
  pbuf_free(nb);
 801a92c:	687b      	ldr	r3, [r7, #4]
 801a92e:	0018      	movs	r0, r3
 801a930:	f7ee feb0 	bl	8009694 <pbuf_free>
  return ERR_OK;
 801a934:	2300      	movs	r3, #0
 801a936:	e00b      	b.n	801a950 <pppos_output_last+0xf8>
    goto failed;
 801a938:	46c0      	nop			; (mov r8, r8)

failed:
  pppos->last_xmit = 0; /* prepend PPP_FLAG to next packet */
 801a93a:	68fb      	ldr	r3, [r7, #12]
 801a93c:	2200      	movs	r2, #0
 801a93e:	609a      	str	r2, [r3, #8]
  LINK_STATS_INC(link.err);
  LINK_STATS_INC(link.drop);
  MIB2_STATS_NETIF_INC(ppp->netif, ifoutdiscards);
  pbuf_free(nb);
 801a940:	687b      	ldr	r3, [r7, #4]
 801a942:	0018      	movs	r0, r3
 801a944:	f7ee fea6 	bl	8009694 <pbuf_free>
  return err;
 801a948:	230b      	movs	r3, #11
 801a94a:	18fb      	adds	r3, r7, r3
 801a94c:	781b      	ldrb	r3, [r3, #0]
 801a94e:	b25b      	sxtb	r3, r3
}
 801a950:	0018      	movs	r0, r3
 801a952:	46bd      	mov	sp, r7
 801a954:	b007      	add	sp, #28
 801a956:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801a958 <ppp_slprintf>:
 * %m (error message), %v (visible string),
 * %q (quoted string), %t (current time) and %I (IP address) formats.
 * Doesn't do floating-point formats.
 * Returns the number of chars put into buf.
 */
int ppp_slprintf(char *buf, int buflen, const char *fmt, ...) {
 801a958:	b40c      	push	{r2, r3}
 801a95a:	b580      	push	{r7, lr}
 801a95c:	b084      	sub	sp, #16
 801a95e:	af00      	add	r7, sp, #0
 801a960:	6078      	str	r0, [r7, #4]
 801a962:	6039      	str	r1, [r7, #0]
    va_list args;
    int n;

    va_start(args, fmt);
 801a964:	231c      	movs	r3, #28
 801a966:	18fb      	adds	r3, r7, r3
 801a968:	60bb      	str	r3, [r7, #8]
    n = ppp_vslprintf(buf, buflen, fmt, args);
 801a96a:	68bb      	ldr	r3, [r7, #8]
 801a96c:	69ba      	ldr	r2, [r7, #24]
 801a96e:	6839      	ldr	r1, [r7, #0]
 801a970:	6878      	ldr	r0, [r7, #4]
 801a972:	f000 f80b 	bl	801a98c <ppp_vslprintf>
 801a976:	0003      	movs	r3, r0
 801a978:	60fb      	str	r3, [r7, #12]
    va_end(args);
    return n;
 801a97a:	68fb      	ldr	r3, [r7, #12]
}
 801a97c:	0018      	movs	r0, r3
 801a97e:	46bd      	mov	sp, r7
 801a980:	b004      	add	sp, #16
 801a982:	bc80      	pop	{r7}
 801a984:	bc08      	pop	{r3}
 801a986:	b002      	add	sp, #8
 801a988:	4718      	bx	r3
	...

0801a98c <ppp_vslprintf>:
/*
 * ppp_vslprintf - like ppp_slprintf, takes a va_list instead of a list of args.
 */
#define OUTCHAR(c)	(buflen > 0? (--buflen, *buf++ = (c)): 0)

int ppp_vslprintf(char *buf, int buflen, const char *fmt, va_list args) {
 801a98c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801a98e:	b0a1      	sub	sp, #132	; 0x84
 801a990:	af04      	add	r7, sp, #16
 801a992:	60f8      	str	r0, [r7, #12]
 801a994:	60b9      	str	r1, [r7, #8]
 801a996:	607a      	str	r2, [r7, #4]
 801a998:	603b      	str	r3, [r7, #0]
    int c, i, n;
    int width, prec, fillch;
    int base, len, neg, quoted;
    unsigned long val = 0;
 801a99a:	2300      	movs	r3, #0
 801a99c:	64fb      	str	r3, [r7, #76]	; 0x4c
    static char hexchars[] = "0123456789abcdef";
#if PRINTPKT_SUPPORT
    struct buffer_info bufinfo;
#endif /* PRINTPKT_SUPPORT */

    buf0 = buf;
 801a99e:	68fb      	ldr	r3, [r7, #12]
 801a9a0:	63fb      	str	r3, [r7, #60]	; 0x3c
    --buflen;
 801a9a2:	68bb      	ldr	r3, [r7, #8]
 801a9a4:	3b01      	subs	r3, #1
 801a9a6:	60bb      	str	r3, [r7, #8]
    while (buflen > 0) {
 801a9a8:	f000 fb8b 	bl	801b0c2 <ppp_vslprintf+0x736>
	for (f = fmt; *f != '%' && *f != 0; ++f)
 801a9ac:	687b      	ldr	r3, [r7, #4]
 801a9ae:	64bb      	str	r3, [r7, #72]	; 0x48
 801a9b0:	e002      	b.n	801a9b8 <ppp_vslprintf+0x2c>
 801a9b2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a9b4:	3301      	adds	r3, #1
 801a9b6:	64bb      	str	r3, [r7, #72]	; 0x48
 801a9b8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a9ba:	781b      	ldrb	r3, [r3, #0]
 801a9bc:	2b25      	cmp	r3, #37	; 0x25
 801a9be:	d003      	beq.n	801a9c8 <ppp_vslprintf+0x3c>
 801a9c0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a9c2:	781b      	ldrb	r3, [r3, #0]
 801a9c4:	2b00      	cmp	r3, #0
 801a9c6:	d1f4      	bne.n	801a9b2 <ppp_vslprintf+0x26>
	    ;
	if (f > fmt) {
 801a9c8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801a9ca:	687b      	ldr	r3, [r7, #4]
 801a9cc:	429a      	cmp	r2, r3
 801a9ce:	d919      	bls.n	801aa04 <ppp_vslprintf+0x78>
	    len = f - fmt;
 801a9d0:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801a9d2:	687b      	ldr	r3, [r7, #4]
 801a9d4:	1ad3      	subs	r3, r2, r3
 801a9d6:	657b      	str	r3, [r7, #84]	; 0x54
	    if (len > buflen)
 801a9d8:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801a9da:	68bb      	ldr	r3, [r7, #8]
 801a9dc:	429a      	cmp	r2, r3
 801a9de:	dd01      	ble.n	801a9e4 <ppp_vslprintf+0x58>
		len = buflen;
 801a9e0:	68bb      	ldr	r3, [r7, #8]
 801a9e2:	657b      	str	r3, [r7, #84]	; 0x54
	    memcpy(buf, fmt, len);
 801a9e4:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801a9e6:	6879      	ldr	r1, [r7, #4]
 801a9e8:	68fb      	ldr	r3, [r7, #12]
 801a9ea:	0018      	movs	r0, r3
 801a9ec:	f001 ff02 	bl	801c7f4 <memcpy>
	    buf += len;
 801a9f0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801a9f2:	68fa      	ldr	r2, [r7, #12]
 801a9f4:	18d3      	adds	r3, r2, r3
 801a9f6:	60fb      	str	r3, [r7, #12]
	    buflen -= len;
 801a9f8:	68ba      	ldr	r2, [r7, #8]
 801a9fa:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801a9fc:	1ad3      	subs	r3, r2, r3
 801a9fe:	60bb      	str	r3, [r7, #8]
	    fmt = f;
 801aa00:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801aa02:	607b      	str	r3, [r7, #4]
	}
	if (*fmt == 0)
 801aa04:	687b      	ldr	r3, [r7, #4]
 801aa06:	781b      	ldrb	r3, [r3, #0]
 801aa08:	2b00      	cmp	r3, #0
 801aa0a:	d101      	bne.n	801aa10 <ppp_vslprintf+0x84>
 801aa0c:	f000 fb5e 	bl	801b0cc <ppp_vslprintf+0x740>
	    break;
	c = *++fmt;
 801aa10:	687b      	ldr	r3, [r7, #4]
 801aa12:	3301      	adds	r3, #1
 801aa14:	607b      	str	r3, [r7, #4]
 801aa16:	687b      	ldr	r3, [r7, #4]
 801aa18:	781b      	ldrb	r3, [r3, #0]
 801aa1a:	66fb      	str	r3, [r7, #108]	; 0x6c
	width = 0;
 801aa1c:	2300      	movs	r3, #0
 801aa1e:	667b      	str	r3, [r7, #100]	; 0x64
	prec = -1;
 801aa20:	2301      	movs	r3, #1
 801aa22:	425b      	negs	r3, r3
 801aa24:	663b      	str	r3, [r7, #96]	; 0x60
	fillch = ' ';
 801aa26:	2320      	movs	r3, #32
 801aa28:	65fb      	str	r3, [r7, #92]	; 0x5c
	if (c == '0') {
 801aa2a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801aa2c:	2b30      	cmp	r3, #48	; 0x30
 801aa2e:	d107      	bne.n	801aa40 <ppp_vslprintf+0xb4>
	    fillch = '0';
 801aa30:	2330      	movs	r3, #48	; 0x30
 801aa32:	65fb      	str	r3, [r7, #92]	; 0x5c
	    c = *++fmt;
 801aa34:	687b      	ldr	r3, [r7, #4]
 801aa36:	3301      	adds	r3, #1
 801aa38:	607b      	str	r3, [r7, #4]
 801aa3a:	687b      	ldr	r3, [r7, #4]
 801aa3c:	781b      	ldrb	r3, [r3, #0]
 801aa3e:	66fb      	str	r3, [r7, #108]	; 0x6c
	}
	if (c == '*') {
 801aa40:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801aa42:	2b2a      	cmp	r3, #42	; 0x2a
 801aa44:	d11b      	bne.n	801aa7e <ppp_vslprintf+0xf2>
	    width = va_arg(args, int);
 801aa46:	683b      	ldr	r3, [r7, #0]
 801aa48:	1d1a      	adds	r2, r3, #4
 801aa4a:	603a      	str	r2, [r7, #0]
 801aa4c:	681b      	ldr	r3, [r3, #0]
 801aa4e:	667b      	str	r3, [r7, #100]	; 0x64
	    c = *++fmt;
 801aa50:	687b      	ldr	r3, [r7, #4]
 801aa52:	3301      	adds	r3, #1
 801aa54:	607b      	str	r3, [r7, #4]
 801aa56:	687b      	ldr	r3, [r7, #4]
 801aa58:	781b      	ldrb	r3, [r3, #0]
 801aa5a:	66fb      	str	r3, [r7, #108]	; 0x6c
 801aa5c:	e019      	b.n	801aa92 <ppp_vslprintf+0x106>
	} else {
	    while (lwip_isdigit(c)) {
		width = width * 10 + c - '0';
 801aa5e:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801aa60:	0013      	movs	r3, r2
 801aa62:	009b      	lsls	r3, r3, #2
 801aa64:	189b      	adds	r3, r3, r2
 801aa66:	005b      	lsls	r3, r3, #1
 801aa68:	001a      	movs	r2, r3
 801aa6a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801aa6c:	18d3      	adds	r3, r2, r3
 801aa6e:	3b30      	subs	r3, #48	; 0x30
 801aa70:	667b      	str	r3, [r7, #100]	; 0x64
		c = *++fmt;
 801aa72:	687b      	ldr	r3, [r7, #4]
 801aa74:	3301      	adds	r3, #1
 801aa76:	607b      	str	r3, [r7, #4]
 801aa78:	687b      	ldr	r3, [r7, #4]
 801aa7a:	781b      	ldrb	r3, [r3, #0]
 801aa7c:	66fb      	str	r3, [r7, #108]	; 0x6c
	    while (lwip_isdigit(c)) {
 801aa7e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801aa80:	b2db      	uxtb	r3, r3
 801aa82:	1c5a      	adds	r2, r3, #1
 801aa84:	4bcf      	ldr	r3, [pc, #828]	; (801adc4 <ppp_vslprintf+0x438>)
 801aa86:	18d3      	adds	r3, r2, r3
 801aa88:	781b      	ldrb	r3, [r3, #0]
 801aa8a:	001a      	movs	r2, r3
 801aa8c:	2304      	movs	r3, #4
 801aa8e:	4013      	ands	r3, r2
 801aa90:	d1e5      	bne.n	801aa5e <ppp_vslprintf+0xd2>
	    }
	}
	if (c == '.') {
 801aa92:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801aa94:	2b2e      	cmp	r3, #46	; 0x2e
 801aa96:	d131      	bne.n	801aafc <ppp_vslprintf+0x170>
	    c = *++fmt;
 801aa98:	687b      	ldr	r3, [r7, #4]
 801aa9a:	3301      	adds	r3, #1
 801aa9c:	607b      	str	r3, [r7, #4]
 801aa9e:	687b      	ldr	r3, [r7, #4]
 801aaa0:	781b      	ldrb	r3, [r3, #0]
 801aaa2:	66fb      	str	r3, [r7, #108]	; 0x6c
	    if (c == '*') {
 801aaa4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801aaa6:	2b2a      	cmp	r3, #42	; 0x2a
 801aaa8:	d10b      	bne.n	801aac2 <ppp_vslprintf+0x136>
		prec = va_arg(args, int);
 801aaaa:	683b      	ldr	r3, [r7, #0]
 801aaac:	1d1a      	adds	r2, r3, #4
 801aaae:	603a      	str	r2, [r7, #0]
 801aab0:	681b      	ldr	r3, [r3, #0]
 801aab2:	663b      	str	r3, [r7, #96]	; 0x60
		c = *++fmt;
 801aab4:	687b      	ldr	r3, [r7, #4]
 801aab6:	3301      	adds	r3, #1
 801aab8:	607b      	str	r3, [r7, #4]
 801aaba:	687b      	ldr	r3, [r7, #4]
 801aabc:	781b      	ldrb	r3, [r3, #0]
 801aabe:	66fb      	str	r3, [r7, #108]	; 0x6c
 801aac0:	e01c      	b.n	801aafc <ppp_vslprintf+0x170>
	    } else {
		prec = 0;
 801aac2:	2300      	movs	r3, #0
 801aac4:	663b      	str	r3, [r7, #96]	; 0x60
		while (lwip_isdigit(c)) {
 801aac6:	e00f      	b.n	801aae8 <ppp_vslprintf+0x15c>
		    prec = prec * 10 + c - '0';
 801aac8:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 801aaca:	0013      	movs	r3, r2
 801aacc:	009b      	lsls	r3, r3, #2
 801aace:	189b      	adds	r3, r3, r2
 801aad0:	005b      	lsls	r3, r3, #1
 801aad2:	001a      	movs	r2, r3
 801aad4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801aad6:	18d3      	adds	r3, r2, r3
 801aad8:	3b30      	subs	r3, #48	; 0x30
 801aada:	663b      	str	r3, [r7, #96]	; 0x60
		    c = *++fmt;
 801aadc:	687b      	ldr	r3, [r7, #4]
 801aade:	3301      	adds	r3, #1
 801aae0:	607b      	str	r3, [r7, #4]
 801aae2:	687b      	ldr	r3, [r7, #4]
 801aae4:	781b      	ldrb	r3, [r3, #0]
 801aae6:	66fb      	str	r3, [r7, #108]	; 0x6c
		while (lwip_isdigit(c)) {
 801aae8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801aaea:	b2db      	uxtb	r3, r3
 801aaec:	1c5a      	adds	r2, r3, #1
 801aaee:	4bb5      	ldr	r3, [pc, #724]	; (801adc4 <ppp_vslprintf+0x438>)
 801aaf0:	18d3      	adds	r3, r2, r3
 801aaf2:	781b      	ldrb	r3, [r3, #0]
 801aaf4:	001a      	movs	r2, r3
 801aaf6:	2304      	movs	r3, #4
 801aaf8:	4013      	ands	r3, r2
 801aafa:	d1e5      	bne.n	801aac8 <ppp_vslprintf+0x13c>
		}
	    }
	}
	str = 0;
 801aafc:	2300      	movs	r3, #0
 801aafe:	647b      	str	r3, [r7, #68]	; 0x44
	base = 0;
 801ab00:	2300      	movs	r3, #0
 801ab02:	65bb      	str	r3, [r7, #88]	; 0x58
	neg = 0;
 801ab04:	2300      	movs	r3, #0
 801ab06:	653b      	str	r3, [r7, #80]	; 0x50
	++fmt;
 801ab08:	687b      	ldr	r3, [r7, #4]
 801ab0a:	3301      	adds	r3, #1
 801ab0c:	607b      	str	r3, [r7, #4]
 801ab0e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ab10:	3b42      	subs	r3, #66	; 0x42
 801ab12:	2b36      	cmp	r3, #54	; 0x36
 801ab14:	d900      	bls.n	801ab18 <ppp_vslprintf+0x18c>
 801ab16:	e229      	b.n	801af6c <ppp_vslprintf+0x5e0>
 801ab18:	009a      	lsls	r2, r3, #2
 801ab1a:	4bab      	ldr	r3, [pc, #684]	; (801adc8 <ppp_vslprintf+0x43c>)
 801ab1c:	18d3      	adds	r3, r2, r3
 801ab1e:	681b      	ldr	r3, [r3, #0]
 801ab20:	469f      	mov	pc, r3
	switch (c) {
	case 'l':
	    c = *fmt++;
 801ab22:	687b      	ldr	r3, [r7, #4]
 801ab24:	1c5a      	adds	r2, r3, #1
 801ab26:	607a      	str	r2, [r7, #4]
 801ab28:	781b      	ldrb	r3, [r3, #0]
 801ab2a:	66fb      	str	r3, [r7, #108]	; 0x6c
 801ab2c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ab2e:	2b64      	cmp	r3, #100	; 0x64
 801ab30:	d003      	beq.n	801ab3a <ppp_vslprintf+0x1ae>
 801ab32:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ab34:	2b75      	cmp	r3, #117	; 0x75
 801ab36:	d010      	beq.n	801ab5a <ppp_vslprintf+0x1ce>
 801ab38:	e017      	b.n	801ab6a <ppp_vslprintf+0x1de>
	    switch (c) {
	    case 'd':
		val = va_arg(args, long);
 801ab3a:	683b      	ldr	r3, [r7, #0]
 801ab3c:	1d1a      	adds	r2, r3, #4
 801ab3e:	603a      	str	r2, [r7, #0]
 801ab40:	681b      	ldr	r3, [r3, #0]
 801ab42:	64fb      	str	r3, [r7, #76]	; 0x4c
		if ((long)val < 0) {
 801ab44:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801ab46:	2b00      	cmp	r3, #0
 801ab48:	da04      	bge.n	801ab54 <ppp_vslprintf+0x1c8>
		    neg = 1;
 801ab4a:	2301      	movs	r3, #1
 801ab4c:	653b      	str	r3, [r7, #80]	; 0x50
		    val = (unsigned long)-(long)val;
 801ab4e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801ab50:	425b      	negs	r3, r3
 801ab52:	64fb      	str	r3, [r7, #76]	; 0x4c
		}
		base = 10;
 801ab54:	230a      	movs	r3, #10
 801ab56:	65bb      	str	r3, [r7, #88]	; 0x58
		break;
 801ab58:	e021      	b.n	801ab9e <ppp_vslprintf+0x212>
	    case 'u':
		val = va_arg(args, unsigned long);
 801ab5a:	683b      	ldr	r3, [r7, #0]
 801ab5c:	1d1a      	adds	r2, r3, #4
 801ab5e:	603a      	str	r2, [r7, #0]
 801ab60:	681b      	ldr	r3, [r3, #0]
 801ab62:	64fb      	str	r3, [r7, #76]	; 0x4c
		base = 10;
 801ab64:	230a      	movs	r3, #10
 801ab66:	65bb      	str	r3, [r7, #88]	; 0x58
		break;
 801ab68:	e019      	b.n	801ab9e <ppp_vslprintf+0x212>
	    default:
		OUTCHAR('%');
 801ab6a:	68bb      	ldr	r3, [r7, #8]
 801ab6c:	2b00      	cmp	r3, #0
 801ab6e:	dd07      	ble.n	801ab80 <ppp_vslprintf+0x1f4>
 801ab70:	68bb      	ldr	r3, [r7, #8]
 801ab72:	3b01      	subs	r3, #1
 801ab74:	60bb      	str	r3, [r7, #8]
 801ab76:	68fb      	ldr	r3, [r7, #12]
 801ab78:	1c5a      	adds	r2, r3, #1
 801ab7a:	60fa      	str	r2, [r7, #12]
 801ab7c:	2225      	movs	r2, #37	; 0x25
 801ab7e:	701a      	strb	r2, [r3, #0]
		OUTCHAR('l');
 801ab80:	68bb      	ldr	r3, [r7, #8]
 801ab82:	2b00      	cmp	r3, #0
 801ab84:	dd07      	ble.n	801ab96 <ppp_vslprintf+0x20a>
 801ab86:	68bb      	ldr	r3, [r7, #8]
 801ab88:	3b01      	subs	r3, #1
 801ab8a:	60bb      	str	r3, [r7, #8]
 801ab8c:	68fb      	ldr	r3, [r7, #12]
 801ab8e:	1c5a      	adds	r2, r3, #1
 801ab90:	60fa      	str	r2, [r7, #12]
 801ab92:	226c      	movs	r2, #108	; 0x6c
 801ab94:	701a      	strb	r2, [r3, #0]
		--fmt;		/* so %lz outputs %lz etc. */
 801ab96:	687b      	ldr	r3, [r7, #4]
 801ab98:	3b01      	subs	r3, #1
 801ab9a:	607b      	str	r3, [r7, #4]
		continue;
 801ab9c:	e291      	b.n	801b0c2 <ppp_vslprintf+0x736>
	    }
	    break;
 801ab9e:	e1f4      	b.n	801af8a <ppp_vslprintf+0x5fe>
	case 'd':
	    i = va_arg(args, int);
 801aba0:	683b      	ldr	r3, [r7, #0]
 801aba2:	1d1a      	adds	r2, r3, #4
 801aba4:	603a      	str	r2, [r7, #0]
 801aba6:	681b      	ldr	r3, [r3, #0]
 801aba8:	637b      	str	r3, [r7, #52]	; 0x34
	    if (i < 0) {
 801abaa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801abac:	2b00      	cmp	r3, #0
 801abae:	da05      	bge.n	801abbc <ppp_vslprintf+0x230>
		neg = 1;
 801abb0:	2301      	movs	r3, #1
 801abb2:	653b      	str	r3, [r7, #80]	; 0x50
		val = -i;
 801abb4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801abb6:	425b      	negs	r3, r3
 801abb8:	64fb      	str	r3, [r7, #76]	; 0x4c
 801abba:	e001      	b.n	801abc0 <ppp_vslprintf+0x234>
	    } else
		val = i;
 801abbc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801abbe:	64fb      	str	r3, [r7, #76]	; 0x4c
	    base = 10;
 801abc0:	230a      	movs	r3, #10
 801abc2:	65bb      	str	r3, [r7, #88]	; 0x58
	    break;
 801abc4:	e1e1      	b.n	801af8a <ppp_vslprintf+0x5fe>
	case 'u':
	    val = va_arg(args, unsigned int);
 801abc6:	683b      	ldr	r3, [r7, #0]
 801abc8:	1d1a      	adds	r2, r3, #4
 801abca:	603a      	str	r2, [r7, #0]
 801abcc:	681b      	ldr	r3, [r3, #0]
 801abce:	64fb      	str	r3, [r7, #76]	; 0x4c
	    base = 10;
 801abd0:	230a      	movs	r3, #10
 801abd2:	65bb      	str	r3, [r7, #88]	; 0x58
	    break;
 801abd4:	e1d9      	b.n	801af8a <ppp_vslprintf+0x5fe>
	case 'o':
	    val = va_arg(args, unsigned int);
 801abd6:	683b      	ldr	r3, [r7, #0]
 801abd8:	1d1a      	adds	r2, r3, #4
 801abda:	603a      	str	r2, [r7, #0]
 801abdc:	681b      	ldr	r3, [r3, #0]
 801abde:	64fb      	str	r3, [r7, #76]	; 0x4c
	    base = 8;
 801abe0:	2308      	movs	r3, #8
 801abe2:	65bb      	str	r3, [r7, #88]	; 0x58
	    break;
 801abe4:	e1d1      	b.n	801af8a <ppp_vslprintf+0x5fe>
	case 'x':
	case 'X':
	    val = va_arg(args, unsigned int);
 801abe6:	683b      	ldr	r3, [r7, #0]
 801abe8:	1d1a      	adds	r2, r3, #4
 801abea:	603a      	str	r2, [r7, #0]
 801abec:	681b      	ldr	r3, [r3, #0]
 801abee:	64fb      	str	r3, [r7, #76]	; 0x4c
	    base = 16;
 801abf0:	2310      	movs	r3, #16
 801abf2:	65bb      	str	r3, [r7, #88]	; 0x58
	    break;
 801abf4:	e1c9      	b.n	801af8a <ppp_vslprintf+0x5fe>
	    base = 16;
	    neg = 2;
	    break;
#endif /* unused (and wrong on LLP64 systems) */
	case 's':
	    str = va_arg(args, char *);
 801abf6:	683b      	ldr	r3, [r7, #0]
 801abf8:	1d1a      	adds	r2, r3, #4
 801abfa:	603a      	str	r2, [r7, #0]
 801abfc:	681b      	ldr	r3, [r3, #0]
 801abfe:	647b      	str	r3, [r7, #68]	; 0x44
	    break;
 801ac00:	e1c3      	b.n	801af8a <ppp_vslprintf+0x5fe>
	case 'c':
	    num[0] = va_arg(args, int);
 801ac02:	683b      	ldr	r3, [r7, #0]
 801ac04:	1d1a      	adds	r2, r3, #4
 801ac06:	603a      	str	r2, [r7, #0]
 801ac08:	681b      	ldr	r3, [r3, #0]
 801ac0a:	b2da      	uxtb	r2, r3
 801ac0c:	2110      	movs	r1, #16
 801ac0e:	187b      	adds	r3, r7, r1
 801ac10:	701a      	strb	r2, [r3, #0]
	    num[1] = 0;
 801ac12:	187b      	adds	r3, r7, r1
 801ac14:	2200      	movs	r2, #0
 801ac16:	705a      	strb	r2, [r3, #1]
	    str = num;
 801ac18:	187b      	adds	r3, r7, r1
 801ac1a:	647b      	str	r3, [r7, #68]	; 0x44
	    break;
 801ac1c:	e1b5      	b.n	801af8a <ppp_vslprintf+0x5fe>
	case 'm':
	    str = strerror(errno);
	    break;
#endif /* do we always have strerror() in embedded ? */
	case 'I':
	    ip = va_arg(args, u32_t);
 801ac1e:	683b      	ldr	r3, [r7, #0]
 801ac20:	1d1a      	adds	r2, r3, #4
 801ac22:	603a      	str	r2, [r7, #0]
 801ac24:	681b      	ldr	r3, [r3, #0]
 801ac26:	633b      	str	r3, [r7, #48]	; 0x30
	    ip = lwip_ntohl(ip);
 801ac28:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ac2a:	0018      	movs	r0, r3
 801ac2c:	f7eb fc98 	bl	8006560 <lwip_htonl>
 801ac30:	0003      	movs	r3, r0
 801ac32:	633b      	str	r3, [r7, #48]	; 0x30
	    ppp_slprintf(num, sizeof(num), "%d.%d.%d.%d", (ip >> 24) & 0xff,
 801ac34:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ac36:	0e1d      	lsrs	r5, r3, #24
		     (ip >> 16) & 0xff, (ip >> 8) & 0xff, ip & 0xff);
 801ac38:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ac3a:	0c1b      	lsrs	r3, r3, #16
	    ppp_slprintf(num, sizeof(num), "%d.%d.%d.%d", (ip >> 24) & 0xff,
 801ac3c:	22ff      	movs	r2, #255	; 0xff
 801ac3e:	4013      	ands	r3, r2
		     (ip >> 16) & 0xff, (ip >> 8) & 0xff, ip & 0xff);
 801ac40:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801ac42:	0a12      	lsrs	r2, r2, #8
	    ppp_slprintf(num, sizeof(num), "%d.%d.%d.%d", (ip >> 24) & 0xff,
 801ac44:	21ff      	movs	r1, #255	; 0xff
 801ac46:	400a      	ands	r2, r1
 801ac48:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801ac4a:	20ff      	movs	r0, #255	; 0xff
 801ac4c:	4001      	ands	r1, r0
 801ac4e:	4c5f      	ldr	r4, [pc, #380]	; (801adcc <ppp_vslprintf+0x440>)
 801ac50:	2610      	movs	r6, #16
 801ac52:	19b8      	adds	r0, r7, r6
 801ac54:	9102      	str	r1, [sp, #8]
 801ac56:	9201      	str	r2, [sp, #4]
 801ac58:	9300      	str	r3, [sp, #0]
 801ac5a:	002b      	movs	r3, r5
 801ac5c:	0022      	movs	r2, r4
 801ac5e:	2120      	movs	r1, #32
 801ac60:	f7ff fe7a 	bl	801a958 <ppp_slprintf>
	    str = num;
 801ac64:	19bb      	adds	r3, r7, r6
 801ac66:	647b      	str	r3, [r7, #68]	; 0x44
	    break;
 801ac68:	e18f      	b.n	801af8a <ppp_vslprintf+0x5fe>
	    str[15] = 0;	/* chop off year and newline */
	    break;
#endif /* need port */
	case 'v':		/* "visible" string */
	case 'q':		/* quoted string */
	    quoted = c == 'q';
 801ac6a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ac6c:	3b71      	subs	r3, #113	; 0x71
 801ac6e:	425a      	negs	r2, r3
 801ac70:	4153      	adcs	r3, r2
 801ac72:	b2db      	uxtb	r3, r3
 801ac74:	63bb      	str	r3, [r7, #56]	; 0x38
	    p = va_arg(args, unsigned char *);
 801ac76:	683b      	ldr	r3, [r7, #0]
 801ac78:	1d1a      	adds	r2, r3, #4
 801ac7a:	603a      	str	r2, [r7, #0]
 801ac7c:	681b      	ldr	r3, [r3, #0]
 801ac7e:	643b      	str	r3, [r7, #64]	; 0x40
	    if (p == NULL)
 801ac80:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801ac82:	2b00      	cmp	r3, #0
 801ac84:	d101      	bne.n	801ac8a <ppp_vslprintf+0x2fe>
		p = (const unsigned char *)"<NULL>";
 801ac86:	4b52      	ldr	r3, [pc, #328]	; (801add0 <ppp_vslprintf+0x444>)
 801ac88:	643b      	str	r3, [r7, #64]	; 0x40
	    if (fillch == '0' && prec >= 0) {
 801ac8a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801ac8c:	2b30      	cmp	r3, #48	; 0x30
 801ac8e:	d105      	bne.n	801ac9c <ppp_vslprintf+0x310>
 801ac90:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801ac92:	2b00      	cmp	r3, #0
 801ac94:	db02      	blt.n	801ac9c <ppp_vslprintf+0x310>
		n = prec;
 801ac96:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801ac98:	66bb      	str	r3, [r7, #104]	; 0x68
 801ac9a:	e010      	b.n	801acbe <ppp_vslprintf+0x332>
	    } else {
		n = strlen((const char *)p);
 801ac9c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801ac9e:	0018      	movs	r0, r3
 801aca0:	f7e5 fa32 	bl	8000108 <strlen>
 801aca4:	0003      	movs	r3, r0
 801aca6:	66bb      	str	r3, [r7, #104]	; 0x68
		if (prec >= 0 && n > prec)
 801aca8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801acaa:	2b00      	cmp	r3, #0
 801acac:	da00      	bge.n	801acb0 <ppp_vslprintf+0x324>
 801acae:	e113      	b.n	801aed8 <ppp_vslprintf+0x54c>
 801acb0:	6eba      	ldr	r2, [r7, #104]	; 0x68
 801acb2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801acb4:	429a      	cmp	r2, r3
 801acb6:	dc00      	bgt.n	801acba <ppp_vslprintf+0x32e>
 801acb8:	e10e      	b.n	801aed8 <ppp_vslprintf+0x54c>
		    n = prec;
 801acba:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801acbc:	66bb      	str	r3, [r7, #104]	; 0x68
	    }
	    while (n > 0 && buflen > 0) {
 801acbe:	e10b      	b.n	801aed8 <ppp_vslprintf+0x54c>
		c = *p++;
 801acc0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801acc2:	1c5a      	adds	r2, r3, #1
 801acc4:	643a      	str	r2, [r7, #64]	; 0x40
 801acc6:	781b      	ldrb	r3, [r3, #0]
 801acc8:	66fb      	str	r3, [r7, #108]	; 0x6c
		--n;
 801acca:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801accc:	3b01      	subs	r3, #1
 801acce:	66bb      	str	r3, [r7, #104]	; 0x68
		if (!quoted && c >= 0x80) {
 801acd0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801acd2:	2b00      	cmp	r3, #0
 801acd4:	d11b      	bne.n	801ad0e <ppp_vslprintf+0x382>
 801acd6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801acd8:	2b7f      	cmp	r3, #127	; 0x7f
 801acda:	dd18      	ble.n	801ad0e <ppp_vslprintf+0x382>
		    OUTCHAR('M');
 801acdc:	68bb      	ldr	r3, [r7, #8]
 801acde:	2b00      	cmp	r3, #0
 801ace0:	dd07      	ble.n	801acf2 <ppp_vslprintf+0x366>
 801ace2:	68bb      	ldr	r3, [r7, #8]
 801ace4:	3b01      	subs	r3, #1
 801ace6:	60bb      	str	r3, [r7, #8]
 801ace8:	68fb      	ldr	r3, [r7, #12]
 801acea:	1c5a      	adds	r2, r3, #1
 801acec:	60fa      	str	r2, [r7, #12]
 801acee:	224d      	movs	r2, #77	; 0x4d
 801acf0:	701a      	strb	r2, [r3, #0]
		    OUTCHAR('-');
 801acf2:	68bb      	ldr	r3, [r7, #8]
 801acf4:	2b00      	cmp	r3, #0
 801acf6:	dd07      	ble.n	801ad08 <ppp_vslprintf+0x37c>
 801acf8:	68bb      	ldr	r3, [r7, #8]
 801acfa:	3b01      	subs	r3, #1
 801acfc:	60bb      	str	r3, [r7, #8]
 801acfe:	68fb      	ldr	r3, [r7, #12]
 801ad00:	1c5a      	adds	r2, r3, #1
 801ad02:	60fa      	str	r2, [r7, #12]
 801ad04:	222d      	movs	r2, #45	; 0x2d
 801ad06:	701a      	strb	r2, [r3, #0]
		    c -= 0x80;
 801ad08:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ad0a:	3b80      	subs	r3, #128	; 0x80
 801ad0c:	66fb      	str	r3, [r7, #108]	; 0x6c
		}
		if (quoted && (c == '"' || c == '\\'))
 801ad0e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801ad10:	2b00      	cmp	r3, #0
 801ad12:	d010      	beq.n	801ad36 <ppp_vslprintf+0x3aa>
 801ad14:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ad16:	2b22      	cmp	r3, #34	; 0x22
 801ad18:	d002      	beq.n	801ad20 <ppp_vslprintf+0x394>
 801ad1a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ad1c:	2b5c      	cmp	r3, #92	; 0x5c
 801ad1e:	d10a      	bne.n	801ad36 <ppp_vslprintf+0x3aa>
		    OUTCHAR('\\');
 801ad20:	68bb      	ldr	r3, [r7, #8]
 801ad22:	2b00      	cmp	r3, #0
 801ad24:	dd07      	ble.n	801ad36 <ppp_vslprintf+0x3aa>
 801ad26:	68bb      	ldr	r3, [r7, #8]
 801ad28:	3b01      	subs	r3, #1
 801ad2a:	60bb      	str	r3, [r7, #8]
 801ad2c:	68fb      	ldr	r3, [r7, #12]
 801ad2e:	1c5a      	adds	r2, r3, #1
 801ad30:	60fa      	str	r2, [r7, #12]
 801ad32:	225c      	movs	r2, #92	; 0x5c
 801ad34:	701a      	strb	r2, [r3, #0]
		if (c < 0x20 || (0x7f <= c && c < 0xa0)) {
 801ad36:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ad38:	2b1f      	cmp	r3, #31
 801ad3a:	dd07      	ble.n	801ad4c <ppp_vslprintf+0x3c0>
 801ad3c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ad3e:	2b7e      	cmp	r3, #126	; 0x7e
 801ad40:	dc00      	bgt.n	801ad44 <ppp_vslprintf+0x3b8>
 801ad42:	e0bd      	b.n	801aec0 <ppp_vslprintf+0x534>
 801ad44:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ad46:	2b9f      	cmp	r3, #159	; 0x9f
 801ad48:	dd00      	ble.n	801ad4c <ppp_vslprintf+0x3c0>
 801ad4a:	e0b9      	b.n	801aec0 <ppp_vslprintf+0x534>
		    if (quoted) {
 801ad4c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801ad4e:	2b00      	cmp	r3, #0
 801ad50:	d100      	bne.n	801ad54 <ppp_vslprintf+0x3c8>
 801ad52:	e081      	b.n	801ae58 <ppp_vslprintf+0x4cc>
			OUTCHAR('\\');
 801ad54:	68bb      	ldr	r3, [r7, #8]
 801ad56:	2b00      	cmp	r3, #0
 801ad58:	dd07      	ble.n	801ad6a <ppp_vslprintf+0x3de>
 801ad5a:	68bb      	ldr	r3, [r7, #8]
 801ad5c:	3b01      	subs	r3, #1
 801ad5e:	60bb      	str	r3, [r7, #8]
 801ad60:	68fb      	ldr	r3, [r7, #12]
 801ad62:	1c5a      	adds	r2, r3, #1
 801ad64:	60fa      	str	r2, [r7, #12]
 801ad66:	225c      	movs	r2, #92	; 0x5c
 801ad68:	701a      	strb	r2, [r3, #0]
 801ad6a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ad6c:	2b0c      	cmp	r3, #12
 801ad6e:	d03e      	beq.n	801adee <ppp_vslprintf+0x462>
 801ad70:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ad72:	2b0c      	cmp	r3, #12
 801ad74:	dc47      	bgt.n	801ae06 <ppp_vslprintf+0x47a>
 801ad76:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ad78:	2b0a      	cmp	r3, #10
 801ad7a:	d015      	beq.n	801ada8 <ppp_vslprintf+0x41c>
 801ad7c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ad7e:	2b0a      	cmp	r3, #10
 801ad80:	dc41      	bgt.n	801ae06 <ppp_vslprintf+0x47a>
 801ad82:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ad84:	2b08      	cmp	r3, #8
 801ad86:	d025      	beq.n	801add4 <ppp_vslprintf+0x448>
 801ad88:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ad8a:	2b09      	cmp	r3, #9
 801ad8c:	d13b      	bne.n	801ae06 <ppp_vslprintf+0x47a>
			switch (c) {
			case '\t':	OUTCHAR('t');	break;
 801ad8e:	68bb      	ldr	r3, [r7, #8]
 801ad90:	2b00      	cmp	r3, #0
 801ad92:	dc00      	bgt.n	801ad96 <ppp_vslprintf+0x40a>
 801ad94:	e08c      	b.n	801aeb0 <ppp_vslprintf+0x524>
 801ad96:	68bb      	ldr	r3, [r7, #8]
 801ad98:	3b01      	subs	r3, #1
 801ad9a:	60bb      	str	r3, [r7, #8]
 801ad9c:	68fb      	ldr	r3, [r7, #12]
 801ad9e:	1c5a      	adds	r2, r3, #1
 801ada0:	60fa      	str	r2, [r7, #12]
 801ada2:	2274      	movs	r2, #116	; 0x74
 801ada4:	701a      	strb	r2, [r3, #0]
 801ada6:	e083      	b.n	801aeb0 <ppp_vslprintf+0x524>
			case '\n':	OUTCHAR('n');	break;
 801ada8:	68bb      	ldr	r3, [r7, #8]
 801adaa:	2b00      	cmp	r3, #0
 801adac:	dc00      	bgt.n	801adb0 <ppp_vslprintf+0x424>
 801adae:	e081      	b.n	801aeb4 <ppp_vslprintf+0x528>
 801adb0:	68bb      	ldr	r3, [r7, #8]
 801adb2:	3b01      	subs	r3, #1
 801adb4:	60bb      	str	r3, [r7, #8]
 801adb6:	68fb      	ldr	r3, [r7, #12]
 801adb8:	1c5a      	adds	r2, r3, #1
 801adba:	60fa      	str	r2, [r7, #12]
 801adbc:	226e      	movs	r2, #110	; 0x6e
 801adbe:	701a      	strb	r2, [r3, #0]
 801adc0:	e078      	b.n	801aeb4 <ppp_vslprintf+0x528>
 801adc2:	46c0      	nop			; (mov r8, r8)
 801adc4:	0802202c 	.word	0x0802202c
 801adc8:	08021f10 	.word	0x08021f10
 801adcc:	08021398 	.word	0x08021398
 801add0:	080213a4 	.word	0x080213a4
			case '\b':	OUTCHAR('b');	break;
 801add4:	68bb      	ldr	r3, [r7, #8]
 801add6:	2b00      	cmp	r3, #0
 801add8:	dc00      	bgt.n	801addc <ppp_vslprintf+0x450>
 801adda:	e06d      	b.n	801aeb8 <ppp_vslprintf+0x52c>
 801addc:	68bb      	ldr	r3, [r7, #8]
 801adde:	3b01      	subs	r3, #1
 801ade0:	60bb      	str	r3, [r7, #8]
 801ade2:	68fb      	ldr	r3, [r7, #12]
 801ade4:	1c5a      	adds	r2, r3, #1
 801ade6:	60fa      	str	r2, [r7, #12]
 801ade8:	2262      	movs	r2, #98	; 0x62
 801adea:	701a      	strb	r2, [r3, #0]
 801adec:	e064      	b.n	801aeb8 <ppp_vslprintf+0x52c>
			case '\f':	OUTCHAR('f');	break;
 801adee:	68bb      	ldr	r3, [r7, #8]
 801adf0:	2b00      	cmp	r3, #0
 801adf2:	dd63      	ble.n	801aebc <ppp_vslprintf+0x530>
 801adf4:	68bb      	ldr	r3, [r7, #8]
 801adf6:	3b01      	subs	r3, #1
 801adf8:	60bb      	str	r3, [r7, #8]
 801adfa:	68fb      	ldr	r3, [r7, #12]
 801adfc:	1c5a      	adds	r2, r3, #1
 801adfe:	60fa      	str	r2, [r7, #12]
 801ae00:	2266      	movs	r2, #102	; 0x66
 801ae02:	701a      	strb	r2, [r3, #0]
 801ae04:	e05a      	b.n	801aebc <ppp_vslprintf+0x530>
			default:
			    OUTCHAR('x');
 801ae06:	68bb      	ldr	r3, [r7, #8]
 801ae08:	2b00      	cmp	r3, #0
 801ae0a:	dd07      	ble.n	801ae1c <ppp_vslprintf+0x490>
 801ae0c:	68bb      	ldr	r3, [r7, #8]
 801ae0e:	3b01      	subs	r3, #1
 801ae10:	60bb      	str	r3, [r7, #8]
 801ae12:	68fb      	ldr	r3, [r7, #12]
 801ae14:	1c5a      	adds	r2, r3, #1
 801ae16:	60fa      	str	r2, [r7, #12]
 801ae18:	2278      	movs	r2, #120	; 0x78
 801ae1a:	701a      	strb	r2, [r3, #0]
			    OUTCHAR(hexchars[c >> 4]);
 801ae1c:	68bb      	ldr	r3, [r7, #8]
 801ae1e:	2b00      	cmp	r3, #0
 801ae20:	dd0a      	ble.n	801ae38 <ppp_vslprintf+0x4ac>
 801ae22:	68bb      	ldr	r3, [r7, #8]
 801ae24:	3b01      	subs	r3, #1
 801ae26:	60bb      	str	r3, [r7, #8]
 801ae28:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ae2a:	111a      	asrs	r2, r3, #4
 801ae2c:	68fb      	ldr	r3, [r7, #12]
 801ae2e:	1c59      	adds	r1, r3, #1
 801ae30:	60f9      	str	r1, [r7, #12]
 801ae32:	49ac      	ldr	r1, [pc, #688]	; (801b0e4 <ppp_vslprintf+0x758>)
 801ae34:	5c8a      	ldrb	r2, [r1, r2]
 801ae36:	701a      	strb	r2, [r3, #0]
			    OUTCHAR(hexchars[c & 0xf]);
 801ae38:	68bb      	ldr	r3, [r7, #8]
 801ae3a:	2b00      	cmp	r3, #0
 801ae3c:	dd4c      	ble.n	801aed8 <ppp_vslprintf+0x54c>
 801ae3e:	68bb      	ldr	r3, [r7, #8]
 801ae40:	3b01      	subs	r3, #1
 801ae42:	60bb      	str	r3, [r7, #8]
 801ae44:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ae46:	220f      	movs	r2, #15
 801ae48:	401a      	ands	r2, r3
 801ae4a:	68fb      	ldr	r3, [r7, #12]
 801ae4c:	1c59      	adds	r1, r3, #1
 801ae4e:	60f9      	str	r1, [r7, #12]
 801ae50:	49a4      	ldr	r1, [pc, #656]	; (801b0e4 <ppp_vslprintf+0x758>)
 801ae52:	5c8a      	ldrb	r2, [r1, r2]
 801ae54:	701a      	strb	r2, [r3, #0]
 801ae56:	e03f      	b.n	801aed8 <ppp_vslprintf+0x54c>
			}
		    } else {
			if (c == '\t')
 801ae58:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ae5a:	2b09      	cmp	r3, #9
 801ae5c:	d10c      	bne.n	801ae78 <ppp_vslprintf+0x4ec>
			    OUTCHAR(c);
 801ae5e:	68bb      	ldr	r3, [r7, #8]
 801ae60:	2b00      	cmp	r3, #0
 801ae62:	dd39      	ble.n	801aed8 <ppp_vslprintf+0x54c>
 801ae64:	68bb      	ldr	r3, [r7, #8]
 801ae66:	3b01      	subs	r3, #1
 801ae68:	60bb      	str	r3, [r7, #8]
 801ae6a:	68fb      	ldr	r3, [r7, #12]
 801ae6c:	1c5a      	adds	r2, r3, #1
 801ae6e:	60fa      	str	r2, [r7, #12]
 801ae70:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801ae72:	b2d2      	uxtb	r2, r2
 801ae74:	701a      	strb	r2, [r3, #0]
 801ae76:	e02f      	b.n	801aed8 <ppp_vslprintf+0x54c>
			else {
			    OUTCHAR('^');
 801ae78:	68bb      	ldr	r3, [r7, #8]
 801ae7a:	2b00      	cmp	r3, #0
 801ae7c:	dd07      	ble.n	801ae8e <ppp_vslprintf+0x502>
 801ae7e:	68bb      	ldr	r3, [r7, #8]
 801ae80:	3b01      	subs	r3, #1
 801ae82:	60bb      	str	r3, [r7, #8]
 801ae84:	68fb      	ldr	r3, [r7, #12]
 801ae86:	1c5a      	adds	r2, r3, #1
 801ae88:	60fa      	str	r2, [r7, #12]
 801ae8a:	225e      	movs	r2, #94	; 0x5e
 801ae8c:	701a      	strb	r2, [r3, #0]
			    OUTCHAR(c ^ 0x40);
 801ae8e:	68bb      	ldr	r3, [r7, #8]
 801ae90:	2b00      	cmp	r3, #0
 801ae92:	dd21      	ble.n	801aed8 <ppp_vslprintf+0x54c>
 801ae94:	68bb      	ldr	r3, [r7, #8]
 801ae96:	3b01      	subs	r3, #1
 801ae98:	60bb      	str	r3, [r7, #8]
 801ae9a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ae9c:	b25b      	sxtb	r3, r3
 801ae9e:	2240      	movs	r2, #64	; 0x40
 801aea0:	4053      	eors	r3, r2
 801aea2:	b259      	sxtb	r1, r3
 801aea4:	68fb      	ldr	r3, [r7, #12]
 801aea6:	1c5a      	adds	r2, r3, #1
 801aea8:	60fa      	str	r2, [r7, #12]
 801aeaa:	b2ca      	uxtb	r2, r1
 801aeac:	701a      	strb	r2, [r3, #0]
 801aeae:	e013      	b.n	801aed8 <ppp_vslprintf+0x54c>
			case '\t':	OUTCHAR('t');	break;
 801aeb0:	46c0      	nop			; (mov r8, r8)
 801aeb2:	e011      	b.n	801aed8 <ppp_vslprintf+0x54c>
			case '\n':	OUTCHAR('n');	break;
 801aeb4:	46c0      	nop			; (mov r8, r8)
 801aeb6:	e00f      	b.n	801aed8 <ppp_vslprintf+0x54c>
			case '\b':	OUTCHAR('b');	break;
 801aeb8:	46c0      	nop			; (mov r8, r8)
 801aeba:	e00d      	b.n	801aed8 <ppp_vslprintf+0x54c>
			case '\f':	OUTCHAR('f');	break;
 801aebc:	46c0      	nop			; (mov r8, r8)
		    if (quoted) {
 801aebe:	e00b      	b.n	801aed8 <ppp_vslprintf+0x54c>
			}
		    }
		} else
		    OUTCHAR(c);
 801aec0:	68bb      	ldr	r3, [r7, #8]
 801aec2:	2b00      	cmp	r3, #0
 801aec4:	dd08      	ble.n	801aed8 <ppp_vslprintf+0x54c>
 801aec6:	68bb      	ldr	r3, [r7, #8]
 801aec8:	3b01      	subs	r3, #1
 801aeca:	60bb      	str	r3, [r7, #8]
 801aecc:	68fb      	ldr	r3, [r7, #12]
 801aece:	1c5a      	adds	r2, r3, #1
 801aed0:	60fa      	str	r2, [r7, #12]
 801aed2:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801aed4:	b2d2      	uxtb	r2, r2
 801aed6:	701a      	strb	r2, [r3, #0]
	    while (n > 0 && buflen > 0) {
 801aed8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801aeda:	2b00      	cmp	r3, #0
 801aedc:	dc00      	bgt.n	801aee0 <ppp_vslprintf+0x554>
 801aede:	e0f0      	b.n	801b0c2 <ppp_vslprintf+0x736>
 801aee0:	68bb      	ldr	r3, [r7, #8]
 801aee2:	2b00      	cmp	r3, #0
 801aee4:	dd00      	ble.n	801aee8 <ppp_vslprintf+0x55c>
 801aee6:	e6eb      	b.n	801acc0 <ppp_vslprintf+0x334>
	    }
	    continue;
 801aee8:	e0eb      	b.n	801b0c2 <ppp_vslprintf+0x736>
	    buf = bufinfo.ptr;
	    buflen = bufinfo.len - 1;
	    continue;
#endif /* PRINTPKT_SUPPORT */
	case 'B':
	    p = va_arg(args, unsigned char *);
 801aeea:	683b      	ldr	r3, [r7, #0]
 801aeec:	1d1a      	adds	r2, r3, #4
 801aeee:	603a      	str	r2, [r7, #0]
 801aef0:	681b      	ldr	r3, [r3, #0]
 801aef2:	643b      	str	r3, [r7, #64]	; 0x40
	    for (n = prec; n > 0; --n) {
 801aef4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801aef6:	66bb      	str	r3, [r7, #104]	; 0x68
 801aef8:	e034      	b.n	801af64 <ppp_vslprintf+0x5d8>
		c = *p++;
 801aefa:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801aefc:	1c5a      	adds	r2, r3, #1
 801aefe:	643a      	str	r2, [r7, #64]	; 0x40
 801af00:	781b      	ldrb	r3, [r3, #0]
 801af02:	66fb      	str	r3, [r7, #108]	; 0x6c
		if (fillch == ' ')
 801af04:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801af06:	2b20      	cmp	r3, #32
 801af08:	d10a      	bne.n	801af20 <ppp_vslprintf+0x594>
		    OUTCHAR(' ');
 801af0a:	68bb      	ldr	r3, [r7, #8]
 801af0c:	2b00      	cmp	r3, #0
 801af0e:	dd07      	ble.n	801af20 <ppp_vslprintf+0x594>
 801af10:	68bb      	ldr	r3, [r7, #8]
 801af12:	3b01      	subs	r3, #1
 801af14:	60bb      	str	r3, [r7, #8]
 801af16:	68fb      	ldr	r3, [r7, #12]
 801af18:	1c5a      	adds	r2, r3, #1
 801af1a:	60fa      	str	r2, [r7, #12]
 801af1c:	2220      	movs	r2, #32
 801af1e:	701a      	strb	r2, [r3, #0]
		OUTCHAR(hexchars[(c >> 4) & 0xf]);
 801af20:	68bb      	ldr	r3, [r7, #8]
 801af22:	2b00      	cmp	r3, #0
 801af24:	dd0c      	ble.n	801af40 <ppp_vslprintf+0x5b4>
 801af26:	68bb      	ldr	r3, [r7, #8]
 801af28:	3b01      	subs	r3, #1
 801af2a:	60bb      	str	r3, [r7, #8]
 801af2c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801af2e:	111b      	asrs	r3, r3, #4
 801af30:	220f      	movs	r2, #15
 801af32:	401a      	ands	r2, r3
 801af34:	68fb      	ldr	r3, [r7, #12]
 801af36:	1c59      	adds	r1, r3, #1
 801af38:	60f9      	str	r1, [r7, #12]
 801af3a:	496a      	ldr	r1, [pc, #424]	; (801b0e4 <ppp_vslprintf+0x758>)
 801af3c:	5c8a      	ldrb	r2, [r1, r2]
 801af3e:	701a      	strb	r2, [r3, #0]
		OUTCHAR(hexchars[c & 0xf]);
 801af40:	68bb      	ldr	r3, [r7, #8]
 801af42:	2b00      	cmp	r3, #0
 801af44:	dd0b      	ble.n	801af5e <ppp_vslprintf+0x5d2>
 801af46:	68bb      	ldr	r3, [r7, #8]
 801af48:	3b01      	subs	r3, #1
 801af4a:	60bb      	str	r3, [r7, #8]
 801af4c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801af4e:	220f      	movs	r2, #15
 801af50:	401a      	ands	r2, r3
 801af52:	68fb      	ldr	r3, [r7, #12]
 801af54:	1c59      	adds	r1, r3, #1
 801af56:	60f9      	str	r1, [r7, #12]
 801af58:	4962      	ldr	r1, [pc, #392]	; (801b0e4 <ppp_vslprintf+0x758>)
 801af5a:	5c8a      	ldrb	r2, [r1, r2]
 801af5c:	701a      	strb	r2, [r3, #0]
	    for (n = prec; n > 0; --n) {
 801af5e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801af60:	3b01      	subs	r3, #1
 801af62:	66bb      	str	r3, [r7, #104]	; 0x68
 801af64:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801af66:	2b00      	cmp	r3, #0
 801af68:	dcc7      	bgt.n	801aefa <ppp_vslprintf+0x56e>
	    }
	    continue;
 801af6a:	e0aa      	b.n	801b0c2 <ppp_vslprintf+0x736>
	default:
	    *buf++ = '%';
 801af6c:	68fb      	ldr	r3, [r7, #12]
 801af6e:	1c5a      	adds	r2, r3, #1
 801af70:	60fa      	str	r2, [r7, #12]
 801af72:	2225      	movs	r2, #37	; 0x25
 801af74:	701a      	strb	r2, [r3, #0]
	    if (c != '%')
 801af76:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801af78:	2b25      	cmp	r3, #37	; 0x25
 801af7a:	d002      	beq.n	801af82 <ppp_vslprintf+0x5f6>
		--fmt;		/* so %z outputs %z etc. */
 801af7c:	687b      	ldr	r3, [r7, #4]
 801af7e:	3b01      	subs	r3, #1
 801af80:	607b      	str	r3, [r7, #4]
	    --buflen;
 801af82:	68bb      	ldr	r3, [r7, #8]
 801af84:	3b01      	subs	r3, #1
 801af86:	60bb      	str	r3, [r7, #8]
	    continue;
 801af88:	e09b      	b.n	801b0c2 <ppp_vslprintf+0x736>
	}
	if (base != 0) {
 801af8a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801af8c:	2b00      	cmp	r3, #0
 801af8e:	d054      	beq.n	801b03a <ppp_vslprintf+0x6ae>
	    str = num + sizeof(num);
 801af90:	2310      	movs	r3, #16
 801af92:	18fb      	adds	r3, r7, r3
 801af94:	3320      	adds	r3, #32
 801af96:	647b      	str	r3, [r7, #68]	; 0x44
	    *--str = 0;
 801af98:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801af9a:	3b01      	subs	r3, #1
 801af9c:	647b      	str	r3, [r7, #68]	; 0x44
 801af9e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801afa0:	2200      	movs	r2, #0
 801afa2:	701a      	strb	r2, [r3, #0]
	    while (str > num + neg) {
 801afa4:	e01e      	b.n	801afe4 <ppp_vslprintf+0x658>
		*--str = hexchars[val % base];
 801afa6:	6dba      	ldr	r2, [r7, #88]	; 0x58
 801afa8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801afaa:	0011      	movs	r1, r2
 801afac:	0018      	movs	r0, r3
 801afae:	f7e5 f943 	bl	8000238 <__aeabi_uidivmod>
 801afb2:	000b      	movs	r3, r1
 801afb4:	001a      	movs	r2, r3
 801afb6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801afb8:	3b01      	subs	r3, #1
 801afba:	647b      	str	r3, [r7, #68]	; 0x44
 801afbc:	4b49      	ldr	r3, [pc, #292]	; (801b0e4 <ppp_vslprintf+0x758>)
 801afbe:	5c9a      	ldrb	r2, [r3, r2]
 801afc0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801afc2:	701a      	strb	r2, [r3, #0]
		val = val / base;
 801afc4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801afc6:	0019      	movs	r1, r3
 801afc8:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 801afca:	f7e5 f8af 	bl	800012c <__udivsi3>
 801afce:	0003      	movs	r3, r0
 801afd0:	64fb      	str	r3, [r7, #76]	; 0x4c
		if (--prec <= 0 && val == 0)
 801afd2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801afd4:	3b01      	subs	r3, #1
 801afd6:	663b      	str	r3, [r7, #96]	; 0x60
 801afd8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801afda:	2b00      	cmp	r3, #0
 801afdc:	dc02      	bgt.n	801afe4 <ppp_vslprintf+0x658>
 801afde:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801afe0:	2b00      	cmp	r3, #0
 801afe2:	d007      	beq.n	801aff4 <ppp_vslprintf+0x668>
	    while (str > num + neg) {
 801afe4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801afe6:	2210      	movs	r2, #16
 801afe8:	18ba      	adds	r2, r7, r2
 801afea:	18d3      	adds	r3, r2, r3
 801afec:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801afee:	429a      	cmp	r2, r3
 801aff0:	d8d9      	bhi.n	801afa6 <ppp_vslprintf+0x61a>
 801aff2:	e000      	b.n	801aff6 <ppp_vslprintf+0x66a>
		    break;
 801aff4:	46c0      	nop			; (mov r8, r8)
	    }
	    switch (neg) {
 801aff6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801aff8:	2b01      	cmp	r3, #1
 801affa:	d003      	beq.n	801b004 <ppp_vslprintf+0x678>
 801affc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801affe:	2b02      	cmp	r3, #2
 801b000:	d007      	beq.n	801b012 <ppp_vslprintf+0x686>
	    case 2:
		*--str = 'x';
		*--str = '0';
		break;
	    default:
		break;
 801b002:	e013      	b.n	801b02c <ppp_vslprintf+0x6a0>
		*--str = '-';
 801b004:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b006:	3b01      	subs	r3, #1
 801b008:	647b      	str	r3, [r7, #68]	; 0x44
 801b00a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b00c:	222d      	movs	r2, #45	; 0x2d
 801b00e:	701a      	strb	r2, [r3, #0]
		break;
 801b010:	e00c      	b.n	801b02c <ppp_vslprintf+0x6a0>
		*--str = 'x';
 801b012:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b014:	3b01      	subs	r3, #1
 801b016:	647b      	str	r3, [r7, #68]	; 0x44
 801b018:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b01a:	2278      	movs	r2, #120	; 0x78
 801b01c:	701a      	strb	r2, [r3, #0]
		*--str = '0';
 801b01e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b020:	3b01      	subs	r3, #1
 801b022:	647b      	str	r3, [r7, #68]	; 0x44
 801b024:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b026:	2230      	movs	r2, #48	; 0x30
 801b028:	701a      	strb	r2, [r3, #0]
		break;
 801b02a:	46c0      	nop			; (mov r8, r8)
	    }
	    len = num + sizeof(num) - 1 - str;
 801b02c:	2310      	movs	r3, #16
 801b02e:	18fb      	adds	r3, r7, r3
 801b030:	331f      	adds	r3, #31
 801b032:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801b034:	1a9b      	subs	r3, r3, r2
 801b036:	657b      	str	r3, [r7, #84]	; 0x54
 801b038:	e00e      	b.n	801b058 <ppp_vslprintf+0x6cc>
	} else {
	    len = strlen(str);
 801b03a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b03c:	0018      	movs	r0, r3
 801b03e:	f7e5 f863 	bl	8000108 <strlen>
 801b042:	0003      	movs	r3, r0
 801b044:	657b      	str	r3, [r7, #84]	; 0x54
	    if (prec >= 0 && len > prec)
 801b046:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b048:	2b00      	cmp	r3, #0
 801b04a:	db05      	blt.n	801b058 <ppp_vslprintf+0x6cc>
 801b04c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801b04e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b050:	429a      	cmp	r2, r3
 801b052:	dd01      	ble.n	801b058 <ppp_vslprintf+0x6cc>
		len = prec;
 801b054:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801b056:	657b      	str	r3, [r7, #84]	; 0x54
	}
	if (width > 0) {
 801b058:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801b05a:	2b00      	cmp	r3, #0
 801b05c:	dd1d      	ble.n	801b09a <ppp_vslprintf+0x70e>
	    if (width > buflen)
 801b05e:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801b060:	68bb      	ldr	r3, [r7, #8]
 801b062:	429a      	cmp	r2, r3
 801b064:	dd01      	ble.n	801b06a <ppp_vslprintf+0x6de>
		width = buflen;
 801b066:	68bb      	ldr	r3, [r7, #8]
 801b068:	667b      	str	r3, [r7, #100]	; 0x64
	    if ((n = width - len) > 0) {
 801b06a:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801b06c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801b06e:	1ad3      	subs	r3, r2, r3
 801b070:	66bb      	str	r3, [r7, #104]	; 0x68
 801b072:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b074:	2b00      	cmp	r3, #0
 801b076:	dd10      	ble.n	801b09a <ppp_vslprintf+0x70e>
		buflen -= n;
 801b078:	68ba      	ldr	r2, [r7, #8]
 801b07a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b07c:	1ad3      	subs	r3, r2, r3
 801b07e:	60bb      	str	r3, [r7, #8]
		for (; n > 0; --n)
 801b080:	e008      	b.n	801b094 <ppp_vslprintf+0x708>
		    *buf++ = fillch;
 801b082:	68fb      	ldr	r3, [r7, #12]
 801b084:	1c5a      	adds	r2, r3, #1
 801b086:	60fa      	str	r2, [r7, #12]
 801b088:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801b08a:	b2d2      	uxtb	r2, r2
 801b08c:	701a      	strb	r2, [r3, #0]
		for (; n > 0; --n)
 801b08e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b090:	3b01      	subs	r3, #1
 801b092:	66bb      	str	r3, [r7, #104]	; 0x68
 801b094:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b096:	2b00      	cmp	r3, #0
 801b098:	dcf3      	bgt.n	801b082 <ppp_vslprintf+0x6f6>
	    }
	}
	if (len > buflen)
 801b09a:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801b09c:	68bb      	ldr	r3, [r7, #8]
 801b09e:	429a      	cmp	r2, r3
 801b0a0:	dd01      	ble.n	801b0a6 <ppp_vslprintf+0x71a>
	    len = buflen;
 801b0a2:	68bb      	ldr	r3, [r7, #8]
 801b0a4:	657b      	str	r3, [r7, #84]	; 0x54
	memcpy(buf, str, len);
 801b0a6:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801b0a8:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801b0aa:	68fb      	ldr	r3, [r7, #12]
 801b0ac:	0018      	movs	r0, r3
 801b0ae:	f001 fba1 	bl	801c7f4 <memcpy>
	buf += len;
 801b0b2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801b0b4:	68fa      	ldr	r2, [r7, #12]
 801b0b6:	18d3      	adds	r3, r2, r3
 801b0b8:	60fb      	str	r3, [r7, #12]
	buflen -= len;
 801b0ba:	68ba      	ldr	r2, [r7, #8]
 801b0bc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801b0be:	1ad3      	subs	r3, r2, r3
 801b0c0:	60bb      	str	r3, [r7, #8]
    while (buflen > 0) {
 801b0c2:	68bb      	ldr	r3, [r7, #8]
 801b0c4:	2b00      	cmp	r3, #0
 801b0c6:	dd00      	ble.n	801b0ca <ppp_vslprintf+0x73e>
 801b0c8:	e470      	b.n	801a9ac <ppp_vslprintf+0x20>
 801b0ca:	e000      	b.n	801b0ce <ppp_vslprintf+0x742>
	    break;
 801b0cc:	46c0      	nop			; (mov r8, r8)
    }
    *buf = 0;
 801b0ce:	68fb      	ldr	r3, [r7, #12]
 801b0d0:	2200      	movs	r2, #0
 801b0d2:	701a      	strb	r2, [r3, #0]
    return buf - buf0;
 801b0d4:	68fa      	ldr	r2, [r7, #12]
 801b0d6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b0d8:	1ad3      	subs	r3, r2, r3
}
 801b0da:	0018      	movs	r0, r3
 801b0dc:	46bd      	mov	sp, r7
 801b0de:	b01d      	add	sp, #116	; 0x74
 801b0e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801b0e2:	46c0      	nop			; (mov r8, r8)
 801b0e4:	20000218 	.word	0x20000218

0801b0e8 <ppp_logit>:
}

/*
 * ppp_logit - does the hard work for fatal et al.
 */
static void ppp_logit(int level, const char *fmt, va_list args) {
 801b0e8:	b590      	push	{r4, r7, lr}
 801b0ea:	4c0c      	ldr	r4, [pc, #48]	; (801b11c <ppp_logit+0x34>)
 801b0ec:	44a5      	add	sp, r4
 801b0ee:	af00      	add	r7, sp, #0
 801b0f0:	60f8      	str	r0, [r7, #12]
 801b0f2:	60b9      	str	r1, [r7, #8]
 801b0f4:	607a      	str	r2, [r7, #4]
    char buf[1024];

    ppp_vslprintf(buf, sizeof(buf), fmt, args);
 801b0f6:	687b      	ldr	r3, [r7, #4]
 801b0f8:	68ba      	ldr	r2, [r7, #8]
 801b0fa:	2180      	movs	r1, #128	; 0x80
 801b0fc:	00c9      	lsls	r1, r1, #3
 801b0fe:	2410      	movs	r4, #16
 801b100:	1938      	adds	r0, r7, r4
 801b102:	f7ff fc43 	bl	801a98c <ppp_vslprintf>
    ppp_log_write(level, buf);
 801b106:	193a      	adds	r2, r7, r4
 801b108:	68fb      	ldr	r3, [r7, #12]
 801b10a:	0011      	movs	r1, r2
 801b10c:	0018      	movs	r0, r3
 801b10e:	f000 f809 	bl	801b124 <ppp_log_write>
}
 801b112:	46c0      	nop			; (mov r8, r8)
 801b114:	46bd      	mov	sp, r7
 801b116:	4b02      	ldr	r3, [pc, #8]	; (801b120 <ppp_logit+0x38>)
 801b118:	449d      	add	sp, r3
 801b11a:	bd90      	pop	{r4, r7, pc}
 801b11c:	fffffbec 	.word	0xfffffbec
 801b120:	00000414 	.word	0x00000414

0801b124 <ppp_log_write>:

static void ppp_log_write(int level, char *buf) {
 801b124:	b580      	push	{r7, lr}
 801b126:	b082      	sub	sp, #8
 801b128:	af00      	add	r7, sp, #0
 801b12a:	6078      	str	r0, [r7, #4]
 801b12c:	6039      	str	r1, [r7, #0]
	if (write(log_to_fd, buf, n) != n
	    || write(log_to_fd, "\n", 1) != 1)
	    log_to_fd = -1;
    }
#endif
}
 801b12e:	46c0      	nop			; (mov r8, r8)
 801b130:	46bd      	mov	sp, r7
 801b132:	b002      	add	sp, #8
 801b134:	bd80      	pop	{r7, pc}

0801b136 <ppp_error>:
}

/*
 * ppp_error - log an error message.
 */
void ppp_error(const char *fmt, ...) {
 801b136:	b40f      	push	{r0, r1, r2, r3}
 801b138:	b580      	push	{r7, lr}
 801b13a:	b082      	sub	sp, #8
 801b13c:	af00      	add	r7, sp, #0
    va_list pvar;

    va_start(pvar, fmt);
 801b13e:	2314      	movs	r3, #20
 801b140:	18fb      	adds	r3, r7, r3
 801b142:	607b      	str	r3, [r7, #4]
    ppp_logit(LOG_ERR, fmt, pvar);
 801b144:	687a      	ldr	r2, [r7, #4]
 801b146:	693b      	ldr	r3, [r7, #16]
 801b148:	0019      	movs	r1, r3
 801b14a:	2003      	movs	r0, #3
 801b14c:	f7ff ffcc 	bl	801b0e8 <ppp_logit>
    va_end(pvar);
#if 0 /* UNUSED */
    ++error_count;
#endif /* UNUSED */
}
 801b150:	46c0      	nop			; (mov r8, r8)
 801b152:	46bd      	mov	sp, r7
 801b154:	b002      	add	sp, #8
 801b156:	bc80      	pop	{r7}
 801b158:	bc08      	pop	{r3}
 801b15a:	b004      	add	sp, #16
 801b15c:	4718      	bx	r3

0801b15e <ppp_warn>:

/*
 * ppp_warn - log a warning message.
 */
void ppp_warn(const char *fmt, ...) {
 801b15e:	b40f      	push	{r0, r1, r2, r3}
 801b160:	b580      	push	{r7, lr}
 801b162:	b082      	sub	sp, #8
 801b164:	af00      	add	r7, sp, #0
    va_list pvar;

    va_start(pvar, fmt);
 801b166:	2314      	movs	r3, #20
 801b168:	18fb      	adds	r3, r7, r3
 801b16a:	607b      	str	r3, [r7, #4]
    ppp_logit(LOG_WARNING, fmt, pvar);
 801b16c:	687a      	ldr	r2, [r7, #4]
 801b16e:	693b      	ldr	r3, [r7, #16]
 801b170:	0019      	movs	r1, r3
 801b172:	2001      	movs	r0, #1
 801b174:	f7ff ffb8 	bl	801b0e8 <ppp_logit>
    va_end(pvar);
}
 801b178:	46c0      	nop			; (mov r8, r8)
 801b17a:	46bd      	mov	sp, r7
 801b17c:	b002      	add	sp, #8
 801b17e:	bc80      	pop	{r7}
 801b180:	bc08      	pop	{r3}
 801b182:	b004      	add	sp, #16
 801b184:	4718      	bx	r3

0801b186 <ppp_notice>:

/*
 * ppp_notice - log a notice-level message.
 */
void ppp_notice(const char *fmt, ...) {
 801b186:	b40f      	push	{r0, r1, r2, r3}
 801b188:	b580      	push	{r7, lr}
 801b18a:	b082      	sub	sp, #8
 801b18c:	af00      	add	r7, sp, #0
    va_list pvar;

    va_start(pvar, fmt);
 801b18e:	2314      	movs	r3, #20
 801b190:	18fb      	adds	r3, r7, r3
 801b192:	607b      	str	r3, [r7, #4]
    ppp_logit(LOG_NOTICE, fmt, pvar);
 801b194:	687a      	ldr	r2, [r7, #4]
 801b196:	693b      	ldr	r3, [r7, #16]
 801b198:	0019      	movs	r1, r3
 801b19a:	2001      	movs	r0, #1
 801b19c:	f7ff ffa4 	bl	801b0e8 <ppp_logit>
    va_end(pvar);
}
 801b1a0:	46c0      	nop			; (mov r8, r8)
 801b1a2:	46bd      	mov	sp, r7
 801b1a4:	b002      	add	sp, #8
 801b1a6:	bc80      	pop	{r7}
 801b1a8:	bc08      	pop	{r3}
 801b1aa:	b004      	add	sp, #16
 801b1ac:	4718      	bx	r3

0801b1ae <ppp_info>:

/*
 * ppp_info - log an informational message.
 */
void ppp_info(const char *fmt, ...) {
 801b1ae:	b40f      	push	{r0, r1, r2, r3}
 801b1b0:	b580      	push	{r7, lr}
 801b1b2:	b082      	sub	sp, #8
 801b1b4:	af00      	add	r7, sp, #0
    va_list pvar;

    va_start(pvar, fmt);
 801b1b6:	2314      	movs	r3, #20
 801b1b8:	18fb      	adds	r3, r7, r3
 801b1ba:	607b      	str	r3, [r7, #4]
    ppp_logit(LOG_INFO, fmt, pvar);
 801b1bc:	687a      	ldr	r2, [r7, #4]
 801b1be:	693b      	ldr	r3, [r7, #16]
 801b1c0:	0019      	movs	r1, r3
 801b1c2:	2000      	movs	r0, #0
 801b1c4:	f7ff ff90 	bl	801b0e8 <ppp_logit>
    va_end(pvar);
}
 801b1c8:	46c0      	nop			; (mov r8, r8)
 801b1ca:	46bd      	mov	sp, r7
 801b1cc:	b002      	add	sp, #8
 801b1ce:	bc80      	pop	{r7}
 801b1d0:	bc08      	pop	{r3}
 801b1d2:	b004      	add	sp, #16
 801b1d4:	4718      	bx	r3

0801b1d6 <ppp_dbglog>:

/*
 * ppp_dbglog - log a debug message.
 */
void ppp_dbglog(const char *fmt, ...) {
 801b1d6:	b40f      	push	{r0, r1, r2, r3}
 801b1d8:	b580      	push	{r7, lr}
 801b1da:	b082      	sub	sp, #8
 801b1dc:	af00      	add	r7, sp, #0
    va_list pvar;

    va_start(pvar, fmt);
 801b1de:	2314      	movs	r3, #20
 801b1e0:	18fb      	adds	r3, r7, r3
 801b1e2:	607b      	str	r3, [r7, #4]
    ppp_logit(LOG_DEBUG, fmt, pvar);
 801b1e4:	687a      	ldr	r2, [r7, #4]
 801b1e6:	693b      	ldr	r3, [r7, #16]
 801b1e8:	0019      	movs	r1, r3
 801b1ea:	2000      	movs	r0, #0
 801b1ec:	f7ff ff7c 	bl	801b0e8 <ppp_logit>
    va_end(pvar);
}
 801b1f0:	46c0      	nop			; (mov r8, r8)
 801b1f2:	46bd      	mov	sp, r7
 801b1f4:	b002      	add	sp, #8
 801b1f6:	bc80      	pop	{r7}
 801b1f8:	bc08      	pop	{r3}
 801b1fa:	b004      	add	sp, #16
 801b1fc:	4718      	bx	r3

0801b1fe <vj_compress_init>:
#define INCR(counter)
#endif

void
vj_compress_init(struct vjcompress *comp)
{
 801b1fe:	b580      	push	{r7, lr}
 801b200:	b084      	sub	sp, #16
 801b202:	af00      	add	r7, sp, #0
 801b204:	6078      	str	r0, [r7, #4]
  u8_t i;
  struct cstate *tstate = comp->tstate;
 801b206:	687b      	ldr	r3, [r7, #4]
 801b208:	330c      	adds	r3, #12
 801b20a:	60bb      	str	r3, [r7, #8]

#if MAX_SLOTS == 0
  memset((char *)comp, 0, sizeof(*comp));
#endif
  comp->maxSlotIndex = MAX_SLOTS - 1;
 801b20c:	687b      	ldr	r3, [r7, #4]
 801b20e:	220f      	movs	r2, #15
 801b210:	721a      	strb	r2, [r3, #8]
  comp->compressSlot = 0;    /* Disable slot ID compression by default. */
 801b212:	687b      	ldr	r3, [r7, #4]
 801b214:	2200      	movs	r2, #0
 801b216:	725a      	strb	r2, [r3, #9]
  for (i = MAX_SLOTS - 1; i > 0; --i) {
 801b218:	230f      	movs	r3, #15
 801b21a:	18fb      	adds	r3, r7, r3
 801b21c:	220f      	movs	r2, #15
 801b21e:	701a      	strb	r2, [r3, #0]
 801b220:	e025      	b.n	801b26e <vj_compress_init+0x70>
    tstate[i].cs_id = i;
 801b222:	200f      	movs	r0, #15
 801b224:	183b      	adds	r3, r7, r0
 801b226:	781a      	ldrb	r2, [r3, #0]
 801b228:	0013      	movs	r3, r2
 801b22a:	011b      	lsls	r3, r3, #4
 801b22c:	189b      	adds	r3, r3, r2
 801b22e:	00db      	lsls	r3, r3, #3
 801b230:	001a      	movs	r2, r3
 801b232:	68bb      	ldr	r3, [r7, #8]
 801b234:	189b      	adds	r3, r3, r2
 801b236:	183a      	adds	r2, r7, r0
 801b238:	7812      	ldrb	r2, [r2, #0]
 801b23a:	719a      	strb	r2, [r3, #6]
    tstate[i].cs_next = &tstate[i - 1];
 801b23c:	183b      	adds	r3, r7, r0
 801b23e:	781a      	ldrb	r2, [r3, #0]
 801b240:	0013      	movs	r3, r2
 801b242:	011b      	lsls	r3, r3, #4
 801b244:	189b      	adds	r3, r3, r2
 801b246:	00db      	lsls	r3, r3, #3
 801b248:	3b88      	subs	r3, #136	; 0x88
 801b24a:	0019      	movs	r1, r3
 801b24c:	183b      	adds	r3, r7, r0
 801b24e:	781a      	ldrb	r2, [r3, #0]
 801b250:	0013      	movs	r3, r2
 801b252:	011b      	lsls	r3, r3, #4
 801b254:	189b      	adds	r3, r3, r2
 801b256:	00db      	lsls	r3, r3, #3
 801b258:	001a      	movs	r2, r3
 801b25a:	68bb      	ldr	r3, [r7, #8]
 801b25c:	189b      	adds	r3, r3, r2
 801b25e:	68ba      	ldr	r2, [r7, #8]
 801b260:	1852      	adds	r2, r2, r1
 801b262:	601a      	str	r2, [r3, #0]
  for (i = MAX_SLOTS - 1; i > 0; --i) {
 801b264:	183b      	adds	r3, r7, r0
 801b266:	183a      	adds	r2, r7, r0
 801b268:	7812      	ldrb	r2, [r2, #0]
 801b26a:	3a01      	subs	r2, #1
 801b26c:	701a      	strb	r2, [r3, #0]
 801b26e:	230f      	movs	r3, #15
 801b270:	18fb      	adds	r3, r7, r3
 801b272:	781b      	ldrb	r3, [r3, #0]
 801b274:	2b00      	cmp	r3, #0
 801b276:	d1d4      	bne.n	801b222 <vj_compress_init+0x24>
  }
  tstate[0].cs_next = &tstate[MAX_SLOTS - 1];
 801b278:	68bb      	ldr	r3, [r7, #8]
 801b27a:	22ff      	movs	r2, #255	; 0xff
 801b27c:	00d2      	lsls	r2, r2, #3
 801b27e:	189a      	adds	r2, r3, r2
 801b280:	68bb      	ldr	r3, [r7, #8]
 801b282:	601a      	str	r2, [r3, #0]
  tstate[0].cs_id = 0;
 801b284:	68bb      	ldr	r3, [r7, #8]
 801b286:	2200      	movs	r2, #0
 801b288:	719a      	strb	r2, [r3, #6]
  comp->last_cs = &tstate[0];
 801b28a:	687b      	ldr	r3, [r7, #4]
 801b28c:	68ba      	ldr	r2, [r7, #8]
 801b28e:	601a      	str	r2, [r3, #0]
  comp->last_recv = 255;
 801b290:	687b      	ldr	r3, [r7, #4]
 801b292:	22ff      	movs	r2, #255	; 0xff
 801b294:	711a      	strb	r2, [r3, #4]
  comp->last_xmit = 255;
 801b296:	687b      	ldr	r3, [r7, #4]
 801b298:	22ff      	movs	r2, #255	; 0xff
 801b29a:	715a      	strb	r2, [r3, #5]
  comp->flags = VJF_TOSS;
 801b29c:	687b      	ldr	r3, [r7, #4]
 801b29e:	2201      	movs	r2, #1
 801b2a0:	80da      	strh	r2, [r3, #6]
}
 801b2a2:	46c0      	nop			; (mov r8, r8)
 801b2a4:	46bd      	mov	sp, r7
 801b2a6:	b004      	add	sp, #16
 801b2a8:	bd80      	pop	{r7, pc}
	...

0801b2ac <vj_compress_tcp>:
 * Return the VJ type code indicating whether or not the packet was
 * compressed.
 */
u8_t
vj_compress_tcp(struct vjcompress *comp, struct pbuf **pb)
{
 801b2ac:	b5b0      	push	{r4, r5, r7, lr}
 801b2ae:	b094      	sub	sp, #80	; 0x50
 801b2b0:	af00      	add	r7, sp, #0
 801b2b2:	6078      	str	r0, [r7, #4]
 801b2b4:	6039      	str	r1, [r7, #0]
  struct pbuf *np = *pb;
 801b2b6:	683b      	ldr	r3, [r7, #0]
 801b2b8:	681b      	ldr	r3, [r3, #0]
 801b2ba:	63fb      	str	r3, [r7, #60]	; 0x3c
  struct ip_hdr *ip = (struct ip_hdr *)np->payload;
 801b2bc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b2be:	685b      	ldr	r3, [r3, #4]
 801b2c0:	63bb      	str	r3, [r7, #56]	; 0x38
  struct cstate *cs = comp->last_cs->cs_next;
 801b2c2:	687b      	ldr	r3, [r7, #4]
 801b2c4:	681b      	ldr	r3, [r3, #0]
 801b2c6:	681b      	ldr	r3, [r3, #0]
 801b2c8:	64fb      	str	r3, [r7, #76]	; 0x4c
  u16_t ilen = IPH_HL(ip);
 801b2ca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b2cc:	781b      	ldrb	r3, [r3, #0]
 801b2ce:	b29a      	uxth	r2, r3
 801b2d0:	2336      	movs	r3, #54	; 0x36
 801b2d2:	18fb      	adds	r3, r7, r3
 801b2d4:	210f      	movs	r1, #15
 801b2d6:	400a      	ands	r2, r1
 801b2d8:	801a      	strh	r2, [r3, #0]
  u16_t hlen;
  struct tcp_hdr *oth;
  struct tcp_hdr *th;
  u16_t deltaS, deltaA = 0;
 801b2da:	2348      	movs	r3, #72	; 0x48
 801b2dc:	18fb      	adds	r3, r7, r3
 801b2de:	2200      	movs	r2, #0
 801b2e0:	801a      	strh	r2, [r3, #0]
  u32_t deltaL;
  u32_t changes = 0;
 801b2e2:	2300      	movs	r3, #0
 801b2e4:	647b      	str	r3, [r7, #68]	; 0x44
  u8_t new_seq[16];
  u8_t *cp = new_seq;
 801b2e6:	230c      	movs	r3, #12
 801b2e8:	18fb      	adds	r3, r7, r3
 801b2ea:	643b      	str	r3, [r7, #64]	; 0x40

  /*
   * Check that the packet is IP proto TCP.
   */
  if (IPH_PROTO(ip) != IP_PROTO_TCP) {
 801b2ec:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b2ee:	7a5b      	ldrb	r3, [r3, #9]
 801b2f0:	2b06      	cmp	r3, #6
 801b2f2:	d002      	beq.n	801b2fa <vj_compress_tcp+0x4e>
    return (TYPE_IP);
 801b2f4:	2340      	movs	r3, #64	; 0x40
 801b2f6:	f000 fc53 	bl	801bba0 <vj_compress_tcp+0x8f4>
  /*
   * Bail if this is an IP fragment or if the TCP packet isn't
   * `compressible' (i.e., ACK isn't set or some other control bit is
   * set).
   */
  if ((IPH_OFFSET(ip) & PP_HTONS(0x3fff)) || np->tot_len < 40) {
 801b2fa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b2fc:	799a      	ldrb	r2, [r3, #6]
 801b2fe:	79db      	ldrb	r3, [r3, #7]
 801b300:	021b      	lsls	r3, r3, #8
 801b302:	4313      	orrs	r3, r2
 801b304:	b29b      	uxth	r3, r3
 801b306:	001a      	movs	r2, r3
 801b308:	4b7c      	ldr	r3, [pc, #496]	; (801b4fc <vj_compress_tcp+0x250>)
 801b30a:	4013      	ands	r3, r2
 801b30c:	d103      	bne.n	801b316 <vj_compress_tcp+0x6a>
 801b30e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b310:	891b      	ldrh	r3, [r3, #8]
 801b312:	2b27      	cmp	r3, #39	; 0x27
 801b314:	d802      	bhi.n	801b31c <vj_compress_tcp+0x70>
    return (TYPE_IP);
 801b316:	2340      	movs	r3, #64	; 0x40
 801b318:	f000 fc42 	bl	801bba0 <vj_compress_tcp+0x8f4>
  }
  th = (struct tcp_hdr *)&((struct vj_u32_t*)ip)[ilen];
 801b31c:	2336      	movs	r3, #54	; 0x36
 801b31e:	18fb      	adds	r3, r7, r3
 801b320:	881b      	ldrh	r3, [r3, #0]
 801b322:	009b      	lsls	r3, r3, #2
 801b324:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801b326:	18d3      	adds	r3, r2, r3
 801b328:	633b      	str	r3, [r7, #48]	; 0x30
  if ((TCPH_FLAGS(th) & (TCP_SYN|TCP_FIN|TCP_RST|TCP_ACK)) != TCP_ACK) {
 801b32a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b32c:	7b1a      	ldrb	r2, [r3, #12]
 801b32e:	7b5b      	ldrb	r3, [r3, #13]
 801b330:	021b      	lsls	r3, r3, #8
 801b332:	4313      	orrs	r3, r2
 801b334:	b29b      	uxth	r3, r3
 801b336:	0018      	movs	r0, r3
 801b338:	f7eb f8fc 	bl	8006534 <lwip_htons>
 801b33c:	0003      	movs	r3, r0
 801b33e:	b2db      	uxtb	r3, r3
 801b340:	001a      	movs	r2, r3
 801b342:	2317      	movs	r3, #23
 801b344:	4013      	ands	r3, r2
 801b346:	2b10      	cmp	r3, #16
 801b348:	d002      	beq.n	801b350 <vj_compress_tcp+0xa4>
    return (TYPE_IP);
 801b34a:	2340      	movs	r3, #64	; 0x40
 801b34c:	f000 fc28 	bl	801bba0 <vj_compress_tcp+0x8f4>
  }

  /* Check that the TCP/IP headers are contained in the first buffer. */
  hlen = ilen + TCPH_HDRLEN(th);
 801b350:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b352:	7b1a      	ldrb	r2, [r3, #12]
 801b354:	7b5b      	ldrb	r3, [r3, #13]
 801b356:	021b      	lsls	r3, r3, #8
 801b358:	4313      	orrs	r3, r2
 801b35a:	b29b      	uxth	r3, r3
 801b35c:	0018      	movs	r0, r3
 801b35e:	f7eb f8e9 	bl	8006534 <lwip_htons>
 801b362:	0003      	movs	r3, r0
 801b364:	0b1b      	lsrs	r3, r3, #12
 801b366:	b299      	uxth	r1, r3
 801b368:	202e      	movs	r0, #46	; 0x2e
 801b36a:	183b      	adds	r3, r7, r0
 801b36c:	2236      	movs	r2, #54	; 0x36
 801b36e:	18ba      	adds	r2, r7, r2
 801b370:	8812      	ldrh	r2, [r2, #0]
 801b372:	188a      	adds	r2, r1, r2
 801b374:	801a      	strh	r2, [r3, #0]
  hlen <<= 2;
 801b376:	0001      	movs	r1, r0
 801b378:	187b      	adds	r3, r7, r1
 801b37a:	187a      	adds	r2, r7, r1
 801b37c:	8812      	ldrh	r2, [r2, #0]
 801b37e:	0092      	lsls	r2, r2, #2
 801b380:	801a      	strh	r2, [r3, #0]
  if (np->len < hlen) {
 801b382:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b384:	895b      	ldrh	r3, [r3, #10]
 801b386:	187a      	adds	r2, r7, r1
 801b388:	8812      	ldrh	r2, [r2, #0]
 801b38a:	429a      	cmp	r2, r3
 801b38c:	d902      	bls.n	801b394 <vj_compress_tcp+0xe8>
    PPPDEBUG(LOG_INFO, ("vj_compress_tcp: header len %d spans buffers\n", hlen));
    return (TYPE_IP);
 801b38e:	2340      	movs	r3, #64	; 0x40
 801b390:	f000 fc06 	bl	801bba0 <vj_compress_tcp+0x8f4>
  }

  /* TCP stack requires that we don't change the packet payload, therefore we copy
   * the whole packet before compression. */
  np = pbuf_clone(PBUF_RAW, PBUF_RAM, *pb);
 801b394:	683b      	ldr	r3, [r7, #0]
 801b396:	681a      	ldr	r2, [r3, #0]
 801b398:	23a0      	movs	r3, #160	; 0xa0
 801b39a:	009b      	lsls	r3, r3, #2
 801b39c:	0019      	movs	r1, r3
 801b39e:	2000      	movs	r0, #0
 801b3a0:	f7ee fe56 	bl	800a050 <pbuf_clone>
 801b3a4:	0003      	movs	r3, r0
 801b3a6:	63fb      	str	r3, [r7, #60]	; 0x3c
  if (!np) {
 801b3a8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b3aa:	2b00      	cmp	r3, #0
 801b3ac:	d102      	bne.n	801b3b4 <vj_compress_tcp+0x108>
    return (TYPE_IP);
 801b3ae:	2340      	movs	r3, #64	; 0x40
 801b3b0:	f000 fbf6 	bl	801bba0 <vj_compress_tcp+0x8f4>
  }

  *pb = np;
 801b3b4:	683b      	ldr	r3, [r7, #0]
 801b3b6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801b3b8:	601a      	str	r2, [r3, #0]
  ip = (struct ip_hdr *)np->payload;
 801b3ba:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b3bc:	685b      	ldr	r3, [r3, #4]
 801b3be:	63bb      	str	r3, [r7, #56]	; 0x38
   * to locate (or create) the connection state.  Special case the
   * most recently used connection since it's most likely to be used
   * again & we don't have to do any reordering if it's used.
   */
  INCR(vjs_packets);
  if (!ip4_addr_cmp(&ip->src, &cs->cs_ip.src)
 801b3c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b3c2:	7b1a      	ldrb	r2, [r3, #12]
 801b3c4:	7b59      	ldrb	r1, [r3, #13]
 801b3c6:	0209      	lsls	r1, r1, #8
 801b3c8:	430a      	orrs	r2, r1
 801b3ca:	7b99      	ldrb	r1, [r3, #14]
 801b3cc:	0409      	lsls	r1, r1, #16
 801b3ce:	430a      	orrs	r2, r1
 801b3d0:	7bdb      	ldrb	r3, [r3, #15]
 801b3d2:	061b      	lsls	r3, r3, #24
 801b3d4:	4313      	orrs	r3, r2
 801b3d6:	001a      	movs	r2, r3
 801b3d8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b3da:	695b      	ldr	r3, [r3, #20]
 801b3dc:	429a      	cmp	r2, r3
 801b3de:	d131      	bne.n	801b444 <vj_compress_tcp+0x198>
      || !ip4_addr_cmp(&ip->dest, &cs->cs_ip.dest)
 801b3e0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b3e2:	7c1a      	ldrb	r2, [r3, #16]
 801b3e4:	7c59      	ldrb	r1, [r3, #17]
 801b3e6:	0209      	lsls	r1, r1, #8
 801b3e8:	430a      	orrs	r2, r1
 801b3ea:	7c99      	ldrb	r1, [r3, #18]
 801b3ec:	0409      	lsls	r1, r1, #16
 801b3ee:	430a      	orrs	r2, r1
 801b3f0:	7cdb      	ldrb	r3, [r3, #19]
 801b3f2:	061b      	lsls	r3, r3, #24
 801b3f4:	4313      	orrs	r3, r2
 801b3f6:	001a      	movs	r2, r3
 801b3f8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b3fa:	699b      	ldr	r3, [r3, #24]
 801b3fc:	429a      	cmp	r2, r3
 801b3fe:	d121      	bne.n	801b444 <vj_compress_tcp+0x198>
      || (*(struct vj_u32_t*)th).v != (((struct vj_u32_t*)&cs->cs_ip)[IPH_HL(&cs->cs_ip)]).v) {
 801b400:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b402:	781a      	ldrb	r2, [r3, #0]
 801b404:	7859      	ldrb	r1, [r3, #1]
 801b406:	0209      	lsls	r1, r1, #8
 801b408:	430a      	orrs	r2, r1
 801b40a:	7899      	ldrb	r1, [r3, #2]
 801b40c:	0409      	lsls	r1, r1, #16
 801b40e:	430a      	orrs	r2, r1
 801b410:	78db      	ldrb	r3, [r3, #3]
 801b412:	061b      	lsls	r3, r3, #24
 801b414:	4313      	orrs	r3, r2
 801b416:	0018      	movs	r0, r3
 801b418:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b41a:	3308      	adds	r3, #8
 801b41c:	001a      	movs	r2, r3
 801b41e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b420:	7a1b      	ldrb	r3, [r3, #8]
 801b422:	0019      	movs	r1, r3
 801b424:	230f      	movs	r3, #15
 801b426:	400b      	ands	r3, r1
 801b428:	009b      	lsls	r3, r3, #2
 801b42a:	18d3      	adds	r3, r2, r3
 801b42c:	781a      	ldrb	r2, [r3, #0]
 801b42e:	7859      	ldrb	r1, [r3, #1]
 801b430:	0209      	lsls	r1, r1, #8
 801b432:	430a      	orrs	r2, r1
 801b434:	7899      	ldrb	r1, [r3, #2]
 801b436:	0409      	lsls	r1, r1, #16
 801b438:	430a      	orrs	r2, r1
 801b43a:	78db      	ldrb	r3, [r3, #3]
 801b43c:	061b      	lsls	r3, r3, #24
 801b43e:	4313      	orrs	r3, r2
 801b440:	4298      	cmp	r0, r3
 801b442:	d068      	beq.n	801b516 <vj_compress_tcp+0x26a>
     * we want is almost always near the front, we locate
     * states via linear search.  If we don't find a state
     * for the datagram, the oldest state is (re-)used.
     */
    struct cstate *lcs;
    struct cstate *lastcs = comp->last_cs;
 801b444:	687b      	ldr	r3, [r7, #4]
 801b446:	681b      	ldr	r3, [r3, #0]
 801b448:	62bb      	str	r3, [r7, #40]	; 0x28

    do {
      lcs = cs; cs = cs->cs_next;
 801b44a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b44c:	627b      	str	r3, [r7, #36]	; 0x24
 801b44e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b450:	681b      	ldr	r3, [r3, #0]
 801b452:	64fb      	str	r3, [r7, #76]	; 0x4c
      INCR(vjs_searches);
      if (ip4_addr_cmp(&ip->src, &cs->cs_ip.src)
 801b454:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b456:	7b1a      	ldrb	r2, [r3, #12]
 801b458:	7b59      	ldrb	r1, [r3, #13]
 801b45a:	0209      	lsls	r1, r1, #8
 801b45c:	430a      	orrs	r2, r1
 801b45e:	7b99      	ldrb	r1, [r3, #14]
 801b460:	0409      	lsls	r1, r1, #16
 801b462:	430a      	orrs	r2, r1
 801b464:	7bdb      	ldrb	r3, [r3, #15]
 801b466:	061b      	lsls	r3, r3, #24
 801b468:	4313      	orrs	r3, r2
 801b46a:	001a      	movs	r2, r3
 801b46c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b46e:	695b      	ldr	r3, [r3, #20]
 801b470:	429a      	cmp	r2, r3
 801b472:	d131      	bne.n	801b4d8 <vj_compress_tcp+0x22c>
          && ip4_addr_cmp(&ip->dest, &cs->cs_ip.dest)
 801b474:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b476:	7c1a      	ldrb	r2, [r3, #16]
 801b478:	7c59      	ldrb	r1, [r3, #17]
 801b47a:	0209      	lsls	r1, r1, #8
 801b47c:	430a      	orrs	r2, r1
 801b47e:	7c99      	ldrb	r1, [r3, #18]
 801b480:	0409      	lsls	r1, r1, #16
 801b482:	430a      	orrs	r2, r1
 801b484:	7cdb      	ldrb	r3, [r3, #19]
 801b486:	061b      	lsls	r3, r3, #24
 801b488:	4313      	orrs	r3, r2
 801b48a:	001a      	movs	r2, r3
 801b48c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b48e:	699b      	ldr	r3, [r3, #24]
 801b490:	429a      	cmp	r2, r3
 801b492:	d121      	bne.n	801b4d8 <vj_compress_tcp+0x22c>
          && (*(struct vj_u32_t*)th).v == (((struct vj_u32_t*)&cs->cs_ip)[IPH_HL(&cs->cs_ip)]).v) {
 801b494:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b496:	781a      	ldrb	r2, [r3, #0]
 801b498:	7859      	ldrb	r1, [r3, #1]
 801b49a:	0209      	lsls	r1, r1, #8
 801b49c:	430a      	orrs	r2, r1
 801b49e:	7899      	ldrb	r1, [r3, #2]
 801b4a0:	0409      	lsls	r1, r1, #16
 801b4a2:	430a      	orrs	r2, r1
 801b4a4:	78db      	ldrb	r3, [r3, #3]
 801b4a6:	061b      	lsls	r3, r3, #24
 801b4a8:	4313      	orrs	r3, r2
 801b4aa:	0018      	movs	r0, r3
 801b4ac:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b4ae:	3308      	adds	r3, #8
 801b4b0:	001a      	movs	r2, r3
 801b4b2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b4b4:	7a1b      	ldrb	r3, [r3, #8]
 801b4b6:	0019      	movs	r1, r3
 801b4b8:	230f      	movs	r3, #15
 801b4ba:	400b      	ands	r3, r1
 801b4bc:	009b      	lsls	r3, r3, #2
 801b4be:	18d3      	adds	r3, r2, r3
 801b4c0:	781a      	ldrb	r2, [r3, #0]
 801b4c2:	7859      	ldrb	r1, [r3, #1]
 801b4c4:	0209      	lsls	r1, r1, #8
 801b4c6:	430a      	orrs	r2, r1
 801b4c8:	7899      	ldrb	r1, [r3, #2]
 801b4ca:	0409      	lsls	r1, r1, #16
 801b4cc:	430a      	orrs	r2, r1
 801b4ce:	78db      	ldrb	r3, [r3, #3]
 801b4d0:	061b      	lsls	r3, r3, #24
 801b4d2:	4313      	orrs	r3, r2
 801b4d4:	4298      	cmp	r0, r3
 801b4d6:	d007      	beq.n	801b4e8 <vj_compress_tcp+0x23c>
        goto found;
      }
    } while (cs != lastcs);
 801b4d8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801b4da:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801b4dc:	429a      	cmp	r2, r3
 801b4de:	d1b4      	bne.n	801b44a <vj_compress_tcp+0x19e>
     * Note that since the state list is circular, the oldest
     * state points to the newest and we only need to set
     * last_cs to update the lru linkage.
     */
    INCR(vjs_misses);
    comp->last_cs = lcs;
 801b4e0:	687b      	ldr	r3, [r7, #4]
 801b4e2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801b4e4:	601a      	str	r2, [r3, #0]
    goto uncompressed;
 801b4e6:	e348      	b.n	801bb7a <vj_compress_tcp+0x8ce>
        goto found;
 801b4e8:	46c0      	nop			; (mov r8, r8)

    found:
    /*
     * Found it -- move to the front on the connection list.
     */
    if (cs == lastcs) {
 801b4ea:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801b4ec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801b4ee:	429a      	cmp	r2, r3
 801b4f0:	d106      	bne.n	801b500 <vj_compress_tcp+0x254>
      comp->last_cs = lcs;
 801b4f2:	687b      	ldr	r3, [r7, #4]
 801b4f4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801b4f6:	601a      	str	r2, [r3, #0]
 801b4f8:	e00d      	b.n	801b516 <vj_compress_tcp+0x26a>
 801b4fa:	46c0      	nop			; (mov r8, r8)
 801b4fc:	0000ff3f 	.word	0x0000ff3f
    } else {
      lcs->cs_next = cs->cs_next;
 801b500:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b502:	681a      	ldr	r2, [r3, #0]
 801b504:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801b506:	601a      	str	r2, [r3, #0]
      cs->cs_next = lastcs->cs_next;
 801b508:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801b50a:	681a      	ldr	r2, [r3, #0]
 801b50c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b50e:	601a      	str	r2, [r3, #0]
      lastcs->cs_next = cs;
 801b510:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801b512:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801b514:	601a      	str	r2, [r3, #0]
    }
  }

  oth = (struct tcp_hdr *)&((struct vj_u32_t*)&cs->cs_ip)[ilen];
 801b516:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b518:	3308      	adds	r3, #8
 801b51a:	001a      	movs	r2, r3
 801b51c:	2136      	movs	r1, #54	; 0x36
 801b51e:	187b      	adds	r3, r7, r1
 801b520:	881b      	ldrh	r3, [r3, #0]
 801b522:	009b      	lsls	r3, r3, #2
 801b524:	18d3      	adds	r3, r2, r3
 801b526:	623b      	str	r3, [r7, #32]
  deltaS = ilen;
 801b528:	254a      	movs	r5, #74	; 0x4a
 801b52a:	197b      	adds	r3, r7, r5
 801b52c:	187a      	adds	r2, r7, r1
 801b52e:	8812      	ldrh	r2, [r2, #0]
 801b530:	801a      	strh	r2, [r3, #0]
   * header length.  The 5th line checks IP options, if any.  The 6th
   * line checks TCP options, if any.  If any of these things are
   * different between the previous & current datagram, we send the
   * current datagram `uncompressed'.
   */
  if ((((struct vj_u16_t*)ip)[0]).v != (((struct vj_u16_t*)&cs->cs_ip)[0]).v
 801b532:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b534:	781a      	ldrb	r2, [r3, #0]
 801b536:	785b      	ldrb	r3, [r3, #1]
 801b538:	021b      	lsls	r3, r3, #8
 801b53a:	4313      	orrs	r3, r2
 801b53c:	b29a      	uxth	r2, r3
 801b53e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b540:	3308      	adds	r3, #8
 801b542:	7819      	ldrb	r1, [r3, #0]
 801b544:	785b      	ldrb	r3, [r3, #1]
 801b546:	021b      	lsls	r3, r3, #8
 801b548:	430b      	orrs	r3, r1
 801b54a:	b29b      	uxth	r3, r3
 801b54c:	429a      	cmp	r2, r3
 801b54e:	d000      	beq.n	801b552 <vj_compress_tcp+0x2a6>
 801b550:	e30a      	b.n	801bb68 <vj_compress_tcp+0x8bc>
      || (((struct vj_u16_t*)ip)[3]).v != (((struct vj_u16_t*)&cs->cs_ip)[3]).v
 801b552:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b554:	3306      	adds	r3, #6
 801b556:	781a      	ldrb	r2, [r3, #0]
 801b558:	785b      	ldrb	r3, [r3, #1]
 801b55a:	021b      	lsls	r3, r3, #8
 801b55c:	4313      	orrs	r3, r2
 801b55e:	b29a      	uxth	r2, r3
 801b560:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b562:	3308      	adds	r3, #8
 801b564:	3306      	adds	r3, #6
 801b566:	7819      	ldrb	r1, [r3, #0]
 801b568:	785b      	ldrb	r3, [r3, #1]
 801b56a:	021b      	lsls	r3, r3, #8
 801b56c:	430b      	orrs	r3, r1
 801b56e:	b29b      	uxth	r3, r3
 801b570:	429a      	cmp	r2, r3
 801b572:	d000      	beq.n	801b576 <vj_compress_tcp+0x2ca>
 801b574:	e2f8      	b.n	801bb68 <vj_compress_tcp+0x8bc>
      || (((struct vj_u16_t*)ip)[4]).v != (((struct vj_u16_t*)&cs->cs_ip)[4]).v
 801b576:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b578:	3308      	adds	r3, #8
 801b57a:	781a      	ldrb	r2, [r3, #0]
 801b57c:	785b      	ldrb	r3, [r3, #1]
 801b57e:	021b      	lsls	r3, r3, #8
 801b580:	4313      	orrs	r3, r2
 801b582:	b29a      	uxth	r2, r3
 801b584:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b586:	3308      	adds	r3, #8
 801b588:	3308      	adds	r3, #8
 801b58a:	7819      	ldrb	r1, [r3, #0]
 801b58c:	785b      	ldrb	r3, [r3, #1]
 801b58e:	021b      	lsls	r3, r3, #8
 801b590:	430b      	orrs	r3, r1
 801b592:	b29b      	uxth	r3, r3
 801b594:	429a      	cmp	r2, r3
 801b596:	d000      	beq.n	801b59a <vj_compress_tcp+0x2ee>
 801b598:	e2e6      	b.n	801bb68 <vj_compress_tcp+0x8bc>
      || TCPH_HDRLEN(th) != TCPH_HDRLEN(oth)
 801b59a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b59c:	7b1a      	ldrb	r2, [r3, #12]
 801b59e:	7b5b      	ldrb	r3, [r3, #13]
 801b5a0:	021b      	lsls	r3, r3, #8
 801b5a2:	4313      	orrs	r3, r2
 801b5a4:	b29b      	uxth	r3, r3
 801b5a6:	0018      	movs	r0, r3
 801b5a8:	f7ea ffc4 	bl	8006534 <lwip_htons>
 801b5ac:	0003      	movs	r3, r0
 801b5ae:	0b1b      	lsrs	r3, r3, #12
 801b5b0:	b29c      	uxth	r4, r3
 801b5b2:	6a3b      	ldr	r3, [r7, #32]
 801b5b4:	7b1a      	ldrb	r2, [r3, #12]
 801b5b6:	7b5b      	ldrb	r3, [r3, #13]
 801b5b8:	021b      	lsls	r3, r3, #8
 801b5ba:	4313      	orrs	r3, r2
 801b5bc:	b29b      	uxth	r3, r3
 801b5be:	0018      	movs	r0, r3
 801b5c0:	f7ea ffb8 	bl	8006534 <lwip_htons>
 801b5c4:	0003      	movs	r3, r0
 801b5c6:	0b1b      	lsrs	r3, r3, #12
 801b5c8:	b29b      	uxth	r3, r3
 801b5ca:	429c      	cmp	r4, r3
 801b5cc:	d000      	beq.n	801b5d0 <vj_compress_tcp+0x324>
 801b5ce:	e2cb      	b.n	801bb68 <vj_compress_tcp+0x8bc>
      || (deltaS > 5 && BCMP(ip + 1, &cs->cs_ip + 1, (deltaS - 5) << 2))
 801b5d0:	197b      	adds	r3, r7, r5
 801b5d2:	881b      	ldrh	r3, [r3, #0]
 801b5d4:	2b05      	cmp	r3, #5
 801b5d6:	d910      	bls.n	801b5fa <vj_compress_tcp+0x34e>
 801b5d8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b5da:	3314      	adds	r3, #20
 801b5dc:	0018      	movs	r0, r3
 801b5de:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b5e0:	3308      	adds	r3, #8
 801b5e2:	3314      	adds	r3, #20
 801b5e4:	0019      	movs	r1, r3
 801b5e6:	197b      	adds	r3, r7, r5
 801b5e8:	881b      	ldrh	r3, [r3, #0]
 801b5ea:	3b05      	subs	r3, #5
 801b5ec:	009b      	lsls	r3, r3, #2
 801b5ee:	001a      	movs	r2, r3
 801b5f0:	f001 f8f2 	bl	801c7d8 <memcmp>
 801b5f4:	1e03      	subs	r3, r0, #0
 801b5f6:	d000      	beq.n	801b5fa <vj_compress_tcp+0x34e>
 801b5f8:	e2b6      	b.n	801bb68 <vj_compress_tcp+0x8bc>
      || (TCPH_HDRLEN(th) > 5 && BCMP(th + 1, oth + 1, (TCPH_HDRLEN(th) - 5) << 2))) {
 801b5fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b5fc:	7b1a      	ldrb	r2, [r3, #12]
 801b5fe:	7b5b      	ldrb	r3, [r3, #13]
 801b600:	021b      	lsls	r3, r3, #8
 801b602:	4313      	orrs	r3, r2
 801b604:	b29b      	uxth	r3, r3
 801b606:	0018      	movs	r0, r3
 801b608:	f7ea ff94 	bl	8006534 <lwip_htons>
 801b60c:	0003      	movs	r3, r0
 801b60e:	0b1b      	lsrs	r3, r3, #12
 801b610:	b29b      	uxth	r3, r3
 801b612:	2b05      	cmp	r3, #5
 801b614:	d91b      	bls.n	801b64e <vj_compress_tcp+0x3a2>
 801b616:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b618:	3314      	adds	r3, #20
 801b61a:	001c      	movs	r4, r3
 801b61c:	6a3b      	ldr	r3, [r7, #32]
 801b61e:	3314      	adds	r3, #20
 801b620:	001d      	movs	r5, r3
 801b622:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b624:	7b1a      	ldrb	r2, [r3, #12]
 801b626:	7b5b      	ldrb	r3, [r3, #13]
 801b628:	021b      	lsls	r3, r3, #8
 801b62a:	4313      	orrs	r3, r2
 801b62c:	b29b      	uxth	r3, r3
 801b62e:	0018      	movs	r0, r3
 801b630:	f7ea ff80 	bl	8006534 <lwip_htons>
 801b634:	0003      	movs	r3, r0
 801b636:	0b1b      	lsrs	r3, r3, #12
 801b638:	b29b      	uxth	r3, r3
 801b63a:	3b05      	subs	r3, #5
 801b63c:	009b      	lsls	r3, r3, #2
 801b63e:	001a      	movs	r2, r3
 801b640:	0029      	movs	r1, r5
 801b642:	0020      	movs	r0, r4
 801b644:	f001 f8c8 	bl	801c7d8 <memcmp>
 801b648:	1e03      	subs	r3, r0, #0
 801b64a:	d000      	beq.n	801b64e <vj_compress_tcp+0x3a2>
 801b64c:	e28c      	b.n	801bb68 <vj_compress_tcp+0x8bc>
   * Figure out which of the changing fields changed.  The
   * receiver expects changes in the order: urgent, window,
   * ack, seq (the order minimizes the number of temporaries
   * needed in this section of code).
   */
  if (TCPH_FLAGS(th) & TCP_URG) {
 801b64e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b650:	7b1a      	ldrb	r2, [r3, #12]
 801b652:	7b5b      	ldrb	r3, [r3, #13]
 801b654:	021b      	lsls	r3, r3, #8
 801b656:	4313      	orrs	r3, r2
 801b658:	b29b      	uxth	r3, r3
 801b65a:	0018      	movs	r0, r3
 801b65c:	f7ea ff6a 	bl	8006534 <lwip_htons>
 801b660:	0003      	movs	r3, r0
 801b662:	b2db      	uxtb	r3, r3
 801b664:	001a      	movs	r2, r3
 801b666:	2320      	movs	r3, #32
 801b668:	4013      	ands	r3, r2
 801b66a:	d038      	beq.n	801b6de <vj_compress_tcp+0x432>
    deltaS = lwip_ntohs(th->urgp);
 801b66c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b66e:	7c9a      	ldrb	r2, [r3, #18]
 801b670:	7cdb      	ldrb	r3, [r3, #19]
 801b672:	021b      	lsls	r3, r3, #8
 801b674:	4313      	orrs	r3, r2
 801b676:	b29b      	uxth	r3, r3
 801b678:	254a      	movs	r5, #74	; 0x4a
 801b67a:	197c      	adds	r4, r7, r5
 801b67c:	0018      	movs	r0, r3
 801b67e:	f7ea ff59 	bl	8006534 <lwip_htons>
 801b682:	0003      	movs	r3, r0
 801b684:	8023      	strh	r3, [r4, #0]
    ENCODEZ(deltaS);
 801b686:	197b      	adds	r3, r7, r5
 801b688:	881b      	ldrh	r3, [r3, #0]
 801b68a:	2bff      	cmp	r3, #255	; 0xff
 801b68c:	d803      	bhi.n	801b696 <vj_compress_tcp+0x3ea>
 801b68e:	197b      	adds	r3, r7, r5
 801b690:	881b      	ldrh	r3, [r3, #0]
 801b692:	2b00      	cmp	r3, #0
 801b694:	d116      	bne.n	801b6c4 <vj_compress_tcp+0x418>
 801b696:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b698:	1c5a      	adds	r2, r3, #1
 801b69a:	643a      	str	r2, [r7, #64]	; 0x40
 801b69c:	2200      	movs	r2, #0
 801b69e:	701a      	strb	r2, [r3, #0]
 801b6a0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b6a2:	3301      	adds	r3, #1
 801b6a4:	214a      	movs	r1, #74	; 0x4a
 801b6a6:	187a      	adds	r2, r7, r1
 801b6a8:	8812      	ldrh	r2, [r2, #0]
 801b6aa:	b2d2      	uxtb	r2, r2
 801b6ac:	701a      	strb	r2, [r3, #0]
 801b6ae:	187b      	adds	r3, r7, r1
 801b6b0:	881b      	ldrh	r3, [r3, #0]
 801b6b2:	0a1b      	lsrs	r3, r3, #8
 801b6b4:	b29b      	uxth	r3, r3
 801b6b6:	b2da      	uxtb	r2, r3
 801b6b8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b6ba:	701a      	strb	r2, [r3, #0]
 801b6bc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b6be:	3302      	adds	r3, #2
 801b6c0:	643b      	str	r3, [r7, #64]	; 0x40
 801b6c2:	e007      	b.n	801b6d4 <vj_compress_tcp+0x428>
 801b6c4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b6c6:	1c5a      	adds	r2, r3, #1
 801b6c8:	643a      	str	r2, [r7, #64]	; 0x40
 801b6ca:	224a      	movs	r2, #74	; 0x4a
 801b6cc:	18ba      	adds	r2, r7, r2
 801b6ce:	8812      	ldrh	r2, [r2, #0]
 801b6d0:	b2d2      	uxtb	r2, r2
 801b6d2:	701a      	strb	r2, [r3, #0]
    changes |= NEW_U;
 801b6d4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b6d6:	2201      	movs	r2, #1
 801b6d8:	4313      	orrs	r3, r2
 801b6da:	647b      	str	r3, [r7, #68]	; 0x44
 801b6dc:	e00e      	b.n	801b6fc <vj_compress_tcp+0x450>
  } else if (th->urgp != oth->urgp) {
 801b6de:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b6e0:	7c9a      	ldrb	r2, [r3, #18]
 801b6e2:	7cdb      	ldrb	r3, [r3, #19]
 801b6e4:	021b      	lsls	r3, r3, #8
 801b6e6:	4313      	orrs	r3, r2
 801b6e8:	b29a      	uxth	r2, r3
 801b6ea:	6a3b      	ldr	r3, [r7, #32]
 801b6ec:	7c99      	ldrb	r1, [r3, #18]
 801b6ee:	7cdb      	ldrb	r3, [r3, #19]
 801b6f0:	021b      	lsls	r3, r3, #8
 801b6f2:	430b      	orrs	r3, r1
 801b6f4:	b29b      	uxth	r3, r3
 801b6f6:	429a      	cmp	r2, r3
 801b6f8:	d000      	beq.n	801b6fc <vj_compress_tcp+0x450>
 801b6fa:	e237      	b.n	801bb6c <vj_compress_tcp+0x8c0>
     * doesn't prohibit the change so we have to deal
     * with it. */
    goto uncompressed;
  }

  if ((deltaS = (u16_t)(lwip_ntohs(th->wnd) - lwip_ntohs(oth->wnd))) != 0) {
 801b6fc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b6fe:	7b9a      	ldrb	r2, [r3, #14]
 801b700:	7bdb      	ldrb	r3, [r3, #15]
 801b702:	021b      	lsls	r3, r3, #8
 801b704:	4313      	orrs	r3, r2
 801b706:	b29b      	uxth	r3, r3
 801b708:	0018      	movs	r0, r3
 801b70a:	f7ea ff13 	bl	8006534 <lwip_htons>
 801b70e:	0003      	movs	r3, r0
 801b710:	001c      	movs	r4, r3
 801b712:	6a3b      	ldr	r3, [r7, #32]
 801b714:	7b9a      	ldrb	r2, [r3, #14]
 801b716:	7bdb      	ldrb	r3, [r3, #15]
 801b718:	021b      	lsls	r3, r3, #8
 801b71a:	4313      	orrs	r3, r2
 801b71c:	b29b      	uxth	r3, r3
 801b71e:	0018      	movs	r0, r3
 801b720:	f7ea ff08 	bl	8006534 <lwip_htons>
 801b724:	0003      	movs	r3, r0
 801b726:	001a      	movs	r2, r3
 801b728:	214a      	movs	r1, #74	; 0x4a
 801b72a:	187b      	adds	r3, r7, r1
 801b72c:	1aa2      	subs	r2, r4, r2
 801b72e:	801a      	strh	r2, [r3, #0]
 801b730:	187b      	adds	r3, r7, r1
 801b732:	881b      	ldrh	r3, [r3, #0]
 801b734:	2b00      	cmp	r3, #0
 801b736:	d025      	beq.n	801b784 <vj_compress_tcp+0x4d8>
    ENCODE(deltaS);
 801b738:	187b      	adds	r3, r7, r1
 801b73a:	881b      	ldrh	r3, [r3, #0]
 801b73c:	2bff      	cmp	r3, #255	; 0xff
 801b73e:	d915      	bls.n	801b76c <vj_compress_tcp+0x4c0>
 801b740:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b742:	1c5a      	adds	r2, r3, #1
 801b744:	643a      	str	r2, [r7, #64]	; 0x40
 801b746:	2200      	movs	r2, #0
 801b748:	701a      	strb	r2, [r3, #0]
 801b74a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b74c:	3301      	adds	r3, #1
 801b74e:	187a      	adds	r2, r7, r1
 801b750:	8812      	ldrh	r2, [r2, #0]
 801b752:	b2d2      	uxtb	r2, r2
 801b754:	701a      	strb	r2, [r3, #0]
 801b756:	187b      	adds	r3, r7, r1
 801b758:	881b      	ldrh	r3, [r3, #0]
 801b75a:	0a1b      	lsrs	r3, r3, #8
 801b75c:	b29b      	uxth	r3, r3
 801b75e:	b2da      	uxtb	r2, r3
 801b760:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b762:	701a      	strb	r2, [r3, #0]
 801b764:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b766:	3302      	adds	r3, #2
 801b768:	643b      	str	r3, [r7, #64]	; 0x40
 801b76a:	e007      	b.n	801b77c <vj_compress_tcp+0x4d0>
 801b76c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b76e:	1c5a      	adds	r2, r3, #1
 801b770:	643a      	str	r2, [r7, #64]	; 0x40
 801b772:	224a      	movs	r2, #74	; 0x4a
 801b774:	18ba      	adds	r2, r7, r2
 801b776:	8812      	ldrh	r2, [r2, #0]
 801b778:	b2d2      	uxtb	r2, r2
 801b77a:	701a      	strb	r2, [r3, #0]
    changes |= NEW_W;
 801b77c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b77e:	2202      	movs	r2, #2
 801b780:	4313      	orrs	r3, r2
 801b782:	647b      	str	r3, [r7, #68]	; 0x44
  }

  if ((deltaL = lwip_ntohl(th->ackno) - lwip_ntohl(oth->ackno)) != 0) {
 801b784:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b786:	7a1a      	ldrb	r2, [r3, #8]
 801b788:	7a59      	ldrb	r1, [r3, #9]
 801b78a:	0209      	lsls	r1, r1, #8
 801b78c:	430a      	orrs	r2, r1
 801b78e:	7a99      	ldrb	r1, [r3, #10]
 801b790:	0409      	lsls	r1, r1, #16
 801b792:	430a      	orrs	r2, r1
 801b794:	7adb      	ldrb	r3, [r3, #11]
 801b796:	061b      	lsls	r3, r3, #24
 801b798:	4313      	orrs	r3, r2
 801b79a:	0018      	movs	r0, r3
 801b79c:	f7ea fee0 	bl	8006560 <lwip_htonl>
 801b7a0:	0004      	movs	r4, r0
 801b7a2:	6a3b      	ldr	r3, [r7, #32]
 801b7a4:	7a1a      	ldrb	r2, [r3, #8]
 801b7a6:	7a59      	ldrb	r1, [r3, #9]
 801b7a8:	0209      	lsls	r1, r1, #8
 801b7aa:	430a      	orrs	r2, r1
 801b7ac:	7a99      	ldrb	r1, [r3, #10]
 801b7ae:	0409      	lsls	r1, r1, #16
 801b7b0:	430a      	orrs	r2, r1
 801b7b2:	7adb      	ldrb	r3, [r3, #11]
 801b7b4:	061b      	lsls	r3, r3, #24
 801b7b6:	4313      	orrs	r3, r2
 801b7b8:	0018      	movs	r0, r3
 801b7ba:	f7ea fed1 	bl	8006560 <lwip_htonl>
 801b7be:	0003      	movs	r3, r0
 801b7c0:	1ae3      	subs	r3, r4, r3
 801b7c2:	61fb      	str	r3, [r7, #28]
 801b7c4:	69fb      	ldr	r3, [r7, #28]
 801b7c6:	2b00      	cmp	r3, #0
 801b7c8:	d02f      	beq.n	801b82a <vj_compress_tcp+0x57e>
    if (deltaL > 0xffff) {
 801b7ca:	69fa      	ldr	r2, [r7, #28]
 801b7cc:	2380      	movs	r3, #128	; 0x80
 801b7ce:	025b      	lsls	r3, r3, #9
 801b7d0:	429a      	cmp	r2, r3
 801b7d2:	d300      	bcc.n	801b7d6 <vj_compress_tcp+0x52a>
 801b7d4:	e1cc      	b.n	801bb70 <vj_compress_tcp+0x8c4>
      goto uncompressed;
    }
    deltaA = (u16_t)deltaL;
 801b7d6:	2148      	movs	r1, #72	; 0x48
 801b7d8:	187b      	adds	r3, r7, r1
 801b7da:	69fa      	ldr	r2, [r7, #28]
 801b7dc:	801a      	strh	r2, [r3, #0]
    ENCODE(deltaA);
 801b7de:	187b      	adds	r3, r7, r1
 801b7e0:	881b      	ldrh	r3, [r3, #0]
 801b7e2:	2bff      	cmp	r3, #255	; 0xff
 801b7e4:	d915      	bls.n	801b812 <vj_compress_tcp+0x566>
 801b7e6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b7e8:	1c5a      	adds	r2, r3, #1
 801b7ea:	643a      	str	r2, [r7, #64]	; 0x40
 801b7ec:	2200      	movs	r2, #0
 801b7ee:	701a      	strb	r2, [r3, #0]
 801b7f0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b7f2:	3301      	adds	r3, #1
 801b7f4:	187a      	adds	r2, r7, r1
 801b7f6:	8812      	ldrh	r2, [r2, #0]
 801b7f8:	b2d2      	uxtb	r2, r2
 801b7fa:	701a      	strb	r2, [r3, #0]
 801b7fc:	187b      	adds	r3, r7, r1
 801b7fe:	881b      	ldrh	r3, [r3, #0]
 801b800:	0a1b      	lsrs	r3, r3, #8
 801b802:	b29b      	uxth	r3, r3
 801b804:	b2da      	uxtb	r2, r3
 801b806:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b808:	701a      	strb	r2, [r3, #0]
 801b80a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b80c:	3302      	adds	r3, #2
 801b80e:	643b      	str	r3, [r7, #64]	; 0x40
 801b810:	e007      	b.n	801b822 <vj_compress_tcp+0x576>
 801b812:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b814:	1c5a      	adds	r2, r3, #1
 801b816:	643a      	str	r2, [r7, #64]	; 0x40
 801b818:	2248      	movs	r2, #72	; 0x48
 801b81a:	18ba      	adds	r2, r7, r2
 801b81c:	8812      	ldrh	r2, [r2, #0]
 801b81e:	b2d2      	uxtb	r2, r2
 801b820:	701a      	strb	r2, [r3, #0]
    changes |= NEW_A;
 801b822:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b824:	2204      	movs	r2, #4
 801b826:	4313      	orrs	r3, r2
 801b828:	647b      	str	r3, [r7, #68]	; 0x44
  }

  if ((deltaL = lwip_ntohl(th->seqno) - lwip_ntohl(oth->seqno)) != 0) {
 801b82a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b82c:	791a      	ldrb	r2, [r3, #4]
 801b82e:	7959      	ldrb	r1, [r3, #5]
 801b830:	0209      	lsls	r1, r1, #8
 801b832:	430a      	orrs	r2, r1
 801b834:	7999      	ldrb	r1, [r3, #6]
 801b836:	0409      	lsls	r1, r1, #16
 801b838:	430a      	orrs	r2, r1
 801b83a:	79db      	ldrb	r3, [r3, #7]
 801b83c:	061b      	lsls	r3, r3, #24
 801b83e:	4313      	orrs	r3, r2
 801b840:	0018      	movs	r0, r3
 801b842:	f7ea fe8d 	bl	8006560 <lwip_htonl>
 801b846:	0004      	movs	r4, r0
 801b848:	6a3b      	ldr	r3, [r7, #32]
 801b84a:	791a      	ldrb	r2, [r3, #4]
 801b84c:	7959      	ldrb	r1, [r3, #5]
 801b84e:	0209      	lsls	r1, r1, #8
 801b850:	430a      	orrs	r2, r1
 801b852:	7999      	ldrb	r1, [r3, #6]
 801b854:	0409      	lsls	r1, r1, #16
 801b856:	430a      	orrs	r2, r1
 801b858:	79db      	ldrb	r3, [r3, #7]
 801b85a:	061b      	lsls	r3, r3, #24
 801b85c:	4313      	orrs	r3, r2
 801b85e:	0018      	movs	r0, r3
 801b860:	f7ea fe7e 	bl	8006560 <lwip_htonl>
 801b864:	0003      	movs	r3, r0
 801b866:	1ae3      	subs	r3, r4, r3
 801b868:	61fb      	str	r3, [r7, #28]
 801b86a:	69fb      	ldr	r3, [r7, #28]
 801b86c:	2b00      	cmp	r3, #0
 801b86e:	d02f      	beq.n	801b8d0 <vj_compress_tcp+0x624>
    if (deltaL > 0xffff) {
 801b870:	69fa      	ldr	r2, [r7, #28]
 801b872:	2380      	movs	r3, #128	; 0x80
 801b874:	025b      	lsls	r3, r3, #9
 801b876:	429a      	cmp	r2, r3
 801b878:	d300      	bcc.n	801b87c <vj_compress_tcp+0x5d0>
 801b87a:	e17b      	b.n	801bb74 <vj_compress_tcp+0x8c8>
      goto uncompressed;
    }
    deltaS = (u16_t)deltaL;
 801b87c:	214a      	movs	r1, #74	; 0x4a
 801b87e:	187b      	adds	r3, r7, r1
 801b880:	69fa      	ldr	r2, [r7, #28]
 801b882:	801a      	strh	r2, [r3, #0]
    ENCODE(deltaS);
 801b884:	187b      	adds	r3, r7, r1
 801b886:	881b      	ldrh	r3, [r3, #0]
 801b888:	2bff      	cmp	r3, #255	; 0xff
 801b88a:	d915      	bls.n	801b8b8 <vj_compress_tcp+0x60c>
 801b88c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b88e:	1c5a      	adds	r2, r3, #1
 801b890:	643a      	str	r2, [r7, #64]	; 0x40
 801b892:	2200      	movs	r2, #0
 801b894:	701a      	strb	r2, [r3, #0]
 801b896:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b898:	3301      	adds	r3, #1
 801b89a:	187a      	adds	r2, r7, r1
 801b89c:	8812      	ldrh	r2, [r2, #0]
 801b89e:	b2d2      	uxtb	r2, r2
 801b8a0:	701a      	strb	r2, [r3, #0]
 801b8a2:	187b      	adds	r3, r7, r1
 801b8a4:	881b      	ldrh	r3, [r3, #0]
 801b8a6:	0a1b      	lsrs	r3, r3, #8
 801b8a8:	b29b      	uxth	r3, r3
 801b8aa:	b2da      	uxtb	r2, r3
 801b8ac:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b8ae:	701a      	strb	r2, [r3, #0]
 801b8b0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b8b2:	3302      	adds	r3, #2
 801b8b4:	643b      	str	r3, [r7, #64]	; 0x40
 801b8b6:	e007      	b.n	801b8c8 <vj_compress_tcp+0x61c>
 801b8b8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b8ba:	1c5a      	adds	r2, r3, #1
 801b8bc:	643a      	str	r2, [r7, #64]	; 0x40
 801b8be:	224a      	movs	r2, #74	; 0x4a
 801b8c0:	18ba      	adds	r2, r7, r2
 801b8c2:	8812      	ldrh	r2, [r2, #0]
 801b8c4:	b2d2      	uxtb	r2, r2
 801b8c6:	701a      	strb	r2, [r3, #0]
    changes |= NEW_S;
 801b8c8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b8ca:	2208      	movs	r2, #8
 801b8cc:	4313      	orrs	r3, r2
 801b8ce:	647b      	str	r3, [r7, #68]	; 0x44
 801b8d0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b8d2:	2b0f      	cmp	r3, #15
 801b8d4:	d851      	bhi.n	801b97a <vj_compress_tcp+0x6ce>
 801b8d6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801b8d8:	009a      	lsls	r2, r3, #2
 801b8da:	4bb3      	ldr	r3, [pc, #716]	; (801bba8 <vj_compress_tcp+0x8fc>)
 801b8dc:	18d3      	adds	r3, r2, r3
 801b8de:	681b      	ldr	r3, [r3, #0]
 801b8e0:	469f      	mov	pc, r3
     * an ack (normal on an interactive connection) and we send
     * it compressed.  Otherwise it's probably a retransmit,
     * retransmitted ack or window probe.  Send it uncompressed
     * in case the other side missed the compressed version.
     */
    if (IPH_LEN(ip) != IPH_LEN(&cs->cs_ip) &&
 801b8e2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b8e4:	789a      	ldrb	r2, [r3, #2]
 801b8e6:	78db      	ldrb	r3, [r3, #3]
 801b8e8:	021b      	lsls	r3, r3, #8
 801b8ea:	4313      	orrs	r3, r2
 801b8ec:	b29a      	uxth	r2, r3
 801b8ee:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b8f0:	895b      	ldrh	r3, [r3, #10]
 801b8f2:	429a      	cmp	r2, r3
 801b8f4:	d100      	bne.n	801b8f8 <vj_compress_tcp+0x64c>
 801b8f6:	e13f      	b.n	801bb78 <vj_compress_tcp+0x8cc>
      lwip_ntohs(IPH_LEN(&cs->cs_ip)) == hlen) {
 801b8f8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b8fa:	895b      	ldrh	r3, [r3, #10]
 801b8fc:	0018      	movs	r0, r3
 801b8fe:	f7ea fe19 	bl	8006534 <lwip_htons>
 801b902:	0003      	movs	r3, r0
 801b904:	001a      	movs	r2, r3
    if (IPH_LEN(ip) != IPH_LEN(&cs->cs_ip) &&
 801b906:	232e      	movs	r3, #46	; 0x2e
 801b908:	18fb      	adds	r3, r7, r3
 801b90a:	881b      	ldrh	r3, [r3, #0]
 801b90c:	4293      	cmp	r3, r2
 801b90e:	d000      	beq.n	801b912 <vj_compress_tcp+0x666>
 801b910:	e132      	b.n	801bb78 <vj_compress_tcp+0x8cc>
      break;
 801b912:	e037      	b.n	801b984 <vj_compress_tcp+0x6d8>
     * send packet uncompressed.
     */
    goto uncompressed;

  case NEW_S|NEW_A:
    if (deltaS == deltaA && deltaS == lwip_ntohs(IPH_LEN(&cs->cs_ip)) - hlen) {
 801b914:	214a      	movs	r1, #74	; 0x4a
 801b916:	187a      	adds	r2, r7, r1
 801b918:	2348      	movs	r3, #72	; 0x48
 801b91a:	18fb      	adds	r3, r7, r3
 801b91c:	8812      	ldrh	r2, [r2, #0]
 801b91e:	881b      	ldrh	r3, [r3, #0]
 801b920:	429a      	cmp	r2, r3
 801b922:	d12c      	bne.n	801b97e <vj_compress_tcp+0x6d2>
 801b924:	187b      	adds	r3, r7, r1
 801b926:	881c      	ldrh	r4, [r3, #0]
 801b928:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b92a:	895b      	ldrh	r3, [r3, #10]
 801b92c:	0018      	movs	r0, r3
 801b92e:	f7ea fe01 	bl	8006534 <lwip_htons>
 801b932:	0003      	movs	r3, r0
 801b934:	001a      	movs	r2, r3
 801b936:	232e      	movs	r3, #46	; 0x2e
 801b938:	18fb      	adds	r3, r7, r3
 801b93a:	881b      	ldrh	r3, [r3, #0]
 801b93c:	1ad3      	subs	r3, r2, r3
 801b93e:	429c      	cmp	r4, r3
 801b940:	d11d      	bne.n	801b97e <vj_compress_tcp+0x6d2>
      /* special case for echoed terminal traffic */
      changes = SPECIAL_I;
 801b942:	230b      	movs	r3, #11
 801b944:	647b      	str	r3, [r7, #68]	; 0x44
      cp = new_seq;
 801b946:	230c      	movs	r3, #12
 801b948:	18fb      	adds	r3, r7, r3
 801b94a:	643b      	str	r3, [r7, #64]	; 0x40
    }
    break;
 801b94c:	e017      	b.n	801b97e <vj_compress_tcp+0x6d2>

  case NEW_S:
    if (deltaS == lwip_ntohs(IPH_LEN(&cs->cs_ip)) - hlen) {
 801b94e:	234a      	movs	r3, #74	; 0x4a
 801b950:	18fb      	adds	r3, r7, r3
 801b952:	881c      	ldrh	r4, [r3, #0]
 801b954:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b956:	895b      	ldrh	r3, [r3, #10]
 801b958:	0018      	movs	r0, r3
 801b95a:	f7ea fdeb 	bl	8006534 <lwip_htons>
 801b95e:	0003      	movs	r3, r0
 801b960:	001a      	movs	r2, r3
 801b962:	232e      	movs	r3, #46	; 0x2e
 801b964:	18fb      	adds	r3, r7, r3
 801b966:	881b      	ldrh	r3, [r3, #0]
 801b968:	1ad3      	subs	r3, r2, r3
 801b96a:	429c      	cmp	r4, r3
 801b96c:	d109      	bne.n	801b982 <vj_compress_tcp+0x6d6>
      /* special case for data xfer */
      changes = SPECIAL_D;
 801b96e:	230f      	movs	r3, #15
 801b970:	647b      	str	r3, [r7, #68]	; 0x44
      cp = new_seq;
 801b972:	230c      	movs	r3, #12
 801b974:	18fb      	adds	r3, r7, r3
 801b976:	643b      	str	r3, [r7, #64]	; 0x40
    }
    break;
 801b978:	e003      	b.n	801b982 <vj_compress_tcp+0x6d6>
  default:
     break;
 801b97a:	46c0      	nop			; (mov r8, r8)
 801b97c:	e002      	b.n	801b984 <vj_compress_tcp+0x6d8>
    break;
 801b97e:	46c0      	nop			; (mov r8, r8)
 801b980:	e000      	b.n	801b984 <vj_compress_tcp+0x6d8>
    break;
 801b982:	46c0      	nop			; (mov r8, r8)
  }

  deltaS = (u16_t)(lwip_ntohs(IPH_ID(ip)) - lwip_ntohs(IPH_ID(&cs->cs_ip)));
 801b984:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b986:	791a      	ldrb	r2, [r3, #4]
 801b988:	795b      	ldrb	r3, [r3, #5]
 801b98a:	021b      	lsls	r3, r3, #8
 801b98c:	4313      	orrs	r3, r2
 801b98e:	b29b      	uxth	r3, r3
 801b990:	0018      	movs	r0, r3
 801b992:	f7ea fdcf 	bl	8006534 <lwip_htons>
 801b996:	0003      	movs	r3, r0
 801b998:	001c      	movs	r4, r3
 801b99a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801b99c:	899b      	ldrh	r3, [r3, #12]
 801b99e:	0018      	movs	r0, r3
 801b9a0:	f7ea fdc8 	bl	8006534 <lwip_htons>
 801b9a4:	0003      	movs	r3, r0
 801b9a6:	001a      	movs	r2, r3
 801b9a8:	214a      	movs	r1, #74	; 0x4a
 801b9aa:	187b      	adds	r3, r7, r1
 801b9ac:	1aa2      	subs	r2, r4, r2
 801b9ae:	801a      	strh	r2, [r3, #0]
  if (deltaS != 1) {
 801b9b0:	187b      	adds	r3, r7, r1
 801b9b2:	881b      	ldrh	r3, [r3, #0]
 801b9b4:	2b01      	cmp	r3, #1
 801b9b6:	d02a      	beq.n	801ba0e <vj_compress_tcp+0x762>
    ENCODEZ(deltaS);
 801b9b8:	187b      	adds	r3, r7, r1
 801b9ba:	881b      	ldrh	r3, [r3, #0]
 801b9bc:	2bff      	cmp	r3, #255	; 0xff
 801b9be:	d803      	bhi.n	801b9c8 <vj_compress_tcp+0x71c>
 801b9c0:	187b      	adds	r3, r7, r1
 801b9c2:	881b      	ldrh	r3, [r3, #0]
 801b9c4:	2b00      	cmp	r3, #0
 801b9c6:	d116      	bne.n	801b9f6 <vj_compress_tcp+0x74a>
 801b9c8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b9ca:	1c5a      	adds	r2, r3, #1
 801b9cc:	643a      	str	r2, [r7, #64]	; 0x40
 801b9ce:	2200      	movs	r2, #0
 801b9d0:	701a      	strb	r2, [r3, #0]
 801b9d2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b9d4:	3301      	adds	r3, #1
 801b9d6:	214a      	movs	r1, #74	; 0x4a
 801b9d8:	187a      	adds	r2, r7, r1
 801b9da:	8812      	ldrh	r2, [r2, #0]
 801b9dc:	b2d2      	uxtb	r2, r2
 801b9de:	701a      	strb	r2, [r3, #0]
 801b9e0:	187b      	adds	r3, r7, r1
 801b9e2:	881b      	ldrh	r3, [r3, #0]
 801b9e4:	0a1b      	lsrs	r3, r3, #8
 801b9e6:	b29b      	uxth	r3, r3
 801b9e8:	b2da      	uxtb	r2, r3
 801b9ea:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b9ec:	701a      	strb	r2, [r3, #0]
 801b9ee:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b9f0:	3302      	adds	r3, #2
 801b9f2:	643b      	str	r3, [r7, #64]	; 0x40
 801b9f4:	e007      	b.n	801ba06 <vj_compress_tcp+0x75a>
 801b9f6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b9f8:	1c5a      	adds	r2, r3, #1
 801b9fa:	643a      	str	r2, [r7, #64]	; 0x40
 801b9fc:	224a      	movs	r2, #74	; 0x4a
 801b9fe:	18ba      	adds	r2, r7, r2
 801ba00:	8812      	ldrh	r2, [r2, #0]
 801ba02:	b2d2      	uxtb	r2, r2
 801ba04:	701a      	strb	r2, [r3, #0]
    changes |= NEW_I;
 801ba06:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801ba08:	2220      	movs	r2, #32
 801ba0a:	4313      	orrs	r3, r2
 801ba0c:	647b      	str	r3, [r7, #68]	; 0x44
  }
  if (TCPH_FLAGS(th) & TCP_PSH) {
 801ba0e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ba10:	7b1a      	ldrb	r2, [r3, #12]
 801ba12:	7b5b      	ldrb	r3, [r3, #13]
 801ba14:	021b      	lsls	r3, r3, #8
 801ba16:	4313      	orrs	r3, r2
 801ba18:	b29b      	uxth	r3, r3
 801ba1a:	0018      	movs	r0, r3
 801ba1c:	f7ea fd8a 	bl	8006534 <lwip_htons>
 801ba20:	0003      	movs	r3, r0
 801ba22:	b2db      	uxtb	r3, r3
 801ba24:	001a      	movs	r2, r3
 801ba26:	2308      	movs	r3, #8
 801ba28:	4013      	ands	r3, r2
 801ba2a:	d003      	beq.n	801ba34 <vj_compress_tcp+0x788>
    changes |= TCP_PUSH_BIT;
 801ba2c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801ba2e:	2210      	movs	r2, #16
 801ba30:	4313      	orrs	r3, r2
 801ba32:	647b      	str	r3, [r7, #68]	; 0x44
  }
  /*
   * Grab the cksum before we overwrite it below.  Then update our
   * state with this packet's header.
   */
  deltaA = lwip_ntohs(th->chksum);
 801ba34:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ba36:	7c1a      	ldrb	r2, [r3, #16]
 801ba38:	7c5b      	ldrb	r3, [r3, #17]
 801ba3a:	021b      	lsls	r3, r3, #8
 801ba3c:	4313      	orrs	r3, r2
 801ba3e:	b29b      	uxth	r3, r3
 801ba40:	2248      	movs	r2, #72	; 0x48
 801ba42:	18bc      	adds	r4, r7, r2
 801ba44:	0018      	movs	r0, r3
 801ba46:	f7ea fd75 	bl	8006534 <lwip_htons>
 801ba4a:	0003      	movs	r3, r0
 801ba4c:	8023      	strh	r3, [r4, #0]
  MEMCPY(&cs->cs_ip, ip, hlen);
 801ba4e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801ba50:	3308      	adds	r3, #8
 801ba52:	0018      	movs	r0, r3
 801ba54:	232e      	movs	r3, #46	; 0x2e
 801ba56:	18fb      	adds	r3, r7, r3
 801ba58:	881a      	ldrh	r2, [r3, #0]
 801ba5a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801ba5c:	0019      	movs	r1, r3
 801ba5e:	f000 fec9 	bl	801c7f4 <memcpy>
   * mask, one for the connection id and two for the tcp checksum.
   * So, (cp - new_seq) + 4 bytes of header are needed.  hlen is how
   * many bytes of the original packet to toss so subtract the two to
   * get the new packet size.
   */
  deltaS = (u16_t)(cp - new_seq);
 801ba62:	230c      	movs	r3, #12
 801ba64:	18fb      	adds	r3, r7, r3
 801ba66:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801ba68:	1ad2      	subs	r2, r2, r3
 801ba6a:	234a      	movs	r3, #74	; 0x4a
 801ba6c:	18fb      	adds	r3, r7, r3
 801ba6e:	801a      	strh	r2, [r3, #0]
  if (!comp->compressSlot || comp->last_xmit != cs->cs_id) {
 801ba70:	687b      	ldr	r3, [r7, #4]
 801ba72:	7a5b      	ldrb	r3, [r3, #9]
 801ba74:	2b00      	cmp	r3, #0
 801ba76:	d005      	beq.n	801ba84 <vj_compress_tcp+0x7d8>
 801ba78:	687b      	ldr	r3, [r7, #4]
 801ba7a:	795a      	ldrb	r2, [r3, #5]
 801ba7c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801ba7e:	799b      	ldrb	r3, [r3, #6]
 801ba80:	429a      	cmp	r2, r3
 801ba82:	d031      	beq.n	801bae8 <vj_compress_tcp+0x83c>
    comp->last_xmit = cs->cs_id;
 801ba84:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801ba86:	799a      	ldrb	r2, [r3, #6]
 801ba88:	687b      	ldr	r3, [r7, #4]
 801ba8a:	715a      	strb	r2, [r3, #5]
    hlen -= deltaS + 4;
 801ba8c:	212e      	movs	r1, #46	; 0x2e
 801ba8e:	187a      	adds	r2, r7, r1
 801ba90:	234a      	movs	r3, #74	; 0x4a
 801ba92:	18fb      	adds	r3, r7, r3
 801ba94:	8812      	ldrh	r2, [r2, #0]
 801ba96:	881b      	ldrh	r3, [r3, #0]
 801ba98:	1ad3      	subs	r3, r2, r3
 801ba9a:	b29a      	uxth	r2, r3
 801ba9c:	187b      	adds	r3, r7, r1
 801ba9e:	3a04      	subs	r2, #4
 801baa0:	801a      	strh	r2, [r3, #0]
    if (pbuf_remove_header(np, hlen)){
 801baa2:	187b      	adds	r3, r7, r1
 801baa4:	881a      	ldrh	r2, [r3, #0]
 801baa6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801baa8:	0011      	movs	r1, r2
 801baaa:	0018      	movs	r0, r3
 801baac:	f7ed fd1a 	bl	80094e4 <pbuf_remove_header>
 801bab0:	1e03      	subs	r3, r0, #0
 801bab2:	d006      	beq.n	801bac2 <vj_compress_tcp+0x816>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 801bab4:	4b3d      	ldr	r3, [pc, #244]	; (801bbac <vj_compress_tcp+0x900>)
 801bab6:	22ce      	movs	r2, #206	; 0xce
 801bab8:	0052      	lsls	r2, r2, #1
 801baba:	493d      	ldr	r1, [pc, #244]	; (801bbb0 <vj_compress_tcp+0x904>)
 801babc:	483d      	ldr	r0, [pc, #244]	; (801bbb4 <vj_compress_tcp+0x908>)
 801babe:	f7e6 fb85 	bl	80021cc <app_debug_rtt_raw>
    }
    cp = (u8_t*)np->payload;
 801bac2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801bac4:	685b      	ldr	r3, [r3, #4]
 801bac6:	643b      	str	r3, [r7, #64]	; 0x40
    *cp++ = (u8_t)(changes | NEW_C);
 801bac8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801baca:	b2da      	uxtb	r2, r3
 801bacc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bace:	1c59      	adds	r1, r3, #1
 801bad0:	6439      	str	r1, [r7, #64]	; 0x40
 801bad2:	2140      	movs	r1, #64	; 0x40
 801bad4:	430a      	orrs	r2, r1
 801bad6:	b2d2      	uxtb	r2, r2
 801bad8:	701a      	strb	r2, [r3, #0]
    *cp++ = cs->cs_id;
 801bada:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801badc:	1c5a      	adds	r2, r3, #1
 801bade:	643a      	str	r2, [r7, #64]	; 0x40
 801bae0:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801bae2:	7992      	ldrb	r2, [r2, #6]
 801bae4:	701a      	strb	r2, [r3, #0]
 801bae6:	e023      	b.n	801bb30 <vj_compress_tcp+0x884>
  } else {
    hlen -= deltaS + 3;
 801bae8:	212e      	movs	r1, #46	; 0x2e
 801baea:	187a      	adds	r2, r7, r1
 801baec:	234a      	movs	r3, #74	; 0x4a
 801baee:	18fb      	adds	r3, r7, r3
 801baf0:	8812      	ldrh	r2, [r2, #0]
 801baf2:	881b      	ldrh	r3, [r3, #0]
 801baf4:	1ad3      	subs	r3, r2, r3
 801baf6:	b29a      	uxth	r2, r3
 801baf8:	187b      	adds	r3, r7, r1
 801bafa:	3a03      	subs	r2, #3
 801bafc:	801a      	strh	r2, [r3, #0]
    if (pbuf_remove_header(np, hlen)) {
 801bafe:	187b      	adds	r3, r7, r1
 801bb00:	881a      	ldrh	r2, [r3, #0]
 801bb02:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801bb04:	0011      	movs	r1, r2
 801bb06:	0018      	movs	r0, r3
 801bb08:	f7ed fcec 	bl	80094e4 <pbuf_remove_header>
 801bb0c:	1e03      	subs	r3, r0, #0
 801bb0e:	d006      	beq.n	801bb1e <vj_compress_tcp+0x872>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 801bb10:	4b26      	ldr	r3, [pc, #152]	; (801bbac <vj_compress_tcp+0x900>)
 801bb12:	22a6      	movs	r2, #166	; 0xa6
 801bb14:	32ff      	adds	r2, #255	; 0xff
 801bb16:	4926      	ldr	r1, [pc, #152]	; (801bbb0 <vj_compress_tcp+0x904>)
 801bb18:	4826      	ldr	r0, [pc, #152]	; (801bbb4 <vj_compress_tcp+0x908>)
 801bb1a:	f7e6 fb57 	bl	80021cc <app_debug_rtt_raw>
    }
    cp = (u8_t*)np->payload;
 801bb1e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801bb20:	685b      	ldr	r3, [r3, #4]
 801bb22:	643b      	str	r3, [r7, #64]	; 0x40
    *cp++ = (u8_t)changes;
 801bb24:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bb26:	1c5a      	adds	r2, r3, #1
 801bb28:	643a      	str	r2, [r7, #64]	; 0x40
 801bb2a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801bb2c:	b2d2      	uxtb	r2, r2
 801bb2e:	701a      	strb	r2, [r3, #0]
  }
  *cp++ = (u8_t)(deltaA >> 8);
 801bb30:	2048      	movs	r0, #72	; 0x48
 801bb32:	183b      	adds	r3, r7, r0
 801bb34:	881b      	ldrh	r3, [r3, #0]
 801bb36:	0a1b      	lsrs	r3, r3, #8
 801bb38:	b299      	uxth	r1, r3
 801bb3a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bb3c:	1c5a      	adds	r2, r3, #1
 801bb3e:	643a      	str	r2, [r7, #64]	; 0x40
 801bb40:	b2ca      	uxtb	r2, r1
 801bb42:	701a      	strb	r2, [r3, #0]
  *cp++ = (u8_t)deltaA;
 801bb44:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bb46:	1c5a      	adds	r2, r3, #1
 801bb48:	643a      	str	r2, [r7, #64]	; 0x40
 801bb4a:	183a      	adds	r2, r7, r0
 801bb4c:	8812      	ldrh	r2, [r2, #0]
 801bb4e:	b2d2      	uxtb	r2, r2
 801bb50:	701a      	strb	r2, [r3, #0]
  MEMCPY(cp, new_seq, deltaS);
 801bb52:	234a      	movs	r3, #74	; 0x4a
 801bb54:	18fb      	adds	r3, r7, r3
 801bb56:	881a      	ldrh	r2, [r3, #0]
 801bb58:	230c      	movs	r3, #12
 801bb5a:	18f9      	adds	r1, r7, r3
 801bb5c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bb5e:	0018      	movs	r0, r3
 801bb60:	f000 fe48 	bl	801c7f4 <memcpy>
  INCR(vjs_compressed);
  return (TYPE_COMPRESSED_TCP);
 801bb64:	2380      	movs	r3, #128	; 0x80
 801bb66:	e01b      	b.n	801bba0 <vj_compress_tcp+0x8f4>
    goto uncompressed;
 801bb68:	46c0      	nop			; (mov r8, r8)
 801bb6a:	e006      	b.n	801bb7a <vj_compress_tcp+0x8ce>
    goto uncompressed;
 801bb6c:	46c0      	nop			; (mov r8, r8)
 801bb6e:	e004      	b.n	801bb7a <vj_compress_tcp+0x8ce>
      goto uncompressed;
 801bb70:	46c0      	nop			; (mov r8, r8)
 801bb72:	e002      	b.n	801bb7a <vj_compress_tcp+0x8ce>
      goto uncompressed;
 801bb74:	46c0      	nop			; (mov r8, r8)
 801bb76:	e000      	b.n	801bb7a <vj_compress_tcp+0x8ce>
    goto uncompressed;
 801bb78:	46c0      	nop			; (mov r8, r8)
   * Update connection state cs & send uncompressed packet (that is,
   * a regular ip/tcp packet but with the 'conversation id' we hope
   * to use on future compressed packets in the protocol field).
   */
uncompressed:
  MEMCPY(&cs->cs_ip, ip, hlen);
 801bb7a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bb7c:	3308      	adds	r3, #8
 801bb7e:	0018      	movs	r0, r3
 801bb80:	232e      	movs	r3, #46	; 0x2e
 801bb82:	18fb      	adds	r3, r7, r3
 801bb84:	881a      	ldrh	r2, [r3, #0]
 801bb86:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801bb88:	0019      	movs	r1, r3
 801bb8a:	f000 fe33 	bl	801c7f4 <memcpy>
  IPH_PROTO_SET(ip, cs->cs_id);
 801bb8e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bb90:	799a      	ldrb	r2, [r3, #6]
 801bb92:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801bb94:	725a      	strb	r2, [r3, #9]
  comp->last_xmit = cs->cs_id;
 801bb96:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bb98:	799a      	ldrb	r2, [r3, #6]
 801bb9a:	687b      	ldr	r3, [r7, #4]
 801bb9c:	715a      	strb	r2, [r3, #5]
  return (TYPE_UNCOMPRESSED_TCP);
 801bb9e:	2370      	movs	r3, #112	; 0x70
}
 801bba0:	0018      	movs	r0, r3
 801bba2:	46bd      	mov	sp, r7
 801bba4:	b014      	add	sp, #80	; 0x50
 801bba6:	bdb0      	pop	{r4, r5, r7, pc}
 801bba8:	08021fec 	.word	0x08021fec
 801bbac:	08021430 	.word	0x08021430
 801bbb0:	0802145c 	.word	0x0802145c
 801bbb4:	08021478 	.word	0x08021478

0801bbb8 <vj_uncompress_err>:
/*
 * Called when we may have missed a packet.
 */
void
vj_uncompress_err(struct vjcompress *comp)
{
 801bbb8:	b580      	push	{r7, lr}
 801bbba:	b082      	sub	sp, #8
 801bbbc:	af00      	add	r7, sp, #0
 801bbbe:	6078      	str	r0, [r7, #4]
  comp->flags |= VJF_TOSS;
 801bbc0:	687b      	ldr	r3, [r7, #4]
 801bbc2:	88db      	ldrh	r3, [r3, #6]
 801bbc4:	2201      	movs	r2, #1
 801bbc6:	4313      	orrs	r3, r2
 801bbc8:	b29a      	uxth	r2, r3
 801bbca:	687b      	ldr	r3, [r7, #4]
 801bbcc:	80da      	strh	r2, [r3, #6]
  INCR(vjs_errorin);
}
 801bbce:	46c0      	nop			; (mov r8, r8)
 801bbd0:	46bd      	mov	sp, r7
 801bbd2:	b002      	add	sp, #8
 801bbd4:	bd80      	pop	{r7, pc}
	...

0801bbd8 <vj_uncompress_uncomp>:
 * "Uncompress" a packet of type TYPE_UNCOMPRESSED_TCP.
 * Return 0 on success, -1 on failure.
 */
int
vj_uncompress_uncomp(struct pbuf *nb, struct vjcompress *comp)
{
 801bbd8:	b580      	push	{r7, lr}
 801bbda:	b086      	sub	sp, #24
 801bbdc:	af00      	add	r7, sp, #0
 801bbde:	6078      	str	r0, [r7, #4]
 801bbe0:	6039      	str	r1, [r7, #0]
  u32_t hlen;
  struct cstate *cs;
  struct ip_hdr *ip;

  ip = (struct ip_hdr *)nb->payload;
 801bbe2:	687b      	ldr	r3, [r7, #4]
 801bbe4:	685b      	ldr	r3, [r3, #4]
 801bbe6:	617b      	str	r3, [r7, #20]
  hlen = IPH_HL(ip) << 2;
 801bbe8:	697b      	ldr	r3, [r7, #20]
 801bbea:	781b      	ldrb	r3, [r3, #0]
 801bbec:	009b      	lsls	r3, r3, #2
 801bbee:	001a      	movs	r2, r3
 801bbf0:	233c      	movs	r3, #60	; 0x3c
 801bbf2:	4013      	ands	r3, r2
 801bbf4:	613b      	str	r3, [r7, #16]
  if (IPH_PROTO(ip) >= MAX_SLOTS
 801bbf6:	697b      	ldr	r3, [r7, #20]
 801bbf8:	7a5b      	ldrb	r3, [r3, #9]
 801bbfa:	2b0f      	cmp	r3, #15
 801bbfc:	d823      	bhi.n	801bc46 <vj_uncompress_uncomp+0x6e>
      || hlen + sizeof(struct tcp_hdr) > nb->len
 801bbfe:	693b      	ldr	r3, [r7, #16]
 801bc00:	3314      	adds	r3, #20
 801bc02:	687a      	ldr	r2, [r7, #4]
 801bc04:	8952      	ldrh	r2, [r2, #10]
 801bc06:	4293      	cmp	r3, r2
 801bc08:	d81d      	bhi.n	801bc46 <vj_uncompress_uncomp+0x6e>
      || (hlen += TCPH_HDRLEN_BYTES((struct tcp_hdr *)&((char *)ip)[hlen]))
 801bc0a:	697a      	ldr	r2, [r7, #20]
 801bc0c:	693b      	ldr	r3, [r7, #16]
 801bc0e:	18d3      	adds	r3, r2, r3
 801bc10:	7b1a      	ldrb	r2, [r3, #12]
 801bc12:	7b5b      	ldrb	r3, [r3, #13]
 801bc14:	021b      	lsls	r3, r3, #8
 801bc16:	4313      	orrs	r3, r2
 801bc18:	b29b      	uxth	r3, r3
 801bc1a:	0018      	movs	r0, r3
 801bc1c:	f7ea fc8a 	bl	8006534 <lwip_htons>
 801bc20:	0003      	movs	r3, r0
 801bc22:	0b1b      	lsrs	r3, r3, #12
 801bc24:	b29b      	uxth	r3, r3
 801bc26:	b2db      	uxtb	r3, r3
 801bc28:	009b      	lsls	r3, r3, #2
 801bc2a:	b2db      	uxtb	r3, r3
 801bc2c:	001a      	movs	r2, r3
 801bc2e:	693b      	ldr	r3, [r7, #16]
 801bc30:	189b      	adds	r3, r3, r2
 801bc32:	613b      	str	r3, [r7, #16]
          > nb->len
 801bc34:	687b      	ldr	r3, [r7, #4]
 801bc36:	895b      	ldrh	r3, [r3, #10]
 801bc38:	001a      	movs	r2, r3
      || (hlen += TCPH_HDRLEN_BYTES((struct tcp_hdr *)&((char *)ip)[hlen]))
 801bc3a:	693b      	ldr	r3, [r7, #16]
 801bc3c:	4293      	cmp	r3, r2
 801bc3e:	d802      	bhi.n	801bc46 <vj_uncompress_uncomp+0x6e>
      || hlen > MAX_HDR) {
 801bc40:	693b      	ldr	r3, [r7, #16]
 801bc42:	2b80      	cmp	r3, #128	; 0x80
 801bc44:	d906      	bls.n	801bc54 <vj_uncompress_uncomp+0x7c>
    PPPDEBUG(LOG_INFO, ("vj_uncompress_uncomp: bad cid=%d, hlen=%d buflen=%d\n",
      IPH_PROTO(ip), hlen, nb->len));
    vj_uncompress_err(comp);
 801bc46:	683b      	ldr	r3, [r7, #0]
 801bc48:	0018      	movs	r0, r3
 801bc4a:	f7ff ffb5 	bl	801bbb8 <vj_uncompress_err>
    return -1;
 801bc4e:	2301      	movs	r3, #1
 801bc50:	425b      	negs	r3, r3
 801bc52:	e029      	b.n	801bca8 <vj_uncompress_uncomp+0xd0>
  }
  cs = &comp->rstate[comp->last_recv = IPH_PROTO(ip)];
 801bc54:	697b      	ldr	r3, [r7, #20]
 801bc56:	7a5a      	ldrb	r2, [r3, #9]
 801bc58:	683b      	ldr	r3, [r7, #0]
 801bc5a:	711a      	strb	r2, [r3, #4]
 801bc5c:	683b      	ldr	r3, [r7, #0]
 801bc5e:	791b      	ldrb	r3, [r3, #4]
 801bc60:	001a      	movs	r2, r3
 801bc62:	0013      	movs	r3, r2
 801bc64:	011b      	lsls	r3, r3, #4
 801bc66:	189b      	adds	r3, r3, r2
 801bc68:	00db      	lsls	r3, r3, #3
 801bc6a:	4a11      	ldr	r2, [pc, #68]	; (801bcb0 <vj_uncompress_uncomp+0xd8>)
 801bc6c:	4694      	mov	ip, r2
 801bc6e:	4463      	add	r3, ip
 801bc70:	683a      	ldr	r2, [r7, #0]
 801bc72:	18d3      	adds	r3, r2, r3
 801bc74:	3304      	adds	r3, #4
 801bc76:	60fb      	str	r3, [r7, #12]
  comp->flags &=~ VJF_TOSS;
 801bc78:	683b      	ldr	r3, [r7, #0]
 801bc7a:	88db      	ldrh	r3, [r3, #6]
 801bc7c:	2201      	movs	r2, #1
 801bc7e:	4393      	bics	r3, r2
 801bc80:	b29a      	uxth	r2, r3
 801bc82:	683b      	ldr	r3, [r7, #0]
 801bc84:	80da      	strh	r2, [r3, #6]
  IPH_PROTO_SET(ip, IP_PROTO_TCP);
 801bc86:	697b      	ldr	r3, [r7, #20]
 801bc88:	2206      	movs	r2, #6
 801bc8a:	725a      	strb	r2, [r3, #9]
  /* copy from/to bigger buffers checked above instead of cs->cs_ip and ip
     just to help static code analysis to see this is correct ;-) */
  MEMCPY(&cs->cs_hdr, nb->payload, hlen);
 801bc8c:	68fb      	ldr	r3, [r7, #12]
 801bc8e:	3308      	adds	r3, #8
 801bc90:	0018      	movs	r0, r3
 801bc92:	687b      	ldr	r3, [r7, #4]
 801bc94:	685b      	ldr	r3, [r3, #4]
 801bc96:	693a      	ldr	r2, [r7, #16]
 801bc98:	0019      	movs	r1, r3
 801bc9a:	f000 fdab 	bl	801c7f4 <memcpy>
  cs->cs_hlen = (u16_t)hlen;
 801bc9e:	693b      	ldr	r3, [r7, #16]
 801bca0:	b29a      	uxth	r2, r3
 801bca2:	68fb      	ldr	r3, [r7, #12]
 801bca4:	809a      	strh	r2, [r3, #4]
  INCR(vjs_uncompressedin);
  return 0;
 801bca6:	2300      	movs	r3, #0
}
 801bca8:	0018      	movs	r0, r3
 801bcaa:	46bd      	mov	sp, r7
 801bcac:	b006      	add	sp, #24
 801bcae:	bd80      	pop	{r7, pc}
 801bcb0:	00000888 	.word	0x00000888

0801bcb4 <vj_uncompress_tcp>:
 * This procedure replaces the compressed header with the uncompressed
 * header and returns the length of the VJ header.
 */
int
vj_uncompress_tcp(struct pbuf **nb, struct vjcompress *comp)
{
 801bcb4:	b590      	push	{r4, r7, lr}
 801bcb6:	b095      	sub	sp, #84	; 0x54
 801bcb8:	af00      	add	r7, sp, #0
 801bcba:	6078      	str	r0, [r7, #4]
 801bcbc:	6039      	str	r1, [r7, #0]
  u8_t *cp;
  struct tcp_hdr *th;
  struct cstate *cs;
  struct vj_u16_t *bp;
  struct pbuf *n0 = *nb;
 801bcbe:	687b      	ldr	r3, [r7, #4]
 801bcc0:	681b      	ldr	r3, [r3, #0]
 801bcc2:	647b      	str	r3, [r7, #68]	; 0x44
  u32_t tmp;
  u32_t vjlen, hlen, changes;

  INCR(vjs_compressedin);
  cp = (u8_t*)n0->payload;
 801bcc4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bcc6:	685b      	ldr	r3, [r3, #4]
 801bcc8:	64fb      	str	r3, [r7, #76]	; 0x4c
  changes = *cp++;
 801bcca:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bccc:	1c5a      	adds	r2, r3, #1
 801bcce:	64fa      	str	r2, [r7, #76]	; 0x4c
 801bcd0:	781b      	ldrb	r3, [r3, #0]
 801bcd2:	63bb      	str	r3, [r7, #56]	; 0x38
  if (changes & NEW_C) {
 801bcd4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801bcd6:	2240      	movs	r2, #64	; 0x40
 801bcd8:	4013      	ands	r3, r2
 801bcda:	d013      	beq.n	801bd04 <vj_uncompress_tcp+0x50>
    /*
     * Make sure the state index is in range, then grab the state.
     * If we have a good state index, clear the 'discard' flag.
     */
    if (*cp >= MAX_SLOTS) {
 801bcdc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bcde:	781b      	ldrb	r3, [r3, #0]
 801bce0:	2b0f      	cmp	r3, #15
 801bce2:	d901      	bls.n	801bce8 <vj_uncompress_tcp+0x34>
 801bce4:	f000 fd00 	bl	801c6e8 <vj_uncompress_tcp+0xa34>
      PPPDEBUG(LOG_INFO, ("vj_uncompress_tcp: bad cid=%d\n", *cp));
      goto bad;
    }

    comp->flags &=~ VJF_TOSS;
 801bce8:	683b      	ldr	r3, [r7, #0]
 801bcea:	88db      	ldrh	r3, [r3, #6]
 801bcec:	2201      	movs	r2, #1
 801bcee:	4393      	bics	r3, r2
 801bcf0:	b29a      	uxth	r2, r3
 801bcf2:	683b      	ldr	r3, [r7, #0]
 801bcf4:	80da      	strh	r2, [r3, #6]
    comp->last_recv = *cp++;
 801bcf6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bcf8:	1c5a      	adds	r2, r3, #1
 801bcfa:	64fa      	str	r2, [r7, #76]	; 0x4c
 801bcfc:	781a      	ldrb	r2, [r3, #0]
 801bcfe:	683b      	ldr	r3, [r7, #0]
 801bd00:	711a      	strb	r2, [r3, #4]
 801bd02:	e009      	b.n	801bd18 <vj_uncompress_tcp+0x64>
    /*
     * this packet has an implicit state index.  If we've
     * had a line error since the last time we got an
     * explicit state index, we have to toss the packet.
     */
    if (comp->flags & VJF_TOSS) {
 801bd04:	683b      	ldr	r3, [r7, #0]
 801bd06:	88db      	ldrh	r3, [r3, #6]
 801bd08:	001a      	movs	r2, r3
 801bd0a:	2301      	movs	r3, #1
 801bd0c:	4013      	ands	r3, r2
 801bd0e:	d003      	beq.n	801bd18 <vj_uncompress_tcp+0x64>
      PPPDEBUG(LOG_INFO, ("vj_uncompress_tcp: tossing\n"));
      INCR(vjs_tossed);
      return (-1);
 801bd10:	2301      	movs	r3, #1
 801bd12:	425b      	negs	r3, r3
 801bd14:	f000 fcf5 	bl	801c702 <vj_uncompress_tcp+0xa4e>
    }
  }
  cs = &comp->rstate[comp->last_recv];
 801bd18:	683b      	ldr	r3, [r7, #0]
 801bd1a:	791b      	ldrb	r3, [r3, #4]
 801bd1c:	001a      	movs	r2, r3
 801bd1e:	0013      	movs	r3, r2
 801bd20:	011b      	lsls	r3, r3, #4
 801bd22:	189b      	adds	r3, r3, r2
 801bd24:	00db      	lsls	r3, r3, #3
 801bd26:	4ae9      	ldr	r2, [pc, #932]	; (801c0cc <vj_uncompress_tcp+0x418>)
 801bd28:	4694      	mov	ip, r2
 801bd2a:	4463      	add	r3, ip
 801bd2c:	683a      	ldr	r2, [r7, #0]
 801bd2e:	18d3      	adds	r3, r2, r3
 801bd30:	3304      	adds	r3, #4
 801bd32:	637b      	str	r3, [r7, #52]	; 0x34
  hlen = IPH_HL(&cs->cs_ip) << 2;
 801bd34:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801bd36:	7a1b      	ldrb	r3, [r3, #8]
 801bd38:	009b      	lsls	r3, r3, #2
 801bd3a:	001a      	movs	r2, r3
 801bd3c:	233c      	movs	r3, #60	; 0x3c
 801bd3e:	4013      	ands	r3, r2
 801bd40:	63fb      	str	r3, [r7, #60]	; 0x3c
  th = (struct tcp_hdr *)&((u8_t*)&cs->cs_ip)[hlen];
 801bd42:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801bd44:	3308      	adds	r3, #8
 801bd46:	001a      	movs	r2, r3
 801bd48:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801bd4a:	18d3      	adds	r3, r2, r3
 801bd4c:	633b      	str	r3, [r7, #48]	; 0x30
  th->chksum = lwip_htons((*cp << 8) | cp[1]);
 801bd4e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bd50:	781b      	ldrb	r3, [r3, #0]
 801bd52:	021b      	lsls	r3, r3, #8
 801bd54:	b21a      	sxth	r2, r3
 801bd56:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bd58:	3301      	adds	r3, #1
 801bd5a:	781b      	ldrb	r3, [r3, #0]
 801bd5c:	b21b      	sxth	r3, r3
 801bd5e:	4313      	orrs	r3, r2
 801bd60:	b21b      	sxth	r3, r3
 801bd62:	b29b      	uxth	r3, r3
 801bd64:	0018      	movs	r0, r3
 801bd66:	f7ea fbe5 	bl	8006534 <lwip_htons>
 801bd6a:	0003      	movs	r3, r0
 801bd6c:	001a      	movs	r2, r3
 801bd6e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bd70:	21ff      	movs	r1, #255	; 0xff
 801bd72:	4011      	ands	r1, r2
 801bd74:	000c      	movs	r4, r1
 801bd76:	7c19      	ldrb	r1, [r3, #16]
 801bd78:	2000      	movs	r0, #0
 801bd7a:	4001      	ands	r1, r0
 801bd7c:	1c08      	adds	r0, r1, #0
 801bd7e:	1c21      	adds	r1, r4, #0
 801bd80:	4301      	orrs	r1, r0
 801bd82:	7419      	strb	r1, [r3, #16]
 801bd84:	0a12      	lsrs	r2, r2, #8
 801bd86:	b290      	uxth	r0, r2
 801bd88:	7c5a      	ldrb	r2, [r3, #17]
 801bd8a:	2100      	movs	r1, #0
 801bd8c:	400a      	ands	r2, r1
 801bd8e:	1c11      	adds	r1, r2, #0
 801bd90:	1c02      	adds	r2, r0, #0
 801bd92:	430a      	orrs	r2, r1
 801bd94:	745a      	strb	r2, [r3, #17]
  cp += 2;
 801bd96:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801bd98:	3302      	adds	r3, #2
 801bd9a:	64fb      	str	r3, [r7, #76]	; 0x4c
  if (changes & TCP_PUSH_BIT) {
 801bd9c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801bd9e:	2210      	movs	r2, #16
 801bda0:	4013      	ands	r3, r2
 801bda2:	d020      	beq.n	801bde6 <vj_uncompress_tcp+0x132>
    TCPH_SET_FLAG(th, TCP_PSH);
 801bda4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bda6:	7b1a      	ldrb	r2, [r3, #12]
 801bda8:	7b5b      	ldrb	r3, [r3, #13]
 801bdaa:	021b      	lsls	r3, r3, #8
 801bdac:	4313      	orrs	r3, r2
 801bdae:	b29c      	uxth	r4, r3
 801bdb0:	2008      	movs	r0, #8
 801bdb2:	f7ea fbbf 	bl	8006534 <lwip_htons>
 801bdb6:	0003      	movs	r3, r0
 801bdb8:	4323      	orrs	r3, r4
 801bdba:	b29a      	uxth	r2, r3
 801bdbc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bdbe:	21ff      	movs	r1, #255	; 0xff
 801bdc0:	4011      	ands	r1, r2
 801bdc2:	000c      	movs	r4, r1
 801bdc4:	7b19      	ldrb	r1, [r3, #12]
 801bdc6:	2000      	movs	r0, #0
 801bdc8:	4001      	ands	r1, r0
 801bdca:	1c08      	adds	r0, r1, #0
 801bdcc:	1c21      	adds	r1, r4, #0
 801bdce:	4301      	orrs	r1, r0
 801bdd0:	7319      	strb	r1, [r3, #12]
 801bdd2:	0a12      	lsrs	r2, r2, #8
 801bdd4:	b290      	uxth	r0, r2
 801bdd6:	7b5a      	ldrb	r2, [r3, #13]
 801bdd8:	2100      	movs	r1, #0
 801bdda:	400a      	ands	r2, r1
 801bddc:	1c11      	adds	r1, r2, #0
 801bdde:	1c02      	adds	r2, r0, #0
 801bde0:	430a      	orrs	r2, r1
 801bde2:	735a      	strb	r2, [r3, #13]
 801bde4:	e024      	b.n	801be30 <vj_uncompress_tcp+0x17c>
  } else {
    TCPH_UNSET_FLAG(th, TCP_PSH);
 801bde6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bde8:	7b1a      	ldrb	r2, [r3, #12]
 801bdea:	7b5b      	ldrb	r3, [r3, #13]
 801bdec:	021b      	lsls	r3, r3, #8
 801bdee:	4313      	orrs	r3, r2
 801bdf0:	b29b      	uxth	r3, r3
 801bdf2:	b21c      	sxth	r4, r3
 801bdf4:	2008      	movs	r0, #8
 801bdf6:	f7ea fb9d 	bl	8006534 <lwip_htons>
 801bdfa:	0003      	movs	r3, r0
 801bdfc:	b21b      	sxth	r3, r3
 801bdfe:	43db      	mvns	r3, r3
 801be00:	b21b      	sxth	r3, r3
 801be02:	4023      	ands	r3, r4
 801be04:	b21b      	sxth	r3, r3
 801be06:	b29a      	uxth	r2, r3
 801be08:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801be0a:	21ff      	movs	r1, #255	; 0xff
 801be0c:	4011      	ands	r1, r2
 801be0e:	000c      	movs	r4, r1
 801be10:	7b19      	ldrb	r1, [r3, #12]
 801be12:	2000      	movs	r0, #0
 801be14:	4001      	ands	r1, r0
 801be16:	1c08      	adds	r0, r1, #0
 801be18:	1c21      	adds	r1, r4, #0
 801be1a:	4301      	orrs	r1, r0
 801be1c:	7319      	strb	r1, [r3, #12]
 801be1e:	0a12      	lsrs	r2, r2, #8
 801be20:	b290      	uxth	r0, r2
 801be22:	7b5a      	ldrb	r2, [r3, #13]
 801be24:	2100      	movs	r1, #0
 801be26:	400a      	ands	r2, r1
 801be28:	1c11      	adds	r1, r2, #0
 801be2a:	1c02      	adds	r2, r0, #0
 801be2c:	430a      	orrs	r2, r1
 801be2e:	735a      	strb	r2, [r3, #13]
  }

  switch (changes & SPECIALS_MASK) {
 801be30:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801be32:	220f      	movs	r2, #15
 801be34:	4013      	ands	r3, r2
 801be36:	2b0b      	cmp	r3, #11
 801be38:	d003      	beq.n	801be42 <vj_uncompress_tcp+0x18e>
 801be3a:	2b0f      	cmp	r3, #15
 801be3c:	d100      	bne.n	801be40 <vj_uncompress_tcp+0x18c>
 801be3e:	e08c      	b.n	801bf5a <vj_uncompress_tcp+0x2a6>
 801be40:	e0d4      	b.n	801bfec <vj_uncompress_tcp+0x338>
  case SPECIAL_I:
    {
      u32_t i = lwip_ntohs(IPH_LEN(&cs->cs_ip)) - cs->cs_hlen;
 801be42:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801be44:	895b      	ldrh	r3, [r3, #10]
 801be46:	0018      	movs	r0, r3
 801be48:	f7ea fb74 	bl	8006534 <lwip_htons>
 801be4c:	0003      	movs	r3, r0
 801be4e:	001a      	movs	r2, r3
 801be50:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801be52:	889b      	ldrh	r3, [r3, #4]
 801be54:	1ad3      	subs	r3, r2, r3
 801be56:	62fb      	str	r3, [r7, #44]	; 0x2c
      /* some compilers can't nest inline assembler.. */
      tmp = lwip_ntohl(th->ackno) + i;
 801be58:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801be5a:	7a1a      	ldrb	r2, [r3, #8]
 801be5c:	7a59      	ldrb	r1, [r3, #9]
 801be5e:	0209      	lsls	r1, r1, #8
 801be60:	430a      	orrs	r2, r1
 801be62:	7a99      	ldrb	r1, [r3, #10]
 801be64:	0409      	lsls	r1, r1, #16
 801be66:	430a      	orrs	r2, r1
 801be68:	7adb      	ldrb	r3, [r3, #11]
 801be6a:	061b      	lsls	r3, r3, #24
 801be6c:	4313      	orrs	r3, r2
 801be6e:	0018      	movs	r0, r3
 801be70:	f7ea fb76 	bl	8006560 <lwip_htonl>
 801be74:	0002      	movs	r2, r0
 801be76:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801be78:	189b      	adds	r3, r3, r2
 801be7a:	643b      	str	r3, [r7, #64]	; 0x40
      th->ackno = lwip_htonl(tmp);
 801be7c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801be7e:	0018      	movs	r0, r3
 801be80:	f7ea fb6e 	bl	8006560 <lwip_htonl>
 801be84:	0002      	movs	r2, r0
 801be86:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801be88:	21ff      	movs	r1, #255	; 0xff
 801be8a:	4011      	ands	r1, r2
 801be8c:	000c      	movs	r4, r1
 801be8e:	7a19      	ldrb	r1, [r3, #8]
 801be90:	2000      	movs	r0, #0
 801be92:	4001      	ands	r1, r0
 801be94:	1c08      	adds	r0, r1, #0
 801be96:	1c21      	adds	r1, r4, #0
 801be98:	4301      	orrs	r1, r0
 801be9a:	7219      	strb	r1, [r3, #8]
 801be9c:	0a11      	lsrs	r1, r2, #8
 801be9e:	20ff      	movs	r0, #255	; 0xff
 801bea0:	4001      	ands	r1, r0
 801bea2:	000c      	movs	r4, r1
 801bea4:	7a59      	ldrb	r1, [r3, #9]
 801bea6:	2000      	movs	r0, #0
 801bea8:	4001      	ands	r1, r0
 801beaa:	1c08      	adds	r0, r1, #0
 801beac:	1c21      	adds	r1, r4, #0
 801beae:	4301      	orrs	r1, r0
 801beb0:	7259      	strb	r1, [r3, #9]
 801beb2:	0c11      	lsrs	r1, r2, #16
 801beb4:	20ff      	movs	r0, #255	; 0xff
 801beb6:	4001      	ands	r1, r0
 801beb8:	000c      	movs	r4, r1
 801beba:	7a99      	ldrb	r1, [r3, #10]
 801bebc:	2000      	movs	r0, #0
 801bebe:	4001      	ands	r1, r0
 801bec0:	1c08      	adds	r0, r1, #0
 801bec2:	1c21      	adds	r1, r4, #0
 801bec4:	4301      	orrs	r1, r0
 801bec6:	7299      	strb	r1, [r3, #10]
 801bec8:	0e10      	lsrs	r0, r2, #24
 801beca:	7ada      	ldrb	r2, [r3, #11]
 801becc:	2100      	movs	r1, #0
 801bece:	400a      	ands	r2, r1
 801bed0:	1c11      	adds	r1, r2, #0
 801bed2:	1c02      	adds	r2, r0, #0
 801bed4:	430a      	orrs	r2, r1
 801bed6:	72da      	strb	r2, [r3, #11]
      tmp = lwip_ntohl(th->seqno) + i;
 801bed8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801beda:	791a      	ldrb	r2, [r3, #4]
 801bedc:	7959      	ldrb	r1, [r3, #5]
 801bede:	0209      	lsls	r1, r1, #8
 801bee0:	430a      	orrs	r2, r1
 801bee2:	7999      	ldrb	r1, [r3, #6]
 801bee4:	0409      	lsls	r1, r1, #16
 801bee6:	430a      	orrs	r2, r1
 801bee8:	79db      	ldrb	r3, [r3, #7]
 801beea:	061b      	lsls	r3, r3, #24
 801beec:	4313      	orrs	r3, r2
 801beee:	0018      	movs	r0, r3
 801bef0:	f7ea fb36 	bl	8006560 <lwip_htonl>
 801bef4:	0002      	movs	r2, r0
 801bef6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801bef8:	189b      	adds	r3, r3, r2
 801befa:	643b      	str	r3, [r7, #64]	; 0x40
      th->seqno = lwip_htonl(tmp);
 801befc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801befe:	0018      	movs	r0, r3
 801bf00:	f7ea fb2e 	bl	8006560 <lwip_htonl>
 801bf04:	0002      	movs	r2, r0
 801bf06:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bf08:	21ff      	movs	r1, #255	; 0xff
 801bf0a:	4011      	ands	r1, r2
 801bf0c:	000c      	movs	r4, r1
 801bf0e:	7919      	ldrb	r1, [r3, #4]
 801bf10:	2000      	movs	r0, #0
 801bf12:	4001      	ands	r1, r0
 801bf14:	1c08      	adds	r0, r1, #0
 801bf16:	1c21      	adds	r1, r4, #0
 801bf18:	4301      	orrs	r1, r0
 801bf1a:	7119      	strb	r1, [r3, #4]
 801bf1c:	0a11      	lsrs	r1, r2, #8
 801bf1e:	20ff      	movs	r0, #255	; 0xff
 801bf20:	4001      	ands	r1, r0
 801bf22:	000c      	movs	r4, r1
 801bf24:	7959      	ldrb	r1, [r3, #5]
 801bf26:	2000      	movs	r0, #0
 801bf28:	4001      	ands	r1, r0
 801bf2a:	1c08      	adds	r0, r1, #0
 801bf2c:	1c21      	adds	r1, r4, #0
 801bf2e:	4301      	orrs	r1, r0
 801bf30:	7159      	strb	r1, [r3, #5]
 801bf32:	0c11      	lsrs	r1, r2, #16
 801bf34:	20ff      	movs	r0, #255	; 0xff
 801bf36:	4001      	ands	r1, r0
 801bf38:	000c      	movs	r4, r1
 801bf3a:	7999      	ldrb	r1, [r3, #6]
 801bf3c:	2000      	movs	r0, #0
 801bf3e:	4001      	ands	r1, r0
 801bf40:	1c08      	adds	r0, r1, #0
 801bf42:	1c21      	adds	r1, r4, #0
 801bf44:	4301      	orrs	r1, r0
 801bf46:	7199      	strb	r1, [r3, #6]
 801bf48:	0e10      	lsrs	r0, r2, #24
 801bf4a:	79da      	ldrb	r2, [r3, #7]
 801bf4c:	2100      	movs	r1, #0
 801bf4e:	400a      	ands	r2, r1
 801bf50:	1c11      	adds	r1, r2, #0
 801bf52:	1c02      	adds	r2, r0, #0
 801bf54:	430a      	orrs	r2, r1
 801bf56:	71da      	strb	r2, [r3, #7]
    }
    break;
 801bf58:	e27f      	b.n	801c45a <vj_uncompress_tcp+0x7a6>

  case SPECIAL_D:
    /* some compilers can't nest inline assembler.. */
    tmp = lwip_ntohl(th->seqno) + lwip_ntohs(IPH_LEN(&cs->cs_ip)) - cs->cs_hlen;
 801bf5a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bf5c:	791a      	ldrb	r2, [r3, #4]
 801bf5e:	7959      	ldrb	r1, [r3, #5]
 801bf60:	0209      	lsls	r1, r1, #8
 801bf62:	430a      	orrs	r2, r1
 801bf64:	7999      	ldrb	r1, [r3, #6]
 801bf66:	0409      	lsls	r1, r1, #16
 801bf68:	430a      	orrs	r2, r1
 801bf6a:	79db      	ldrb	r3, [r3, #7]
 801bf6c:	061b      	lsls	r3, r3, #24
 801bf6e:	4313      	orrs	r3, r2
 801bf70:	0018      	movs	r0, r3
 801bf72:	f7ea faf5 	bl	8006560 <lwip_htonl>
 801bf76:	0004      	movs	r4, r0
 801bf78:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801bf7a:	895b      	ldrh	r3, [r3, #10]
 801bf7c:	0018      	movs	r0, r3
 801bf7e:	f7ea fad9 	bl	8006534 <lwip_htons>
 801bf82:	0003      	movs	r3, r0
 801bf84:	18e3      	adds	r3, r4, r3
 801bf86:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801bf88:	8892      	ldrh	r2, [r2, #4]
 801bf8a:	1a9b      	subs	r3, r3, r2
 801bf8c:	643b      	str	r3, [r7, #64]	; 0x40
    th->seqno = lwip_htonl(tmp);
 801bf8e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bf90:	0018      	movs	r0, r3
 801bf92:	f7ea fae5 	bl	8006560 <lwip_htonl>
 801bf96:	0002      	movs	r2, r0
 801bf98:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bf9a:	21ff      	movs	r1, #255	; 0xff
 801bf9c:	4011      	ands	r1, r2
 801bf9e:	000c      	movs	r4, r1
 801bfa0:	7919      	ldrb	r1, [r3, #4]
 801bfa2:	2000      	movs	r0, #0
 801bfa4:	4001      	ands	r1, r0
 801bfa6:	1c08      	adds	r0, r1, #0
 801bfa8:	1c21      	adds	r1, r4, #0
 801bfaa:	4301      	orrs	r1, r0
 801bfac:	7119      	strb	r1, [r3, #4]
 801bfae:	0a11      	lsrs	r1, r2, #8
 801bfb0:	20ff      	movs	r0, #255	; 0xff
 801bfb2:	4001      	ands	r1, r0
 801bfb4:	000c      	movs	r4, r1
 801bfb6:	7959      	ldrb	r1, [r3, #5]
 801bfb8:	2000      	movs	r0, #0
 801bfba:	4001      	ands	r1, r0
 801bfbc:	1c08      	adds	r0, r1, #0
 801bfbe:	1c21      	adds	r1, r4, #0
 801bfc0:	4301      	orrs	r1, r0
 801bfc2:	7159      	strb	r1, [r3, #5]
 801bfc4:	0c11      	lsrs	r1, r2, #16
 801bfc6:	20ff      	movs	r0, #255	; 0xff
 801bfc8:	4001      	ands	r1, r0
 801bfca:	000c      	movs	r4, r1
 801bfcc:	7999      	ldrb	r1, [r3, #6]
 801bfce:	2000      	movs	r0, #0
 801bfd0:	4001      	ands	r1, r0
 801bfd2:	1c08      	adds	r0, r1, #0
 801bfd4:	1c21      	adds	r1, r4, #0
 801bfd6:	4301      	orrs	r1, r0
 801bfd8:	7199      	strb	r1, [r3, #6]
 801bfda:	0e10      	lsrs	r0, r2, #24
 801bfdc:	79da      	ldrb	r2, [r3, #7]
 801bfde:	2100      	movs	r1, #0
 801bfe0:	400a      	ands	r2, r1
 801bfe2:	1c11      	adds	r1, r2, #0
 801bfe4:	1c02      	adds	r2, r0, #0
 801bfe6:	430a      	orrs	r2, r1
 801bfe8:	71da      	strb	r2, [r3, #7]
    break;
 801bfea:	e236      	b.n	801c45a <vj_uncompress_tcp+0x7a6>

  default:
    if (changes & NEW_U) {
 801bfec:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801bfee:	2201      	movs	r2, #1
 801bff0:	4013      	ands	r3, r2
 801bff2:	d06d      	beq.n	801c0d0 <vj_uncompress_tcp+0x41c>
      TCPH_SET_FLAG(th, TCP_URG);
 801bff4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801bff6:	7b1a      	ldrb	r2, [r3, #12]
 801bff8:	7b5b      	ldrb	r3, [r3, #13]
 801bffa:	021b      	lsls	r3, r3, #8
 801bffc:	4313      	orrs	r3, r2
 801bffe:	b29c      	uxth	r4, r3
 801c000:	2020      	movs	r0, #32
 801c002:	f7ea fa97 	bl	8006534 <lwip_htons>
 801c006:	0003      	movs	r3, r0
 801c008:	4323      	orrs	r3, r4
 801c00a:	b29a      	uxth	r2, r3
 801c00c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c00e:	21ff      	movs	r1, #255	; 0xff
 801c010:	4011      	ands	r1, r2
 801c012:	000c      	movs	r4, r1
 801c014:	7b19      	ldrb	r1, [r3, #12]
 801c016:	2000      	movs	r0, #0
 801c018:	4001      	ands	r1, r0
 801c01a:	1c08      	adds	r0, r1, #0
 801c01c:	1c21      	adds	r1, r4, #0
 801c01e:	4301      	orrs	r1, r0
 801c020:	7319      	strb	r1, [r3, #12]
 801c022:	0a12      	lsrs	r2, r2, #8
 801c024:	b290      	uxth	r0, r2
 801c026:	7b5a      	ldrb	r2, [r3, #13]
 801c028:	2100      	movs	r1, #0
 801c02a:	400a      	ands	r2, r1
 801c02c:	1c11      	adds	r1, r2, #0
 801c02e:	1c02      	adds	r2, r0, #0
 801c030:	430a      	orrs	r2, r1
 801c032:	735a      	strb	r2, [r3, #13]
      DECODEU(th->urgp);
 801c034:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c036:	781b      	ldrb	r3, [r3, #0]
 801c038:	2b00      	cmp	r3, #0
 801c03a:	d128      	bne.n	801c08e <vj_uncompress_tcp+0x3da>
 801c03c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c03e:	3301      	adds	r3, #1
 801c040:	781b      	ldrb	r3, [r3, #0]
 801c042:	021b      	lsls	r3, r3, #8
 801c044:	b21a      	sxth	r2, r3
 801c046:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c048:	3302      	adds	r3, #2
 801c04a:	781b      	ldrb	r3, [r3, #0]
 801c04c:	b21b      	sxth	r3, r3
 801c04e:	4313      	orrs	r3, r2
 801c050:	b21b      	sxth	r3, r3
 801c052:	b29b      	uxth	r3, r3
 801c054:	0018      	movs	r0, r3
 801c056:	f7ea fa6d 	bl	8006534 <lwip_htons>
 801c05a:	0003      	movs	r3, r0
 801c05c:	001a      	movs	r2, r3
 801c05e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c060:	21ff      	movs	r1, #255	; 0xff
 801c062:	4011      	ands	r1, r2
 801c064:	000c      	movs	r4, r1
 801c066:	7c99      	ldrb	r1, [r3, #18]
 801c068:	2000      	movs	r0, #0
 801c06a:	4001      	ands	r1, r0
 801c06c:	1c08      	adds	r0, r1, #0
 801c06e:	1c21      	adds	r1, r4, #0
 801c070:	4301      	orrs	r1, r0
 801c072:	7499      	strb	r1, [r3, #18]
 801c074:	0a12      	lsrs	r2, r2, #8
 801c076:	b290      	uxth	r0, r2
 801c078:	7cda      	ldrb	r2, [r3, #19]
 801c07a:	2100      	movs	r1, #0
 801c07c:	400a      	ands	r2, r1
 801c07e:	1c11      	adds	r1, r2, #0
 801c080:	1c02      	adds	r2, r0, #0
 801c082:	430a      	orrs	r2, r1
 801c084:	74da      	strb	r2, [r3, #19]
 801c086:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c088:	3303      	adds	r3, #3
 801c08a:	64fb      	str	r3, [r7, #76]	; 0x4c
 801c08c:	e045      	b.n	801c11a <vj_uncompress_tcp+0x466>
 801c08e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c090:	1c5a      	adds	r2, r3, #1
 801c092:	64fa      	str	r2, [r7, #76]	; 0x4c
 801c094:	781b      	ldrb	r3, [r3, #0]
 801c096:	b29b      	uxth	r3, r3
 801c098:	0018      	movs	r0, r3
 801c09a:	f7ea fa4b 	bl	8006534 <lwip_htons>
 801c09e:	0003      	movs	r3, r0
 801c0a0:	001a      	movs	r2, r3
 801c0a2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c0a4:	21ff      	movs	r1, #255	; 0xff
 801c0a6:	4011      	ands	r1, r2
 801c0a8:	000c      	movs	r4, r1
 801c0aa:	7c99      	ldrb	r1, [r3, #18]
 801c0ac:	2000      	movs	r0, #0
 801c0ae:	4001      	ands	r1, r0
 801c0b0:	1c08      	adds	r0, r1, #0
 801c0b2:	1c21      	adds	r1, r4, #0
 801c0b4:	4301      	orrs	r1, r0
 801c0b6:	7499      	strb	r1, [r3, #18]
 801c0b8:	0a12      	lsrs	r2, r2, #8
 801c0ba:	b290      	uxth	r0, r2
 801c0bc:	7cda      	ldrb	r2, [r3, #19]
 801c0be:	2100      	movs	r1, #0
 801c0c0:	400a      	ands	r2, r1
 801c0c2:	1c11      	adds	r1, r2, #0
 801c0c4:	1c02      	adds	r2, r0, #0
 801c0c6:	430a      	orrs	r2, r1
 801c0c8:	74da      	strb	r2, [r3, #19]
 801c0ca:	e026      	b.n	801c11a <vj_uncompress_tcp+0x466>
 801c0cc:	00000888 	.word	0x00000888
    } else {
      TCPH_UNSET_FLAG(th, TCP_URG);
 801c0d0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c0d2:	7b1a      	ldrb	r2, [r3, #12]
 801c0d4:	7b5b      	ldrb	r3, [r3, #13]
 801c0d6:	021b      	lsls	r3, r3, #8
 801c0d8:	4313      	orrs	r3, r2
 801c0da:	b29b      	uxth	r3, r3
 801c0dc:	b21c      	sxth	r4, r3
 801c0de:	2020      	movs	r0, #32
 801c0e0:	f7ea fa28 	bl	8006534 <lwip_htons>
 801c0e4:	0003      	movs	r3, r0
 801c0e6:	b21b      	sxth	r3, r3
 801c0e8:	43db      	mvns	r3, r3
 801c0ea:	b21b      	sxth	r3, r3
 801c0ec:	4023      	ands	r3, r4
 801c0ee:	b21b      	sxth	r3, r3
 801c0f0:	b29a      	uxth	r2, r3
 801c0f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c0f4:	21ff      	movs	r1, #255	; 0xff
 801c0f6:	4011      	ands	r1, r2
 801c0f8:	000c      	movs	r4, r1
 801c0fa:	7b19      	ldrb	r1, [r3, #12]
 801c0fc:	2000      	movs	r0, #0
 801c0fe:	4001      	ands	r1, r0
 801c100:	1c08      	adds	r0, r1, #0
 801c102:	1c21      	adds	r1, r4, #0
 801c104:	4301      	orrs	r1, r0
 801c106:	7319      	strb	r1, [r3, #12]
 801c108:	0a12      	lsrs	r2, r2, #8
 801c10a:	b290      	uxth	r0, r2
 801c10c:	7b5a      	ldrb	r2, [r3, #13]
 801c10e:	2100      	movs	r1, #0
 801c110:	400a      	ands	r2, r1
 801c112:	1c11      	adds	r1, r2, #0
 801c114:	1c02      	adds	r2, r0, #0
 801c116:	430a      	orrs	r2, r1
 801c118:	735a      	strb	r2, [r3, #13]
    }
    if (changes & NEW_W) {
 801c11a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c11c:	2202      	movs	r2, #2
 801c11e:	4013      	ands	r3, r2
 801c120:	d06c      	beq.n	801c1fc <vj_uncompress_tcp+0x548>
      DECODES(th->wnd);
 801c122:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c124:	781b      	ldrb	r3, [r3, #0]
 801c126:	2b00      	cmp	r3, #0
 801c128:	d139      	bne.n	801c19e <vj_uncompress_tcp+0x4ea>
 801c12a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c12c:	7b9a      	ldrb	r2, [r3, #14]
 801c12e:	7bdb      	ldrb	r3, [r3, #15]
 801c130:	021b      	lsls	r3, r3, #8
 801c132:	4313      	orrs	r3, r2
 801c134:	b29b      	uxth	r3, r3
 801c136:	0018      	movs	r0, r3
 801c138:	f7ea f9fc 	bl	8006534 <lwip_htons>
 801c13c:	0003      	movs	r3, r0
 801c13e:	0019      	movs	r1, r3
 801c140:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c142:	3301      	adds	r3, #1
 801c144:	781b      	ldrb	r3, [r3, #0]
 801c146:	021b      	lsls	r3, r3, #8
 801c148:	b21a      	sxth	r2, r3
 801c14a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c14c:	3302      	adds	r3, #2
 801c14e:	781b      	ldrb	r3, [r3, #0]
 801c150:	b21b      	sxth	r3, r3
 801c152:	4313      	orrs	r3, r2
 801c154:	b21b      	sxth	r3, r3
 801c156:	b29a      	uxth	r2, r3
 801c158:	2028      	movs	r0, #40	; 0x28
 801c15a:	183b      	adds	r3, r7, r0
 801c15c:	188a      	adds	r2, r1, r2
 801c15e:	801a      	strh	r2, [r3, #0]
 801c160:	183b      	adds	r3, r7, r0
 801c162:	881b      	ldrh	r3, [r3, #0]
 801c164:	0018      	movs	r0, r3
 801c166:	f7ea f9e5 	bl	8006534 <lwip_htons>
 801c16a:	0003      	movs	r3, r0
 801c16c:	001a      	movs	r2, r3
 801c16e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c170:	21ff      	movs	r1, #255	; 0xff
 801c172:	4011      	ands	r1, r2
 801c174:	000c      	movs	r4, r1
 801c176:	7b99      	ldrb	r1, [r3, #14]
 801c178:	2000      	movs	r0, #0
 801c17a:	4001      	ands	r1, r0
 801c17c:	1c08      	adds	r0, r1, #0
 801c17e:	1c21      	adds	r1, r4, #0
 801c180:	4301      	orrs	r1, r0
 801c182:	7399      	strb	r1, [r3, #14]
 801c184:	0a12      	lsrs	r2, r2, #8
 801c186:	b290      	uxth	r0, r2
 801c188:	7bda      	ldrb	r2, [r3, #15]
 801c18a:	2100      	movs	r1, #0
 801c18c:	400a      	ands	r2, r1
 801c18e:	1c11      	adds	r1, r2, #0
 801c190:	1c02      	adds	r2, r0, #0
 801c192:	430a      	orrs	r2, r1
 801c194:	73da      	strb	r2, [r3, #15]
 801c196:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c198:	3303      	adds	r3, #3
 801c19a:	64fb      	str	r3, [r7, #76]	; 0x4c
 801c19c:	e02e      	b.n	801c1fc <vj_uncompress_tcp+0x548>
 801c19e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c1a0:	7b9a      	ldrb	r2, [r3, #14]
 801c1a2:	7bdb      	ldrb	r3, [r3, #15]
 801c1a4:	021b      	lsls	r3, r3, #8
 801c1a6:	4313      	orrs	r3, r2
 801c1a8:	b29b      	uxth	r3, r3
 801c1aa:	0018      	movs	r0, r3
 801c1ac:	f7ea f9c2 	bl	8006534 <lwip_htons>
 801c1b0:	0003      	movs	r3, r0
 801c1b2:	0019      	movs	r1, r3
 801c1b4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c1b6:	1c5a      	adds	r2, r3, #1
 801c1b8:	64fa      	str	r2, [r7, #76]	; 0x4c
 801c1ba:	781b      	ldrb	r3, [r3, #0]
 801c1bc:	b29a      	uxth	r2, r3
 801c1be:	202a      	movs	r0, #42	; 0x2a
 801c1c0:	183b      	adds	r3, r7, r0
 801c1c2:	188a      	adds	r2, r1, r2
 801c1c4:	801a      	strh	r2, [r3, #0]
 801c1c6:	183b      	adds	r3, r7, r0
 801c1c8:	881b      	ldrh	r3, [r3, #0]
 801c1ca:	0018      	movs	r0, r3
 801c1cc:	f7ea f9b2 	bl	8006534 <lwip_htons>
 801c1d0:	0003      	movs	r3, r0
 801c1d2:	001a      	movs	r2, r3
 801c1d4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c1d6:	21ff      	movs	r1, #255	; 0xff
 801c1d8:	4011      	ands	r1, r2
 801c1da:	000c      	movs	r4, r1
 801c1dc:	7b99      	ldrb	r1, [r3, #14]
 801c1de:	2000      	movs	r0, #0
 801c1e0:	4001      	ands	r1, r0
 801c1e2:	1c08      	adds	r0, r1, #0
 801c1e4:	1c21      	adds	r1, r4, #0
 801c1e6:	4301      	orrs	r1, r0
 801c1e8:	7399      	strb	r1, [r3, #14]
 801c1ea:	0a12      	lsrs	r2, r2, #8
 801c1ec:	b290      	uxth	r0, r2
 801c1ee:	7bda      	ldrb	r2, [r3, #15]
 801c1f0:	2100      	movs	r1, #0
 801c1f2:	400a      	ands	r2, r1
 801c1f4:	1c11      	adds	r1, r2, #0
 801c1f6:	1c02      	adds	r2, r0, #0
 801c1f8:	430a      	orrs	r2, r1
 801c1fa:	73da      	strb	r2, [r3, #15]
    }
    if (changes & NEW_A) {
 801c1fc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c1fe:	2204      	movs	r2, #4
 801c200:	4013      	ands	r3, r2
 801c202:	d100      	bne.n	801c206 <vj_uncompress_tcp+0x552>
 801c204:	e091      	b.n	801c32a <vj_uncompress_tcp+0x676>
      DECODEL(th->ackno);
 801c206:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c208:	781b      	ldrb	r3, [r3, #0]
 801c20a:	2b00      	cmp	r3, #0
 801c20c:	d14a      	bne.n	801c2a4 <vj_uncompress_tcp+0x5f0>
 801c20e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c210:	7a1a      	ldrb	r2, [r3, #8]
 801c212:	7a59      	ldrb	r1, [r3, #9]
 801c214:	0209      	lsls	r1, r1, #8
 801c216:	430a      	orrs	r2, r1
 801c218:	7a99      	ldrb	r1, [r3, #10]
 801c21a:	0409      	lsls	r1, r1, #16
 801c21c:	430a      	orrs	r2, r1
 801c21e:	7adb      	ldrb	r3, [r3, #11]
 801c220:	061b      	lsls	r3, r3, #24
 801c222:	4313      	orrs	r3, r2
 801c224:	0018      	movs	r0, r3
 801c226:	f7ea f99b 	bl	8006560 <lwip_htonl>
 801c22a:	0001      	movs	r1, r0
 801c22c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c22e:	3301      	adds	r3, #1
 801c230:	781b      	ldrb	r3, [r3, #0]
 801c232:	021b      	lsls	r3, r3, #8
 801c234:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801c236:	3202      	adds	r2, #2
 801c238:	7812      	ldrb	r2, [r2, #0]
 801c23a:	4313      	orrs	r3, r2
 801c23c:	18cb      	adds	r3, r1, r3
 801c23e:	623b      	str	r3, [r7, #32]
 801c240:	6a3b      	ldr	r3, [r7, #32]
 801c242:	0018      	movs	r0, r3
 801c244:	f7ea f98c 	bl	8006560 <lwip_htonl>
 801c248:	0002      	movs	r2, r0
 801c24a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c24c:	21ff      	movs	r1, #255	; 0xff
 801c24e:	4011      	ands	r1, r2
 801c250:	000c      	movs	r4, r1
 801c252:	7a19      	ldrb	r1, [r3, #8]
 801c254:	2000      	movs	r0, #0
 801c256:	4001      	ands	r1, r0
 801c258:	1c08      	adds	r0, r1, #0
 801c25a:	1c21      	adds	r1, r4, #0
 801c25c:	4301      	orrs	r1, r0
 801c25e:	7219      	strb	r1, [r3, #8]
 801c260:	0a11      	lsrs	r1, r2, #8
 801c262:	20ff      	movs	r0, #255	; 0xff
 801c264:	4001      	ands	r1, r0
 801c266:	000c      	movs	r4, r1
 801c268:	7a59      	ldrb	r1, [r3, #9]
 801c26a:	2000      	movs	r0, #0
 801c26c:	4001      	ands	r1, r0
 801c26e:	1c08      	adds	r0, r1, #0
 801c270:	1c21      	adds	r1, r4, #0
 801c272:	4301      	orrs	r1, r0
 801c274:	7259      	strb	r1, [r3, #9]
 801c276:	0c11      	lsrs	r1, r2, #16
 801c278:	20ff      	movs	r0, #255	; 0xff
 801c27a:	4001      	ands	r1, r0
 801c27c:	000c      	movs	r4, r1
 801c27e:	7a99      	ldrb	r1, [r3, #10]
 801c280:	2000      	movs	r0, #0
 801c282:	4001      	ands	r1, r0
 801c284:	1c08      	adds	r0, r1, #0
 801c286:	1c21      	adds	r1, r4, #0
 801c288:	4301      	orrs	r1, r0
 801c28a:	7299      	strb	r1, [r3, #10]
 801c28c:	0e10      	lsrs	r0, r2, #24
 801c28e:	7ada      	ldrb	r2, [r3, #11]
 801c290:	2100      	movs	r1, #0
 801c292:	400a      	ands	r2, r1
 801c294:	1c11      	adds	r1, r2, #0
 801c296:	1c02      	adds	r2, r0, #0
 801c298:	430a      	orrs	r2, r1
 801c29a:	72da      	strb	r2, [r3, #11]
 801c29c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c29e:	3303      	adds	r3, #3
 801c2a0:	64fb      	str	r3, [r7, #76]	; 0x4c
 801c2a2:	e042      	b.n	801c32a <vj_uncompress_tcp+0x676>
 801c2a4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c2a6:	7a1a      	ldrb	r2, [r3, #8]
 801c2a8:	7a59      	ldrb	r1, [r3, #9]
 801c2aa:	0209      	lsls	r1, r1, #8
 801c2ac:	430a      	orrs	r2, r1
 801c2ae:	7a99      	ldrb	r1, [r3, #10]
 801c2b0:	0409      	lsls	r1, r1, #16
 801c2b2:	430a      	orrs	r2, r1
 801c2b4:	7adb      	ldrb	r3, [r3, #11]
 801c2b6:	061b      	lsls	r3, r3, #24
 801c2b8:	4313      	orrs	r3, r2
 801c2ba:	0018      	movs	r0, r3
 801c2bc:	f7ea f950 	bl	8006560 <lwip_htonl>
 801c2c0:	0001      	movs	r1, r0
 801c2c2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c2c4:	1c5a      	adds	r2, r3, #1
 801c2c6:	64fa      	str	r2, [r7, #76]	; 0x4c
 801c2c8:	781b      	ldrb	r3, [r3, #0]
 801c2ca:	18cb      	adds	r3, r1, r3
 801c2cc:	627b      	str	r3, [r7, #36]	; 0x24
 801c2ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c2d0:	0018      	movs	r0, r3
 801c2d2:	f7ea f945 	bl	8006560 <lwip_htonl>
 801c2d6:	0002      	movs	r2, r0
 801c2d8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c2da:	21ff      	movs	r1, #255	; 0xff
 801c2dc:	4011      	ands	r1, r2
 801c2de:	000c      	movs	r4, r1
 801c2e0:	7a19      	ldrb	r1, [r3, #8]
 801c2e2:	2000      	movs	r0, #0
 801c2e4:	4001      	ands	r1, r0
 801c2e6:	1c08      	adds	r0, r1, #0
 801c2e8:	1c21      	adds	r1, r4, #0
 801c2ea:	4301      	orrs	r1, r0
 801c2ec:	7219      	strb	r1, [r3, #8]
 801c2ee:	0a11      	lsrs	r1, r2, #8
 801c2f0:	20ff      	movs	r0, #255	; 0xff
 801c2f2:	4001      	ands	r1, r0
 801c2f4:	000c      	movs	r4, r1
 801c2f6:	7a59      	ldrb	r1, [r3, #9]
 801c2f8:	2000      	movs	r0, #0
 801c2fa:	4001      	ands	r1, r0
 801c2fc:	1c08      	adds	r0, r1, #0
 801c2fe:	1c21      	adds	r1, r4, #0
 801c300:	4301      	orrs	r1, r0
 801c302:	7259      	strb	r1, [r3, #9]
 801c304:	0c11      	lsrs	r1, r2, #16
 801c306:	20ff      	movs	r0, #255	; 0xff
 801c308:	4001      	ands	r1, r0
 801c30a:	000c      	movs	r4, r1
 801c30c:	7a99      	ldrb	r1, [r3, #10]
 801c30e:	2000      	movs	r0, #0
 801c310:	4001      	ands	r1, r0
 801c312:	1c08      	adds	r0, r1, #0
 801c314:	1c21      	adds	r1, r4, #0
 801c316:	4301      	orrs	r1, r0
 801c318:	7299      	strb	r1, [r3, #10]
 801c31a:	0e10      	lsrs	r0, r2, #24
 801c31c:	7ada      	ldrb	r2, [r3, #11]
 801c31e:	2100      	movs	r1, #0
 801c320:	400a      	ands	r2, r1
 801c322:	1c11      	adds	r1, r2, #0
 801c324:	1c02      	adds	r2, r0, #0
 801c326:	430a      	orrs	r2, r1
 801c328:	72da      	strb	r2, [r3, #11]
    }
    if (changes & NEW_S) {
 801c32a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c32c:	2208      	movs	r2, #8
 801c32e:	4013      	ands	r3, r2
 801c330:	d100      	bne.n	801c334 <vj_uncompress_tcp+0x680>
 801c332:	e091      	b.n	801c458 <vj_uncompress_tcp+0x7a4>

    	DECODEL(th->seqno);
 801c334:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c336:	781b      	ldrb	r3, [r3, #0]
 801c338:	2b00      	cmp	r3, #0
 801c33a:	d14a      	bne.n	801c3d2 <vj_uncompress_tcp+0x71e>
 801c33c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c33e:	791a      	ldrb	r2, [r3, #4]
 801c340:	7959      	ldrb	r1, [r3, #5]
 801c342:	0209      	lsls	r1, r1, #8
 801c344:	430a      	orrs	r2, r1
 801c346:	7999      	ldrb	r1, [r3, #6]
 801c348:	0409      	lsls	r1, r1, #16
 801c34a:	430a      	orrs	r2, r1
 801c34c:	79db      	ldrb	r3, [r3, #7]
 801c34e:	061b      	lsls	r3, r3, #24
 801c350:	4313      	orrs	r3, r2
 801c352:	0018      	movs	r0, r3
 801c354:	f7ea f904 	bl	8006560 <lwip_htonl>
 801c358:	0001      	movs	r1, r0
 801c35a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c35c:	3301      	adds	r3, #1
 801c35e:	781b      	ldrb	r3, [r3, #0]
 801c360:	021b      	lsls	r3, r3, #8
 801c362:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801c364:	3202      	adds	r2, #2
 801c366:	7812      	ldrb	r2, [r2, #0]
 801c368:	4313      	orrs	r3, r2
 801c36a:	18cb      	adds	r3, r1, r3
 801c36c:	61bb      	str	r3, [r7, #24]
 801c36e:	69bb      	ldr	r3, [r7, #24]
 801c370:	0018      	movs	r0, r3
 801c372:	f7ea f8f5 	bl	8006560 <lwip_htonl>
 801c376:	0002      	movs	r2, r0
 801c378:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c37a:	21ff      	movs	r1, #255	; 0xff
 801c37c:	4011      	ands	r1, r2
 801c37e:	000c      	movs	r4, r1
 801c380:	7919      	ldrb	r1, [r3, #4]
 801c382:	2000      	movs	r0, #0
 801c384:	4001      	ands	r1, r0
 801c386:	1c08      	adds	r0, r1, #0
 801c388:	1c21      	adds	r1, r4, #0
 801c38a:	4301      	orrs	r1, r0
 801c38c:	7119      	strb	r1, [r3, #4]
 801c38e:	0a11      	lsrs	r1, r2, #8
 801c390:	20ff      	movs	r0, #255	; 0xff
 801c392:	4001      	ands	r1, r0
 801c394:	000c      	movs	r4, r1
 801c396:	7959      	ldrb	r1, [r3, #5]
 801c398:	2000      	movs	r0, #0
 801c39a:	4001      	ands	r1, r0
 801c39c:	1c08      	adds	r0, r1, #0
 801c39e:	1c21      	adds	r1, r4, #0
 801c3a0:	4301      	orrs	r1, r0
 801c3a2:	7159      	strb	r1, [r3, #5]
 801c3a4:	0c11      	lsrs	r1, r2, #16
 801c3a6:	20ff      	movs	r0, #255	; 0xff
 801c3a8:	4001      	ands	r1, r0
 801c3aa:	000c      	movs	r4, r1
 801c3ac:	7999      	ldrb	r1, [r3, #6]
 801c3ae:	2000      	movs	r0, #0
 801c3b0:	4001      	ands	r1, r0
 801c3b2:	1c08      	adds	r0, r1, #0
 801c3b4:	1c21      	adds	r1, r4, #0
 801c3b6:	4301      	orrs	r1, r0
 801c3b8:	7199      	strb	r1, [r3, #6]
 801c3ba:	0e10      	lsrs	r0, r2, #24
 801c3bc:	79da      	ldrb	r2, [r3, #7]
 801c3be:	2100      	movs	r1, #0
 801c3c0:	400a      	ands	r2, r1
 801c3c2:	1c11      	adds	r1, r2, #0
 801c3c4:	1c02      	adds	r2, r0, #0
 801c3c6:	430a      	orrs	r2, r1
 801c3c8:	71da      	strb	r2, [r3, #7]
 801c3ca:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c3cc:	3303      	adds	r3, #3
 801c3ce:	64fb      	str	r3, [r7, #76]	; 0x4c
    }
    break;
 801c3d0:	e042      	b.n	801c458 <vj_uncompress_tcp+0x7a4>
    	DECODEL(th->seqno);
 801c3d2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c3d4:	791a      	ldrb	r2, [r3, #4]
 801c3d6:	7959      	ldrb	r1, [r3, #5]
 801c3d8:	0209      	lsls	r1, r1, #8
 801c3da:	430a      	orrs	r2, r1
 801c3dc:	7999      	ldrb	r1, [r3, #6]
 801c3de:	0409      	lsls	r1, r1, #16
 801c3e0:	430a      	orrs	r2, r1
 801c3e2:	79db      	ldrb	r3, [r3, #7]
 801c3e4:	061b      	lsls	r3, r3, #24
 801c3e6:	4313      	orrs	r3, r2
 801c3e8:	0018      	movs	r0, r3
 801c3ea:	f7ea f8b9 	bl	8006560 <lwip_htonl>
 801c3ee:	0001      	movs	r1, r0
 801c3f0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c3f2:	1c5a      	adds	r2, r3, #1
 801c3f4:	64fa      	str	r2, [r7, #76]	; 0x4c
 801c3f6:	781b      	ldrb	r3, [r3, #0]
 801c3f8:	18cb      	adds	r3, r1, r3
 801c3fa:	61fb      	str	r3, [r7, #28]
 801c3fc:	69fb      	ldr	r3, [r7, #28]
 801c3fe:	0018      	movs	r0, r3
 801c400:	f7ea f8ae 	bl	8006560 <lwip_htonl>
 801c404:	0002      	movs	r2, r0
 801c406:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c408:	21ff      	movs	r1, #255	; 0xff
 801c40a:	4011      	ands	r1, r2
 801c40c:	000c      	movs	r4, r1
 801c40e:	7919      	ldrb	r1, [r3, #4]
 801c410:	2000      	movs	r0, #0
 801c412:	4001      	ands	r1, r0
 801c414:	1c08      	adds	r0, r1, #0
 801c416:	1c21      	adds	r1, r4, #0
 801c418:	4301      	orrs	r1, r0
 801c41a:	7119      	strb	r1, [r3, #4]
 801c41c:	0a11      	lsrs	r1, r2, #8
 801c41e:	20ff      	movs	r0, #255	; 0xff
 801c420:	4001      	ands	r1, r0
 801c422:	000c      	movs	r4, r1
 801c424:	7959      	ldrb	r1, [r3, #5]
 801c426:	2000      	movs	r0, #0
 801c428:	4001      	ands	r1, r0
 801c42a:	1c08      	adds	r0, r1, #0
 801c42c:	1c21      	adds	r1, r4, #0
 801c42e:	4301      	orrs	r1, r0
 801c430:	7159      	strb	r1, [r3, #5]
 801c432:	0c11      	lsrs	r1, r2, #16
 801c434:	20ff      	movs	r0, #255	; 0xff
 801c436:	4001      	ands	r1, r0
 801c438:	000c      	movs	r4, r1
 801c43a:	7999      	ldrb	r1, [r3, #6]
 801c43c:	2000      	movs	r0, #0
 801c43e:	4001      	ands	r1, r0
 801c440:	1c08      	adds	r0, r1, #0
 801c442:	1c21      	adds	r1, r4, #0
 801c444:	4301      	orrs	r1, r0
 801c446:	7199      	strb	r1, [r3, #6]
 801c448:	0e10      	lsrs	r0, r2, #24
 801c44a:	79da      	ldrb	r2, [r3, #7]
 801c44c:	2100      	movs	r1, #0
 801c44e:	400a      	ands	r2, r1
 801c450:	1c11      	adds	r1, r2, #0
 801c452:	1c02      	adds	r2, r0, #0
 801c454:	430a      	orrs	r2, r1
 801c456:	71da      	strb	r2, [r3, #7]
    break;
 801c458:	46c0      	nop			; (mov r8, r8)
  }
  if (changes & NEW_I) {
 801c45a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c45c:	2220      	movs	r2, #32
 801c45e:	4013      	ands	r3, r2
 801c460:	d041      	beq.n	801c4e6 <vj_uncompress_tcp+0x832>
    DECODES(cs->cs_ip._id);
 801c462:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c464:	781b      	ldrb	r3, [r3, #0]
 801c466:	2b00      	cmp	r3, #0
 801c468:	d123      	bne.n	801c4b2 <vj_uncompress_tcp+0x7fe>
 801c46a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c46c:	899b      	ldrh	r3, [r3, #12]
 801c46e:	0018      	movs	r0, r3
 801c470:	f7ea f860 	bl	8006534 <lwip_htons>
 801c474:	0003      	movs	r3, r0
 801c476:	0019      	movs	r1, r3
 801c478:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c47a:	3301      	adds	r3, #1
 801c47c:	781b      	ldrb	r3, [r3, #0]
 801c47e:	021b      	lsls	r3, r3, #8
 801c480:	b21a      	sxth	r2, r3
 801c482:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c484:	3302      	adds	r3, #2
 801c486:	781b      	ldrb	r3, [r3, #0]
 801c488:	b21b      	sxth	r3, r3
 801c48a:	4313      	orrs	r3, r2
 801c48c:	b21b      	sxth	r3, r3
 801c48e:	b29a      	uxth	r2, r3
 801c490:	2014      	movs	r0, #20
 801c492:	183b      	adds	r3, r7, r0
 801c494:	188a      	adds	r2, r1, r2
 801c496:	801a      	strh	r2, [r3, #0]
 801c498:	183b      	adds	r3, r7, r0
 801c49a:	881b      	ldrh	r3, [r3, #0]
 801c49c:	0018      	movs	r0, r3
 801c49e:	f7ea f849 	bl	8006534 <lwip_htons>
 801c4a2:	0003      	movs	r3, r0
 801c4a4:	001a      	movs	r2, r3
 801c4a6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c4a8:	819a      	strh	r2, [r3, #12]
 801c4aa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c4ac:	3303      	adds	r3, #3
 801c4ae:	64fb      	str	r3, [r7, #76]	; 0x4c
 801c4b0:	e02c      	b.n	801c50c <vj_uncompress_tcp+0x858>
 801c4b2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c4b4:	899b      	ldrh	r3, [r3, #12]
 801c4b6:	0018      	movs	r0, r3
 801c4b8:	f7ea f83c 	bl	8006534 <lwip_htons>
 801c4bc:	0003      	movs	r3, r0
 801c4be:	0019      	movs	r1, r3
 801c4c0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801c4c2:	1c5a      	adds	r2, r3, #1
 801c4c4:	64fa      	str	r2, [r7, #76]	; 0x4c
 801c4c6:	781b      	ldrb	r3, [r3, #0]
 801c4c8:	b29a      	uxth	r2, r3
 801c4ca:	2016      	movs	r0, #22
 801c4cc:	183b      	adds	r3, r7, r0
 801c4ce:	188a      	adds	r2, r1, r2
 801c4d0:	801a      	strh	r2, [r3, #0]
 801c4d2:	183b      	adds	r3, r7, r0
 801c4d4:	881b      	ldrh	r3, [r3, #0]
 801c4d6:	0018      	movs	r0, r3
 801c4d8:	f7ea f82c 	bl	8006534 <lwip_htons>
 801c4dc:	0003      	movs	r3, r0
 801c4de:	001a      	movs	r2, r3
 801c4e0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c4e2:	819a      	strh	r2, [r3, #12]
 801c4e4:	e012      	b.n	801c50c <vj_uncompress_tcp+0x858>
  } else {
    IPH_ID_SET(&cs->cs_ip, lwip_ntohs(IPH_ID(&cs->cs_ip)) + 1);
 801c4e6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c4e8:	899b      	ldrh	r3, [r3, #12]
 801c4ea:	0018      	movs	r0, r3
 801c4ec:	f7ea f822 	bl	8006534 <lwip_htons>
 801c4f0:	0003      	movs	r3, r0
 801c4f2:	3301      	adds	r3, #1
 801c4f4:	b29a      	uxth	r2, r3
 801c4f6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c4f8:	819a      	strh	r2, [r3, #12]
    IPH_ID_SET(&cs->cs_ip, lwip_htons(IPH_ID(&cs->cs_ip)));
 801c4fa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c4fc:	899b      	ldrh	r3, [r3, #12]
 801c4fe:	0018      	movs	r0, r3
 801c500:	f7ea f818 	bl	8006534 <lwip_htons>
 801c504:	0003      	movs	r3, r0
 801c506:	001a      	movs	r2, r3
 801c508:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c50a:	819a      	strh	r2, [r3, #12]
  /*
   * At this point, cp points to the first byte of data in the
   * packet.  Fill in the IP total length and update the IP
   * header checksum.
   */
  vjlen = (u16_t)(cp - (u8_t*)n0->payload);
 801c50c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c50e:	685b      	ldr	r3, [r3, #4]
 801c510:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801c512:	1ad3      	subs	r3, r2, r3
 801c514:	b29b      	uxth	r3, r3
 801c516:	613b      	str	r3, [r7, #16]
  if (n0->len < vjlen) {
 801c518:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c51a:	895b      	ldrh	r3, [r3, #10]
 801c51c:	001a      	movs	r2, r3
 801c51e:	693b      	ldr	r3, [r7, #16]
 801c520:	4293      	cmp	r3, r2
 801c522:	d900      	bls.n	801c526 <vj_uncompress_tcp+0x872>
 801c524:	e0e2      	b.n	801c6ec <vj_uncompress_tcp+0xa38>
          n0->len, vjlen));
    goto bad;
  }

#if BYTE_ORDER == LITTLE_ENDIAN
  tmp = n0->tot_len - vjlen + cs->cs_hlen;
 801c526:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c528:	891b      	ldrh	r3, [r3, #8]
 801c52a:	001a      	movs	r2, r3
 801c52c:	693b      	ldr	r3, [r7, #16]
 801c52e:	1ad3      	subs	r3, r2, r3
 801c530:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801c532:	8892      	ldrh	r2, [r2, #4]
 801c534:	189b      	adds	r3, r3, r2
 801c536:	643b      	str	r3, [r7, #64]	; 0x40
  IPH_LEN_SET(&cs->cs_ip, lwip_htons((u16_t)tmp));
 801c538:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c53a:	b29b      	uxth	r3, r3
 801c53c:	0018      	movs	r0, r3
 801c53e:	f7e9 fff9 	bl	8006534 <lwip_htons>
 801c542:	0003      	movs	r3, r0
 801c544:	001a      	movs	r2, r3
 801c546:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c548:	815a      	strh	r2, [r3, #10]
#else
  IPH_LEN_SET(&cs->cs_ip, lwip_htons(n0->tot_len - vjlen + cs->cs_hlen));
#endif

  /* recompute the ip header checksum */
  bp = (struct vj_u16_t*) &cs->cs_ip;
 801c54a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c54c:	3308      	adds	r3, #8
 801c54e:	64bb      	str	r3, [r7, #72]	; 0x48
  IPH_CHKSUM_SET(&cs->cs_ip, 0);
 801c550:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c552:	2200      	movs	r2, #0
 801c554:	825a      	strh	r2, [r3, #18]
  for (tmp = 0; hlen > 0; hlen -= 2) {
 801c556:	2300      	movs	r3, #0
 801c558:	643b      	str	r3, [r7, #64]	; 0x40
 801c55a:	e00e      	b.n	801c57a <vj_uncompress_tcp+0x8c6>
    tmp += (*bp++).v;
 801c55c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801c55e:	1c9a      	adds	r2, r3, #2
 801c560:	64ba      	str	r2, [r7, #72]	; 0x48
 801c562:	781a      	ldrb	r2, [r3, #0]
 801c564:	785b      	ldrb	r3, [r3, #1]
 801c566:	021b      	lsls	r3, r3, #8
 801c568:	4313      	orrs	r3, r2
 801c56a:	b29b      	uxth	r3, r3
 801c56c:	001a      	movs	r2, r3
 801c56e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c570:	189b      	adds	r3, r3, r2
 801c572:	643b      	str	r3, [r7, #64]	; 0x40
  for (tmp = 0; hlen > 0; hlen -= 2) {
 801c574:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c576:	3b02      	subs	r3, #2
 801c578:	63fb      	str	r3, [r7, #60]	; 0x3c
 801c57a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c57c:	2b00      	cmp	r3, #0
 801c57e:	d1ed      	bne.n	801c55c <vj_uncompress_tcp+0x8a8>
  }
  tmp = (tmp & 0xffff) + (tmp >> 16);
 801c580:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c582:	041b      	lsls	r3, r3, #16
 801c584:	0c1a      	lsrs	r2, r3, #16
 801c586:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c588:	0c1b      	lsrs	r3, r3, #16
 801c58a:	18d3      	adds	r3, r2, r3
 801c58c:	643b      	str	r3, [r7, #64]	; 0x40
  tmp = (tmp & 0xffff) + (tmp >> 16);
 801c58e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c590:	041b      	lsls	r3, r3, #16
 801c592:	0c1a      	lsrs	r2, r3, #16
 801c594:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c596:	0c1b      	lsrs	r3, r3, #16
 801c598:	18d3      	adds	r3, r2, r3
 801c59a:	643b      	str	r3, [r7, #64]	; 0x40
  IPH_CHKSUM_SET(&cs->cs_ip,  (u16_t)(~tmp));
 801c59c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c59e:	b29b      	uxth	r3, r3
 801c5a0:	43db      	mvns	r3, r3
 801c5a2:	b29a      	uxth	r2, r3
 801c5a4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c5a6:	825a      	strh	r2, [r3, #18]

  /* Remove the compressed header and prepend the uncompressed header. */
  if (pbuf_remove_header(n0, vjlen)) {
 801c5a8:	693a      	ldr	r2, [r7, #16]
 801c5aa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c5ac:	0011      	movs	r1, r2
 801c5ae:	0018      	movs	r0, r3
 801c5b0:	f7ec ff98 	bl	80094e4 <pbuf_remove_header>
 801c5b4:	1e03      	subs	r3, r0, #0
 801c5b6:	d006      	beq.n	801c5c6 <vj_uncompress_tcp+0x912>
    /* Can we cope with this failing?  Just assert for now */
    LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 801c5b8:	4b54      	ldr	r3, [pc, #336]	; (801c70c <vj_uncompress_tcp+0xa58>)
 801c5ba:	4a55      	ldr	r2, [pc, #340]	; (801c710 <vj_uncompress_tcp+0xa5c>)
 801c5bc:	4955      	ldr	r1, [pc, #340]	; (801c714 <vj_uncompress_tcp+0xa60>)
 801c5be:	4856      	ldr	r0, [pc, #344]	; (801c718 <vj_uncompress_tcp+0xa64>)
 801c5c0:	f7e5 fe04 	bl	80021cc <app_debug_rtt_raw>
    goto bad;
 801c5c4:	e097      	b.n	801c6f6 <vj_uncompress_tcp+0xa42>
  }

  if(LWIP_MEM_ALIGN(n0->payload) != n0->payload) {
 801c5c6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c5c8:	685b      	ldr	r3, [r3, #4]
 801c5ca:	3303      	adds	r3, #3
 801c5cc:	2203      	movs	r2, #3
 801c5ce:	4393      	bics	r3, r2
 801c5d0:	001a      	movs	r2, r3
 801c5d2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c5d4:	685b      	ldr	r3, [r3, #4]
 801c5d6:	429a      	cmp	r2, r3
 801c5d8:	d040      	beq.n	801c65c <vj_uncompress_tcp+0x9a8>
     * the packet is being allocated with enough header space to be
     * forwarded (to Ethernet for example).
     */
    np = pbuf_alloc(PBUF_LINK, n0->len + cs->cs_hlen, PBUF_POOL);
#else /* IP_FORWARD */
    np = pbuf_alloc(PBUF_RAW, n0->len + cs->cs_hlen, PBUF_POOL);
 801c5da:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c5dc:	895a      	ldrh	r2, [r3, #10]
 801c5de:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c5e0:	889b      	ldrh	r3, [r3, #4]
 801c5e2:	18d3      	adds	r3, r2, r3
 801c5e4:	b29b      	uxth	r3, r3
 801c5e6:	22c1      	movs	r2, #193	; 0xc1
 801c5e8:	0052      	lsls	r2, r2, #1
 801c5ea:	0019      	movs	r1, r3
 801c5ec:	2000      	movs	r0, #0
 801c5ee:	f7ec fcd9 	bl	8008fa4 <pbuf_alloc>
 801c5f2:	0003      	movs	r3, r0
 801c5f4:	60fb      	str	r3, [r7, #12]
#endif /* IP_FORWARD */
    if(!np) {
 801c5f6:	68fb      	ldr	r3, [r7, #12]
 801c5f8:	2b00      	cmp	r3, #0
 801c5fa:	d100      	bne.n	801c5fe <vj_uncompress_tcp+0x94a>
 801c5fc:	e078      	b.n	801c6f0 <vj_uncompress_tcp+0xa3c>
      PPPDEBUG(LOG_WARNING, ("vj_uncompress_tcp: realign failed\n"));
      goto bad;
    }

    if (pbuf_remove_header(np, cs->cs_hlen)) {
 801c5fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c600:	889b      	ldrh	r3, [r3, #4]
 801c602:	001a      	movs	r2, r3
 801c604:	68fb      	ldr	r3, [r7, #12]
 801c606:	0011      	movs	r1, r2
 801c608:	0018      	movs	r0, r3
 801c60a:	f7ec ff6b 	bl	80094e4 <pbuf_remove_header>
 801c60e:	1e03      	subs	r3, r0, #0
 801c610:	d007      	beq.n	801c622 <vj_uncompress_tcp+0x96e>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_remove_header failed\n", 0);
 801c612:	4b3e      	ldr	r3, [pc, #248]	; (801c70c <vj_uncompress_tcp+0xa58>)
 801c614:	22a2      	movs	r2, #162	; 0xa2
 801c616:	0092      	lsls	r2, r2, #2
 801c618:	493e      	ldr	r1, [pc, #248]	; (801c714 <vj_uncompress_tcp+0xa60>)
 801c61a:	483f      	ldr	r0, [pc, #252]	; (801c718 <vj_uncompress_tcp+0xa64>)
 801c61c:	f7e5 fdd6 	bl	80021cc <app_debug_rtt_raw>
      goto bad;
 801c620:	e069      	b.n	801c6f6 <vj_uncompress_tcp+0xa42>
    }

    pbuf_take(np, n0->payload, n0->len);
 801c622:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c624:	6859      	ldr	r1, [r3, #4]
 801c626:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c628:	895a      	ldrh	r2, [r3, #10]
 801c62a:	68fb      	ldr	r3, [r7, #12]
 801c62c:	0018      	movs	r0, r3
 801c62e:	f7ed fbd1 	bl	8009dd4 <pbuf_take>

    if(n0->next) {
 801c632:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c634:	681b      	ldr	r3, [r3, #0]
 801c636:	2b00      	cmp	r3, #0
 801c638:	d00a      	beq.n	801c650 <vj_uncompress_tcp+0x99c>
      pbuf_chain(np, n0->next);
 801c63a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c63c:	681a      	ldr	r2, [r3, #0]
 801c63e:	68fb      	ldr	r3, [r7, #12]
 801c640:	0011      	movs	r1, r2
 801c642:	0018      	movs	r0, r3
 801c644:	f7ed f95a 	bl	80098fc <pbuf_chain>
      pbuf_dechain(n0);
 801c648:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c64a:	0018      	movs	r0, r3
 801c64c:	f7ed f96a 	bl	8009924 <pbuf_dechain>
    }
    pbuf_free(n0);
 801c650:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c652:	0018      	movs	r0, r3
 801c654:	f7ed f81e 	bl	8009694 <pbuf_free>
    n0 = np;
 801c658:	68fb      	ldr	r3, [r7, #12]
 801c65a:	647b      	str	r3, [r7, #68]	; 0x44
  }

  if (pbuf_add_header(n0, cs->cs_hlen)) {
 801c65c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c65e:	889b      	ldrh	r3, [r3, #4]
 801c660:	001a      	movs	r2, r3
 801c662:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c664:	0011      	movs	r1, r2
 801c666:	0018      	movs	r0, r3
 801c668:	f7ec ff2c 	bl	80094c4 <pbuf_add_header>
 801c66c:	1e03      	subs	r3, r0, #0
 801c66e:	d020      	beq.n	801c6b2 <vj_uncompress_tcp+0x9fe>
    struct pbuf *np;

    LWIP_ASSERT("vj_uncompress_tcp: cs->cs_hlen <= PBUF_POOL_BUFSIZE", cs->cs_hlen <= PBUF_POOL_BUFSIZE);
 801c670:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c672:	889a      	ldrh	r2, [r3, #4]
 801c674:	2394      	movs	r3, #148	; 0x94
 801c676:	009b      	lsls	r3, r3, #2
 801c678:	429a      	cmp	r2, r3
 801c67a:	d905      	bls.n	801c688 <vj_uncompress_tcp+0x9d4>
 801c67c:	4b23      	ldr	r3, [pc, #140]	; (801c70c <vj_uncompress_tcp+0xa58>)
 801c67e:	4a27      	ldr	r2, [pc, #156]	; (801c71c <vj_uncompress_tcp+0xa68>)
 801c680:	4927      	ldr	r1, [pc, #156]	; (801c720 <vj_uncompress_tcp+0xa6c>)
 801c682:	4825      	ldr	r0, [pc, #148]	; (801c718 <vj_uncompress_tcp+0xa64>)
 801c684:	f7e5 fda2 	bl	80021cc <app_debug_rtt_raw>
    np = pbuf_alloc(PBUF_RAW, cs->cs_hlen, PBUF_POOL);
 801c688:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c68a:	889b      	ldrh	r3, [r3, #4]
 801c68c:	22c1      	movs	r2, #193	; 0xc1
 801c68e:	0052      	lsls	r2, r2, #1
 801c690:	0019      	movs	r1, r3
 801c692:	2000      	movs	r0, #0
 801c694:	f7ec fc86 	bl	8008fa4 <pbuf_alloc>
 801c698:	0003      	movs	r3, r0
 801c69a:	60bb      	str	r3, [r7, #8]
    if(!np) {
 801c69c:	68bb      	ldr	r3, [r7, #8]
 801c69e:	2b00      	cmp	r3, #0
 801c6a0:	d028      	beq.n	801c6f4 <vj_uncompress_tcp+0xa40>
      PPPDEBUG(LOG_WARNING, ("vj_uncompress_tcp: prepend failed\n"));
      goto bad;
    }
    pbuf_cat(np, n0);
 801c6a2:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801c6a4:	68bb      	ldr	r3, [r7, #8]
 801c6a6:	0011      	movs	r1, r2
 801c6a8:	0018      	movs	r0, r3
 801c6aa:	f7ed f8d3 	bl	8009854 <pbuf_cat>
    n0 = np;
 801c6ae:	68bb      	ldr	r3, [r7, #8]
 801c6b0:	647b      	str	r3, [r7, #68]	; 0x44
  }
  LWIP_ASSERT("n0->len >= cs->cs_hlen", n0->len >= cs->cs_hlen);
 801c6b2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c6b4:	895a      	ldrh	r2, [r3, #10]
 801c6b6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c6b8:	889b      	ldrh	r3, [r3, #4]
 801c6ba:	429a      	cmp	r2, r3
 801c6bc:	d205      	bcs.n	801c6ca <vj_uncompress_tcp+0xa16>
 801c6be:	4b13      	ldr	r3, [pc, #76]	; (801c70c <vj_uncompress_tcp+0xa58>)
 801c6c0:	4a18      	ldr	r2, [pc, #96]	; (801c724 <vj_uncompress_tcp+0xa70>)
 801c6c2:	4919      	ldr	r1, [pc, #100]	; (801c728 <vj_uncompress_tcp+0xa74>)
 801c6c4:	4814      	ldr	r0, [pc, #80]	; (801c718 <vj_uncompress_tcp+0xa64>)
 801c6c6:	f7e5 fd81 	bl	80021cc <app_debug_rtt_raw>
  MEMCPY(n0->payload, &cs->cs_ip, cs->cs_hlen);
 801c6ca:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c6cc:	6858      	ldr	r0, [r3, #4]
 801c6ce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c6d0:	3308      	adds	r3, #8
 801c6d2:	0019      	movs	r1, r3
 801c6d4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801c6d6:	889b      	ldrh	r3, [r3, #4]
 801c6d8:	001a      	movs	r2, r3
 801c6da:	f000 f88b 	bl	801c7f4 <memcpy>

  *nb = n0;
 801c6de:	687b      	ldr	r3, [r7, #4]
 801c6e0:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801c6e2:	601a      	str	r2, [r3, #0]

  return vjlen;
 801c6e4:	693b      	ldr	r3, [r7, #16]
 801c6e6:	e00c      	b.n	801c702 <vj_uncompress_tcp+0xa4e>
      goto bad;
 801c6e8:	46c0      	nop			; (mov r8, r8)
 801c6ea:	e004      	b.n	801c6f6 <vj_uncompress_tcp+0xa42>
    goto bad;
 801c6ec:	46c0      	nop			; (mov r8, r8)
 801c6ee:	e002      	b.n	801c6f6 <vj_uncompress_tcp+0xa42>
      goto bad;
 801c6f0:	46c0      	nop			; (mov r8, r8)
 801c6f2:	e000      	b.n	801c6f6 <vj_uncompress_tcp+0xa42>
      goto bad;
 801c6f4:	46c0      	nop			; (mov r8, r8)

bad:
  vj_uncompress_err(comp);
 801c6f6:	683b      	ldr	r3, [r7, #0]
 801c6f8:	0018      	movs	r0, r3
 801c6fa:	f7ff fa5d 	bl	801bbb8 <vj_uncompress_err>
  return (-1);
 801c6fe:	2301      	movs	r3, #1
 801c700:	425b      	negs	r3, r3
}
 801c702:	0018      	movs	r0, r3
 801c704:	46bd      	mov	sp, r7
 801c706:	b015      	add	sp, #84	; 0x54
 801c708:	bd90      	pop	{r4, r7, pc}
 801c70a:	46c0      	nop			; (mov r8, r8)
 801c70c:	08021430 	.word	0x08021430
 801c710:	00000271 	.word	0x00000271
 801c714:	0802145c 	.word	0x0802145c
 801c718:	08021478 	.word	0x08021478
 801c71c:	00000299 	.word	0x00000299
 801c720:	080214a4 	.word	0x080214a4
 801c724:	000002a2 	.word	0x000002a2
 801c728:	080214d8 	.word	0x080214d8

0801c72c <sys_rand>:
 */



extern uint32_t sys_rand()
{
 801c72c:	b580      	push	{r7, lr}
 801c72e:	af00      	add	r7, sp, #0
    return SysTick->VAL;
 801c730:	4b02      	ldr	r3, [pc, #8]	; (801c73c <sys_rand+0x10>)
 801c732:	689b      	ldr	r3, [r3, #8]
}
 801c734:	0018      	movs	r0, r3
 801c736:	46bd      	mov	sp, r7
 801c738:	bd80      	pop	{r7, pc}
 801c73a:	46c0      	nop			; (mov r8, r8)
 801c73c:	e000e010 	.word	0xe000e010

0801c740 <sys_get_tick_ms>:

extern uint32_t sys_get_tick_ms()
{
 801c740:	b580      	push	{r7, lr}
 801c742:	af00      	add	r7, sp, #0
    return HAL_GetTick();
 801c744:	f7e5 feac 	bl	80024a0 <HAL_GetTick>
 801c748:	0003      	movs	r3, r0
}
 801c74a:	0018      	movs	r0, r3
 801c74c:	46bd      	mov	sp, r7
 801c74e:	bd80      	pop	{r7, pc}

0801c750 <sys_now>:



uint32_t sys_now(void)
{
 801c750:	b580      	push	{r7, lr}
 801c752:	af00      	add	r7, sp, #0
    return sys_get_tick_ms();
 801c754:	f7ff fff4 	bl	801c740 <sys_get_tick_ms>
 801c758:	0003      	movs	r3, r0
}
 801c75a:	0018      	movs	r0, r3
 801c75c:	46bd      	mov	sp, r7
 801c75e:	bd80      	pop	{r7, pc}

0801c760 <sys_jiffies>:

/**
 * @brief Override LWIP weak function
 */
uint32_t sys_jiffies(void)
{
 801c760:	b580      	push	{r7, lr}
 801c762:	af00      	add	r7, sp, #0
    return sys_get_tick_ms();
 801c764:	f7ff ffec 	bl	801c740 <sys_get_tick_ms>
 801c768:	0003      	movs	r3, r0
}
 801c76a:	0018      	movs	r0, r3
 801c76c:	46bd      	mov	sp, r7
 801c76e:	bd80      	pop	{r7, pc}

0801c770 <atoi>:
 801c770:	b510      	push	{r4, lr}
 801c772:	220a      	movs	r2, #10
 801c774:	2100      	movs	r1, #0
 801c776:	f000 fa07 	bl	801cb88 <strtol>
 801c77a:	bd10      	pop	{r4, pc}

0801c77c <__libc_init_array>:
 801c77c:	b570      	push	{r4, r5, r6, lr}
 801c77e:	2600      	movs	r6, #0
 801c780:	4d0c      	ldr	r5, [pc, #48]	; (801c7b4 <__libc_init_array+0x38>)
 801c782:	4c0d      	ldr	r4, [pc, #52]	; (801c7b8 <__libc_init_array+0x3c>)
 801c784:	1b64      	subs	r4, r4, r5
 801c786:	10a4      	asrs	r4, r4, #2
 801c788:	42a6      	cmp	r6, r4
 801c78a:	d109      	bne.n	801c7a0 <__libc_init_array+0x24>
 801c78c:	2600      	movs	r6, #0
 801c78e:	f000 fd75 	bl	801d27c <_init>
 801c792:	4d0a      	ldr	r5, [pc, #40]	; (801c7bc <__libc_init_array+0x40>)
 801c794:	4c0a      	ldr	r4, [pc, #40]	; (801c7c0 <__libc_init_array+0x44>)
 801c796:	1b64      	subs	r4, r4, r5
 801c798:	10a4      	asrs	r4, r4, #2
 801c79a:	42a6      	cmp	r6, r4
 801c79c:	d105      	bne.n	801c7aa <__libc_init_array+0x2e>
 801c79e:	bd70      	pop	{r4, r5, r6, pc}
 801c7a0:	00b3      	lsls	r3, r6, #2
 801c7a2:	58eb      	ldr	r3, [r5, r3]
 801c7a4:	4798      	blx	r3
 801c7a6:	3601      	adds	r6, #1
 801c7a8:	e7ee      	b.n	801c788 <__libc_init_array+0xc>
 801c7aa:	00b3      	lsls	r3, r6, #2
 801c7ac:	58eb      	ldr	r3, [r5, r3]
 801c7ae:	4798      	blx	r3
 801c7b0:	3601      	adds	r6, #1
 801c7b2:	e7f2      	b.n	801c79a <__libc_init_array+0x1e>
 801c7b4:	080221c8 	.word	0x080221c8
 801c7b8:	080221c8 	.word	0x080221c8
 801c7bc:	080221c8 	.word	0x080221c8
 801c7c0:	080221cc 	.word	0x080221cc

0801c7c4 <malloc>:
 801c7c4:	b510      	push	{r4, lr}
 801c7c6:	4b03      	ldr	r3, [pc, #12]	; (801c7d4 <malloc+0x10>)
 801c7c8:	0001      	movs	r1, r0
 801c7ca:	6818      	ldr	r0, [r3, #0]
 801c7cc:	f000 f880 	bl	801c8d0 <_malloc_r>
 801c7d0:	bd10      	pop	{r4, pc}
 801c7d2:	46c0      	nop			; (mov r8, r8)
 801c7d4:	2000022c 	.word	0x2000022c

0801c7d8 <memcmp>:
 801c7d8:	b530      	push	{r4, r5, lr}
 801c7da:	2400      	movs	r4, #0
 801c7dc:	3901      	subs	r1, #1
 801c7de:	42a2      	cmp	r2, r4
 801c7e0:	d101      	bne.n	801c7e6 <memcmp+0xe>
 801c7e2:	2000      	movs	r0, #0
 801c7e4:	e005      	b.n	801c7f2 <memcmp+0x1a>
 801c7e6:	5d03      	ldrb	r3, [r0, r4]
 801c7e8:	3401      	adds	r4, #1
 801c7ea:	5d0d      	ldrb	r5, [r1, r4]
 801c7ec:	42ab      	cmp	r3, r5
 801c7ee:	d0f6      	beq.n	801c7de <memcmp+0x6>
 801c7f0:	1b58      	subs	r0, r3, r5
 801c7f2:	bd30      	pop	{r4, r5, pc}

0801c7f4 <memcpy>:
 801c7f4:	2300      	movs	r3, #0
 801c7f6:	b510      	push	{r4, lr}
 801c7f8:	429a      	cmp	r2, r3
 801c7fa:	d100      	bne.n	801c7fe <memcpy+0xa>
 801c7fc:	bd10      	pop	{r4, pc}
 801c7fe:	5ccc      	ldrb	r4, [r1, r3]
 801c800:	54c4      	strb	r4, [r0, r3]
 801c802:	3301      	adds	r3, #1
 801c804:	e7f8      	b.n	801c7f8 <memcpy+0x4>

0801c806 <memmove>:
 801c806:	b510      	push	{r4, lr}
 801c808:	4288      	cmp	r0, r1
 801c80a:	d902      	bls.n	801c812 <memmove+0xc>
 801c80c:	188b      	adds	r3, r1, r2
 801c80e:	4298      	cmp	r0, r3
 801c810:	d303      	bcc.n	801c81a <memmove+0x14>
 801c812:	2300      	movs	r3, #0
 801c814:	e007      	b.n	801c826 <memmove+0x20>
 801c816:	5c8b      	ldrb	r3, [r1, r2]
 801c818:	5483      	strb	r3, [r0, r2]
 801c81a:	3a01      	subs	r2, #1
 801c81c:	d2fb      	bcs.n	801c816 <memmove+0x10>
 801c81e:	bd10      	pop	{r4, pc}
 801c820:	5ccc      	ldrb	r4, [r1, r3]
 801c822:	54c4      	strb	r4, [r0, r3]
 801c824:	3301      	adds	r3, #1
 801c826:	429a      	cmp	r2, r3
 801c828:	d1fa      	bne.n	801c820 <memmove+0x1a>
 801c82a:	e7f8      	b.n	801c81e <memmove+0x18>

0801c82c <memset>:
 801c82c:	0003      	movs	r3, r0
 801c82e:	1882      	adds	r2, r0, r2
 801c830:	4293      	cmp	r3, r2
 801c832:	d100      	bne.n	801c836 <memset+0xa>
 801c834:	4770      	bx	lr
 801c836:	7019      	strb	r1, [r3, #0]
 801c838:	3301      	adds	r3, #1
 801c83a:	e7f9      	b.n	801c830 <memset+0x4>

0801c83c <_free_r>:
 801c83c:	b570      	push	{r4, r5, r6, lr}
 801c83e:	0005      	movs	r5, r0
 801c840:	2900      	cmp	r1, #0
 801c842:	d010      	beq.n	801c866 <_free_r+0x2a>
 801c844:	1f0c      	subs	r4, r1, #4
 801c846:	6823      	ldr	r3, [r4, #0]
 801c848:	2b00      	cmp	r3, #0
 801c84a:	da00      	bge.n	801c84e <_free_r+0x12>
 801c84c:	18e4      	adds	r4, r4, r3
 801c84e:	0028      	movs	r0, r5
 801c850:	f000 f9e6 	bl	801cc20 <__malloc_lock>
 801c854:	4a1d      	ldr	r2, [pc, #116]	; (801c8cc <_free_r+0x90>)
 801c856:	6813      	ldr	r3, [r2, #0]
 801c858:	2b00      	cmp	r3, #0
 801c85a:	d105      	bne.n	801c868 <_free_r+0x2c>
 801c85c:	6063      	str	r3, [r4, #4]
 801c85e:	6014      	str	r4, [r2, #0]
 801c860:	0028      	movs	r0, r5
 801c862:	f000 f9e5 	bl	801cc30 <__malloc_unlock>
 801c866:	bd70      	pop	{r4, r5, r6, pc}
 801c868:	42a3      	cmp	r3, r4
 801c86a:	d908      	bls.n	801c87e <_free_r+0x42>
 801c86c:	6821      	ldr	r1, [r4, #0]
 801c86e:	1860      	adds	r0, r4, r1
 801c870:	4283      	cmp	r3, r0
 801c872:	d1f3      	bne.n	801c85c <_free_r+0x20>
 801c874:	6818      	ldr	r0, [r3, #0]
 801c876:	685b      	ldr	r3, [r3, #4]
 801c878:	1841      	adds	r1, r0, r1
 801c87a:	6021      	str	r1, [r4, #0]
 801c87c:	e7ee      	b.n	801c85c <_free_r+0x20>
 801c87e:	001a      	movs	r2, r3
 801c880:	685b      	ldr	r3, [r3, #4]
 801c882:	2b00      	cmp	r3, #0
 801c884:	d001      	beq.n	801c88a <_free_r+0x4e>
 801c886:	42a3      	cmp	r3, r4
 801c888:	d9f9      	bls.n	801c87e <_free_r+0x42>
 801c88a:	6811      	ldr	r1, [r2, #0]
 801c88c:	1850      	adds	r0, r2, r1
 801c88e:	42a0      	cmp	r0, r4
 801c890:	d10b      	bne.n	801c8aa <_free_r+0x6e>
 801c892:	6820      	ldr	r0, [r4, #0]
 801c894:	1809      	adds	r1, r1, r0
 801c896:	1850      	adds	r0, r2, r1
 801c898:	6011      	str	r1, [r2, #0]
 801c89a:	4283      	cmp	r3, r0
 801c89c:	d1e0      	bne.n	801c860 <_free_r+0x24>
 801c89e:	6818      	ldr	r0, [r3, #0]
 801c8a0:	685b      	ldr	r3, [r3, #4]
 801c8a2:	1841      	adds	r1, r0, r1
 801c8a4:	6011      	str	r1, [r2, #0]
 801c8a6:	6053      	str	r3, [r2, #4]
 801c8a8:	e7da      	b.n	801c860 <_free_r+0x24>
 801c8aa:	42a0      	cmp	r0, r4
 801c8ac:	d902      	bls.n	801c8b4 <_free_r+0x78>
 801c8ae:	230c      	movs	r3, #12
 801c8b0:	602b      	str	r3, [r5, #0]
 801c8b2:	e7d5      	b.n	801c860 <_free_r+0x24>
 801c8b4:	6821      	ldr	r1, [r4, #0]
 801c8b6:	1860      	adds	r0, r4, r1
 801c8b8:	4283      	cmp	r3, r0
 801c8ba:	d103      	bne.n	801c8c4 <_free_r+0x88>
 801c8bc:	6818      	ldr	r0, [r3, #0]
 801c8be:	685b      	ldr	r3, [r3, #4]
 801c8c0:	1841      	adds	r1, r0, r1
 801c8c2:	6021      	str	r1, [r4, #0]
 801c8c4:	6063      	str	r3, [r4, #4]
 801c8c6:	6054      	str	r4, [r2, #4]
 801c8c8:	e7ca      	b.n	801c860 <_free_r+0x24>
 801c8ca:	46c0      	nop			; (mov r8, r8)
 801c8cc:	200013c0 	.word	0x200013c0

0801c8d0 <_malloc_r>:
 801c8d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801c8d2:	2303      	movs	r3, #3
 801c8d4:	1ccd      	adds	r5, r1, #3
 801c8d6:	439d      	bics	r5, r3
 801c8d8:	3508      	adds	r5, #8
 801c8da:	0006      	movs	r6, r0
 801c8dc:	2d0c      	cmp	r5, #12
 801c8de:	d21f      	bcs.n	801c920 <_malloc_r+0x50>
 801c8e0:	250c      	movs	r5, #12
 801c8e2:	42a9      	cmp	r1, r5
 801c8e4:	d81e      	bhi.n	801c924 <_malloc_r+0x54>
 801c8e6:	0030      	movs	r0, r6
 801c8e8:	f000 f99a 	bl	801cc20 <__malloc_lock>
 801c8ec:	4925      	ldr	r1, [pc, #148]	; (801c984 <_malloc_r+0xb4>)
 801c8ee:	680a      	ldr	r2, [r1, #0]
 801c8f0:	0014      	movs	r4, r2
 801c8f2:	2c00      	cmp	r4, #0
 801c8f4:	d11a      	bne.n	801c92c <_malloc_r+0x5c>
 801c8f6:	4f24      	ldr	r7, [pc, #144]	; (801c988 <_malloc_r+0xb8>)
 801c8f8:	683b      	ldr	r3, [r7, #0]
 801c8fa:	2b00      	cmp	r3, #0
 801c8fc:	d104      	bne.n	801c908 <_malloc_r+0x38>
 801c8fe:	0021      	movs	r1, r4
 801c900:	0030      	movs	r0, r6
 801c902:	f000 f843 	bl	801c98c <_sbrk_r>
 801c906:	6038      	str	r0, [r7, #0]
 801c908:	0029      	movs	r1, r5
 801c90a:	0030      	movs	r0, r6
 801c90c:	f000 f83e 	bl	801c98c <_sbrk_r>
 801c910:	1c43      	adds	r3, r0, #1
 801c912:	d12b      	bne.n	801c96c <_malloc_r+0x9c>
 801c914:	230c      	movs	r3, #12
 801c916:	0030      	movs	r0, r6
 801c918:	6033      	str	r3, [r6, #0]
 801c91a:	f000 f989 	bl	801cc30 <__malloc_unlock>
 801c91e:	e003      	b.n	801c928 <_malloc_r+0x58>
 801c920:	2d00      	cmp	r5, #0
 801c922:	dade      	bge.n	801c8e2 <_malloc_r+0x12>
 801c924:	230c      	movs	r3, #12
 801c926:	6033      	str	r3, [r6, #0]
 801c928:	2000      	movs	r0, #0
 801c92a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801c92c:	6823      	ldr	r3, [r4, #0]
 801c92e:	1b5b      	subs	r3, r3, r5
 801c930:	d419      	bmi.n	801c966 <_malloc_r+0x96>
 801c932:	2b0b      	cmp	r3, #11
 801c934:	d903      	bls.n	801c93e <_malloc_r+0x6e>
 801c936:	6023      	str	r3, [r4, #0]
 801c938:	18e4      	adds	r4, r4, r3
 801c93a:	6025      	str	r5, [r4, #0]
 801c93c:	e003      	b.n	801c946 <_malloc_r+0x76>
 801c93e:	6863      	ldr	r3, [r4, #4]
 801c940:	42a2      	cmp	r2, r4
 801c942:	d10e      	bne.n	801c962 <_malloc_r+0x92>
 801c944:	600b      	str	r3, [r1, #0]
 801c946:	0030      	movs	r0, r6
 801c948:	f000 f972 	bl	801cc30 <__malloc_unlock>
 801c94c:	0020      	movs	r0, r4
 801c94e:	2207      	movs	r2, #7
 801c950:	300b      	adds	r0, #11
 801c952:	1d23      	adds	r3, r4, #4
 801c954:	4390      	bics	r0, r2
 801c956:	1ac2      	subs	r2, r0, r3
 801c958:	4298      	cmp	r0, r3
 801c95a:	d0e6      	beq.n	801c92a <_malloc_r+0x5a>
 801c95c:	1a1b      	subs	r3, r3, r0
 801c95e:	50a3      	str	r3, [r4, r2]
 801c960:	e7e3      	b.n	801c92a <_malloc_r+0x5a>
 801c962:	6053      	str	r3, [r2, #4]
 801c964:	e7ef      	b.n	801c946 <_malloc_r+0x76>
 801c966:	0022      	movs	r2, r4
 801c968:	6864      	ldr	r4, [r4, #4]
 801c96a:	e7c2      	b.n	801c8f2 <_malloc_r+0x22>
 801c96c:	2303      	movs	r3, #3
 801c96e:	1cc4      	adds	r4, r0, #3
 801c970:	439c      	bics	r4, r3
 801c972:	42a0      	cmp	r0, r4
 801c974:	d0e1      	beq.n	801c93a <_malloc_r+0x6a>
 801c976:	1a21      	subs	r1, r4, r0
 801c978:	0030      	movs	r0, r6
 801c97a:	f000 f807 	bl	801c98c <_sbrk_r>
 801c97e:	1c43      	adds	r3, r0, #1
 801c980:	d1db      	bne.n	801c93a <_malloc_r+0x6a>
 801c982:	e7c7      	b.n	801c914 <_malloc_r+0x44>
 801c984:	200013c0 	.word	0x200013c0
 801c988:	200013c4 	.word	0x200013c4

0801c98c <_sbrk_r>:
 801c98c:	2300      	movs	r3, #0
 801c98e:	b570      	push	{r4, r5, r6, lr}
 801c990:	4d06      	ldr	r5, [pc, #24]	; (801c9ac <_sbrk_r+0x20>)
 801c992:	0004      	movs	r4, r0
 801c994:	0008      	movs	r0, r1
 801c996:	602b      	str	r3, [r5, #0]
 801c998:	f7e3 ff48 	bl	800082c <_sbrk>
 801c99c:	1c43      	adds	r3, r0, #1
 801c99e:	d103      	bne.n	801c9a8 <_sbrk_r+0x1c>
 801c9a0:	682b      	ldr	r3, [r5, #0]
 801c9a2:	2b00      	cmp	r3, #0
 801c9a4:	d000      	beq.n	801c9a8 <_sbrk_r+0x1c>
 801c9a6:	6023      	str	r3, [r4, #0]
 801c9a8:	bd70      	pop	{r4, r5, r6, pc}
 801c9aa:	46c0      	nop			; (mov r8, r8)
 801c9ac:	20003e00 	.word	0x20003e00

0801c9b0 <sniprintf>:
 801c9b0:	b40c      	push	{r2, r3}
 801c9b2:	b530      	push	{r4, r5, lr}
 801c9b4:	4b17      	ldr	r3, [pc, #92]	; (801ca14 <sniprintf+0x64>)
 801c9b6:	000c      	movs	r4, r1
 801c9b8:	681d      	ldr	r5, [r3, #0]
 801c9ba:	b09d      	sub	sp, #116	; 0x74
 801c9bc:	2900      	cmp	r1, #0
 801c9be:	da08      	bge.n	801c9d2 <sniprintf+0x22>
 801c9c0:	238b      	movs	r3, #139	; 0x8b
 801c9c2:	2001      	movs	r0, #1
 801c9c4:	602b      	str	r3, [r5, #0]
 801c9c6:	4240      	negs	r0, r0
 801c9c8:	b01d      	add	sp, #116	; 0x74
 801c9ca:	bc30      	pop	{r4, r5}
 801c9cc:	bc08      	pop	{r3}
 801c9ce:	b002      	add	sp, #8
 801c9d0:	4718      	bx	r3
 801c9d2:	2382      	movs	r3, #130	; 0x82
 801c9d4:	466a      	mov	r2, sp
 801c9d6:	009b      	lsls	r3, r3, #2
 801c9d8:	8293      	strh	r3, [r2, #20]
 801c9da:	2300      	movs	r3, #0
 801c9dc:	9002      	str	r0, [sp, #8]
 801c9de:	9006      	str	r0, [sp, #24]
 801c9e0:	4299      	cmp	r1, r3
 801c9e2:	d000      	beq.n	801c9e6 <sniprintf+0x36>
 801c9e4:	1e4b      	subs	r3, r1, #1
 801c9e6:	9304      	str	r3, [sp, #16]
 801c9e8:	9307      	str	r3, [sp, #28]
 801c9ea:	2301      	movs	r3, #1
 801c9ec:	466a      	mov	r2, sp
 801c9ee:	425b      	negs	r3, r3
 801c9f0:	82d3      	strh	r3, [r2, #22]
 801c9f2:	0028      	movs	r0, r5
 801c9f4:	ab21      	add	r3, sp, #132	; 0x84
 801c9f6:	9a20      	ldr	r2, [sp, #128]	; 0x80
 801c9f8:	a902      	add	r1, sp, #8
 801c9fa:	9301      	str	r3, [sp, #4]
 801c9fc:	f000 f982 	bl	801cd04 <_svfiprintf_r>
 801ca00:	1c43      	adds	r3, r0, #1
 801ca02:	da01      	bge.n	801ca08 <sniprintf+0x58>
 801ca04:	238b      	movs	r3, #139	; 0x8b
 801ca06:	602b      	str	r3, [r5, #0]
 801ca08:	2c00      	cmp	r4, #0
 801ca0a:	d0dd      	beq.n	801c9c8 <sniprintf+0x18>
 801ca0c:	2300      	movs	r3, #0
 801ca0e:	9a02      	ldr	r2, [sp, #8]
 801ca10:	7013      	strb	r3, [r2, #0]
 801ca12:	e7d9      	b.n	801c9c8 <sniprintf+0x18>
 801ca14:	2000022c 	.word	0x2000022c

0801ca18 <strncpy>:
 801ca18:	0003      	movs	r3, r0
 801ca1a:	b530      	push	{r4, r5, lr}
 801ca1c:	001d      	movs	r5, r3
 801ca1e:	2a00      	cmp	r2, #0
 801ca20:	d006      	beq.n	801ca30 <strncpy+0x18>
 801ca22:	780c      	ldrb	r4, [r1, #0]
 801ca24:	3a01      	subs	r2, #1
 801ca26:	3301      	adds	r3, #1
 801ca28:	702c      	strb	r4, [r5, #0]
 801ca2a:	3101      	adds	r1, #1
 801ca2c:	2c00      	cmp	r4, #0
 801ca2e:	d1f5      	bne.n	801ca1c <strncpy+0x4>
 801ca30:	2100      	movs	r1, #0
 801ca32:	189a      	adds	r2, r3, r2
 801ca34:	4293      	cmp	r3, r2
 801ca36:	d100      	bne.n	801ca3a <strncpy+0x22>
 801ca38:	bd30      	pop	{r4, r5, pc}
 801ca3a:	7019      	strb	r1, [r3, #0]
 801ca3c:	3301      	adds	r3, #1
 801ca3e:	e7f9      	b.n	801ca34 <strncpy+0x1c>

0801ca40 <strstr>:
 801ca40:	780a      	ldrb	r2, [r1, #0]
 801ca42:	b530      	push	{r4, r5, lr}
 801ca44:	2a00      	cmp	r2, #0
 801ca46:	d10c      	bne.n	801ca62 <strstr+0x22>
 801ca48:	bd30      	pop	{r4, r5, pc}
 801ca4a:	429a      	cmp	r2, r3
 801ca4c:	d108      	bne.n	801ca60 <strstr+0x20>
 801ca4e:	2301      	movs	r3, #1
 801ca50:	5ccc      	ldrb	r4, [r1, r3]
 801ca52:	2c00      	cmp	r4, #0
 801ca54:	d0f8      	beq.n	801ca48 <strstr+0x8>
 801ca56:	5cc5      	ldrb	r5, [r0, r3]
 801ca58:	42a5      	cmp	r5, r4
 801ca5a:	d101      	bne.n	801ca60 <strstr+0x20>
 801ca5c:	3301      	adds	r3, #1
 801ca5e:	e7f7      	b.n	801ca50 <strstr+0x10>
 801ca60:	3001      	adds	r0, #1
 801ca62:	7803      	ldrb	r3, [r0, #0]
 801ca64:	2b00      	cmp	r3, #0
 801ca66:	d1f0      	bne.n	801ca4a <strstr+0xa>
 801ca68:	0018      	movs	r0, r3
 801ca6a:	e7ed      	b.n	801ca48 <strstr+0x8>

0801ca6c <_strtol_l.isra.0>:
 801ca6c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801ca6e:	b087      	sub	sp, #28
 801ca70:	001e      	movs	r6, r3
 801ca72:	9005      	str	r0, [sp, #20]
 801ca74:	9101      	str	r1, [sp, #4]
 801ca76:	9202      	str	r2, [sp, #8]
 801ca78:	2b01      	cmp	r3, #1
 801ca7a:	d045      	beq.n	801cb08 <_strtol_l.isra.0+0x9c>
 801ca7c:	0008      	movs	r0, r1
 801ca7e:	2b24      	cmp	r3, #36	; 0x24
 801ca80:	d842      	bhi.n	801cb08 <_strtol_l.isra.0+0x9c>
 801ca82:	4b3f      	ldr	r3, [pc, #252]	; (801cb80 <_strtol_l.isra.0+0x114>)
 801ca84:	2208      	movs	r2, #8
 801ca86:	469c      	mov	ip, r3
 801ca88:	0003      	movs	r3, r0
 801ca8a:	4661      	mov	r1, ip
 801ca8c:	781c      	ldrb	r4, [r3, #0]
 801ca8e:	1c45      	adds	r5, r0, #1
 801ca90:	5d09      	ldrb	r1, [r1, r4]
 801ca92:	0028      	movs	r0, r5
 801ca94:	000f      	movs	r7, r1
 801ca96:	4017      	ands	r7, r2
 801ca98:	4211      	tst	r1, r2
 801ca9a:	d1f5      	bne.n	801ca88 <_strtol_l.isra.0+0x1c>
 801ca9c:	2c2d      	cmp	r4, #45	; 0x2d
 801ca9e:	d13a      	bne.n	801cb16 <_strtol_l.isra.0+0xaa>
 801caa0:	2701      	movs	r7, #1
 801caa2:	782c      	ldrb	r4, [r5, #0]
 801caa4:	1c9d      	adds	r5, r3, #2
 801caa6:	2e00      	cmp	r6, #0
 801caa8:	d065      	beq.n	801cb76 <_strtol_l.isra.0+0x10a>
 801caaa:	2e10      	cmp	r6, #16
 801caac:	d109      	bne.n	801cac2 <_strtol_l.isra.0+0x56>
 801caae:	2c30      	cmp	r4, #48	; 0x30
 801cab0:	d107      	bne.n	801cac2 <_strtol_l.isra.0+0x56>
 801cab2:	2220      	movs	r2, #32
 801cab4:	782b      	ldrb	r3, [r5, #0]
 801cab6:	4393      	bics	r3, r2
 801cab8:	2b58      	cmp	r3, #88	; 0x58
 801caba:	d157      	bne.n	801cb6c <_strtol_l.isra.0+0x100>
 801cabc:	2610      	movs	r6, #16
 801cabe:	786c      	ldrb	r4, [r5, #1]
 801cac0:	3502      	adds	r5, #2
 801cac2:	4b30      	ldr	r3, [pc, #192]	; (801cb84 <_strtol_l.isra.0+0x118>)
 801cac4:	0031      	movs	r1, r6
 801cac6:	18fb      	adds	r3, r7, r3
 801cac8:	0018      	movs	r0, r3
 801caca:	9303      	str	r3, [sp, #12]
 801cacc:	f7e3 fbb4 	bl	8000238 <__aeabi_uidivmod>
 801cad0:	2300      	movs	r3, #0
 801cad2:	2201      	movs	r2, #1
 801cad4:	4684      	mov	ip, r0
 801cad6:	0018      	movs	r0, r3
 801cad8:	9104      	str	r1, [sp, #16]
 801cada:	4252      	negs	r2, r2
 801cadc:	0021      	movs	r1, r4
 801cade:	3930      	subs	r1, #48	; 0x30
 801cae0:	2909      	cmp	r1, #9
 801cae2:	d81d      	bhi.n	801cb20 <_strtol_l.isra.0+0xb4>
 801cae4:	000c      	movs	r4, r1
 801cae6:	42a6      	cmp	r6, r4
 801cae8:	dd28      	ble.n	801cb3c <_strtol_l.isra.0+0xd0>
 801caea:	2b00      	cmp	r3, #0
 801caec:	db24      	blt.n	801cb38 <_strtol_l.isra.0+0xcc>
 801caee:	0013      	movs	r3, r2
 801caf0:	4584      	cmp	ip, r0
 801caf2:	d306      	bcc.n	801cb02 <_strtol_l.isra.0+0x96>
 801caf4:	d102      	bne.n	801cafc <_strtol_l.isra.0+0x90>
 801caf6:	9904      	ldr	r1, [sp, #16]
 801caf8:	42a1      	cmp	r1, r4
 801cafa:	db02      	blt.n	801cb02 <_strtol_l.isra.0+0x96>
 801cafc:	2301      	movs	r3, #1
 801cafe:	4370      	muls	r0, r6
 801cb00:	1820      	adds	r0, r4, r0
 801cb02:	782c      	ldrb	r4, [r5, #0]
 801cb04:	3501      	adds	r5, #1
 801cb06:	e7e9      	b.n	801cadc <_strtol_l.isra.0+0x70>
 801cb08:	f000 f882 	bl	801cc10 <__errno>
 801cb0c:	2316      	movs	r3, #22
 801cb0e:	6003      	str	r3, [r0, #0]
 801cb10:	2000      	movs	r0, #0
 801cb12:	b007      	add	sp, #28
 801cb14:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801cb16:	2c2b      	cmp	r4, #43	; 0x2b
 801cb18:	d1c5      	bne.n	801caa6 <_strtol_l.isra.0+0x3a>
 801cb1a:	782c      	ldrb	r4, [r5, #0]
 801cb1c:	1c9d      	adds	r5, r3, #2
 801cb1e:	e7c2      	b.n	801caa6 <_strtol_l.isra.0+0x3a>
 801cb20:	0021      	movs	r1, r4
 801cb22:	3941      	subs	r1, #65	; 0x41
 801cb24:	2919      	cmp	r1, #25
 801cb26:	d801      	bhi.n	801cb2c <_strtol_l.isra.0+0xc0>
 801cb28:	3c37      	subs	r4, #55	; 0x37
 801cb2a:	e7dc      	b.n	801cae6 <_strtol_l.isra.0+0x7a>
 801cb2c:	0021      	movs	r1, r4
 801cb2e:	3961      	subs	r1, #97	; 0x61
 801cb30:	2919      	cmp	r1, #25
 801cb32:	d803      	bhi.n	801cb3c <_strtol_l.isra.0+0xd0>
 801cb34:	3c57      	subs	r4, #87	; 0x57
 801cb36:	e7d6      	b.n	801cae6 <_strtol_l.isra.0+0x7a>
 801cb38:	0013      	movs	r3, r2
 801cb3a:	e7e2      	b.n	801cb02 <_strtol_l.isra.0+0x96>
 801cb3c:	2b00      	cmp	r3, #0
 801cb3e:	da09      	bge.n	801cb54 <_strtol_l.isra.0+0xe8>
 801cb40:	2322      	movs	r3, #34	; 0x22
 801cb42:	9a05      	ldr	r2, [sp, #20]
 801cb44:	9803      	ldr	r0, [sp, #12]
 801cb46:	6013      	str	r3, [r2, #0]
 801cb48:	9b02      	ldr	r3, [sp, #8]
 801cb4a:	2b00      	cmp	r3, #0
 801cb4c:	d0e1      	beq.n	801cb12 <_strtol_l.isra.0+0xa6>
 801cb4e:	1e6b      	subs	r3, r5, #1
 801cb50:	9301      	str	r3, [sp, #4]
 801cb52:	e007      	b.n	801cb64 <_strtol_l.isra.0+0xf8>
 801cb54:	2f00      	cmp	r7, #0
 801cb56:	d000      	beq.n	801cb5a <_strtol_l.isra.0+0xee>
 801cb58:	4240      	negs	r0, r0
 801cb5a:	9a02      	ldr	r2, [sp, #8]
 801cb5c:	2a00      	cmp	r2, #0
 801cb5e:	d0d8      	beq.n	801cb12 <_strtol_l.isra.0+0xa6>
 801cb60:	2b00      	cmp	r3, #0
 801cb62:	d1f4      	bne.n	801cb4e <_strtol_l.isra.0+0xe2>
 801cb64:	9b02      	ldr	r3, [sp, #8]
 801cb66:	9a01      	ldr	r2, [sp, #4]
 801cb68:	601a      	str	r2, [r3, #0]
 801cb6a:	e7d2      	b.n	801cb12 <_strtol_l.isra.0+0xa6>
 801cb6c:	2430      	movs	r4, #48	; 0x30
 801cb6e:	2e00      	cmp	r6, #0
 801cb70:	d1a7      	bne.n	801cac2 <_strtol_l.isra.0+0x56>
 801cb72:	3608      	adds	r6, #8
 801cb74:	e7a5      	b.n	801cac2 <_strtol_l.isra.0+0x56>
 801cb76:	2c30      	cmp	r4, #48	; 0x30
 801cb78:	d09b      	beq.n	801cab2 <_strtol_l.isra.0+0x46>
 801cb7a:	260a      	movs	r6, #10
 801cb7c:	e7a1      	b.n	801cac2 <_strtol_l.isra.0+0x56>
 801cb7e:	46c0      	nop			; (mov r8, r8)
 801cb80:	0802202d 	.word	0x0802202d
 801cb84:	7fffffff 	.word	0x7fffffff

0801cb88 <strtol>:
 801cb88:	b510      	push	{r4, lr}
 801cb8a:	0013      	movs	r3, r2
 801cb8c:	000a      	movs	r2, r1
 801cb8e:	0001      	movs	r1, r0
 801cb90:	4802      	ldr	r0, [pc, #8]	; (801cb9c <strtol+0x14>)
 801cb92:	6800      	ldr	r0, [r0, #0]
 801cb94:	f7ff ff6a 	bl	801ca6c <_strtol_l.isra.0>
 801cb98:	bd10      	pop	{r4, pc}
 801cb9a:	46c0      	nop			; (mov r8, r8)
 801cb9c:	2000022c 	.word	0x2000022c

0801cba0 <_vsniprintf_r>:
 801cba0:	b530      	push	{r4, r5, lr}
 801cba2:	0014      	movs	r4, r2
 801cba4:	0005      	movs	r5, r0
 801cba6:	001a      	movs	r2, r3
 801cba8:	b09b      	sub	sp, #108	; 0x6c
 801cbaa:	2c00      	cmp	r4, #0
 801cbac:	da05      	bge.n	801cbba <_vsniprintf_r+0x1a>
 801cbae:	238b      	movs	r3, #139	; 0x8b
 801cbb0:	6003      	str	r3, [r0, #0]
 801cbb2:	2001      	movs	r0, #1
 801cbb4:	4240      	negs	r0, r0
 801cbb6:	b01b      	add	sp, #108	; 0x6c
 801cbb8:	bd30      	pop	{r4, r5, pc}
 801cbba:	2382      	movs	r3, #130	; 0x82
 801cbbc:	4668      	mov	r0, sp
 801cbbe:	009b      	lsls	r3, r3, #2
 801cbc0:	8183      	strh	r3, [r0, #12]
 801cbc2:	2300      	movs	r3, #0
 801cbc4:	9100      	str	r1, [sp, #0]
 801cbc6:	9104      	str	r1, [sp, #16]
 801cbc8:	429c      	cmp	r4, r3
 801cbca:	d000      	beq.n	801cbce <_vsniprintf_r+0x2e>
 801cbcc:	1e63      	subs	r3, r4, #1
 801cbce:	9302      	str	r3, [sp, #8]
 801cbd0:	9305      	str	r3, [sp, #20]
 801cbd2:	2301      	movs	r3, #1
 801cbd4:	4669      	mov	r1, sp
 801cbd6:	425b      	negs	r3, r3
 801cbd8:	81cb      	strh	r3, [r1, #14]
 801cbda:	0028      	movs	r0, r5
 801cbdc:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 801cbde:	f000 f891 	bl	801cd04 <_svfiprintf_r>
 801cbe2:	1c43      	adds	r3, r0, #1
 801cbe4:	da01      	bge.n	801cbea <_vsniprintf_r+0x4a>
 801cbe6:	238b      	movs	r3, #139	; 0x8b
 801cbe8:	602b      	str	r3, [r5, #0]
 801cbea:	2c00      	cmp	r4, #0
 801cbec:	d0e3      	beq.n	801cbb6 <_vsniprintf_r+0x16>
 801cbee:	2300      	movs	r3, #0
 801cbf0:	9a00      	ldr	r2, [sp, #0]
 801cbf2:	7013      	strb	r3, [r2, #0]
 801cbf4:	e7df      	b.n	801cbb6 <_vsniprintf_r+0x16>
	...

0801cbf8 <vsniprintf>:
 801cbf8:	b507      	push	{r0, r1, r2, lr}
 801cbfa:	9300      	str	r3, [sp, #0]
 801cbfc:	0013      	movs	r3, r2
 801cbfe:	000a      	movs	r2, r1
 801cc00:	0001      	movs	r1, r0
 801cc02:	4802      	ldr	r0, [pc, #8]	; (801cc0c <vsniprintf+0x14>)
 801cc04:	6800      	ldr	r0, [r0, #0]
 801cc06:	f7ff ffcb 	bl	801cba0 <_vsniprintf_r>
 801cc0a:	bd0e      	pop	{r1, r2, r3, pc}
 801cc0c:	2000022c 	.word	0x2000022c

0801cc10 <__errno>:
 801cc10:	4b01      	ldr	r3, [pc, #4]	; (801cc18 <__errno+0x8>)
 801cc12:	6818      	ldr	r0, [r3, #0]
 801cc14:	4770      	bx	lr
 801cc16:	46c0      	nop			; (mov r8, r8)
 801cc18:	2000022c 	.word	0x2000022c

0801cc1c <__retarget_lock_acquire_recursive>:
 801cc1c:	4770      	bx	lr

0801cc1e <__retarget_lock_release_recursive>:
 801cc1e:	4770      	bx	lr

0801cc20 <__malloc_lock>:
 801cc20:	b510      	push	{r4, lr}
 801cc22:	4802      	ldr	r0, [pc, #8]	; (801cc2c <__malloc_lock+0xc>)
 801cc24:	f7ff fffa 	bl	801cc1c <__retarget_lock_acquire_recursive>
 801cc28:	bd10      	pop	{r4, pc}
 801cc2a:	46c0      	nop			; (mov r8, r8)
 801cc2c:	20003e08 	.word	0x20003e08

0801cc30 <__malloc_unlock>:
 801cc30:	b510      	push	{r4, lr}
 801cc32:	4802      	ldr	r0, [pc, #8]	; (801cc3c <__malloc_unlock+0xc>)
 801cc34:	f7ff fff3 	bl	801cc1e <__retarget_lock_release_recursive>
 801cc38:	bd10      	pop	{r4, pc}
 801cc3a:	46c0      	nop			; (mov r8, r8)
 801cc3c:	20003e08 	.word	0x20003e08

0801cc40 <__ssputs_r>:
 801cc40:	b5f0      	push	{r4, r5, r6, r7, lr}
 801cc42:	688e      	ldr	r6, [r1, #8]
 801cc44:	b085      	sub	sp, #20
 801cc46:	0007      	movs	r7, r0
 801cc48:	000c      	movs	r4, r1
 801cc4a:	9203      	str	r2, [sp, #12]
 801cc4c:	9301      	str	r3, [sp, #4]
 801cc4e:	429e      	cmp	r6, r3
 801cc50:	d83c      	bhi.n	801cccc <__ssputs_r+0x8c>
 801cc52:	2390      	movs	r3, #144	; 0x90
 801cc54:	898a      	ldrh	r2, [r1, #12]
 801cc56:	00db      	lsls	r3, r3, #3
 801cc58:	421a      	tst	r2, r3
 801cc5a:	d034      	beq.n	801ccc6 <__ssputs_r+0x86>
 801cc5c:	2503      	movs	r5, #3
 801cc5e:	6909      	ldr	r1, [r1, #16]
 801cc60:	6823      	ldr	r3, [r4, #0]
 801cc62:	1a5b      	subs	r3, r3, r1
 801cc64:	9302      	str	r3, [sp, #8]
 801cc66:	6963      	ldr	r3, [r4, #20]
 801cc68:	9802      	ldr	r0, [sp, #8]
 801cc6a:	435d      	muls	r5, r3
 801cc6c:	0feb      	lsrs	r3, r5, #31
 801cc6e:	195d      	adds	r5, r3, r5
 801cc70:	9b01      	ldr	r3, [sp, #4]
 801cc72:	106d      	asrs	r5, r5, #1
 801cc74:	3301      	adds	r3, #1
 801cc76:	181b      	adds	r3, r3, r0
 801cc78:	42ab      	cmp	r3, r5
 801cc7a:	d900      	bls.n	801cc7e <__ssputs_r+0x3e>
 801cc7c:	001d      	movs	r5, r3
 801cc7e:	0553      	lsls	r3, r2, #21
 801cc80:	d532      	bpl.n	801cce8 <__ssputs_r+0xa8>
 801cc82:	0029      	movs	r1, r5
 801cc84:	0038      	movs	r0, r7
 801cc86:	f7ff fe23 	bl	801c8d0 <_malloc_r>
 801cc8a:	1e06      	subs	r6, r0, #0
 801cc8c:	d109      	bne.n	801cca2 <__ssputs_r+0x62>
 801cc8e:	230c      	movs	r3, #12
 801cc90:	603b      	str	r3, [r7, #0]
 801cc92:	2340      	movs	r3, #64	; 0x40
 801cc94:	2001      	movs	r0, #1
 801cc96:	89a2      	ldrh	r2, [r4, #12]
 801cc98:	4240      	negs	r0, r0
 801cc9a:	4313      	orrs	r3, r2
 801cc9c:	81a3      	strh	r3, [r4, #12]
 801cc9e:	b005      	add	sp, #20
 801cca0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801cca2:	9a02      	ldr	r2, [sp, #8]
 801cca4:	6921      	ldr	r1, [r4, #16]
 801cca6:	f7ff fda5 	bl	801c7f4 <memcpy>
 801ccaa:	89a3      	ldrh	r3, [r4, #12]
 801ccac:	4a14      	ldr	r2, [pc, #80]	; (801cd00 <__ssputs_r+0xc0>)
 801ccae:	401a      	ands	r2, r3
 801ccb0:	2380      	movs	r3, #128	; 0x80
 801ccb2:	4313      	orrs	r3, r2
 801ccb4:	81a3      	strh	r3, [r4, #12]
 801ccb6:	9b02      	ldr	r3, [sp, #8]
 801ccb8:	6126      	str	r6, [r4, #16]
 801ccba:	18f6      	adds	r6, r6, r3
 801ccbc:	6026      	str	r6, [r4, #0]
 801ccbe:	6165      	str	r5, [r4, #20]
 801ccc0:	9e01      	ldr	r6, [sp, #4]
 801ccc2:	1aed      	subs	r5, r5, r3
 801ccc4:	60a5      	str	r5, [r4, #8]
 801ccc6:	9b01      	ldr	r3, [sp, #4]
 801ccc8:	429e      	cmp	r6, r3
 801ccca:	d900      	bls.n	801ccce <__ssputs_r+0x8e>
 801cccc:	9e01      	ldr	r6, [sp, #4]
 801ccce:	0032      	movs	r2, r6
 801ccd0:	9903      	ldr	r1, [sp, #12]
 801ccd2:	6820      	ldr	r0, [r4, #0]
 801ccd4:	f7ff fd97 	bl	801c806 <memmove>
 801ccd8:	68a3      	ldr	r3, [r4, #8]
 801ccda:	2000      	movs	r0, #0
 801ccdc:	1b9b      	subs	r3, r3, r6
 801ccde:	60a3      	str	r3, [r4, #8]
 801cce0:	6823      	ldr	r3, [r4, #0]
 801cce2:	199e      	adds	r6, r3, r6
 801cce4:	6026      	str	r6, [r4, #0]
 801cce6:	e7da      	b.n	801cc9e <__ssputs_r+0x5e>
 801cce8:	002a      	movs	r2, r5
 801ccea:	0038      	movs	r0, r7
 801ccec:	f000 fa97 	bl	801d21e <_realloc_r>
 801ccf0:	1e06      	subs	r6, r0, #0
 801ccf2:	d1e0      	bne.n	801ccb6 <__ssputs_r+0x76>
 801ccf4:	0038      	movs	r0, r7
 801ccf6:	6921      	ldr	r1, [r4, #16]
 801ccf8:	f7ff fda0 	bl	801c83c <_free_r>
 801ccfc:	e7c7      	b.n	801cc8e <__ssputs_r+0x4e>
 801ccfe:	46c0      	nop			; (mov r8, r8)
 801cd00:	fffffb7f 	.word	0xfffffb7f

0801cd04 <_svfiprintf_r>:
 801cd04:	b5f0      	push	{r4, r5, r6, r7, lr}
 801cd06:	b0a1      	sub	sp, #132	; 0x84
 801cd08:	9003      	str	r0, [sp, #12]
 801cd0a:	001d      	movs	r5, r3
 801cd0c:	898b      	ldrh	r3, [r1, #12]
 801cd0e:	000f      	movs	r7, r1
 801cd10:	0016      	movs	r6, r2
 801cd12:	061b      	lsls	r3, r3, #24
 801cd14:	d511      	bpl.n	801cd3a <_svfiprintf_r+0x36>
 801cd16:	690b      	ldr	r3, [r1, #16]
 801cd18:	2b00      	cmp	r3, #0
 801cd1a:	d10e      	bne.n	801cd3a <_svfiprintf_r+0x36>
 801cd1c:	2140      	movs	r1, #64	; 0x40
 801cd1e:	f7ff fdd7 	bl	801c8d0 <_malloc_r>
 801cd22:	6038      	str	r0, [r7, #0]
 801cd24:	6138      	str	r0, [r7, #16]
 801cd26:	2800      	cmp	r0, #0
 801cd28:	d105      	bne.n	801cd36 <_svfiprintf_r+0x32>
 801cd2a:	230c      	movs	r3, #12
 801cd2c:	9a03      	ldr	r2, [sp, #12]
 801cd2e:	3801      	subs	r0, #1
 801cd30:	6013      	str	r3, [r2, #0]
 801cd32:	b021      	add	sp, #132	; 0x84
 801cd34:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801cd36:	2340      	movs	r3, #64	; 0x40
 801cd38:	617b      	str	r3, [r7, #20]
 801cd3a:	2300      	movs	r3, #0
 801cd3c:	ac08      	add	r4, sp, #32
 801cd3e:	6163      	str	r3, [r4, #20]
 801cd40:	3320      	adds	r3, #32
 801cd42:	7663      	strb	r3, [r4, #25]
 801cd44:	3310      	adds	r3, #16
 801cd46:	76a3      	strb	r3, [r4, #26]
 801cd48:	9507      	str	r5, [sp, #28]
 801cd4a:	0035      	movs	r5, r6
 801cd4c:	782b      	ldrb	r3, [r5, #0]
 801cd4e:	2b00      	cmp	r3, #0
 801cd50:	d001      	beq.n	801cd56 <_svfiprintf_r+0x52>
 801cd52:	2b25      	cmp	r3, #37	; 0x25
 801cd54:	d147      	bne.n	801cde6 <_svfiprintf_r+0xe2>
 801cd56:	1bab      	subs	r3, r5, r6
 801cd58:	9305      	str	r3, [sp, #20]
 801cd5a:	42b5      	cmp	r5, r6
 801cd5c:	d00c      	beq.n	801cd78 <_svfiprintf_r+0x74>
 801cd5e:	0032      	movs	r2, r6
 801cd60:	0039      	movs	r1, r7
 801cd62:	9803      	ldr	r0, [sp, #12]
 801cd64:	f7ff ff6c 	bl	801cc40 <__ssputs_r>
 801cd68:	1c43      	adds	r3, r0, #1
 801cd6a:	d100      	bne.n	801cd6e <_svfiprintf_r+0x6a>
 801cd6c:	e0ae      	b.n	801cecc <_svfiprintf_r+0x1c8>
 801cd6e:	6962      	ldr	r2, [r4, #20]
 801cd70:	9b05      	ldr	r3, [sp, #20]
 801cd72:	4694      	mov	ip, r2
 801cd74:	4463      	add	r3, ip
 801cd76:	6163      	str	r3, [r4, #20]
 801cd78:	782b      	ldrb	r3, [r5, #0]
 801cd7a:	2b00      	cmp	r3, #0
 801cd7c:	d100      	bne.n	801cd80 <_svfiprintf_r+0x7c>
 801cd7e:	e0a5      	b.n	801cecc <_svfiprintf_r+0x1c8>
 801cd80:	2201      	movs	r2, #1
 801cd82:	2300      	movs	r3, #0
 801cd84:	4252      	negs	r2, r2
 801cd86:	6062      	str	r2, [r4, #4]
 801cd88:	a904      	add	r1, sp, #16
 801cd8a:	3254      	adds	r2, #84	; 0x54
 801cd8c:	1852      	adds	r2, r2, r1
 801cd8e:	1c6e      	adds	r6, r5, #1
 801cd90:	6023      	str	r3, [r4, #0]
 801cd92:	60e3      	str	r3, [r4, #12]
 801cd94:	60a3      	str	r3, [r4, #8]
 801cd96:	7013      	strb	r3, [r2, #0]
 801cd98:	65a3      	str	r3, [r4, #88]	; 0x58
 801cd9a:	2205      	movs	r2, #5
 801cd9c:	7831      	ldrb	r1, [r6, #0]
 801cd9e:	4854      	ldr	r0, [pc, #336]	; (801cef0 <_svfiprintf_r+0x1ec>)
 801cda0:	f000 fa32 	bl	801d208 <memchr>
 801cda4:	1c75      	adds	r5, r6, #1
 801cda6:	2800      	cmp	r0, #0
 801cda8:	d11f      	bne.n	801cdea <_svfiprintf_r+0xe6>
 801cdaa:	6822      	ldr	r2, [r4, #0]
 801cdac:	06d3      	lsls	r3, r2, #27
 801cdae:	d504      	bpl.n	801cdba <_svfiprintf_r+0xb6>
 801cdb0:	2353      	movs	r3, #83	; 0x53
 801cdb2:	a904      	add	r1, sp, #16
 801cdb4:	185b      	adds	r3, r3, r1
 801cdb6:	2120      	movs	r1, #32
 801cdb8:	7019      	strb	r1, [r3, #0]
 801cdba:	0713      	lsls	r3, r2, #28
 801cdbc:	d504      	bpl.n	801cdc8 <_svfiprintf_r+0xc4>
 801cdbe:	2353      	movs	r3, #83	; 0x53
 801cdc0:	a904      	add	r1, sp, #16
 801cdc2:	185b      	adds	r3, r3, r1
 801cdc4:	212b      	movs	r1, #43	; 0x2b
 801cdc6:	7019      	strb	r1, [r3, #0]
 801cdc8:	7833      	ldrb	r3, [r6, #0]
 801cdca:	2b2a      	cmp	r3, #42	; 0x2a
 801cdcc:	d016      	beq.n	801cdfc <_svfiprintf_r+0xf8>
 801cdce:	0035      	movs	r5, r6
 801cdd0:	2100      	movs	r1, #0
 801cdd2:	200a      	movs	r0, #10
 801cdd4:	68e3      	ldr	r3, [r4, #12]
 801cdd6:	782a      	ldrb	r2, [r5, #0]
 801cdd8:	1c6e      	adds	r6, r5, #1
 801cdda:	3a30      	subs	r2, #48	; 0x30
 801cddc:	2a09      	cmp	r2, #9
 801cdde:	d94e      	bls.n	801ce7e <_svfiprintf_r+0x17a>
 801cde0:	2900      	cmp	r1, #0
 801cde2:	d111      	bne.n	801ce08 <_svfiprintf_r+0x104>
 801cde4:	e017      	b.n	801ce16 <_svfiprintf_r+0x112>
 801cde6:	3501      	adds	r5, #1
 801cde8:	e7b0      	b.n	801cd4c <_svfiprintf_r+0x48>
 801cdea:	4b41      	ldr	r3, [pc, #260]	; (801cef0 <_svfiprintf_r+0x1ec>)
 801cdec:	6822      	ldr	r2, [r4, #0]
 801cdee:	1ac0      	subs	r0, r0, r3
 801cdf0:	2301      	movs	r3, #1
 801cdf2:	4083      	lsls	r3, r0
 801cdf4:	4313      	orrs	r3, r2
 801cdf6:	002e      	movs	r6, r5
 801cdf8:	6023      	str	r3, [r4, #0]
 801cdfa:	e7ce      	b.n	801cd9a <_svfiprintf_r+0x96>
 801cdfc:	9b07      	ldr	r3, [sp, #28]
 801cdfe:	1d19      	adds	r1, r3, #4
 801ce00:	681b      	ldr	r3, [r3, #0]
 801ce02:	9107      	str	r1, [sp, #28]
 801ce04:	2b00      	cmp	r3, #0
 801ce06:	db01      	blt.n	801ce0c <_svfiprintf_r+0x108>
 801ce08:	930b      	str	r3, [sp, #44]	; 0x2c
 801ce0a:	e004      	b.n	801ce16 <_svfiprintf_r+0x112>
 801ce0c:	425b      	negs	r3, r3
 801ce0e:	60e3      	str	r3, [r4, #12]
 801ce10:	2302      	movs	r3, #2
 801ce12:	4313      	orrs	r3, r2
 801ce14:	6023      	str	r3, [r4, #0]
 801ce16:	782b      	ldrb	r3, [r5, #0]
 801ce18:	2b2e      	cmp	r3, #46	; 0x2e
 801ce1a:	d10a      	bne.n	801ce32 <_svfiprintf_r+0x12e>
 801ce1c:	786b      	ldrb	r3, [r5, #1]
 801ce1e:	2b2a      	cmp	r3, #42	; 0x2a
 801ce20:	d135      	bne.n	801ce8e <_svfiprintf_r+0x18a>
 801ce22:	9b07      	ldr	r3, [sp, #28]
 801ce24:	3502      	adds	r5, #2
 801ce26:	1d1a      	adds	r2, r3, #4
 801ce28:	681b      	ldr	r3, [r3, #0]
 801ce2a:	9207      	str	r2, [sp, #28]
 801ce2c:	2b00      	cmp	r3, #0
 801ce2e:	db2b      	blt.n	801ce88 <_svfiprintf_r+0x184>
 801ce30:	9309      	str	r3, [sp, #36]	; 0x24
 801ce32:	4e30      	ldr	r6, [pc, #192]	; (801cef4 <_svfiprintf_r+0x1f0>)
 801ce34:	2203      	movs	r2, #3
 801ce36:	0030      	movs	r0, r6
 801ce38:	7829      	ldrb	r1, [r5, #0]
 801ce3a:	f000 f9e5 	bl	801d208 <memchr>
 801ce3e:	2800      	cmp	r0, #0
 801ce40:	d006      	beq.n	801ce50 <_svfiprintf_r+0x14c>
 801ce42:	2340      	movs	r3, #64	; 0x40
 801ce44:	1b80      	subs	r0, r0, r6
 801ce46:	4083      	lsls	r3, r0
 801ce48:	6822      	ldr	r2, [r4, #0]
 801ce4a:	3501      	adds	r5, #1
 801ce4c:	4313      	orrs	r3, r2
 801ce4e:	6023      	str	r3, [r4, #0]
 801ce50:	7829      	ldrb	r1, [r5, #0]
 801ce52:	2206      	movs	r2, #6
 801ce54:	4828      	ldr	r0, [pc, #160]	; (801cef8 <_svfiprintf_r+0x1f4>)
 801ce56:	1c6e      	adds	r6, r5, #1
 801ce58:	7621      	strb	r1, [r4, #24]
 801ce5a:	f000 f9d5 	bl	801d208 <memchr>
 801ce5e:	2800      	cmp	r0, #0
 801ce60:	d03c      	beq.n	801cedc <_svfiprintf_r+0x1d8>
 801ce62:	4b26      	ldr	r3, [pc, #152]	; (801cefc <_svfiprintf_r+0x1f8>)
 801ce64:	2b00      	cmp	r3, #0
 801ce66:	d125      	bne.n	801ceb4 <_svfiprintf_r+0x1b0>
 801ce68:	2207      	movs	r2, #7
 801ce6a:	9b07      	ldr	r3, [sp, #28]
 801ce6c:	3307      	adds	r3, #7
 801ce6e:	4393      	bics	r3, r2
 801ce70:	3308      	adds	r3, #8
 801ce72:	9307      	str	r3, [sp, #28]
 801ce74:	6963      	ldr	r3, [r4, #20]
 801ce76:	9a04      	ldr	r2, [sp, #16]
 801ce78:	189b      	adds	r3, r3, r2
 801ce7a:	6163      	str	r3, [r4, #20]
 801ce7c:	e765      	b.n	801cd4a <_svfiprintf_r+0x46>
 801ce7e:	4343      	muls	r3, r0
 801ce80:	0035      	movs	r5, r6
 801ce82:	2101      	movs	r1, #1
 801ce84:	189b      	adds	r3, r3, r2
 801ce86:	e7a6      	b.n	801cdd6 <_svfiprintf_r+0xd2>
 801ce88:	2301      	movs	r3, #1
 801ce8a:	425b      	negs	r3, r3
 801ce8c:	e7d0      	b.n	801ce30 <_svfiprintf_r+0x12c>
 801ce8e:	2300      	movs	r3, #0
 801ce90:	200a      	movs	r0, #10
 801ce92:	001a      	movs	r2, r3
 801ce94:	3501      	adds	r5, #1
 801ce96:	6063      	str	r3, [r4, #4]
 801ce98:	7829      	ldrb	r1, [r5, #0]
 801ce9a:	1c6e      	adds	r6, r5, #1
 801ce9c:	3930      	subs	r1, #48	; 0x30
 801ce9e:	2909      	cmp	r1, #9
 801cea0:	d903      	bls.n	801ceaa <_svfiprintf_r+0x1a6>
 801cea2:	2b00      	cmp	r3, #0
 801cea4:	d0c5      	beq.n	801ce32 <_svfiprintf_r+0x12e>
 801cea6:	9209      	str	r2, [sp, #36]	; 0x24
 801cea8:	e7c3      	b.n	801ce32 <_svfiprintf_r+0x12e>
 801ceaa:	4342      	muls	r2, r0
 801ceac:	0035      	movs	r5, r6
 801ceae:	2301      	movs	r3, #1
 801ceb0:	1852      	adds	r2, r2, r1
 801ceb2:	e7f1      	b.n	801ce98 <_svfiprintf_r+0x194>
 801ceb4:	ab07      	add	r3, sp, #28
 801ceb6:	9300      	str	r3, [sp, #0]
 801ceb8:	003a      	movs	r2, r7
 801ceba:	0021      	movs	r1, r4
 801cebc:	4b10      	ldr	r3, [pc, #64]	; (801cf00 <_svfiprintf_r+0x1fc>)
 801cebe:	9803      	ldr	r0, [sp, #12]
 801cec0:	e000      	b.n	801cec4 <_svfiprintf_r+0x1c0>
 801cec2:	bf00      	nop
 801cec4:	9004      	str	r0, [sp, #16]
 801cec6:	9b04      	ldr	r3, [sp, #16]
 801cec8:	3301      	adds	r3, #1
 801ceca:	d1d3      	bne.n	801ce74 <_svfiprintf_r+0x170>
 801cecc:	89bb      	ldrh	r3, [r7, #12]
 801cece:	980d      	ldr	r0, [sp, #52]	; 0x34
 801ced0:	065b      	lsls	r3, r3, #25
 801ced2:	d400      	bmi.n	801ced6 <_svfiprintf_r+0x1d2>
 801ced4:	e72d      	b.n	801cd32 <_svfiprintf_r+0x2e>
 801ced6:	2001      	movs	r0, #1
 801ced8:	4240      	negs	r0, r0
 801ceda:	e72a      	b.n	801cd32 <_svfiprintf_r+0x2e>
 801cedc:	ab07      	add	r3, sp, #28
 801cede:	9300      	str	r3, [sp, #0]
 801cee0:	003a      	movs	r2, r7
 801cee2:	0021      	movs	r1, r4
 801cee4:	4b06      	ldr	r3, [pc, #24]	; (801cf00 <_svfiprintf_r+0x1fc>)
 801cee6:	9803      	ldr	r0, [sp, #12]
 801cee8:	f000 f87c 	bl	801cfe4 <_printf_i>
 801ceec:	e7ea      	b.n	801cec4 <_svfiprintf_r+0x1c0>
 801ceee:	46c0      	nop			; (mov r8, r8)
 801cef0:	0802212d 	.word	0x0802212d
 801cef4:	08022133 	.word	0x08022133
 801cef8:	08022137 	.word	0x08022137
 801cefc:	00000000 	.word	0x00000000
 801cf00:	0801cc41 	.word	0x0801cc41

0801cf04 <_printf_common>:
 801cf04:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 801cf06:	0015      	movs	r5, r2
 801cf08:	9301      	str	r3, [sp, #4]
 801cf0a:	688a      	ldr	r2, [r1, #8]
 801cf0c:	690b      	ldr	r3, [r1, #16]
 801cf0e:	000c      	movs	r4, r1
 801cf10:	9000      	str	r0, [sp, #0]
 801cf12:	4293      	cmp	r3, r2
 801cf14:	da00      	bge.n	801cf18 <_printf_common+0x14>
 801cf16:	0013      	movs	r3, r2
 801cf18:	0022      	movs	r2, r4
 801cf1a:	602b      	str	r3, [r5, #0]
 801cf1c:	3243      	adds	r2, #67	; 0x43
 801cf1e:	7812      	ldrb	r2, [r2, #0]
 801cf20:	2a00      	cmp	r2, #0
 801cf22:	d001      	beq.n	801cf28 <_printf_common+0x24>
 801cf24:	3301      	adds	r3, #1
 801cf26:	602b      	str	r3, [r5, #0]
 801cf28:	6823      	ldr	r3, [r4, #0]
 801cf2a:	069b      	lsls	r3, r3, #26
 801cf2c:	d502      	bpl.n	801cf34 <_printf_common+0x30>
 801cf2e:	682b      	ldr	r3, [r5, #0]
 801cf30:	3302      	adds	r3, #2
 801cf32:	602b      	str	r3, [r5, #0]
 801cf34:	6822      	ldr	r2, [r4, #0]
 801cf36:	2306      	movs	r3, #6
 801cf38:	0017      	movs	r7, r2
 801cf3a:	401f      	ands	r7, r3
 801cf3c:	421a      	tst	r2, r3
 801cf3e:	d027      	beq.n	801cf90 <_printf_common+0x8c>
 801cf40:	0023      	movs	r3, r4
 801cf42:	3343      	adds	r3, #67	; 0x43
 801cf44:	781b      	ldrb	r3, [r3, #0]
 801cf46:	1e5a      	subs	r2, r3, #1
 801cf48:	4193      	sbcs	r3, r2
 801cf4a:	6822      	ldr	r2, [r4, #0]
 801cf4c:	0692      	lsls	r2, r2, #26
 801cf4e:	d430      	bmi.n	801cfb2 <_printf_common+0xae>
 801cf50:	0022      	movs	r2, r4
 801cf52:	9901      	ldr	r1, [sp, #4]
 801cf54:	9800      	ldr	r0, [sp, #0]
 801cf56:	9e08      	ldr	r6, [sp, #32]
 801cf58:	3243      	adds	r2, #67	; 0x43
 801cf5a:	47b0      	blx	r6
 801cf5c:	1c43      	adds	r3, r0, #1
 801cf5e:	d025      	beq.n	801cfac <_printf_common+0xa8>
 801cf60:	2306      	movs	r3, #6
 801cf62:	6820      	ldr	r0, [r4, #0]
 801cf64:	682a      	ldr	r2, [r5, #0]
 801cf66:	68e1      	ldr	r1, [r4, #12]
 801cf68:	2500      	movs	r5, #0
 801cf6a:	4003      	ands	r3, r0
 801cf6c:	2b04      	cmp	r3, #4
 801cf6e:	d103      	bne.n	801cf78 <_printf_common+0x74>
 801cf70:	1a8d      	subs	r5, r1, r2
 801cf72:	43eb      	mvns	r3, r5
 801cf74:	17db      	asrs	r3, r3, #31
 801cf76:	401d      	ands	r5, r3
 801cf78:	68a3      	ldr	r3, [r4, #8]
 801cf7a:	6922      	ldr	r2, [r4, #16]
 801cf7c:	4293      	cmp	r3, r2
 801cf7e:	dd01      	ble.n	801cf84 <_printf_common+0x80>
 801cf80:	1a9b      	subs	r3, r3, r2
 801cf82:	18ed      	adds	r5, r5, r3
 801cf84:	2700      	movs	r7, #0
 801cf86:	42bd      	cmp	r5, r7
 801cf88:	d120      	bne.n	801cfcc <_printf_common+0xc8>
 801cf8a:	2000      	movs	r0, #0
 801cf8c:	e010      	b.n	801cfb0 <_printf_common+0xac>
 801cf8e:	3701      	adds	r7, #1
 801cf90:	68e3      	ldr	r3, [r4, #12]
 801cf92:	682a      	ldr	r2, [r5, #0]
 801cf94:	1a9b      	subs	r3, r3, r2
 801cf96:	42bb      	cmp	r3, r7
 801cf98:	ddd2      	ble.n	801cf40 <_printf_common+0x3c>
 801cf9a:	0022      	movs	r2, r4
 801cf9c:	2301      	movs	r3, #1
 801cf9e:	9901      	ldr	r1, [sp, #4]
 801cfa0:	9800      	ldr	r0, [sp, #0]
 801cfa2:	9e08      	ldr	r6, [sp, #32]
 801cfa4:	3219      	adds	r2, #25
 801cfa6:	47b0      	blx	r6
 801cfa8:	1c43      	adds	r3, r0, #1
 801cfaa:	d1f0      	bne.n	801cf8e <_printf_common+0x8a>
 801cfac:	2001      	movs	r0, #1
 801cfae:	4240      	negs	r0, r0
 801cfb0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 801cfb2:	2030      	movs	r0, #48	; 0x30
 801cfb4:	18e1      	adds	r1, r4, r3
 801cfb6:	3143      	adds	r1, #67	; 0x43
 801cfb8:	7008      	strb	r0, [r1, #0]
 801cfba:	0021      	movs	r1, r4
 801cfbc:	1c5a      	adds	r2, r3, #1
 801cfbe:	3145      	adds	r1, #69	; 0x45
 801cfc0:	7809      	ldrb	r1, [r1, #0]
 801cfc2:	18a2      	adds	r2, r4, r2
 801cfc4:	3243      	adds	r2, #67	; 0x43
 801cfc6:	3302      	adds	r3, #2
 801cfc8:	7011      	strb	r1, [r2, #0]
 801cfca:	e7c1      	b.n	801cf50 <_printf_common+0x4c>
 801cfcc:	0022      	movs	r2, r4
 801cfce:	2301      	movs	r3, #1
 801cfd0:	9901      	ldr	r1, [sp, #4]
 801cfd2:	9800      	ldr	r0, [sp, #0]
 801cfd4:	9e08      	ldr	r6, [sp, #32]
 801cfd6:	321a      	adds	r2, #26
 801cfd8:	47b0      	blx	r6
 801cfda:	1c43      	adds	r3, r0, #1
 801cfdc:	d0e6      	beq.n	801cfac <_printf_common+0xa8>
 801cfde:	3701      	adds	r7, #1
 801cfe0:	e7d1      	b.n	801cf86 <_printf_common+0x82>
	...

0801cfe4 <_printf_i>:
 801cfe4:	b5f0      	push	{r4, r5, r6, r7, lr}
 801cfe6:	b08b      	sub	sp, #44	; 0x2c
 801cfe8:	9206      	str	r2, [sp, #24]
 801cfea:	000a      	movs	r2, r1
 801cfec:	3243      	adds	r2, #67	; 0x43
 801cfee:	9307      	str	r3, [sp, #28]
 801cff0:	9005      	str	r0, [sp, #20]
 801cff2:	9204      	str	r2, [sp, #16]
 801cff4:	7e0a      	ldrb	r2, [r1, #24]
 801cff6:	000c      	movs	r4, r1
 801cff8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801cffa:	2a78      	cmp	r2, #120	; 0x78
 801cffc:	d806      	bhi.n	801d00c <_printf_i+0x28>
 801cffe:	2a62      	cmp	r2, #98	; 0x62
 801d000:	d808      	bhi.n	801d014 <_printf_i+0x30>
 801d002:	2a00      	cmp	r2, #0
 801d004:	d100      	bne.n	801d008 <_printf_i+0x24>
 801d006:	e0c0      	b.n	801d18a <_printf_i+0x1a6>
 801d008:	2a58      	cmp	r2, #88	; 0x58
 801d00a:	d052      	beq.n	801d0b2 <_printf_i+0xce>
 801d00c:	0026      	movs	r6, r4
 801d00e:	3642      	adds	r6, #66	; 0x42
 801d010:	7032      	strb	r2, [r6, #0]
 801d012:	e022      	b.n	801d05a <_printf_i+0x76>
 801d014:	0010      	movs	r0, r2
 801d016:	3863      	subs	r0, #99	; 0x63
 801d018:	2815      	cmp	r0, #21
 801d01a:	d8f7      	bhi.n	801d00c <_printf_i+0x28>
 801d01c:	f7e3 f87c 	bl	8000118 <__gnu_thumb1_case_shi>
 801d020:	001f0016 	.word	0x001f0016
 801d024:	fff6fff6 	.word	0xfff6fff6
 801d028:	fff6fff6 	.word	0xfff6fff6
 801d02c:	fff6001f 	.word	0xfff6001f
 801d030:	fff6fff6 	.word	0xfff6fff6
 801d034:	00a8fff6 	.word	0x00a8fff6
 801d038:	009a0036 	.word	0x009a0036
 801d03c:	fff6fff6 	.word	0xfff6fff6
 801d040:	fff600b9 	.word	0xfff600b9
 801d044:	fff60036 	.word	0xfff60036
 801d048:	009efff6 	.word	0x009efff6
 801d04c:	0026      	movs	r6, r4
 801d04e:	681a      	ldr	r2, [r3, #0]
 801d050:	3642      	adds	r6, #66	; 0x42
 801d052:	1d11      	adds	r1, r2, #4
 801d054:	6019      	str	r1, [r3, #0]
 801d056:	6813      	ldr	r3, [r2, #0]
 801d058:	7033      	strb	r3, [r6, #0]
 801d05a:	2301      	movs	r3, #1
 801d05c:	e0a7      	b.n	801d1ae <_printf_i+0x1ca>
 801d05e:	6808      	ldr	r0, [r1, #0]
 801d060:	6819      	ldr	r1, [r3, #0]
 801d062:	1d0a      	adds	r2, r1, #4
 801d064:	0605      	lsls	r5, r0, #24
 801d066:	d50b      	bpl.n	801d080 <_printf_i+0x9c>
 801d068:	680d      	ldr	r5, [r1, #0]
 801d06a:	601a      	str	r2, [r3, #0]
 801d06c:	2d00      	cmp	r5, #0
 801d06e:	da03      	bge.n	801d078 <_printf_i+0x94>
 801d070:	232d      	movs	r3, #45	; 0x2d
 801d072:	9a04      	ldr	r2, [sp, #16]
 801d074:	426d      	negs	r5, r5
 801d076:	7013      	strb	r3, [r2, #0]
 801d078:	4b61      	ldr	r3, [pc, #388]	; (801d200 <_printf_i+0x21c>)
 801d07a:	270a      	movs	r7, #10
 801d07c:	9303      	str	r3, [sp, #12]
 801d07e:	e032      	b.n	801d0e6 <_printf_i+0x102>
 801d080:	680d      	ldr	r5, [r1, #0]
 801d082:	601a      	str	r2, [r3, #0]
 801d084:	0641      	lsls	r1, r0, #25
 801d086:	d5f1      	bpl.n	801d06c <_printf_i+0x88>
 801d088:	b22d      	sxth	r5, r5
 801d08a:	e7ef      	b.n	801d06c <_printf_i+0x88>
 801d08c:	680d      	ldr	r5, [r1, #0]
 801d08e:	6819      	ldr	r1, [r3, #0]
 801d090:	1d08      	adds	r0, r1, #4
 801d092:	6018      	str	r0, [r3, #0]
 801d094:	062e      	lsls	r6, r5, #24
 801d096:	d501      	bpl.n	801d09c <_printf_i+0xb8>
 801d098:	680d      	ldr	r5, [r1, #0]
 801d09a:	e003      	b.n	801d0a4 <_printf_i+0xc0>
 801d09c:	066d      	lsls	r5, r5, #25
 801d09e:	d5fb      	bpl.n	801d098 <_printf_i+0xb4>
 801d0a0:	680d      	ldr	r5, [r1, #0]
 801d0a2:	b2ad      	uxth	r5, r5
 801d0a4:	4b56      	ldr	r3, [pc, #344]	; (801d200 <_printf_i+0x21c>)
 801d0a6:	270a      	movs	r7, #10
 801d0a8:	9303      	str	r3, [sp, #12]
 801d0aa:	2a6f      	cmp	r2, #111	; 0x6f
 801d0ac:	d117      	bne.n	801d0de <_printf_i+0xfa>
 801d0ae:	2708      	movs	r7, #8
 801d0b0:	e015      	b.n	801d0de <_printf_i+0xfa>
 801d0b2:	3145      	adds	r1, #69	; 0x45
 801d0b4:	700a      	strb	r2, [r1, #0]
 801d0b6:	4a52      	ldr	r2, [pc, #328]	; (801d200 <_printf_i+0x21c>)
 801d0b8:	9203      	str	r2, [sp, #12]
 801d0ba:	681a      	ldr	r2, [r3, #0]
 801d0bc:	6821      	ldr	r1, [r4, #0]
 801d0be:	ca20      	ldmia	r2!, {r5}
 801d0c0:	601a      	str	r2, [r3, #0]
 801d0c2:	0608      	lsls	r0, r1, #24
 801d0c4:	d550      	bpl.n	801d168 <_printf_i+0x184>
 801d0c6:	07cb      	lsls	r3, r1, #31
 801d0c8:	d502      	bpl.n	801d0d0 <_printf_i+0xec>
 801d0ca:	2320      	movs	r3, #32
 801d0cc:	4319      	orrs	r1, r3
 801d0ce:	6021      	str	r1, [r4, #0]
 801d0d0:	2710      	movs	r7, #16
 801d0d2:	2d00      	cmp	r5, #0
 801d0d4:	d103      	bne.n	801d0de <_printf_i+0xfa>
 801d0d6:	2320      	movs	r3, #32
 801d0d8:	6822      	ldr	r2, [r4, #0]
 801d0da:	439a      	bics	r2, r3
 801d0dc:	6022      	str	r2, [r4, #0]
 801d0de:	0023      	movs	r3, r4
 801d0e0:	2200      	movs	r2, #0
 801d0e2:	3343      	adds	r3, #67	; 0x43
 801d0e4:	701a      	strb	r2, [r3, #0]
 801d0e6:	6863      	ldr	r3, [r4, #4]
 801d0e8:	60a3      	str	r3, [r4, #8]
 801d0ea:	2b00      	cmp	r3, #0
 801d0ec:	db03      	blt.n	801d0f6 <_printf_i+0x112>
 801d0ee:	2204      	movs	r2, #4
 801d0f0:	6821      	ldr	r1, [r4, #0]
 801d0f2:	4391      	bics	r1, r2
 801d0f4:	6021      	str	r1, [r4, #0]
 801d0f6:	2d00      	cmp	r5, #0
 801d0f8:	d102      	bne.n	801d100 <_printf_i+0x11c>
 801d0fa:	9e04      	ldr	r6, [sp, #16]
 801d0fc:	2b00      	cmp	r3, #0
 801d0fe:	d00c      	beq.n	801d11a <_printf_i+0x136>
 801d100:	9e04      	ldr	r6, [sp, #16]
 801d102:	0028      	movs	r0, r5
 801d104:	0039      	movs	r1, r7
 801d106:	f7e3 f897 	bl	8000238 <__aeabi_uidivmod>
 801d10a:	9b03      	ldr	r3, [sp, #12]
 801d10c:	3e01      	subs	r6, #1
 801d10e:	5c5b      	ldrb	r3, [r3, r1]
 801d110:	7033      	strb	r3, [r6, #0]
 801d112:	002b      	movs	r3, r5
 801d114:	0005      	movs	r5, r0
 801d116:	429f      	cmp	r7, r3
 801d118:	d9f3      	bls.n	801d102 <_printf_i+0x11e>
 801d11a:	2f08      	cmp	r7, #8
 801d11c:	d109      	bne.n	801d132 <_printf_i+0x14e>
 801d11e:	6823      	ldr	r3, [r4, #0]
 801d120:	07db      	lsls	r3, r3, #31
 801d122:	d506      	bpl.n	801d132 <_printf_i+0x14e>
 801d124:	6863      	ldr	r3, [r4, #4]
 801d126:	6922      	ldr	r2, [r4, #16]
 801d128:	4293      	cmp	r3, r2
 801d12a:	dc02      	bgt.n	801d132 <_printf_i+0x14e>
 801d12c:	2330      	movs	r3, #48	; 0x30
 801d12e:	3e01      	subs	r6, #1
 801d130:	7033      	strb	r3, [r6, #0]
 801d132:	9b04      	ldr	r3, [sp, #16]
 801d134:	1b9b      	subs	r3, r3, r6
 801d136:	6123      	str	r3, [r4, #16]
 801d138:	9b07      	ldr	r3, [sp, #28]
 801d13a:	0021      	movs	r1, r4
 801d13c:	9300      	str	r3, [sp, #0]
 801d13e:	9805      	ldr	r0, [sp, #20]
 801d140:	9b06      	ldr	r3, [sp, #24]
 801d142:	aa09      	add	r2, sp, #36	; 0x24
 801d144:	f7ff fede 	bl	801cf04 <_printf_common>
 801d148:	1c43      	adds	r3, r0, #1
 801d14a:	d135      	bne.n	801d1b8 <_printf_i+0x1d4>
 801d14c:	2001      	movs	r0, #1
 801d14e:	4240      	negs	r0, r0
 801d150:	b00b      	add	sp, #44	; 0x2c
 801d152:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801d154:	2220      	movs	r2, #32
 801d156:	6809      	ldr	r1, [r1, #0]
 801d158:	430a      	orrs	r2, r1
 801d15a:	6022      	str	r2, [r4, #0]
 801d15c:	0022      	movs	r2, r4
 801d15e:	2178      	movs	r1, #120	; 0x78
 801d160:	3245      	adds	r2, #69	; 0x45
 801d162:	7011      	strb	r1, [r2, #0]
 801d164:	4a27      	ldr	r2, [pc, #156]	; (801d204 <_printf_i+0x220>)
 801d166:	e7a7      	b.n	801d0b8 <_printf_i+0xd4>
 801d168:	0648      	lsls	r0, r1, #25
 801d16a:	d5ac      	bpl.n	801d0c6 <_printf_i+0xe2>
 801d16c:	b2ad      	uxth	r5, r5
 801d16e:	e7aa      	b.n	801d0c6 <_printf_i+0xe2>
 801d170:	681a      	ldr	r2, [r3, #0]
 801d172:	680d      	ldr	r5, [r1, #0]
 801d174:	1d10      	adds	r0, r2, #4
 801d176:	6949      	ldr	r1, [r1, #20]
 801d178:	6018      	str	r0, [r3, #0]
 801d17a:	6813      	ldr	r3, [r2, #0]
 801d17c:	062e      	lsls	r6, r5, #24
 801d17e:	d501      	bpl.n	801d184 <_printf_i+0x1a0>
 801d180:	6019      	str	r1, [r3, #0]
 801d182:	e002      	b.n	801d18a <_printf_i+0x1a6>
 801d184:	066d      	lsls	r5, r5, #25
 801d186:	d5fb      	bpl.n	801d180 <_printf_i+0x19c>
 801d188:	8019      	strh	r1, [r3, #0]
 801d18a:	2300      	movs	r3, #0
 801d18c:	9e04      	ldr	r6, [sp, #16]
 801d18e:	6123      	str	r3, [r4, #16]
 801d190:	e7d2      	b.n	801d138 <_printf_i+0x154>
 801d192:	681a      	ldr	r2, [r3, #0]
 801d194:	1d11      	adds	r1, r2, #4
 801d196:	6019      	str	r1, [r3, #0]
 801d198:	6816      	ldr	r6, [r2, #0]
 801d19a:	2100      	movs	r1, #0
 801d19c:	0030      	movs	r0, r6
 801d19e:	6862      	ldr	r2, [r4, #4]
 801d1a0:	f000 f832 	bl	801d208 <memchr>
 801d1a4:	2800      	cmp	r0, #0
 801d1a6:	d001      	beq.n	801d1ac <_printf_i+0x1c8>
 801d1a8:	1b80      	subs	r0, r0, r6
 801d1aa:	6060      	str	r0, [r4, #4]
 801d1ac:	6863      	ldr	r3, [r4, #4]
 801d1ae:	6123      	str	r3, [r4, #16]
 801d1b0:	2300      	movs	r3, #0
 801d1b2:	9a04      	ldr	r2, [sp, #16]
 801d1b4:	7013      	strb	r3, [r2, #0]
 801d1b6:	e7bf      	b.n	801d138 <_printf_i+0x154>
 801d1b8:	6923      	ldr	r3, [r4, #16]
 801d1ba:	0032      	movs	r2, r6
 801d1bc:	9906      	ldr	r1, [sp, #24]
 801d1be:	9805      	ldr	r0, [sp, #20]
 801d1c0:	9d07      	ldr	r5, [sp, #28]
 801d1c2:	47a8      	blx	r5
 801d1c4:	1c43      	adds	r3, r0, #1
 801d1c6:	d0c1      	beq.n	801d14c <_printf_i+0x168>
 801d1c8:	6823      	ldr	r3, [r4, #0]
 801d1ca:	079b      	lsls	r3, r3, #30
 801d1cc:	d415      	bmi.n	801d1fa <_printf_i+0x216>
 801d1ce:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801d1d0:	68e0      	ldr	r0, [r4, #12]
 801d1d2:	4298      	cmp	r0, r3
 801d1d4:	dabc      	bge.n	801d150 <_printf_i+0x16c>
 801d1d6:	0018      	movs	r0, r3
 801d1d8:	e7ba      	b.n	801d150 <_printf_i+0x16c>
 801d1da:	0022      	movs	r2, r4
 801d1dc:	2301      	movs	r3, #1
 801d1de:	9906      	ldr	r1, [sp, #24]
 801d1e0:	9805      	ldr	r0, [sp, #20]
 801d1e2:	9e07      	ldr	r6, [sp, #28]
 801d1e4:	3219      	adds	r2, #25
 801d1e6:	47b0      	blx	r6
 801d1e8:	1c43      	adds	r3, r0, #1
 801d1ea:	d0af      	beq.n	801d14c <_printf_i+0x168>
 801d1ec:	3501      	adds	r5, #1
 801d1ee:	68e3      	ldr	r3, [r4, #12]
 801d1f0:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801d1f2:	1a9b      	subs	r3, r3, r2
 801d1f4:	42ab      	cmp	r3, r5
 801d1f6:	dcf0      	bgt.n	801d1da <_printf_i+0x1f6>
 801d1f8:	e7e9      	b.n	801d1ce <_printf_i+0x1ea>
 801d1fa:	2500      	movs	r5, #0
 801d1fc:	e7f7      	b.n	801d1ee <_printf_i+0x20a>
 801d1fe:	46c0      	nop			; (mov r8, r8)
 801d200:	0802213e 	.word	0x0802213e
 801d204:	0802214f 	.word	0x0802214f

0801d208 <memchr>:
 801d208:	b2c9      	uxtb	r1, r1
 801d20a:	1882      	adds	r2, r0, r2
 801d20c:	4290      	cmp	r0, r2
 801d20e:	d101      	bne.n	801d214 <memchr+0xc>
 801d210:	2000      	movs	r0, #0
 801d212:	4770      	bx	lr
 801d214:	7803      	ldrb	r3, [r0, #0]
 801d216:	428b      	cmp	r3, r1
 801d218:	d0fb      	beq.n	801d212 <memchr+0xa>
 801d21a:	3001      	adds	r0, #1
 801d21c:	e7f6      	b.n	801d20c <memchr+0x4>

0801d21e <_realloc_r>:
 801d21e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801d220:	0007      	movs	r7, r0
 801d222:	000d      	movs	r5, r1
 801d224:	0016      	movs	r6, r2
 801d226:	2900      	cmp	r1, #0
 801d228:	d105      	bne.n	801d236 <_realloc_r+0x18>
 801d22a:	0011      	movs	r1, r2
 801d22c:	f7ff fb50 	bl	801c8d0 <_malloc_r>
 801d230:	0004      	movs	r4, r0
 801d232:	0020      	movs	r0, r4
 801d234:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801d236:	2a00      	cmp	r2, #0
 801d238:	d103      	bne.n	801d242 <_realloc_r+0x24>
 801d23a:	f7ff faff 	bl	801c83c <_free_r>
 801d23e:	0034      	movs	r4, r6
 801d240:	e7f7      	b.n	801d232 <_realloc_r+0x14>
 801d242:	f000 f812 	bl	801d26a <_malloc_usable_size_r>
 801d246:	002c      	movs	r4, r5
 801d248:	42b0      	cmp	r0, r6
 801d24a:	d2f2      	bcs.n	801d232 <_realloc_r+0x14>
 801d24c:	0031      	movs	r1, r6
 801d24e:	0038      	movs	r0, r7
 801d250:	f7ff fb3e 	bl	801c8d0 <_malloc_r>
 801d254:	1e04      	subs	r4, r0, #0
 801d256:	d0ec      	beq.n	801d232 <_realloc_r+0x14>
 801d258:	0029      	movs	r1, r5
 801d25a:	0032      	movs	r2, r6
 801d25c:	f7ff faca 	bl	801c7f4 <memcpy>
 801d260:	0029      	movs	r1, r5
 801d262:	0038      	movs	r0, r7
 801d264:	f7ff faea 	bl	801c83c <_free_r>
 801d268:	e7e3      	b.n	801d232 <_realloc_r+0x14>

0801d26a <_malloc_usable_size_r>:
 801d26a:	1f0b      	subs	r3, r1, #4
 801d26c:	681b      	ldr	r3, [r3, #0]
 801d26e:	1f18      	subs	r0, r3, #4
 801d270:	2b00      	cmp	r3, #0
 801d272:	da01      	bge.n	801d278 <_malloc_usable_size_r+0xe>
 801d274:	580b      	ldr	r3, [r1, r0]
 801d276:	18c0      	adds	r0, r0, r3
 801d278:	4770      	bx	lr
	...

0801d27c <_init>:
 801d27c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801d27e:	46c0      	nop			; (mov r8, r8)
 801d280:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801d282:	bc08      	pop	{r3}
 801d284:	469e      	mov	lr, r3
 801d286:	4770      	bx	lr

0801d288 <_fini>:
 801d288:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801d28a:	46c0      	nop			; (mov r8, r8)
 801d28c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801d28e:	bc08      	pop	{r3}
 801d290:	469e      	mov	lr, r3
 801d292:	4770      	bx	lr
